// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_remoteclient_discovery.proto

#include "steammessages_remoteclient_discovery.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CMsgRemoteClientBroadcastHeader::CMsgRemoteClientBroadcastHeader(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , instance_id_(uint64_t{0u})
  , device_id_(uint64_t{0u})
  , msg_type_(0)
{}
struct CMsgRemoteClientBroadcastHeaderDefaultTypeInternal {
  constexpr CMsgRemoteClientBroadcastHeaderDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteClientBroadcastHeaderDefaultTypeInternal() {}
  union {
    CMsgRemoteClientBroadcastHeader _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteClientBroadcastHeaderDefaultTypeInternal _CMsgRemoteClientBroadcastHeader_default_instance_;
constexpr CMsgRemoteClientBroadcastStatus_User::CMsgRemoteClientBroadcastStatus_User(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : steamid_(uint64_t{0u})
  , auth_key_id_(0u){}
struct CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal {
  constexpr CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal() {}
  union {
    CMsgRemoteClientBroadcastStatus_User _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal _CMsgRemoteClientBroadcastStatus_User_default_instance_;
constexpr CMsgRemoteClientBroadcastStatus::CMsgRemoteClientBroadcastStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : users_()
  , mac_addresses_()
  , ip_addresses_()
  , hostname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , public_ip_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_(0)
  , min_version_(0)
  , connect_port_(0u)
  , enabled_services_(0u)
  , ostype_(0)
  , euniverse_(0)
  , timestamp_(0u)
  , is64bit_(false)
  , screen_locked_(false)
  , games_running_(false)
  , broadcasting_active_(false)
  , download_lan_peer_group_(0u)
  , content_cache_port_(0u)
  , vr_active_(false)
  , remoteplay_active_(false)
  , steam_deck_(false)
  , supported_services_(0u)
  , steam_version_(uint64_t{0u}){}
struct CMsgRemoteClientBroadcastStatusDefaultTypeInternal {
  constexpr CMsgRemoteClientBroadcastStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteClientBroadcastStatusDefaultTypeInternal() {}
  union {
    CMsgRemoteClientBroadcastStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteClientBroadcastStatusDefaultTypeInternal _CMsgRemoteClientBroadcastStatus_default_instance_;
constexpr CMsgRemoteClientBroadcastDiscovery::CMsgRemoteClientBroadcastDiscovery(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_ids_()
  , seq_num_(0u){}
struct CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal {
  constexpr CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal() {}
  union {
    CMsgRemoteClientBroadcastDiscovery _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal _CMsgRemoteClientBroadcastDiscovery_default_instance_;
constexpr CMsgRemoteClientBroadcastClientIDDeconflict::CMsgRemoteClientBroadcastClientIDDeconflict(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_ids_(){}
struct CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal {
  constexpr CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal() {}
  union {
    CMsgRemoteClientBroadcastClientIDDeconflict _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal _CMsgRemoteClientBroadcastClientIDDeconflict_default_instance_;
constexpr CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , payload_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_model_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_serial_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , identifier_(uint64_t{0u})
  , timestamp_(0u)
  , usage_(0)

  , device_provisioning_id_(0u){}
struct CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal {
  constexpr CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal _CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket_default_instance_;
constexpr CMsgRemoteDeviceAuthorizationRequest::CMsgRemoteDeviceAuthorizationRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encrypted_request_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auth_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal {
  constexpr CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceAuthorizationRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal _CMsgRemoteDeviceAuthorizationRequest_default_instance_;
constexpr CMsgRemoteDeviceAuthorizationCancelRequest::CMsgRemoteDeviceAuthorizationCancelRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal {
  constexpr CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceAuthorizationCancelRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal _CMsgRemoteDeviceAuthorizationCancelRequest_default_instance_;
constexpr CMsgRemoteDeviceAuthorizationResponse::CMsgRemoteDeviceAuthorizationResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : auth_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , steamid_(uint64_t{0u})
  , result_(0)
{}
struct CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal {
  constexpr CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceAuthorizationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal _CMsgRemoteDeviceAuthorizationResponse_default_instance_;
constexpr CMsgRemoteDeviceAuthorizationConfirmed::CMsgRemoteDeviceAuthorizationConfirmed(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(0)
{}
struct CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal {
  constexpr CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceAuthorizationConfirmed _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal _CMsgRemoteDeviceAuthorizationConfirmed_default_instance_;
constexpr CMsgRemoteDeviceStreamingRequest_ReservedGamepad::CMsgRemoteDeviceStreamingRequest_ReservedGamepad(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_type_(0u)
  , controller_subtype_(0u){}
struct CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamingRequest_ReservedGamepad _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal _CMsgRemoteDeviceStreamingRequest_ReservedGamepad_default_instance_;
constexpr CMsgRemoteDeviceStreamingRequest::CMsgRemoteDeviceStreamingRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supported_transport_()
  , gamepads_()
  , device_version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , pin_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(0u)
  , maximum_resolution_x_(0)
  , maximum_resolution_y_(0)
  , stream_desktop_(false)
  , network_test_(false)
  , restricted_(false)
  , client_id_(uint64_t{0u})
  , form_factor_(0)

  , gamepad_count_(0)
  , gameid_(uint64_t{0u})
  , stream_interface_(0)

  , audio_channel_count_(2)
  , enable_video_streaming_(true)
  , enable_audio_streaming_(true)
  , enable_input_streaming_(true){}
struct CMsgRemoteDeviceStreamingRequestDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamingRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamingRequestDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamingRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamingRequestDefaultTypeInternal _CMsgRemoteDeviceStreamingRequest_default_instance_;
constexpr CMsgRemoteDeviceStreamingCancelRequest::CMsgRemoteDeviceStreamingCancelRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(0u){}
struct CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamingCancelRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal _CMsgRemoteDeviceStreamingCancelRequest_default_instance_;
constexpr CMsgRemoteDeviceStreamingProgress::CMsgRemoteDeviceStreamingProgress(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(0u)
  , progress_(0){}
struct CMsgRemoteDeviceStreamingProgressDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamingProgressDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamingProgressDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamingProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamingProgressDefaultTypeInternal _CMsgRemoteDeviceStreamingProgress_default_instance_;
constexpr CMsgRemoteDeviceStreamingResponse::CMsgRemoteDeviceStreamingResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : encrypted_session_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , relay_server_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cert_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(0u)
  , result_(0)

  , port_(0u)
  , transport_(1)
{}
struct CMsgRemoteDeviceStreamingResponseDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamingResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamingResponseDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamingResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamingResponseDefaultTypeInternal _CMsgRemoteDeviceStreamingResponse_default_instance_;
constexpr CMsgRemoteDeviceProofRequest::CMsgRemoteDeviceProofRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : challenge_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(0u)
  , update_secret_(false){}
struct CMsgRemoteDeviceProofRequestDefaultTypeInternal {
  constexpr CMsgRemoteDeviceProofRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceProofRequestDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceProofRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceProofRequestDefaultTypeInternal _CMsgRemoteDeviceProofRequest_default_instance_;
constexpr CMsgRemoteDeviceProofResponse::CMsgRemoteDeviceProofResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : response_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(0u)
  , updated_secret_(false){}
struct CMsgRemoteDeviceProofResponseDefaultTypeInternal {
  constexpr CMsgRemoteDeviceProofResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceProofResponseDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceProofResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceProofResponseDefaultTypeInternal _CMsgRemoteDeviceProofResponse_default_instance_;
constexpr CMsgRemoteDeviceStreamTransportSignal::CMsgRemoteDeviceStreamTransportSignal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , payload_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal {
  constexpr CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal() {}
  union {
    CMsgRemoteDeviceStreamTransportSignal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal _CMsgRemoteDeviceStreamTransportSignal_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[18];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[8];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto = nullptr;

const uint32_t TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, client_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, msg_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, instance_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, device_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastHeader, device_token_),
  1,
  4,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus_User, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus_User, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus_User, steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus_User, auth_key_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, version_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, min_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, connect_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, hostname_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, enabled_services_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, ostype_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, is64bit_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, users_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, euniverse_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, screen_locked_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, games_running_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, mac_addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, download_lan_peer_group_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, broadcasting_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, vr_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, content_cache_port_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, ip_addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, public_ip_address_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, remoteplay_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, supported_services_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, steam_deck_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastStatus, steam_version_),
  2,
  3,
  4,
  0,
  5,
  6,
  9,
  ~0u,
  7,
  8,
  10,
  11,
  ~0u,
  13,
  12,
  15,
  14,
  ~0u,
  1,
  16,
  18,
  17,
  19,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastDiscovery, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastDiscovery, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastDiscovery, seq_num_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastDiscovery, client_ids_),
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastClientIDDeconflict, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteClientBroadcastClientIDDeconflict, client_ids_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, password_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, identifier_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, payload_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, usage_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, device_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, device_model_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, device_serial_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, device_provisioning_id_),
  0,
  5,
  1,
  6,
  7,
  2,
  3,
  4,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, device_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, device_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, encrypted_request_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationRequest, auth_key_),
  0,
  1,
  2,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationCancelRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, result_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, auth_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationResponse, device_token_),
  3,
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationConfirmed, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationConfirmed, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceAuthorizationConfirmed, result_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest_ReservedGamepad, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest_ReservedGamepad, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest_ReservedGamepad, controller_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest_ReservedGamepad, controller_subtype_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, request_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, maximum_resolution_x_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, maximum_resolution_y_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, audio_channel_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, device_version_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, stream_desktop_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, device_token_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, pin_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, enable_video_streaming_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, enable_audio_streaming_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, enable_input_streaming_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, network_test_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, client_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, supported_transport_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, restricted_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, form_factor_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, gamepad_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, gamepads_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, gameid_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingRequest, stream_interface_),
  3,
  4,
  5,
  14,
  0,
  6,
  1,
  2,
  15,
  16,
  17,
  7,
  9,
  ~0u,
  8,
  10,
  11,
  ~0u,
  12,
  13,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingCancelRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingCancelRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingCancelRequest, request_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingProgress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingProgress, request_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingProgress, progress_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, request_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, result_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, port_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, encrypted_session_key_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, transport_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, relay_server_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamingResponse, cert_),
  3,
  4,
  5,
  0,
  6,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofRequest, challenge_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofRequest, request_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofRequest, update_secret_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofResponse, response_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofResponse, request_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceProofResponse, updated_secret_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamTransportSignal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamTransportSignal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamTransportSignal, token_),
  PROTOBUF_FIELD_OFFSET(::CMsgRemoteDeviceStreamTransportSignal, payload_),
  0,
  1,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::CMsgRemoteClientBroadcastHeader)},
  { 16, 24, -1, sizeof(::CMsgRemoteClientBroadcastStatus_User)},
  { 26, 55, -1, sizeof(::CMsgRemoteClientBroadcastStatus)},
  { 78, 86, -1, sizeof(::CMsgRemoteClientBroadcastDiscovery)},
  { 88, -1, -1, sizeof(::CMsgRemoteClientBroadcastClientIDDeconflict)},
  { 95, 110, -1, sizeof(::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket)},
  { 119, 129, -1, sizeof(::CMsgRemoteDeviceAuthorizationRequest)},
  { 133, -1, -1, sizeof(::CMsgRemoteDeviceAuthorizationCancelRequest)},
  { 139, 149, -1, sizeof(::CMsgRemoteDeviceAuthorizationResponse)},
  { 153, 160, -1, sizeof(::CMsgRemoteDeviceAuthorizationConfirmed)},
  { 161, 169, -1, sizeof(::CMsgRemoteDeviceStreamingRequest_ReservedGamepad)},
  { 171, 197, -1, sizeof(::CMsgRemoteDeviceStreamingRequest)},
  { 217, 224, -1, sizeof(::CMsgRemoteDeviceStreamingCancelRequest)},
  { 225, 233, -1, sizeof(::CMsgRemoteDeviceStreamingProgress)},
  { 235, 248, -1, sizeof(::CMsgRemoteDeviceStreamingResponse)},
  { 255, 264, -1, sizeof(::CMsgRemoteDeviceProofRequest)},
  { 267, 276, -1, sizeof(::CMsgRemoteDeviceProofResponse)},
  { 279, 287, -1, sizeof(::CMsgRemoteDeviceStreamTransportSignal)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteClientBroadcastHeader_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteClientBroadcastStatus_User_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteClientBroadcastStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteClientBroadcastDiscovery_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteClientBroadcastClientIDDeconflict_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceAuthorizationRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceAuthorizationCancelRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceAuthorizationResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceAuthorizationConfirmed_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamingRequest_ReservedGamepad_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamingRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamingCancelRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamingProgress_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamingResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceProofRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceProofResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgRemoteDeviceStreamTransportSignal_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fremoteclient_5fdiscovery_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n*steammessages_remoteclient_discovery.p"
  "roto\"\306\001\n\037CMsgRemoteClientBroadcastHeader"
  "\022\021\n\tclient_id\030\001 \001(\004\022R\n\010msg_type\030\002 \001(\0162\032."
  "ERemoteClientBroadcastMsg:$k_ERemoteClie"
  "ntBroadcastMsgDiscovery\022\023\n\013instance_id\030\003"
  " \001(\004\022\021\n\tdevice_id\030\004 \001(\004\022\024\n\014device_token\030"
  "\005 \001(\014\"\374\004\n\037CMsgRemoteClientBroadcastStatu"
  "s\022\017\n\007version\030\001 \001(\005\022\023\n\013min_version\030\002 \001(\005\022"
  "\024\n\014connect_port\030\003 \001(\r\022\020\n\010hostname\030\004 \001(\t\022"
  "\030\n\020enabled_services\030\006 \001(\r\022\021\n\006ostype\030\007 \001("
  "\005:\0010\022\017\n\007is64bit\030\010 \001(\010\0224\n\005users\030\t \003(\0132%.C"
  "MsgRemoteClientBroadcastStatus.User\022\021\n\te"
  "universe\030\013 \001(\005\022\021\n\ttimestamp\030\014 \001(\r\022\025\n\rscr"
  "een_locked\030\r \001(\010\022\025\n\rgames_running\030\016 \001(\010\022"
  "\025\n\rmac_addresses\030\017 \003(\t\022\037\n\027download_lan_p"
  "eer_group\030\020 \001(\r\022\033\n\023broadcasting_active\030\021"
  " \001(\010\022\021\n\tvr_active\030\022 \001(\010\022\032\n\022content_cache"
  "_port\030\023 \001(\r\022\024\n\014ip_addresses\030\024 \003(\t\022\031\n\021pub"
  "lic_ip_address\030\025 \001(\t\022\031\n\021remoteplay_activ"
  "e\030\026 \001(\010\022\032\n\022supported_services\030\027 \001(\r\022\022\n\ns"
  "team_deck\030\030 \001(\010\022\025\n\rsteam_version\030\031 \001(\004\032,"
  "\n\004User\022\017\n\007steamid\030\001 \001(\006\022\023\n\013auth_key_id\030\002"
  " \001(\r\"I\n\"CMsgRemoteClientBroadcastDiscove"
  "ry\022\017\n\007seq_num\030\001 \001(\r\022\022\n\nclient_ids\030\002 \003(\004\""
  "A\n+CMsgRemoteClientBroadcastClientIDDeco"
  "nflict\022\022\n\nclient_ids\030\002 \003(\004\"\341\003\n$CMsgRemot"
  "eDeviceAuthorizationRequest\022\024\n\014device_to"
  "ken\030\001 \002(\014\022\023\n\013device_name\030\002 \001(\t\022\031\n\021encryp"
  "ted_request\030\003 \002(\014\022\020\n\010auth_key\030\004 \001(\014\032\247\002\n\021"
  "CKeyEscrow_Ticket\022\020\n\010password\030\001 \001(\014\022\022\n\ni"
  "dentifier\030\002 \001(\004\022\017\n\007payload\030\003 \001(\014\022\021\n\ttime"
  "stamp\030\004 \001(\r\022f\n\005usage\030\005 \001(\01625.CMsgRemoteD"
  "eviceAuthorizationRequest.EKeyEscrowUsag"
  "e: k_EKeyEscrowUsageStreamingDevice\022\023\n\013d"
  "evice_name\030\006 \001(\t\022\024\n\014device_model\030\007 \001(\t\022\025"
  "\n\rdevice_serial\030\010 \001(\t\022\036\n\026device_provisio"
  "ning_id\030\t \001(\r\"7\n\017EKeyEscrowUsage\022$\n k_EK"
  "eyEscrowUsageStreamingDevice\020\000\",\n*CMsgRe"
  "moteDeviceAuthorizationCancelRequest\"\270\001\n"
  "%CMsgRemoteDeviceAuthorizationResponse\022V"
  "\n\006result\030\001 \002(\0162!.ERemoteDeviceAuthorizat"
  "ionResult:#k_ERemoteDeviceAuthorizationS"
  "uccess\022\017\n\007steamid\030\002 \001(\006\022\020\n\010auth_key\030\003 \001("
  "\014\022\024\n\014device_token\030\004 \001(\014\"\200\001\n&CMsgRemoteDe"
  "viceAuthorizationConfirmed\022V\n\006result\030\001 \002"
  "(\0162!.ERemoteDeviceAuthorizationResult:#k"
  "_ERemoteDeviceAuthorizationSuccess\"\221\006\n C"
  "MsgRemoteDeviceStreamingRequest\022\022\n\nreque"
  "st_id\030\001 \002(\r\022\034\n\024maximum_resolution_x\030\002 \001("
  "\005\022\034\n\024maximum_resolution_y\030\003 \001(\005\022\036\n\023audio"
  "_channel_count\030\004 \001(\005:\0012\022\026\n\016device_versio"
  "n\030\005 \001(\t\022\026\n\016stream_desktop\030\006 \001(\010\022\024\n\014devic"
  "e_token\030\007 \001(\014\022\013\n\003pin\030\010 \001(\014\022$\n\026enable_vid"
  "eo_streaming\030\t \001(\010:\004true\022$\n\026enable_audio"
  "_streaming\030\n \001(\010:\004true\022$\n\026enable_input_s"
  "treaming\030\013 \001(\010:\004true\022\024\n\014network_test\030\014 \001"
  "(\010\022\021\n\tclient_id\030\r \001(\004\022.\n\023supported_trans"
  "port\030\016 \003(\0162\021.EStreamTransport\022\022\n\nrestric"
  "ted\030\017 \001(\010\022O\n\013form_factor\030\020 \001(\0162\030.EStream"
  "DeviceFormFactor: k_EStreamDeviceFormFac"
  "torUnknown\022\025\n\rgamepad_count\030\021 \001(\005\022C\n\010gam"
  "epads\030\022 \003(\01321.CMsgRemoteDeviceStreamingR"
  "equest.ReservedGamepad\022\016\n\006gameid\030\023 \001(\004\022F"
  "\n\020stream_interface\030\024 \001(\0162\021.EStreamInterf"
  "ace:\031k_EStreamInterfaceDefault\032F\n\017Reserv"
  "edGamepad\022\027\n\017controller_type\030\001 \001(\r\022\032\n\022co"
  "ntroller_subtype\030\002 \001(\r\"<\n&CMsgRemoteDevi"
  "ceStreamingCancelRequest\022\022\n\nrequest_id\030\001"
  " \002(\r\"I\n!CMsgRemoteDeviceStreamingProgres"
  "s\022\022\n\nrequest_id\030\001 \002(\r\022\020\n\010progress\030\002 \001(\002\""
  "\225\002\n!CMsgRemoteDeviceStreamingResponse\022\022\n"
  "\nrequest_id\030\001 \002(\r\022N\n\006result\030\002 \002(\0162\035.ERem"
  "oteDeviceStreamingResult:\037k_ERemoteDevic"
  "eStreamingSuccess\022\014\n\004port\030\003 \001(\r\022\035\n\025encry"
  "pted_session_key\030\004 \001(\014\022;\n\ttransport\030\006 \001("
  "\0162\021.EStreamTransport:\025k_EStreamTransport"
  "UDP\022\024\n\014relay_server\030\007 \001(\t\022\014\n\004cert\030\010 \001(\t\""
  "\\\n\034CMsgRemoteDeviceProofRequest\022\021\n\tchall"
  "enge\030\001 \002(\014\022\022\n\nrequest_id\030\002 \001(\r\022\025\n\rupdate"
  "_secret\030\003 \001(\010\"]\n\035CMsgRemoteDeviceProofRe"
  "sponse\022\020\n\010response\030\001 \002(\014\022\022\n\nrequest_id\030\002"
  " \001(\r\022\026\n\016updated_secret\030\003 \001(\010\"G\n%CMsgRemo"
  "teDeviceStreamTransportSignal\022\r\n\005token\030\001"
  " \001(\014\022\017\n\007payload\030\002 \001(\014*\375\004\n\031ERemoteClientB"
  "roadcastMsg\022(\n$k_ERemoteClientBroadcastM"
  "sgDiscovery\020\000\022%\n!k_ERemoteClientBroadcas"
  "tMsgStatus\020\001\022&\n\"k_ERemoteClientBroadcast"
  "MsgOffline\020\002\022\'\n#k_ERemoteDeviceAuthoriza"
  "tionRequest\020\003\022(\n$k_ERemoteDeviceAuthoriz"
  "ationResponse\020\004\022#\n\037k_ERemoteDeviceStream"
  "ingRequest\020\005\022$\n k_ERemoteDeviceStreaming"
  "Response\020\006\022\037\n\033k_ERemoteDeviceProofReques"
  "t\020\007\022 \n\034k_ERemoteDeviceProofResponse\020\010\022-\n"
  ")k_ERemoteDeviceAuthorizationCancelReque"
  "st\020\t\022)\n%k_ERemoteDeviceStreamingCancelRe"
  "quest\020\n\0221\n-k_ERemoteClientBroadcastMsgCl"
  "ientIDDeconflict\020\013\022(\n$k_ERemoteDeviceStr"
  "eamTransportSignal\020\014\022$\n k_ERemoteDeviceS"
  "treamingProgress\020\r\022)\n%k_ERemoteDeviceAut"
  "horizationConfirmed\020\016*\200\002\n\024ERemoteClientS"
  "ervice\022\036\n\032k_ERemoteClientServiceNone\020\000\022\'"
  "\n#k_ERemoteClientServiceRemoteControl\020\001\022"
  "\'\n#k_ERemoteClientServiceGameStreaming\020\002"
  "\022%\n!k_ERemoteClientServiceSiteLicense\020\004\022"
  "&\n\"k_ERemoteClientServiceContentCache\020\010\022"
  "\'\n#k_ERemoteClientServiceContentServer\020\020"
  "*\227\003\n ERemoteDeviceAuthorizationResult\022\'\n"
  "#k_ERemoteDeviceAuthorizationSuccess\020\000\022&"
  "\n\"k_ERemoteDeviceAuthorizationDenied\020\001\022+"
  "\n\'k_ERemoteDeviceAuthorizationNotLoggedI"
  "n\020\002\022\'\n#k_ERemoteDeviceAuthorizationOffli"
  "ne\020\003\022$\n k_ERemoteDeviceAuthorizationBusy"
  "\020\004\022*\n&k_ERemoteDeviceAuthorizationInProg"
  "ress\020\005\022(\n$k_ERemoteDeviceAuthorizationTi"
  "medOut\020\006\022&\n\"k_ERemoteDeviceAuthorization"
  "Failed\020\007\022(\n$k_ERemoteDeviceAuthorization"
  "Canceled\020\010*\320\001\n\027EStreamDeviceFormFactor\022$"
  "\n k_EStreamDeviceFormFactorUnknown\020\000\022\"\n\036"
  "k_EStreamDeviceFormFactorPhone\020\001\022#\n\037k_ES"
  "treamDeviceFormFactorTablet\020\002\022%\n!k_EStre"
  "amDeviceFormFactorComputer\020\003\022\037\n\033k_EStrea"
  "mDeviceFormFactorTV\020\004*\345\001\n\020EStreamTranspo"
  "rt\022\032\n\026k_EStreamTransportNone\020\000\022\031\n\025k_EStr"
  "eamTransportUDP\020\001\022\036\n\032k_EStreamTransportU"
  "DPRelay\020\002\022\034\n\030k_EStreamTransportWebRTC\020\003\022"
  "\031\n\025k_EStreamTransportSDR\020\004\022\035\n\031k_EStreamT"
  "ransportUDP_SNS\020\005\022\"\n\036k_EStreamTransportU"
  "DPRelay_SNS\020\006*\225\001\n\020EStreamInterface\022\035\n\031k_"
  "EStreamInterfaceDefault\020\000\022!\n\035k_EStreamIn"
  "terfaceRecentGames\020\001\022 \n\034k_EStreamInterfa"
  "ceBigPicture\020\002\022\035\n\031k_EStreamInterfaceDesk"
  "top\020\003*\210\005\n\034ERemoteDeviceStreamingResult\022#"
  "\n\037k_ERemoteDeviceStreamingSuccess\020\000\022(\n$k"
  "_ERemoteDeviceStreamingUnauthorized\020\001\022(\n"
  "$k_ERemoteDeviceStreamingScreenLocked\020\002\022"
  "\"\n\036k_ERemoteDeviceStreamingFailed\020\003\022 \n\034k"
  "_ERemoteDeviceStreamingBusy\020\004\022&\n\"k_ERemo"
  "teDeviceStreamingInProgress\020\005\022$\n k_ERemo"
  "teDeviceStreamingCanceled\020\006\022/\n+k_ERemote"
  "DeviceStreamingDriversNotInstalled\020\007\022$\n "
  "k_ERemoteDeviceStreamingDisabled\020\010\022.\n*k_"
  "ERemoteDeviceStreamingBroadcastingActive"
  "\020\t\022$\n k_ERemoteDeviceStreamingVRActive\020\n"
  "\022\'\n#k_ERemoteDeviceStreamingPINRequired\020"
  "\013\0220\n,k_ERemoteDeviceStreamingTransportUn"
  "available\020\014\022%\n!k_ERemoteDeviceStreamingI"
  "nvisible\020\r\022,\n(k_ERemoteDeviceStreamingGa"
  "meLaunchFailed\020\016B\002H\001"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto = {
  false, false, 5900, descriptor_table_protodef_steammessages_5fremoteclient_5fdiscovery_2eproto, "steammessages_remoteclient_discovery.proto", 
  &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once, nullptr, 0, 18,
  schemas, file_default_instances, TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto::offsets,
  file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto, file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto, file_level_service_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter() {
  return &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fremoteclient_5fdiscovery_2eproto(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[0];
}
bool CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest::k_EKeyEscrowUsageStreamingDevice;
constexpr CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest::EKeyEscrowUsage_MIN;
constexpr CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest::EKeyEscrowUsage_MAX;
constexpr int CMsgRemoteDeviceAuthorizationRequest::EKeyEscrowUsage_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteClientBroadcastMsg_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[1];
}
bool ERemoteClientBroadcastMsg_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteClientService_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[2];
}
bool ERemoteClientService_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteDeviceAuthorizationResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[3];
}
bool ERemoteDeviceAuthorizationResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDeviceFormFactor_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[4];
}
bool EStreamDeviceFormFactor_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamTransport_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[5];
}
bool EStreamTransport_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamInterface_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[6];
}
bool EStreamInterface_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteDeviceStreamingResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteclient_5fdiscovery_2eproto[7];
}
bool ERemoteDeviceStreamingResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgRemoteClientBroadcastHeader::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteClientBroadcastHeader>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_instance_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgRemoteClientBroadcastHeader::CMsgRemoteClientBroadcastHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteClientBroadcastHeader)
}
CMsgRemoteClientBroadcastHeader::CMsgRemoteClientBroadcastHeader(const CMsgRemoteClientBroadcastHeader& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_token()) {
    device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&msg_type_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(msg_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteClientBroadcastHeader)
}

inline void CMsgRemoteClientBroadcastHeader::SharedCtor() {
device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&msg_type_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(msg_type_));
}

CMsgRemoteClientBroadcastHeader::~CMsgRemoteClientBroadcastHeader() {
  // @@protoc_insertion_point(destructor:CMsgRemoteClientBroadcastHeader)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteClientBroadcastHeader::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteClientBroadcastHeader::ArenaDtor(void* object) {
  CMsgRemoteClientBroadcastHeader* _this = reinterpret_cast< CMsgRemoteClientBroadcastHeader* >(object);
  (void)_this;
}
void CMsgRemoteClientBroadcastHeader::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteClientBroadcastHeader::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteClientBroadcastHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteClientBroadcastHeader)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&msg_type_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(msg_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteClientBroadcastHeader::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ERemoteClientBroadcastMsg msg_type = 2 [default = k_ERemoteClientBroadcastMsgDiscovery];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ERemoteClientBroadcastMsg_IsValid(val))) {
            _internal_set_msg_type(static_cast<::ERemoteClientBroadcastMsg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 instance_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_instance_id(&has_bits);
          instance_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 device_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_token = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteClientBroadcastHeader::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteClientBroadcastHeader)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional .ERemoteClientBroadcastMsg msg_type = 2 [default = k_ERemoteClientBroadcastMsgDiscovery];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_msg_type(), target);
  }

  // optional uint64 instance_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_instance_id(), target);
  }

  // optional uint64 device_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_device_id(), target);
  }

  // optional bytes device_token = 5;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        5, this->_internal_device_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteClientBroadcastHeader)
  return target;
}

size_t CMsgRemoteClientBroadcastHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteClientBroadcastHeader)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes device_token = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_token());
    }

    // optional uint64 client_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional uint64 instance_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_instance_id());
    }

    // optional uint64 device_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_device_id());
    }

    // optional .ERemoteClientBroadcastMsg msg_type = 2 [default = k_ERemoteClientBroadcastMsgDiscovery];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_msg_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteClientBroadcastHeader::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteClientBroadcastHeader::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteClientBroadcastHeader::GetClassData() const { return &_class_data_; }

void CMsgRemoteClientBroadcastHeader::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteClientBroadcastHeader *>(to)->MergeFrom(
      static_cast<const CMsgRemoteClientBroadcastHeader &>(from));
}


void CMsgRemoteClientBroadcastHeader::MergeFrom(const CMsgRemoteClientBroadcastHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteClientBroadcastHeader)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_token(from._internal_device_token());
    }
    if (cached_has_bits & 0x00000002u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      instance_id_ = from.instance_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      device_id_ = from.device_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      msg_type_ = from.msg_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteClientBroadcastHeader::CopyFrom(const CMsgRemoteClientBroadcastHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteClientBroadcastHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteClientBroadcastHeader::IsInitialized() const {
  return true;
}

void CMsgRemoteClientBroadcastHeader::InternalSwap(CMsgRemoteClientBroadcastHeader* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_token_, lhs_arena,
      &other->device_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastHeader, msg_type_)
      + sizeof(CMsgRemoteClientBroadcastHeader::msg_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastHeader, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteClientBroadcastHeader::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[0]);
}

// ===================================================================

class CMsgRemoteClientBroadcastStatus_User::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteClientBroadcastStatus_User>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auth_key_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgRemoteClientBroadcastStatus_User::CMsgRemoteClientBroadcastStatus_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteClientBroadcastStatus.User)
}
CMsgRemoteClientBroadcastStatus_User::CMsgRemoteClientBroadcastStatus_User(const CMsgRemoteClientBroadcastStatus_User& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&auth_key_id_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(auth_key_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteClientBroadcastStatus.User)
}

inline void CMsgRemoteClientBroadcastStatus_User::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&auth_key_id_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(auth_key_id_));
}

CMsgRemoteClientBroadcastStatus_User::~CMsgRemoteClientBroadcastStatus_User() {
  // @@protoc_insertion_point(destructor:CMsgRemoteClientBroadcastStatus.User)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteClientBroadcastStatus_User::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteClientBroadcastStatus_User::ArenaDtor(void* object) {
  CMsgRemoteClientBroadcastStatus_User* _this = reinterpret_cast< CMsgRemoteClientBroadcastStatus_User* >(object);
  (void)_this;
}
void CMsgRemoteClientBroadcastStatus_User::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteClientBroadcastStatus_User::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteClientBroadcastStatus_User::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteClientBroadcastStatus.User)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&auth_key_id_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(auth_key_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteClientBroadcastStatus_User::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_key_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_auth_key_id(&has_bits);
          auth_key_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteClientBroadcastStatus_User::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteClientBroadcastStatus.User)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 auth_key_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_auth_key_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteClientBroadcastStatus.User)
  return target;
}

size_t CMsgRemoteClientBroadcastStatus_User::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteClientBroadcastStatus.User)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 auth_key_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_auth_key_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteClientBroadcastStatus_User::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteClientBroadcastStatus_User::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteClientBroadcastStatus_User::GetClassData() const { return &_class_data_; }

void CMsgRemoteClientBroadcastStatus_User::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteClientBroadcastStatus_User *>(to)->MergeFrom(
      static_cast<const CMsgRemoteClientBroadcastStatus_User &>(from));
}


void CMsgRemoteClientBroadcastStatus_User::MergeFrom(const CMsgRemoteClientBroadcastStatus_User& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteClientBroadcastStatus.User)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      auth_key_id_ = from.auth_key_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteClientBroadcastStatus_User::CopyFrom(const CMsgRemoteClientBroadcastStatus_User& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteClientBroadcastStatus.User)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteClientBroadcastStatus_User::IsInitialized() const {
  return true;
}

void CMsgRemoteClientBroadcastStatus_User::InternalSwap(CMsgRemoteClientBroadcastStatus_User* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastStatus_User, auth_key_id_)
      + sizeof(CMsgRemoteClientBroadcastStatus_User::auth_key_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastStatus_User, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteClientBroadcastStatus_User::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[1]);
}

// ===================================================================

class CMsgRemoteClientBroadcastStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteClientBroadcastStatus>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_min_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_connect_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enabled_services(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_ostype(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is64bit(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_euniverse(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_screen_locked(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_games_running(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_download_lan_peer_group(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_broadcasting_active(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_vr_active(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_content_cache_port(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_public_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remoteplay_active(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_supported_services(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_steam_deck(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_steam_version(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

CMsgRemoteClientBroadcastStatus::CMsgRemoteClientBroadcastStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  users_(arena),
  mac_addresses_(arena),
  ip_addresses_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteClientBroadcastStatus)
}
CMsgRemoteClientBroadcastStatus::CMsgRemoteClientBroadcastStatus(const CMsgRemoteClientBroadcastStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      users_(from.users_),
      mac_addresses_(from.mac_addresses_),
      ip_addresses_(from.ip_addresses_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hostname(), 
      GetArenaForAllocation());
  }
  public_ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    public_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_public_ip_address()) {
    public_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_public_ip_address(), 
      GetArenaForAllocation());
  }
  ::memcpy(&version_, &from.version_,
    static_cast<size_t>(reinterpret_cast<char*>(&steam_version_) -
    reinterpret_cast<char*>(&version_)) + sizeof(steam_version_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteClientBroadcastStatus)
}

inline void CMsgRemoteClientBroadcastStatus::SharedCtor() {
hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
public_ip_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  public_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&version_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steam_version_) -
    reinterpret_cast<char*>(&version_)) + sizeof(steam_version_));
}

CMsgRemoteClientBroadcastStatus::~CMsgRemoteClientBroadcastStatus() {
  // @@protoc_insertion_point(destructor:CMsgRemoteClientBroadcastStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteClientBroadcastStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  public_ip_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteClientBroadcastStatus::ArenaDtor(void* object) {
  CMsgRemoteClientBroadcastStatus* _this = reinterpret_cast< CMsgRemoteClientBroadcastStatus* >(object);
  (void)_this;
}
void CMsgRemoteClientBroadcastStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteClientBroadcastStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteClientBroadcastStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteClientBroadcastStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  users_.Clear();
  mac_addresses_.Clear();
  ip_addresses_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hostname_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      public_ip_address_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&version_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&euniverse_) -
        reinterpret_cast<char*>(&version_)) + sizeof(euniverse_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&vr_active_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(vr_active_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&remoteplay_active_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steam_version_) -
        reinterpret_cast<char*>(&remoteplay_active_)) + sizeof(steam_version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteClientBroadcastStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 version = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 min_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_min_version(&has_bits);
          min_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 connect_port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_connect_port(&has_bits);
          connect_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string hostname = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_hostname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteClientBroadcastStatus.hostname");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 enabled_services = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enabled_services(&has_bits);
          enabled_services_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 ostype = 7 [default = 0];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ostype(&has_bits);
          ostype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is64bit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is64bit(&has_bits);
          is64bit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_users(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 euniverse = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_euniverse(&has_bits);
          euniverse_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool screen_locked = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_screen_locked(&has_bits);
          screen_locked_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool games_running = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_games_running(&has_bits);
          games_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string mac_addresses = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_mac_addresses();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteClientBroadcastStatus.mac_addresses");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 download_lan_peer_group = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_download_lan_peer_group(&has_bits);
          download_lan_peer_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool broadcasting_active = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_broadcasting_active(&has_bits);
          broadcasting_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool vr_active = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_vr_active(&has_bits);
          vr_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 content_cache_port = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_content_cache_port(&has_bits);
          content_cache_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string ip_addresses = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_ip_addresses();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteClientBroadcastStatus.ip_addresses");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<162>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string public_ip_address = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_public_ip_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteClientBroadcastStatus.public_ip_address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool remoteplay_active = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_remoteplay_active(&has_bits);
          remoteplay_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 supported_services = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_supported_services(&has_bits);
          supported_services_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool steam_deck = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_steam_deck(&has_bits);
          steam_deck_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steam_version = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_steam_version(&has_bits);
          steam_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteClientBroadcastStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteClientBroadcastStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 version = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
  }

  // optional int32 min_version = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_min_version(), target);
  }

  // optional uint32 connect_port = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_connect_port(), target);
  }

  // optional string hostname = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteClientBroadcastStatus.hostname");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_hostname(), target);
  }

  // optional uint32 enabled_services = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_enabled_services(), target);
  }

  // optional int32 ostype = 7 [default = 0];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_ostype(), target);
  }

  // optional bool is64bit = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is64bit(), target);
  }

  // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_users_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, this->_internal_users(i), target, stream);
  }

  // optional int32 euniverse = 11;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_euniverse(), target);
  }

  // optional uint32 timestamp = 12;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_timestamp(), target);
  }

  // optional bool screen_locked = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_screen_locked(), target);
  }

  // optional bool games_running = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_games_running(), target);
  }

  // repeated string mac_addresses = 15;
  for (int i = 0, n = this->_internal_mac_addresses_size(); i < n; i++) {
    const auto& s = this->_internal_mac_addresses(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteClientBroadcastStatus.mac_addresses");
    target = stream->WriteString(15, s, target);
  }

  // optional uint32 download_lan_peer_group = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(16, this->_internal_download_lan_peer_group(), target);
  }

  // optional bool broadcasting_active = 17;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_broadcasting_active(), target);
  }

  // optional bool vr_active = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_vr_active(), target);
  }

  // optional uint32 content_cache_port = 19;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(19, this->_internal_content_cache_port(), target);
  }

  // repeated string ip_addresses = 20;
  for (int i = 0, n = this->_internal_ip_addresses_size(); i < n; i++) {
    const auto& s = this->_internal_ip_addresses(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteClientBroadcastStatus.ip_addresses");
    target = stream->WriteString(20, s, target);
  }

  // optional string public_ip_address = 21;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_public_ip_address().data(), static_cast<int>(this->_internal_public_ip_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteClientBroadcastStatus.public_ip_address");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_public_ip_address(), target);
  }

  // optional bool remoteplay_active = 22;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_remoteplay_active(), target);
  }

  // optional uint32 supported_services = 23;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(23, this->_internal_supported_services(), target);
  }

  // optional bool steam_deck = 24;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_steam_deck(), target);
  }

  // optional uint64 steam_version = 25;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(25, this->_internal_steam_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteClientBroadcastStatus)
  return target;
}

size_t CMsgRemoteClientBroadcastStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteClientBroadcastStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;
  total_size += 1UL * this->_internal_users_size();
  for (const auto& msg : this->users_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string mac_addresses = 15;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(mac_addresses_.size());
  for (int i = 0, n = mac_addresses_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      mac_addresses_.Get(i));
  }

  // repeated string ip_addresses = 20;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(ip_addresses_.size());
  for (int i = 0, n = ip_addresses_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      ip_addresses_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string hostname = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hostname());
    }

    // optional string public_ip_address = 21;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_public_ip_address());
    }

    // optional int32 version = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

    // optional int32 min_version = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_min_version());
    }

    // optional uint32 connect_port = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_connect_port());
    }

    // optional uint32 enabled_services = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_enabled_services());
    }

    // optional int32 ostype = 7 [default = 0];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ostype());
    }

    // optional int32 euniverse = 11;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_euniverse());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 timestamp = 12;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional bool is64bit = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool screen_locked = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool games_running = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool broadcasting_active = 17;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional uint32 download_lan_peer_group = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_download_lan_peer_group());
    }

    // optional uint32 content_cache_port = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_content_cache_port());
    }

    // optional bool vr_active = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional bool remoteplay_active = 22;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool steam_deck = 24;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional uint32 supported_services = 23;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_supported_services());
    }

    // optional uint64 steam_version = 25;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_steam_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteClientBroadcastStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteClientBroadcastStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteClientBroadcastStatus::GetClassData() const { return &_class_data_; }

void CMsgRemoteClientBroadcastStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteClientBroadcastStatus *>(to)->MergeFrom(
      static_cast<const CMsgRemoteClientBroadcastStatus &>(from));
}


void CMsgRemoteClientBroadcastStatus::MergeFrom(const CMsgRemoteClientBroadcastStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteClientBroadcastStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  users_.MergeFrom(from.users_);
  mac_addresses_.MergeFrom(from.mac_addresses_);
  ip_addresses_.MergeFrom(from.ip_addresses_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hostname(from._internal_hostname());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_public_ip_address(from._internal_public_ip_address());
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000008u) {
      min_version_ = from.min_version_;
    }
    if (cached_has_bits & 0x00000010u) {
      connect_port_ = from.connect_port_;
    }
    if (cached_has_bits & 0x00000020u) {
      enabled_services_ = from.enabled_services_;
    }
    if (cached_has_bits & 0x00000040u) {
      ostype_ = from.ostype_;
    }
    if (cached_has_bits & 0x00000080u) {
      euniverse_ = from.euniverse_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000200u) {
      is64bit_ = from.is64bit_;
    }
    if (cached_has_bits & 0x00000400u) {
      screen_locked_ = from.screen_locked_;
    }
    if (cached_has_bits & 0x00000800u) {
      games_running_ = from.games_running_;
    }
    if (cached_has_bits & 0x00001000u) {
      broadcasting_active_ = from.broadcasting_active_;
    }
    if (cached_has_bits & 0x00002000u) {
      download_lan_peer_group_ = from.download_lan_peer_group_;
    }
    if (cached_has_bits & 0x00004000u) {
      content_cache_port_ = from.content_cache_port_;
    }
    if (cached_has_bits & 0x00008000u) {
      vr_active_ = from.vr_active_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      remoteplay_active_ = from.remoteplay_active_;
    }
    if (cached_has_bits & 0x00020000u) {
      steam_deck_ = from.steam_deck_;
    }
    if (cached_has_bits & 0x00040000u) {
      supported_services_ = from.supported_services_;
    }
    if (cached_has_bits & 0x00080000u) {
      steam_version_ = from.steam_version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteClientBroadcastStatus::CopyFrom(const CMsgRemoteClientBroadcastStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteClientBroadcastStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteClientBroadcastStatus::IsInitialized() const {
  return true;
}

void CMsgRemoteClientBroadcastStatus::InternalSwap(CMsgRemoteClientBroadcastStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  users_.InternalSwap(&other->users_);
  mac_addresses_.InternalSwap(&other->mac_addresses_);
  ip_addresses_.InternalSwap(&other->ip_addresses_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &public_ip_address_, lhs_arena,
      &other->public_ip_address_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastStatus, steam_version_)
      + sizeof(CMsgRemoteClientBroadcastStatus::steam_version_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteClientBroadcastStatus, version_)>(
          reinterpret_cast<char*>(&version_),
          reinterpret_cast<char*>(&other->version_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteClientBroadcastStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[2]);
}

// ===================================================================

class CMsgRemoteClientBroadcastDiscovery::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteClientBroadcastDiscovery>()._has_bits_);
  static void set_has_seq_num(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgRemoteClientBroadcastDiscovery::CMsgRemoteClientBroadcastDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  client_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteClientBroadcastDiscovery)
}
CMsgRemoteClientBroadcastDiscovery::CMsgRemoteClientBroadcastDiscovery(const CMsgRemoteClientBroadcastDiscovery& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      client_ids_(from.client_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  seq_num_ = from.seq_num_;
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteClientBroadcastDiscovery)
}

inline void CMsgRemoteClientBroadcastDiscovery::SharedCtor() {
seq_num_ = 0u;
}

CMsgRemoteClientBroadcastDiscovery::~CMsgRemoteClientBroadcastDiscovery() {
  // @@protoc_insertion_point(destructor:CMsgRemoteClientBroadcastDiscovery)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteClientBroadcastDiscovery::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteClientBroadcastDiscovery::ArenaDtor(void* object) {
  CMsgRemoteClientBroadcastDiscovery* _this = reinterpret_cast< CMsgRemoteClientBroadcastDiscovery* >(object);
  (void)_this;
}
void CMsgRemoteClientBroadcastDiscovery::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteClientBroadcastDiscovery::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteClientBroadcastDiscovery::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteClientBroadcastDiscovery)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_ids_.Clear();
  seq_num_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteClientBroadcastDiscovery::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 seq_num = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_seq_num(&has_bits);
          seq_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint64 client_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_client_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_client_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteClientBroadcastDiscovery::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteClientBroadcastDiscovery)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 seq_num = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_seq_num(), target);
  }

  // repeated uint64 client_ids = 2;
  for (int i = 0, n = this->_internal_client_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_client_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteClientBroadcastDiscovery)
  return target;
}

size_t CMsgRemoteClientBroadcastDiscovery::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteClientBroadcastDiscovery)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 client_ids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->client_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_client_ids_size());
    total_size += data_size;
  }

  // optional uint32 seq_num = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_seq_num());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteClientBroadcastDiscovery::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteClientBroadcastDiscovery::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteClientBroadcastDiscovery::GetClassData() const { return &_class_data_; }

void CMsgRemoteClientBroadcastDiscovery::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteClientBroadcastDiscovery *>(to)->MergeFrom(
      static_cast<const CMsgRemoteClientBroadcastDiscovery &>(from));
}


void CMsgRemoteClientBroadcastDiscovery::MergeFrom(const CMsgRemoteClientBroadcastDiscovery& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteClientBroadcastDiscovery)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  client_ids_.MergeFrom(from.client_ids_);
  if (from._internal_has_seq_num()) {
    _internal_set_seq_num(from._internal_seq_num());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteClientBroadcastDiscovery::CopyFrom(const CMsgRemoteClientBroadcastDiscovery& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteClientBroadcastDiscovery)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteClientBroadcastDiscovery::IsInitialized() const {
  return true;
}

void CMsgRemoteClientBroadcastDiscovery::InternalSwap(CMsgRemoteClientBroadcastDiscovery* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  client_ids_.InternalSwap(&other->client_ids_);
  swap(seq_num_, other->seq_num_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteClientBroadcastDiscovery::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[3]);
}

// ===================================================================

class CMsgRemoteClientBroadcastClientIDDeconflict::_Internal {
 public:
};

CMsgRemoteClientBroadcastClientIDDeconflict::CMsgRemoteClientBroadcastClientIDDeconflict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  client_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteClientBroadcastClientIDDeconflict)
}
CMsgRemoteClientBroadcastClientIDDeconflict::CMsgRemoteClientBroadcastClientIDDeconflict(const CMsgRemoteClientBroadcastClientIDDeconflict& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      client_ids_(from.client_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteClientBroadcastClientIDDeconflict)
}

inline void CMsgRemoteClientBroadcastClientIDDeconflict::SharedCtor() {
}

CMsgRemoteClientBroadcastClientIDDeconflict::~CMsgRemoteClientBroadcastClientIDDeconflict() {
  // @@protoc_insertion_point(destructor:CMsgRemoteClientBroadcastClientIDDeconflict)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteClientBroadcastClientIDDeconflict::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteClientBroadcastClientIDDeconflict::ArenaDtor(void* object) {
  CMsgRemoteClientBroadcastClientIDDeconflict* _this = reinterpret_cast< CMsgRemoteClientBroadcastClientIDDeconflict* >(object);
  (void)_this;
}
void CMsgRemoteClientBroadcastClientIDDeconflict::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteClientBroadcastClientIDDeconflict::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteClientBroadcastClientIDDeconflict::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteClientBroadcastClientIDDeconflict)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteClientBroadcastClientIDDeconflict::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 client_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_client_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_client_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteClientBroadcastClientIDDeconflict::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteClientBroadcastClientIDDeconflict)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 client_ids = 2;
  for (int i = 0, n = this->_internal_client_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_client_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteClientBroadcastClientIDDeconflict)
  return target;
}

size_t CMsgRemoteClientBroadcastClientIDDeconflict::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteClientBroadcastClientIDDeconflict)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 client_ids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->client_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_client_ids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteClientBroadcastClientIDDeconflict::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteClientBroadcastClientIDDeconflict::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteClientBroadcastClientIDDeconflict::GetClassData() const { return &_class_data_; }

void CMsgRemoteClientBroadcastClientIDDeconflict::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteClientBroadcastClientIDDeconflict *>(to)->MergeFrom(
      static_cast<const CMsgRemoteClientBroadcastClientIDDeconflict &>(from));
}


void CMsgRemoteClientBroadcastClientIDDeconflict::MergeFrom(const CMsgRemoteClientBroadcastClientIDDeconflict& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteClientBroadcastClientIDDeconflict)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  client_ids_.MergeFrom(from.client_ids_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteClientBroadcastClientIDDeconflict::CopyFrom(const CMsgRemoteClientBroadcastClientIDDeconflict& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteClientBroadcastClientIDDeconflict)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteClientBroadcastClientIDDeconflict::IsInitialized() const {
  return true;
}

void CMsgRemoteClientBroadcastClientIDDeconflict::InternalSwap(CMsgRemoteClientBroadcastClientIDDeconflict* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  client_ids_.InternalSwap(&other->client_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteClientBroadcastClientIDDeconflict::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[4]);
}

// ===================================================================

class CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket>()._has_bits_);
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_identifier(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_device_model(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_device_provisioning_id(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
}
CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_payload(), 
      GetArenaForAllocation());
  }
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_name(), 
      GetArenaForAllocation());
  }
  device_model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_model()) {
    device_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_model(), 
      GetArenaForAllocation());
  }
  device_serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_serial()) {
    device_serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_serial(), 
      GetArenaForAllocation());
  }
  ::memcpy(&identifier_, &from.identifier_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_provisioning_id_) -
    reinterpret_cast<char*>(&identifier_)) + sizeof(device_provisioning_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
}

inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::SharedCtor() {
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&identifier_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_provisioning_id_) -
    reinterpret_cast<char*>(&identifier_)) + sizeof(device_provisioning_id_));
}

CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::~CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::ArenaDtor(void* object) {
  CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* _this = reinterpret_cast< CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* >(object);
  (void)_this;
}
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      payload_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      device_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      device_model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      device_serial_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&identifier_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&usage_) -
        reinterpret_cast<char*>(&identifier_)) + sizeof(usage_));
  }
  device_provisioning_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes password = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 identifier = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_identifier(&has_bits);
          identifier_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_payload();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5 [default = k_EKeyEscrowUsageStreamingDevice];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_IsValid(val))) {
            _internal_set_usage(static_cast<::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_device_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_model = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device_model();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_serial = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_device_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 device_provisioning_id = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_device_provisioning_id(&has_bits);
          device_provisioning_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes password = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_password(), target);
  }

  // optional uint64 identifier = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_identifier(), target);
  }

  // optional bytes payload = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_payload(), target);
  }

  // optional uint32 timestamp = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_timestamp(), target);
  }

  // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5 [default = k_EKeyEscrowUsageStreamingDevice];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_usage(), target);
  }

  // optional string device_name = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_name().data(), static_cast<int>(this->_internal_device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_device_name(), target);
  }

  // optional string device_model = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_model().data(), static_cast<int>(this->_internal_device_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_device_model(), target);
  }

  // optional string device_serial = 8;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_serial().data(), static_cast<int>(this->_internal_device_serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_device_serial(), target);
  }

  // optional uint32 device_provisioning_id = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_device_provisioning_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  return target;
}

size_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes password = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_password());
    }

    // optional bytes payload = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

    // optional string device_name = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_name());
    }

    // optional string device_model = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_model());
    }

    // optional string device_serial = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_serial());
    }

    // optional uint64 identifier = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_identifier());
    }

    // optional uint32 timestamp = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5 [default = k_EKeyEscrowUsageStreamingDevice];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_usage());
    }

  }
  // optional uint32 device_provisioning_id = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_device_provisioning_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket &>(from));
}


void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::MergeFrom(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_payload(from._internal_payload());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_device_name(from._internal_device_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_device_model(from._internal_device_model());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_device_serial(from._internal_device_serial());
    }
    if (cached_has_bits & 0x00000020u) {
      identifier_ = from.identifier_;
    }
    if (cached_has_bits & 0x00000040u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      usage_ = from.usage_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_device_provisioning_id(from._internal_device_provisioning_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::CopyFrom(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::IsInitialized() const {
  return true;
}

void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::InternalSwap(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &payload_, lhs_arena,
      &other->payload_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_name_, lhs_arena,
      &other->device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_model_, lhs_arena,
      &other->device_model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_serial_, lhs_arena,
      &other->device_serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, device_provisioning_id_)
      + sizeof(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::device_provisioning_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket, identifier_)>(
          reinterpret_cast<char*>(&identifier_),
          reinterpret_cast<char*>(&other->identifier_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[5]);
}

// ===================================================================

class CMsgRemoteDeviceAuthorizationRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceAuthorizationRequest>()._has_bits_);
  static void set_has_device_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encrypted_request(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CMsgRemoteDeviceAuthorizationRequest::CMsgRemoteDeviceAuthorizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceAuthorizationRequest)
}
CMsgRemoteDeviceAuthorizationRequest::CMsgRemoteDeviceAuthorizationRequest(const CMsgRemoteDeviceAuthorizationRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_token()) {
    device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_token(), 
      GetArenaForAllocation());
  }
  device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_name()) {
    device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_name(), 
      GetArenaForAllocation());
  }
  encrypted_request_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_request_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_request()) {
    encrypted_request_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_request(), 
      GetArenaForAllocation());
  }
  auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_key()) {
    auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_key(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceAuthorizationRequest)
}

inline void CMsgRemoteDeviceAuthorizationRequest::SharedCtor() {
device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
encrypted_request_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_request_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgRemoteDeviceAuthorizationRequest::~CMsgRemoteDeviceAuthorizationRequest() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceAuthorizationRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceAuthorizationRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encrypted_request_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auth_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceAuthorizationRequest::ArenaDtor(void* object) {
  CMsgRemoteDeviceAuthorizationRequest* _this = reinterpret_cast< CMsgRemoteDeviceAuthorizationRequest* >(object);
  (void)_this;
}
void CMsgRemoteDeviceAuthorizationRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceAuthorizationRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceAuthorizationRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceAuthorizationRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      device_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      device_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      encrypted_request_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      auth_key_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceAuthorizationRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes device_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_device_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceAuthorizationRequest.device_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required bytes encrypted_request = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_encrypted_request();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes auth_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_auth_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceAuthorizationRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceAuthorizationRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes device_token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_device_token(), target);
  }

  // optional string device_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_name().data(), static_cast<int>(this->_internal_device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceAuthorizationRequest.device_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_device_name(), target);
  }

  // required bytes encrypted_request = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_encrypted_request(), target);
  }

  // optional bytes auth_key = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_auth_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceAuthorizationRequest)
  return target;
}

size_t CMsgRemoteDeviceAuthorizationRequest::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CMsgRemoteDeviceAuthorizationRequest)
  size_t total_size = 0;

  if (_internal_has_device_token()) {
    // required bytes device_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_device_token());
  }

  if (_internal_has_encrypted_request()) {
    // required bytes encrypted_request = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_request());
  }

  return total_size;
}
size_t CMsgRemoteDeviceAuthorizationRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceAuthorizationRequest)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required bytes device_token = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_device_token());

    // required bytes encrypted_request = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_encrypted_request());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_name = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_name());
  }

  // optional bytes auth_key = 4;
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_auth_key());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceAuthorizationRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceAuthorizationRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceAuthorizationRequest::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceAuthorizationRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceAuthorizationRequest *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceAuthorizationRequest &>(from));
}


void CMsgRemoteDeviceAuthorizationRequest::MergeFrom(const CMsgRemoteDeviceAuthorizationRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceAuthorizationRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_token(from._internal_device_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_device_name(from._internal_device_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_encrypted_request(from._internal_encrypted_request());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_auth_key(from._internal_auth_key());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceAuthorizationRequest::CopyFrom(const CMsgRemoteDeviceAuthorizationRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceAuthorizationRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceAuthorizationRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceAuthorizationRequest::InternalSwap(CMsgRemoteDeviceAuthorizationRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_token_, lhs_arena,
      &other->device_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_name_, lhs_arena,
      &other->device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_request_, lhs_arena,
      &other->encrypted_request_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_key_, lhs_arena,
      &other->auth_key_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceAuthorizationRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[6]);
}

// ===================================================================

class CMsgRemoteDeviceAuthorizationCancelRequest::_Internal {
 public:
};

CMsgRemoteDeviceAuthorizationCancelRequest::CMsgRemoteDeviceAuthorizationCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceAuthorizationCancelRequest)
}
CMsgRemoteDeviceAuthorizationCancelRequest::CMsgRemoteDeviceAuthorizationCancelRequest(const CMsgRemoteDeviceAuthorizationCancelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceAuthorizationCancelRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceAuthorizationCancelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceAuthorizationCancelRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceAuthorizationCancelRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[7]);
}

// ===================================================================

class CMsgRemoteDeviceAuthorizationResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceAuthorizationResponse>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_device_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

CMsgRemoteDeviceAuthorizationResponse::CMsgRemoteDeviceAuthorizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceAuthorizationResponse)
}
CMsgRemoteDeviceAuthorizationResponse::CMsgRemoteDeviceAuthorizationResponse(const CMsgRemoteDeviceAuthorizationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_key()) {
    auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_key(), 
      GetArenaForAllocation());
  }
  device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_token()) {
    device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&result_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(result_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceAuthorizationResponse)
}

inline void CMsgRemoteDeviceAuthorizationResponse::SharedCtor() {
auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&result_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(result_));
}

CMsgRemoteDeviceAuthorizationResponse::~CMsgRemoteDeviceAuthorizationResponse() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceAuthorizationResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceAuthorizationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  auth_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceAuthorizationResponse::ArenaDtor(void* object) {
  CMsgRemoteDeviceAuthorizationResponse* _this = reinterpret_cast< CMsgRemoteDeviceAuthorizationResponse* >(object);
  (void)_this;
}
void CMsgRemoteDeviceAuthorizationResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceAuthorizationResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceAuthorizationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceAuthorizationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      auth_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      device_token_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&result_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(result_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceAuthorizationResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ERemoteDeviceAuthorizationResult_IsValid(val))) {
            _internal_set_result(static_cast<::ERemoteDeviceAuthorizationResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes auth_key = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_auth_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_token = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_device_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceAuthorizationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceAuthorizationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional bytes auth_key = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_auth_key(), target);
  }

  // optional bytes device_token = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_device_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceAuthorizationResponse)
  return target;
}

size_t CMsgRemoteDeviceAuthorizationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceAuthorizationResponse)
  size_t total_size = 0;

  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  if (_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes auth_key = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_auth_key());
    }

    // optional bytes device_token = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_token());
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceAuthorizationResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceAuthorizationResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceAuthorizationResponse::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceAuthorizationResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceAuthorizationResponse *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceAuthorizationResponse &>(from));
}


void CMsgRemoteDeviceAuthorizationResponse::MergeFrom(const CMsgRemoteDeviceAuthorizationResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceAuthorizationResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_auth_key(from._internal_auth_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_device_token(from._internal_device_token());
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      result_ = from.result_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceAuthorizationResponse::CopyFrom(const CMsgRemoteDeviceAuthorizationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceAuthorizationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceAuthorizationResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceAuthorizationResponse::InternalSwap(CMsgRemoteDeviceAuthorizationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_key_, lhs_arena,
      &other->auth_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_token_, lhs_arena,
      &other->device_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceAuthorizationResponse, result_)
      + sizeof(CMsgRemoteDeviceAuthorizationResponse::result_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceAuthorizationResponse, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceAuthorizationResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[8]);
}

// ===================================================================

class CMsgRemoteDeviceAuthorizationConfirmed::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceAuthorizationConfirmed>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgRemoteDeviceAuthorizationConfirmed::CMsgRemoteDeviceAuthorizationConfirmed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceAuthorizationConfirmed)
}
CMsgRemoteDeviceAuthorizationConfirmed::CMsgRemoteDeviceAuthorizationConfirmed(const CMsgRemoteDeviceAuthorizationConfirmed& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  result_ = from.result_;
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceAuthorizationConfirmed)
}

inline void CMsgRemoteDeviceAuthorizationConfirmed::SharedCtor() {
result_ = 0;
}

CMsgRemoteDeviceAuthorizationConfirmed::~CMsgRemoteDeviceAuthorizationConfirmed() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceAuthorizationConfirmed)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceAuthorizationConfirmed::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteDeviceAuthorizationConfirmed::ArenaDtor(void* object) {
  CMsgRemoteDeviceAuthorizationConfirmed* _this = reinterpret_cast< CMsgRemoteDeviceAuthorizationConfirmed* >(object);
  (void)_this;
}
void CMsgRemoteDeviceAuthorizationConfirmed::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceAuthorizationConfirmed::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceAuthorizationConfirmed::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceAuthorizationConfirmed)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  result_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceAuthorizationConfirmed::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ERemoteDeviceAuthorizationResult_IsValid(val))) {
            _internal_set_result(static_cast<::ERemoteDeviceAuthorizationResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceAuthorizationConfirmed::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceAuthorizationConfirmed)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceAuthorizationConfirmed)
  return target;
}

size_t CMsgRemoteDeviceAuthorizationConfirmed::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceAuthorizationConfirmed)
  size_t total_size = 0;

  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  if (_internal_has_result()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceAuthorizationConfirmed::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceAuthorizationConfirmed::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceAuthorizationConfirmed::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceAuthorizationConfirmed::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceAuthorizationConfirmed *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceAuthorizationConfirmed &>(from));
}


void CMsgRemoteDeviceAuthorizationConfirmed::MergeFrom(const CMsgRemoteDeviceAuthorizationConfirmed& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceAuthorizationConfirmed)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_set_result(from._internal_result());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceAuthorizationConfirmed::CopyFrom(const CMsgRemoteDeviceAuthorizationConfirmed& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceAuthorizationConfirmed)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceAuthorizationConfirmed::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceAuthorizationConfirmed::InternalSwap(CMsgRemoteDeviceAuthorizationConfirmed* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceAuthorizationConfirmed::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[9]);
}

// ===================================================================

class CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>()._has_bits_);
  static void set_has_controller_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controller_subtype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgRemoteDeviceStreamingRequest_ReservedGamepad::CMsgRemoteDeviceStreamingRequest_ReservedGamepad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
}
CMsgRemoteDeviceStreamingRequest_ReservedGamepad::CMsgRemoteDeviceStreamingRequest_ReservedGamepad(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&controller_type_, &from.controller_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&controller_subtype_) -
    reinterpret_cast<char*>(&controller_type_)) + sizeof(controller_subtype_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
}

inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&controller_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controller_subtype_) -
    reinterpret_cast<char*>(&controller_type_)) + sizeof(controller_subtype_));
}

CMsgRemoteDeviceStreamingRequest_ReservedGamepad::~CMsgRemoteDeviceStreamingRequest_ReservedGamepad() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamingRequest_ReservedGamepad* _this = reinterpret_cast< CMsgRemoteDeviceStreamingRequest_ReservedGamepad* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&controller_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&controller_subtype_) -
        reinterpret_cast<char*>(&controller_type_)) + sizeof(controller_subtype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 controller_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_controller_type(&has_bits);
          controller_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 controller_subtype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_controller_subtype(&has_bits);
          controller_subtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 controller_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_controller_type(), target);
  }

  // optional uint32 controller_subtype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_controller_subtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  return target;
}

size_t CMsgRemoteDeviceStreamingRequest_ReservedGamepad::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 controller_type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_controller_type());
    }

    // optional uint32 controller_subtype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_controller_subtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamingRequest_ReservedGamepad::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamingRequest_ReservedGamepad::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamingRequest_ReservedGamepad *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamingRequest_ReservedGamepad &>(from));
}


void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::MergeFrom(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      controller_type_ = from.controller_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      controller_subtype_ = from.controller_subtype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::CopyFrom(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamingRequest_ReservedGamepad::IsInitialized() const {
  return true;
}

void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::InternalSwap(CMsgRemoteDeviceStreamingRequest_ReservedGamepad* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingRequest_ReservedGamepad, controller_subtype_)
      + sizeof(CMsgRemoteDeviceStreamingRequest_ReservedGamepad::controller_subtype_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingRequest_ReservedGamepad, controller_type_)>(
          reinterpret_cast<char*>(&controller_type_),
          reinterpret_cast<char*>(&other->controller_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamingRequest_ReservedGamepad::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[10]);
}

// ===================================================================

class CMsgRemoteDeviceStreamingRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamingRequest>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_maximum_resolution_x(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_maximum_resolution_y(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_audio_channel_count(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_device_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_stream_desktop(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_device_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pin(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_video_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_enable_audio_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_enable_input_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_network_test(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_restricted(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_form_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gamepad_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_stream_interface(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

CMsgRemoteDeviceStreamingRequest::CMsgRemoteDeviceStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  supported_transport_(arena),
  gamepads_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamingRequest)
}
CMsgRemoteDeviceStreamingRequest::CMsgRemoteDeviceStreamingRequest(const CMsgRemoteDeviceStreamingRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      supported_transport_(from.supported_transport_),
      gamepads_(from.gamepads_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_version()) {
    device_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_version(), 
      GetArenaForAllocation());
  }
  device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_token()) {
    device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_token(), 
      GetArenaForAllocation());
  }
  pin_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    pin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_pin()) {
    pin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_pin(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&enable_input_streaming_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(enable_input_streaming_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamingRequest)
}

inline void CMsgRemoteDeviceStreamingRequest::SharedCtor() {
device_version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
pin_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  pin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stream_interface_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(stream_interface_));
audio_channel_count_ = 2;
enable_video_streaming_ = true;
enable_audio_streaming_ = true;
enable_input_streaming_ = true;
}

CMsgRemoteDeviceStreamingRequest::~CMsgRemoteDeviceStreamingRequest() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamingRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamingRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  pin_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceStreamingRequest::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamingRequest* _this = reinterpret_cast< CMsgRemoteDeviceStreamingRequest* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamingRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamingRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamingRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_transport_.Clear();
  gamepads_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      device_version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      device_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      pin_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&network_test_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(network_test_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&restricted_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stream_interface_) -
        reinterpret_cast<char*>(&restricted_)) + sizeof(stream_interface_));
    audio_channel_count_ = 2;
    enable_video_streaming_ = true;
  }
  if (cached_has_bits & 0x00030000u) {
    enable_audio_streaming_ = true;
    enable_input_streaming_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamingRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_resolution_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum_resolution_x(&has_bits);
          maximum_resolution_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_resolution_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_maximum_resolution_y(&has_bits);
          maximum_resolution_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audio_channel_count = 4 [default = 2];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_audio_channel_count(&has_bits);
          audio_channel_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string device_version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_device_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceStreamingRequest.device_version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool stream_desktop = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_stream_desktop(&has_bits);
          stream_desktop_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes device_token = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes pin = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_pin();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_video_streaming = 9 [default = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_enable_video_streaming(&has_bits);
          enable_video_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_audio_streaming = 10 [default = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_enable_audio_streaming(&has_bits);
          enable_audio_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_input_streaming = 11 [default = true];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enable_input_streaming(&has_bits);
          enable_input_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool network_test = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_network_test(&has_bits);
          network_test_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 client_id = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EStreamTransport supported_transport = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EStreamTransport_IsValid(val))) {
              _internal_add_supported_transport(static_cast<::EStreamTransport>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(14, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<112>(ptr));
        } else if (static_cast<uint8_t>(tag) == 114) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_supported_transport(), ptr, ctx, ::EStreamTransport_IsValid, &_internal_metadata_, 14);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool restricted = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_restricted(&has_bits);
          restricted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamDeviceFormFactor form_factor = 16 [default = k_EStreamDeviceFormFactorUnknown];
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamDeviceFormFactor_IsValid(val))) {
            _internal_set_form_factor(static_cast<::EStreamDeviceFormFactor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(16, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 gamepad_count = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_gamepad_count(&has_bits);
          gamepad_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_gamepads(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<146>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gameid = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamInterface stream_interface = 20 [default = k_EStreamInterfaceDefault];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamInterface_IsValid(val))) {
            _internal_set_stream_interface(static_cast<::EStreamInterface>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamingRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamingRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // optional int32 maximum_resolution_x = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_maximum_resolution_x(), target);
  }

  // optional int32 maximum_resolution_y = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_maximum_resolution_y(), target);
  }

  // optional int32 audio_channel_count = 4 [default = 2];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_audio_channel_count(), target);
  }

  // optional string device_version = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_version().data(), static_cast<int>(this->_internal_device_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceStreamingRequest.device_version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_device_version(), target);
  }

  // optional bool stream_desktop = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_stream_desktop(), target);
  }

  // optional bytes device_token = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_device_token(), target);
  }

  // optional bytes pin = 8;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        8, this->_internal_pin(), target);
  }

  // optional bool enable_video_streaming = 9 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_enable_video_streaming(), target);
  }

  // optional bool enable_audio_streaming = 10 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_enable_audio_streaming(), target);
  }

  // optional bool enable_input_streaming = 11 [default = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_enable_input_streaming(), target);
  }

  // optional bool network_test = 12;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_network_test(), target);
  }

  // optional uint64 client_id = 13;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(13, this->_internal_client_id(), target);
  }

  // repeated .EStreamTransport supported_transport = 14;
  for (int i = 0, n = this->_internal_supported_transport_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        14, this->_internal_supported_transport(i), target);
  }

  // optional bool restricted = 15;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_restricted(), target);
  }

  // optional .EStreamDeviceFormFactor form_factor = 16 [default = k_EStreamDeviceFormFactorUnknown];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      16, this->_internal_form_factor(), target);
  }

  // optional int32 gamepad_count = 17;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_gamepad_count(), target);
  }

  // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_gamepads_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(18, this->_internal_gamepads(i), target, stream);
  }

  // optional uint64 gameid = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(19, this->_internal_gameid(), target);
  }

  // optional .EStreamInterface stream_interface = 20 [default = k_EStreamInterfaceDefault];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      20, this->_internal_stream_interface(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamingRequest)
  return target;
}

size_t CMsgRemoteDeviceStreamingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamingRequest)
  size_t total_size = 0;

  // required uint32 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EStreamTransport supported_transport = 14;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_transport_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_transport(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;
  total_size += 2UL * this->_internal_gamepads_size();
  for (const auto& msg : this->gamepads_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string device_version = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_version());
    }

    // optional bytes device_token = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_device_token());
    }

    // optional bytes pin = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_pin());
    }

  }
  if (cached_has_bits & 0x000000f0u) {
    // optional int32 maximum_resolution_x = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maximum_resolution_x());
    }

    // optional int32 maximum_resolution_y = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maximum_resolution_y());
    }

    // optional bool stream_desktop = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool network_test = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool restricted = 15;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional uint64 client_id = 13;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional .EStreamDeviceFormFactor form_factor = 16 [default = k_EStreamDeviceFormFactorUnknown];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_form_factor());
    }

    // optional int32 gamepad_count = 17;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_gamepad_count());
    }

    // optional uint64 gameid = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_gameid());
    }

    // optional .EStreamInterface stream_interface = 20 [default = k_EStreamInterfaceDefault];
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_stream_interface());
    }

    // optional int32 audio_channel_count = 4 [default = 2];
    if (cached_has_bits & 0x00004000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_audio_channel_count());
    }

    // optional bool enable_video_streaming = 9 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional bool enable_audio_streaming = 10 [default = true];
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool enable_input_streaming = 11 [default = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamingRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamingRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamingRequest::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamingRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamingRequest *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamingRequest &>(from));
}


void CMsgRemoteDeviceStreamingRequest::MergeFrom(const CMsgRemoteDeviceStreamingRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamingRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_transport_.MergeFrom(from.supported_transport_);
  gamepads_.MergeFrom(from.gamepads_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_version(from._internal_device_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_device_token(from._internal_device_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_pin(from._internal_pin());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      maximum_resolution_x_ = from.maximum_resolution_x_;
    }
    if (cached_has_bits & 0x00000020u) {
      maximum_resolution_y_ = from.maximum_resolution_y_;
    }
    if (cached_has_bits & 0x00000040u) {
      stream_desktop_ = from.stream_desktop_;
    }
    if (cached_has_bits & 0x00000080u) {
      network_test_ = from.network_test_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      restricted_ = from.restricted_;
    }
    if (cached_has_bits & 0x00000200u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      form_factor_ = from.form_factor_;
    }
    if (cached_has_bits & 0x00000800u) {
      gamepad_count_ = from.gamepad_count_;
    }
    if (cached_has_bits & 0x00001000u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00002000u) {
      stream_interface_ = from.stream_interface_;
    }
    if (cached_has_bits & 0x00004000u) {
      audio_channel_count_ = from.audio_channel_count_;
    }
    if (cached_has_bits & 0x00008000u) {
      enable_video_streaming_ = from.enable_video_streaming_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      enable_audio_streaming_ = from.enable_audio_streaming_;
    }
    if (cached_has_bits & 0x00020000u) {
      enable_input_streaming_ = from.enable_input_streaming_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamingRequest::CopyFrom(const CMsgRemoteDeviceStreamingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamingRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceStreamingRequest::InternalSwap(CMsgRemoteDeviceStreamingRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_transport_.InternalSwap(&other->supported_transport_);
  gamepads_.InternalSwap(&other->gamepads_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_version_, lhs_arena,
      &other->device_version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_token_, lhs_arena,
      &other->device_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &pin_, lhs_arena,
      &other->pin_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingRequest, stream_interface_)
      + sizeof(CMsgRemoteDeviceStreamingRequest::stream_interface_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingRequest, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
  swap(audio_channel_count_, other->audio_channel_count_);
  swap(enable_video_streaming_, other->enable_video_streaming_);
  swap(enable_audio_streaming_, other->enable_audio_streaming_);
  swap(enable_input_streaming_, other->enable_input_streaming_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamingRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[11]);
}

// ===================================================================

class CMsgRemoteDeviceStreamingCancelRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamingCancelRequest>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgRemoteDeviceStreamingCancelRequest::CMsgRemoteDeviceStreamingCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamingCancelRequest)
}
CMsgRemoteDeviceStreamingCancelRequest::CMsgRemoteDeviceStreamingCancelRequest(const CMsgRemoteDeviceStreamingCancelRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  request_id_ = from.request_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamingCancelRequest)
}

inline void CMsgRemoteDeviceStreamingCancelRequest::SharedCtor() {
request_id_ = 0u;
}

CMsgRemoteDeviceStreamingCancelRequest::~CMsgRemoteDeviceStreamingCancelRequest() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamingCancelRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamingCancelRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteDeviceStreamingCancelRequest::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamingCancelRequest* _this = reinterpret_cast< CMsgRemoteDeviceStreamingCancelRequest* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamingCancelRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamingCancelRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamingCancelRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamingCancelRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  request_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamingCancelRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamingCancelRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamingCancelRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamingCancelRequest)
  return target;
}

size_t CMsgRemoteDeviceStreamingCancelRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamingCancelRequest)
  size_t total_size = 0;

  // required uint32 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamingCancelRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamingCancelRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamingCancelRequest::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamingCancelRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamingCancelRequest *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamingCancelRequest &>(from));
}


void CMsgRemoteDeviceStreamingCancelRequest::MergeFrom(const CMsgRemoteDeviceStreamingCancelRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamingCancelRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_request_id()) {
    _internal_set_request_id(from._internal_request_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamingCancelRequest::CopyFrom(const CMsgRemoteDeviceStreamingCancelRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamingCancelRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamingCancelRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceStreamingCancelRequest::InternalSwap(CMsgRemoteDeviceStreamingCancelRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(request_id_, other->request_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamingCancelRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[12]);
}

// ===================================================================

class CMsgRemoteDeviceStreamingProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamingProgress>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgRemoteDeviceStreamingProgress::CMsgRemoteDeviceStreamingProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamingProgress)
}
CMsgRemoteDeviceStreamingProgress::CMsgRemoteDeviceStreamingProgress(const CMsgRemoteDeviceStreamingProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&progress_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(progress_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamingProgress)
}

inline void CMsgRemoteDeviceStreamingProgress::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&progress_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(progress_));
}

CMsgRemoteDeviceStreamingProgress::~CMsgRemoteDeviceStreamingProgress() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamingProgress)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamingProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgRemoteDeviceStreamingProgress::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamingProgress* _this = reinterpret_cast< CMsgRemoteDeviceStreamingProgress* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamingProgress::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamingProgress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamingProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamingProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&progress_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(progress_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamingProgress::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float progress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_progress(&has_bits);
          progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamingProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamingProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // optional float progress = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamingProgress)
  return target;
}

size_t CMsgRemoteDeviceStreamingProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamingProgress)
  size_t total_size = 0;

  // required uint32 request_id = 1;
  if (_internal_has_request_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float progress = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamingProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamingProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamingProgress::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamingProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamingProgress *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamingProgress &>(from));
}


void CMsgRemoteDeviceStreamingProgress::MergeFrom(const CMsgRemoteDeviceStreamingProgress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamingProgress)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      progress_ = from.progress_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamingProgress::CopyFrom(const CMsgRemoteDeviceStreamingProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamingProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamingProgress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceStreamingProgress::InternalSwap(CMsgRemoteDeviceStreamingProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingProgress, progress_)
      + sizeof(CMsgRemoteDeviceStreamingProgress::progress_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingProgress, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamingProgress::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[13]);
}

// ===================================================================

class CMsgRemoteDeviceStreamingResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamingResponse>()._has_bits_);
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_encrypted_session_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_transport(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_relay_server(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cert(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000018) ^ 0x00000018) != 0;
  }
};

CMsgRemoteDeviceStreamingResponse::CMsgRemoteDeviceStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamingResponse)
}
CMsgRemoteDeviceStreamingResponse::CMsgRemoteDeviceStreamingResponse(const CMsgRemoteDeviceStreamingResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  encrypted_session_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_session_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_session_key()) {
    encrypted_session_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_session_key(), 
      GetArenaForAllocation());
  }
  relay_server_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    relay_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_relay_server()) {
    relay_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_relay_server(), 
      GetArenaForAllocation());
  }
  cert_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cert()) {
    cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cert(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&transport_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(transport_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamingResponse)
}

inline void CMsgRemoteDeviceStreamingResponse::SharedCtor() {
encrypted_session_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_session_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
relay_server_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  relay_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cert_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&port_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(port_));
transport_ = 1;
}

CMsgRemoteDeviceStreamingResponse::~CMsgRemoteDeviceStreamingResponse() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamingResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamingResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  encrypted_session_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  relay_server_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  cert_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceStreamingResponse::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamingResponse* _this = reinterpret_cast< CMsgRemoteDeviceStreamingResponse* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamingResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamingResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamingResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      encrypted_session_key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      relay_server_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      cert_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&port_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(port_));
    transport_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamingResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 request_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ERemoteDeviceStreamingResult_IsValid(val))) {
            _internal_set_result(static_cast<::ERemoteDeviceStreamingResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 port = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes encrypted_session_key = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_encrypted_session_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamTransport transport = 6 [default = k_EStreamTransportUDP];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamTransport_IsValid(val))) {
            _internal_set_transport(static_cast<::EStreamTransport>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string relay_server = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_relay_server();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceStreamingResponse.relay_server");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cert = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_cert();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgRemoteDeviceStreamingResponse.cert");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamingResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamingResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 request_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_request_id(), target);
  }

  // required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_result(), target);
  }

  // optional uint32 port = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_port(), target);
  }

  // optional bytes encrypted_session_key = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_encrypted_session_key(), target);
  }

  // optional .EStreamTransport transport = 6 [default = k_EStreamTransportUDP];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_transport(), target);
  }

  // optional string relay_server = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_relay_server().data(), static_cast<int>(this->_internal_relay_server().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceStreamingResponse.relay_server");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_relay_server(), target);
  }

  // optional string cert = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cert().data(), static_cast<int>(this->_internal_cert().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgRemoteDeviceStreamingResponse.cert");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_cert(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamingResponse)
  return target;
}

size_t CMsgRemoteDeviceStreamingResponse::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CMsgRemoteDeviceStreamingResponse)
  size_t total_size = 0;

  if (_internal_has_request_id()) {
    // required uint32 request_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
  }

  if (_internal_has_result()) {
    // required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());
  }

  return total_size;
}
size_t CMsgRemoteDeviceStreamingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamingResponse)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000018) ^ 0x00000018) == 0) {  // All required fields are present.
    // required uint32 request_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());

    // required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes encrypted_session_key = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_encrypted_session_key());
    }

    // optional string relay_server = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_relay_server());
    }

    // optional string cert = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cert());
    }

  }
  if (cached_has_bits & 0x00000060u) {
    // optional uint32 port = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
    }

    // optional .EStreamTransport transport = 6 [default = k_EStreamTransportUDP];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_transport());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamingResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamingResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamingResponse::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamingResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamingResponse *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamingResponse &>(from));
}


void CMsgRemoteDeviceStreamingResponse::MergeFrom(const CMsgRemoteDeviceStreamingResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamingResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_encrypted_session_key(from._internal_encrypted_session_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_relay_server(from._internal_relay_server());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_cert(from._internal_cert());
    }
    if (cached_has_bits & 0x00000008u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      result_ = from.result_;
    }
    if (cached_has_bits & 0x00000020u) {
      port_ = from.port_;
    }
    if (cached_has_bits & 0x00000040u) {
      transport_ = from.transport_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamingResponse::CopyFrom(const CMsgRemoteDeviceStreamingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamingResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceStreamingResponse::InternalSwap(CMsgRemoteDeviceStreamingResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_session_key_, lhs_arena,
      &other->encrypted_session_key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &relay_server_, lhs_arena,
      &other->relay_server_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cert_, lhs_arena,
      &other->cert_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingResponse, port_)
      + sizeof(CMsgRemoteDeviceStreamingResponse::port_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceStreamingResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
  swap(transport_, other->transport_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamingResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[14]);
}

// ===================================================================

class CMsgRemoteDeviceProofRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceProofRequest>()._has_bits_);
  static void set_has_challenge(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_update_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgRemoteDeviceProofRequest::CMsgRemoteDeviceProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceProofRequest)
}
CMsgRemoteDeviceProofRequest::CMsgRemoteDeviceProofRequest(const CMsgRemoteDeviceProofRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  challenge_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    challenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_challenge()) {
    challenge_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_challenge(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&update_secret_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(update_secret_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceProofRequest)
}

inline void CMsgRemoteDeviceProofRequest::SharedCtor() {
challenge_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  challenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&update_secret_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(update_secret_));
}

CMsgRemoteDeviceProofRequest::~CMsgRemoteDeviceProofRequest() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceProofRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceProofRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  challenge_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceProofRequest::ArenaDtor(void* object) {
  CMsgRemoteDeviceProofRequest* _this = reinterpret_cast< CMsgRemoteDeviceProofRequest* >(object);
  (void)_this;
}
void CMsgRemoteDeviceProofRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceProofRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceProofRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceProofRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    challenge_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&update_secret_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(update_secret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceProofRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes challenge = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_challenge();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool update_secret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_update_secret(&has_bits);
          update_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceProofRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceProofRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes challenge = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_challenge(), target);
  }

  // optional uint32 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_request_id(), target);
  }

  // optional bool update_secret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_update_secret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceProofRequest)
  return target;
}

size_t CMsgRemoteDeviceProofRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceProofRequest)
  size_t total_size = 0;

  // required bytes challenge = 1;
  if (_internal_has_challenge()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_challenge());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 request_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
    }

    // optional bool update_secret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceProofRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceProofRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceProofRequest::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceProofRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceProofRequest *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceProofRequest &>(from));
}


void CMsgRemoteDeviceProofRequest::MergeFrom(const CMsgRemoteDeviceProofRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceProofRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_challenge(from._internal_challenge());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      update_secret_ = from.update_secret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceProofRequest::CopyFrom(const CMsgRemoteDeviceProofRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceProofRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceProofRequest::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceProofRequest::InternalSwap(CMsgRemoteDeviceProofRequest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &challenge_, lhs_arena,
      &other->challenge_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceProofRequest, update_secret_)
      + sizeof(CMsgRemoteDeviceProofRequest::update_secret_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceProofRequest, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceProofRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[15]);
}

// ===================================================================

class CMsgRemoteDeviceProofResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceProofResponse>()._has_bits_);
  static void set_has_response(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_updated_secret(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgRemoteDeviceProofResponse::CMsgRemoteDeviceProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceProofResponse)
}
CMsgRemoteDeviceProofResponse::CMsgRemoteDeviceProofResponse(const CMsgRemoteDeviceProofResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    response_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_response()) {
    response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_response(), 
      GetArenaForAllocation());
  }
  ::memcpy(&request_id_, &from.request_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&updated_secret_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(updated_secret_));
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceProofResponse)
}

inline void CMsgRemoteDeviceProofResponse::SharedCtor() {
response_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  response_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&request_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&updated_secret_) -
    reinterpret_cast<char*>(&request_id_)) + sizeof(updated_secret_));
}

CMsgRemoteDeviceProofResponse::~CMsgRemoteDeviceProofResponse() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceProofResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceProofResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  response_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceProofResponse::ArenaDtor(void* object) {
  CMsgRemoteDeviceProofResponse* _this = reinterpret_cast< CMsgRemoteDeviceProofResponse* >(object);
  (void)_this;
}
void CMsgRemoteDeviceProofResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceProofResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceProofResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceProofResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    response_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&request_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&updated_secret_) -
        reinterpret_cast<char*>(&request_id_)) + sizeof(updated_secret_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceProofResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bytes response = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_response();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_request_id(&has_bits);
          request_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool updated_secret = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_updated_secret(&has_bits);
          updated_secret_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceProofResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceProofResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bytes response = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_response(), target);
  }

  // optional uint32 request_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_request_id(), target);
  }

  // optional bool updated_secret = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_updated_secret(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceProofResponse)
  return target;
}

size_t CMsgRemoteDeviceProofResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceProofResponse)
  size_t total_size = 0;

  // required bytes response = 1;
  if (_internal_has_response()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_response());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 request_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_request_id());
    }

    // optional bool updated_secret = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceProofResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceProofResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceProofResponse::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceProofResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceProofResponse *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceProofResponse &>(from));
}


void CMsgRemoteDeviceProofResponse::MergeFrom(const CMsgRemoteDeviceProofResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceProofResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_response(from._internal_response());
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_ = from.request_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      updated_secret_ = from.updated_secret_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceProofResponse::CopyFrom(const CMsgRemoteDeviceProofResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceProofResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceProofResponse::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgRemoteDeviceProofResponse::InternalSwap(CMsgRemoteDeviceProofResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &response_, lhs_arena,
      &other->response_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceProofResponse, updated_secret_)
      + sizeof(CMsgRemoteDeviceProofResponse::updated_secret_)
      - PROTOBUF_FIELD_OFFSET(CMsgRemoteDeviceProofResponse, request_id_)>(
          reinterpret_cast<char*>(&request_id_),
          reinterpret_cast<char*>(&other->request_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceProofResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[16]);
}

// ===================================================================

class CMsgRemoteDeviceStreamTransportSignal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgRemoteDeviceStreamTransportSignal>()._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_payload(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgRemoteDeviceStreamTransportSignal::CMsgRemoteDeviceStreamTransportSignal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgRemoteDeviceStreamTransportSignal)
}
CMsgRemoteDeviceStreamTransportSignal::CMsgRemoteDeviceStreamTransportSignal(const CMsgRemoteDeviceStreamTransportSignal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_payload()) {
    payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_payload(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgRemoteDeviceStreamTransportSignal)
}

inline void CMsgRemoteDeviceStreamTransportSignal::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
payload_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgRemoteDeviceStreamTransportSignal::~CMsgRemoteDeviceStreamTransportSignal() {
  // @@protoc_insertion_point(destructor:CMsgRemoteDeviceStreamTransportSignal)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgRemoteDeviceStreamTransportSignal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  payload_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgRemoteDeviceStreamTransportSignal::ArenaDtor(void* object) {
  CMsgRemoteDeviceStreamTransportSignal* _this = reinterpret_cast< CMsgRemoteDeviceStreamTransportSignal* >(object);
  (void)_this;
}
void CMsgRemoteDeviceStreamTransportSignal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgRemoteDeviceStreamTransportSignal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgRemoteDeviceStreamTransportSignal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgRemoteDeviceStreamTransportSignal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      payload_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgRemoteDeviceStreamTransportSignal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes payload = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_payload();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgRemoteDeviceStreamTransportSignal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgRemoteDeviceStreamTransportSignal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional bytes payload = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_payload(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgRemoteDeviceStreamTransportSignal)
  return target;
}

size_t CMsgRemoteDeviceStreamTransportSignal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgRemoteDeviceStreamTransportSignal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional bytes payload = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_payload());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgRemoteDeviceStreamTransportSignal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgRemoteDeviceStreamTransportSignal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgRemoteDeviceStreamTransportSignal::GetClassData() const { return &_class_data_; }

void CMsgRemoteDeviceStreamTransportSignal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgRemoteDeviceStreamTransportSignal *>(to)->MergeFrom(
      static_cast<const CMsgRemoteDeviceStreamTransportSignal &>(from));
}


void CMsgRemoteDeviceStreamTransportSignal::MergeFrom(const CMsgRemoteDeviceStreamTransportSignal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgRemoteDeviceStreamTransportSignal)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_payload(from._internal_payload());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgRemoteDeviceStreamTransportSignal::CopyFrom(const CMsgRemoteDeviceStreamTransportSignal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgRemoteDeviceStreamTransportSignal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgRemoteDeviceStreamTransportSignal::IsInitialized() const {
  return true;
}

void CMsgRemoteDeviceStreamTransportSignal::InternalSwap(CMsgRemoteDeviceStreamTransportSignal* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &payload_, lhs_arena,
      &other->payload_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgRemoteDeviceStreamTransportSignal::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_getter, &descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto_once,
      file_level_metadata_steammessages_5fremoteclient_5fdiscovery_2eproto[17]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgRemoteClientBroadcastHeader* Arena::CreateMaybeMessage< ::CMsgRemoteClientBroadcastHeader >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteClientBroadcastHeader >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteClientBroadcastStatus_User* Arena::CreateMaybeMessage< ::CMsgRemoteClientBroadcastStatus_User >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteClientBroadcastStatus_User >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteClientBroadcastStatus* Arena::CreateMaybeMessage< ::CMsgRemoteClientBroadcastStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteClientBroadcastStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteClientBroadcastDiscovery* Arena::CreateMaybeMessage< ::CMsgRemoteClientBroadcastDiscovery >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteClientBroadcastDiscovery >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteClientBroadcastClientIDDeconflict* Arena::CreateMaybeMessage< ::CMsgRemoteClientBroadcastClientIDDeconflict >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteClientBroadcastClientIDDeconflict >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceAuthorizationRequest* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceAuthorizationRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceAuthorizationRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceAuthorizationCancelRequest* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceAuthorizationCancelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceAuthorizationCancelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceAuthorizationResponse* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceAuthorizationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceAuthorizationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceAuthorizationConfirmed* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceAuthorizationConfirmed >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceAuthorizationConfirmed >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamingRequest* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamingRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamingRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamingCancelRequest* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamingCancelRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamingCancelRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamingProgress* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamingProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamingProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamingResponse* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamingResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamingResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceProofRequest* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceProofRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceProofRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceProofResponse* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceProofResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceProofResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgRemoteDeviceStreamTransportSignal* Arena::CreateMaybeMessage< ::CMsgRemoteDeviceStreamTransportSignal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgRemoteDeviceStreamTransportSignal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
