// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_auth.steamclient.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fauth_2esteamclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fauth_2esteamclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
#include "steammessages_unified_base.steamclient.pb.h"
#include "enums.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fauth_2esteamclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fauth_2esteamclient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[46]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fauth_2esteamclient_2eproto;
class CAuthenticationSupport_GetTokenHistory_Request;
struct CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal;
extern CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal _CAuthenticationSupport_GetTokenHistory_Request_default_instance_;
class CAuthenticationSupport_GetTokenHistory_Response;
struct CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal;
extern CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal _CAuthenticationSupport_GetTokenHistory_Response_default_instance_;
class CAuthenticationSupport_QueryRefreshTokenByID_Request;
struct CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal;
extern CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokenByID_Request_default_instance_;
class CAuthenticationSupport_QueryRefreshTokenByID_Response;
struct CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal;
extern CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokenByID_Response_default_instance_;
class CAuthenticationSupport_QueryRefreshTokensByAccount_Request;
struct CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal;
extern CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokensByAccount_Request_default_instance_;
class CAuthenticationSupport_QueryRefreshTokensByAccount_Response;
struct CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal;
extern CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokensByAccount_Response_default_instance_;
class CAuthenticationSupport_RevokeToken_Request;
struct CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal;
extern CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal _CAuthenticationSupport_RevokeToken_Request_default_instance_;
class CAuthenticationSupport_RevokeToken_Response;
struct CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal;
extern CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal _CAuthenticationSupport_RevokeToken_Response_default_instance_;
class CAuthentication_AccessToken_GenerateForApp_Request;
struct CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal;
extern CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal _CAuthentication_AccessToken_GenerateForApp_Request_default_instance_;
class CAuthentication_AccessToken_GenerateForApp_Response;
struct CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal;
extern CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal _CAuthentication_AccessToken_GenerateForApp_Response_default_instance_;
class CAuthentication_AllowedConfirmation;
struct CAuthentication_AllowedConfirmationDefaultTypeInternal;
extern CAuthentication_AllowedConfirmationDefaultTypeInternal _CAuthentication_AllowedConfirmation_default_instance_;
class CAuthentication_BeginAuthSessionViaCredentials_Request;
struct CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal;
extern CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal _CAuthentication_BeginAuthSessionViaCredentials_Request_default_instance_;
class CAuthentication_BeginAuthSessionViaCredentials_Response;
struct CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal;
extern CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal _CAuthentication_BeginAuthSessionViaCredentials_Response_default_instance_;
class CAuthentication_BeginAuthSessionViaQR_Request;
struct CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal;
extern CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal _CAuthentication_BeginAuthSessionViaQR_Request_default_instance_;
class CAuthentication_BeginAuthSessionViaQR_Response;
struct CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal;
extern CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal _CAuthentication_BeginAuthSessionViaQR_Response_default_instance_;
class CAuthentication_DeviceDetails;
struct CAuthentication_DeviceDetailsDefaultTypeInternal;
extern CAuthentication_DeviceDetailsDefaultTypeInternal _CAuthentication_DeviceDetails_default_instance_;
class CAuthentication_GetAuthSessionInfo_Request;
struct CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal;
extern CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal _CAuthentication_GetAuthSessionInfo_Request_default_instance_;
class CAuthentication_GetAuthSessionInfo_Response;
struct CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal;
extern CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal _CAuthentication_GetAuthSessionInfo_Response_default_instance_;
class CAuthentication_GetAuthSessionsForAccount_Request;
struct CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal;
extern CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal _CAuthentication_GetAuthSessionsForAccount_Request_default_instance_;
class CAuthentication_GetAuthSessionsForAccount_Response;
struct CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal;
extern CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal _CAuthentication_GetAuthSessionsForAccount_Response_default_instance_;
class CAuthentication_GetPasswordRSAPublicKey_Request;
struct CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal;
extern CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal _CAuthentication_GetPasswordRSAPublicKey_Request_default_instance_;
class CAuthentication_GetPasswordRSAPublicKey_Response;
struct CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal;
extern CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal _CAuthentication_GetPasswordRSAPublicKey_Response_default_instance_;
class CAuthentication_MigrateMobileSession_Request;
struct CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal;
extern CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal _CAuthentication_MigrateMobileSession_Request_default_instance_;
class CAuthentication_MigrateMobileSession_Response;
struct CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal;
extern CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal _CAuthentication_MigrateMobileSession_Response_default_instance_;
class CAuthentication_PollAuthSessionStatus_Request;
struct CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal;
extern CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal _CAuthentication_PollAuthSessionStatus_Request_default_instance_;
class CAuthentication_PollAuthSessionStatus_Response;
struct CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal;
extern CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal _CAuthentication_PollAuthSessionStatus_Response_default_instance_;
class CAuthentication_RefreshToken_Enumerate_Request;
struct CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal;
extern CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Request_default_instance_;
class CAuthentication_RefreshToken_Enumerate_Response;
struct CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal;
extern CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_default_instance_;
class CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription;
struct CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal;
extern CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription_default_instance_;
class CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent;
struct CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal;
extern CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_;
class CAuthentication_RefreshToken_Revoke_Request;
struct CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal;
extern CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal _CAuthentication_RefreshToken_Revoke_Request_default_instance_;
class CAuthentication_RefreshToken_Revoke_Response;
struct CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal;
extern CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal _CAuthentication_RefreshToken_Revoke_Response_default_instance_;
class CAuthentication_Token_Revoke_Request;
struct CAuthentication_Token_Revoke_RequestDefaultTypeInternal;
extern CAuthentication_Token_Revoke_RequestDefaultTypeInternal _CAuthentication_Token_Revoke_Request_default_instance_;
class CAuthentication_Token_Revoke_Response;
struct CAuthentication_Token_Revoke_ResponseDefaultTypeInternal;
extern CAuthentication_Token_Revoke_ResponseDefaultTypeInternal _CAuthentication_Token_Revoke_Response_default_instance_;
class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request;
struct CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal;
extern CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request_default_instance_;
class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response;
struct CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal;
extern CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response_default_instance_;
class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request;
struct CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal;
extern CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request_default_instance_;
class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response;
struct CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal;
extern CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response_default_instance_;
class CCloudGaming_CreateNonce_Request;
struct CCloudGaming_CreateNonce_RequestDefaultTypeInternal;
extern CCloudGaming_CreateNonce_RequestDefaultTypeInternal _CCloudGaming_CreateNonce_Request_default_instance_;
class CCloudGaming_CreateNonce_Response;
struct CCloudGaming_CreateNonce_ResponseDefaultTypeInternal;
extern CCloudGaming_CreateNonce_ResponseDefaultTypeInternal _CCloudGaming_CreateNonce_Response_default_instance_;
class CCloudGaming_GetTimeRemaining_Request;
struct CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal;
extern CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal _CCloudGaming_GetTimeRemaining_Request_default_instance_;
class CCloudGaming_GetTimeRemaining_Response;
struct CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal;
extern CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal _CCloudGaming_GetTimeRemaining_Response_default_instance_;
class CCloudGaming_TimeRemaining;
struct CCloudGaming_TimeRemainingDefaultTypeInternal;
extern CCloudGaming_TimeRemainingDefaultTypeInternal _CCloudGaming_TimeRemaining_default_instance_;
class CSupportRefreshTokenAudit;
struct CSupportRefreshTokenAuditDefaultTypeInternal;
extern CSupportRefreshTokenAuditDefaultTypeInternal _CSupportRefreshTokenAudit_default_instance_;
class CSupportRefreshTokenDescription;
struct CSupportRefreshTokenDescriptionDefaultTypeInternal;
extern CSupportRefreshTokenDescriptionDefaultTypeInternal _CSupportRefreshTokenDescription_default_instance_;
class CSupportRefreshTokenDescription_TokenUsageEvent;
struct CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal;
extern CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal _CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CAuthenticationSupport_GetTokenHistory_Request* Arena::CreateMaybeMessage<::CAuthenticationSupport_GetTokenHistory_Request>(Arena*);
template<> ::CAuthenticationSupport_GetTokenHistory_Response* Arena::CreateMaybeMessage<::CAuthenticationSupport_GetTokenHistory_Response>(Arena*);
template<> ::CAuthenticationSupport_QueryRefreshTokenByID_Request* Arena::CreateMaybeMessage<::CAuthenticationSupport_QueryRefreshTokenByID_Request>(Arena*);
template<> ::CAuthenticationSupport_QueryRefreshTokenByID_Response* Arena::CreateMaybeMessage<::CAuthenticationSupport_QueryRefreshTokenByID_Response>(Arena*);
template<> ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request* Arena::CreateMaybeMessage<::CAuthenticationSupport_QueryRefreshTokensByAccount_Request>(Arena*);
template<> ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response* Arena::CreateMaybeMessage<::CAuthenticationSupport_QueryRefreshTokensByAccount_Response>(Arena*);
template<> ::CAuthenticationSupport_RevokeToken_Request* Arena::CreateMaybeMessage<::CAuthenticationSupport_RevokeToken_Request>(Arena*);
template<> ::CAuthenticationSupport_RevokeToken_Response* Arena::CreateMaybeMessage<::CAuthenticationSupport_RevokeToken_Response>(Arena*);
template<> ::CAuthentication_AccessToken_GenerateForApp_Request* Arena::CreateMaybeMessage<::CAuthentication_AccessToken_GenerateForApp_Request>(Arena*);
template<> ::CAuthentication_AccessToken_GenerateForApp_Response* Arena::CreateMaybeMessage<::CAuthentication_AccessToken_GenerateForApp_Response>(Arena*);
template<> ::CAuthentication_AllowedConfirmation* Arena::CreateMaybeMessage<::CAuthentication_AllowedConfirmation>(Arena*);
template<> ::CAuthentication_BeginAuthSessionViaCredentials_Request* Arena::CreateMaybeMessage<::CAuthentication_BeginAuthSessionViaCredentials_Request>(Arena*);
template<> ::CAuthentication_BeginAuthSessionViaCredentials_Response* Arena::CreateMaybeMessage<::CAuthentication_BeginAuthSessionViaCredentials_Response>(Arena*);
template<> ::CAuthentication_BeginAuthSessionViaQR_Request* Arena::CreateMaybeMessage<::CAuthentication_BeginAuthSessionViaQR_Request>(Arena*);
template<> ::CAuthentication_BeginAuthSessionViaQR_Response* Arena::CreateMaybeMessage<::CAuthentication_BeginAuthSessionViaQR_Response>(Arena*);
template<> ::CAuthentication_DeviceDetails* Arena::CreateMaybeMessage<::CAuthentication_DeviceDetails>(Arena*);
template<> ::CAuthentication_GetAuthSessionInfo_Request* Arena::CreateMaybeMessage<::CAuthentication_GetAuthSessionInfo_Request>(Arena*);
template<> ::CAuthentication_GetAuthSessionInfo_Response* Arena::CreateMaybeMessage<::CAuthentication_GetAuthSessionInfo_Response>(Arena*);
template<> ::CAuthentication_GetAuthSessionsForAccount_Request* Arena::CreateMaybeMessage<::CAuthentication_GetAuthSessionsForAccount_Request>(Arena*);
template<> ::CAuthentication_GetAuthSessionsForAccount_Response* Arena::CreateMaybeMessage<::CAuthentication_GetAuthSessionsForAccount_Response>(Arena*);
template<> ::CAuthentication_GetPasswordRSAPublicKey_Request* Arena::CreateMaybeMessage<::CAuthentication_GetPasswordRSAPublicKey_Request>(Arena*);
template<> ::CAuthentication_GetPasswordRSAPublicKey_Response* Arena::CreateMaybeMessage<::CAuthentication_GetPasswordRSAPublicKey_Response>(Arena*);
template<> ::CAuthentication_MigrateMobileSession_Request* Arena::CreateMaybeMessage<::CAuthentication_MigrateMobileSession_Request>(Arena*);
template<> ::CAuthentication_MigrateMobileSession_Response* Arena::CreateMaybeMessage<::CAuthentication_MigrateMobileSession_Response>(Arena*);
template<> ::CAuthentication_PollAuthSessionStatus_Request* Arena::CreateMaybeMessage<::CAuthentication_PollAuthSessionStatus_Request>(Arena*);
template<> ::CAuthentication_PollAuthSessionStatus_Response* Arena::CreateMaybeMessage<::CAuthentication_PollAuthSessionStatus_Response>(Arena*);
template<> ::CAuthentication_RefreshToken_Enumerate_Request* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Request>(Arena*);
template<> ::CAuthentication_RefreshToken_Enumerate_Response* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Response>(Arena*);
template<> ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription>(Arena*);
template<> ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>(Arena*);
template<> ::CAuthentication_RefreshToken_Revoke_Request* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Revoke_Request>(Arena*);
template<> ::CAuthentication_RefreshToken_Revoke_Response* Arena::CreateMaybeMessage<::CAuthentication_RefreshToken_Revoke_Response>(Arena*);
template<> ::CAuthentication_Token_Revoke_Request* Arena::CreateMaybeMessage<::CAuthentication_Token_Revoke_Request>(Arena*);
template<> ::CAuthentication_Token_Revoke_Response* Arena::CreateMaybeMessage<::CAuthentication_Token_Revoke_Response>(Arena*);
template<> ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* Arena::CreateMaybeMessage<::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request>(Arena*);
template<> ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* Arena::CreateMaybeMessage<::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response>(Arena*);
template<> ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* Arena::CreateMaybeMessage<::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request>(Arena*);
template<> ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* Arena::CreateMaybeMessage<::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response>(Arena*);
template<> ::CCloudGaming_CreateNonce_Request* Arena::CreateMaybeMessage<::CCloudGaming_CreateNonce_Request>(Arena*);
template<> ::CCloudGaming_CreateNonce_Response* Arena::CreateMaybeMessage<::CCloudGaming_CreateNonce_Response>(Arena*);
template<> ::CCloudGaming_GetTimeRemaining_Request* Arena::CreateMaybeMessage<::CCloudGaming_GetTimeRemaining_Request>(Arena*);
template<> ::CCloudGaming_GetTimeRemaining_Response* Arena::CreateMaybeMessage<::CCloudGaming_GetTimeRemaining_Response>(Arena*);
template<> ::CCloudGaming_TimeRemaining* Arena::CreateMaybeMessage<::CCloudGaming_TimeRemaining>(Arena*);
template<> ::CSupportRefreshTokenAudit* Arena::CreateMaybeMessage<::CSupportRefreshTokenAudit>(Arena*);
template<> ::CSupportRefreshTokenDescription* Arena::CreateMaybeMessage<::CSupportRefreshTokenDescription>(Arena*);
template<> ::CSupportRefreshTokenDescription_TokenUsageEvent* Arena::CreateMaybeMessage<::CSupportRefreshTokenDescription_TokenUsageEvent>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EAuthTokenPlatformType : int {
  k_EAuthTokenPlatformType_Unknown = 0,
  k_EAuthTokenPlatformType_SteamClient = 1,
  k_EAuthTokenPlatformType_WebBrowser = 2,
  k_EAuthTokenPlatformType_MobileApp = 3
};
bool EAuthTokenPlatformType_IsValid(int value);
constexpr EAuthTokenPlatformType EAuthTokenPlatformType_MIN = k_EAuthTokenPlatformType_Unknown;
constexpr EAuthTokenPlatformType EAuthTokenPlatformType_MAX = k_EAuthTokenPlatformType_MobileApp;
constexpr int EAuthTokenPlatformType_ARRAYSIZE = EAuthTokenPlatformType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenPlatformType_descriptor();
template<typename T>
inline const std::string& EAuthTokenPlatformType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAuthTokenPlatformType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAuthTokenPlatformType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAuthTokenPlatformType_descriptor(), enum_t_value);
}
inline bool EAuthTokenPlatformType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAuthTokenPlatformType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAuthTokenPlatformType>(
    EAuthTokenPlatformType_descriptor(), name, value);
}
enum EAuthSessionGuardType : int {
  k_EAuthSessionGuardType_Unknown = 0,
  k_EAuthSessionGuardType_None = 1,
  k_EAuthSessionGuardType_EmailCode = 2,
  k_EAuthSessionGuardType_DeviceCode = 3,
  k_EAuthSessionGuardType_DeviceConfirmation = 4,
  k_EAuthSessionGuardType_EmailConfirmation = 5,
  k_EAuthSessionGuardType_MachineToken = 6,
  k_EAuthSessionGuardType_LegacyMachineAuth = 7
};
bool EAuthSessionGuardType_IsValid(int value);
constexpr EAuthSessionGuardType EAuthSessionGuardType_MIN = k_EAuthSessionGuardType_Unknown;
constexpr EAuthSessionGuardType EAuthSessionGuardType_MAX = k_EAuthSessionGuardType_LegacyMachineAuth;
constexpr int EAuthSessionGuardType_ARRAYSIZE = EAuthSessionGuardType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthSessionGuardType_descriptor();
template<typename T>
inline const std::string& EAuthSessionGuardType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAuthSessionGuardType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAuthSessionGuardType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAuthSessionGuardType_descriptor(), enum_t_value);
}
inline bool EAuthSessionGuardType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAuthSessionGuardType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAuthSessionGuardType>(
    EAuthSessionGuardType_descriptor(), name, value);
}
enum EAuthSessionSecurityHistory : int {
  k_EAuthSessionSecurityHistory_Invalid = 0,
  k_EAuthSessionSecurityHistory_UsedPreviously = 1,
  k_EAuthSessionSecurityHistory_NoPriorHistory = 2
};
bool EAuthSessionSecurityHistory_IsValid(int value);
constexpr EAuthSessionSecurityHistory EAuthSessionSecurityHistory_MIN = k_EAuthSessionSecurityHistory_Invalid;
constexpr EAuthSessionSecurityHistory EAuthSessionSecurityHistory_MAX = k_EAuthSessionSecurityHistory_NoPriorHistory;
constexpr int EAuthSessionSecurityHistory_ARRAYSIZE = EAuthSessionSecurityHistory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthSessionSecurityHistory_descriptor();
template<typename T>
inline const std::string& EAuthSessionSecurityHistory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAuthSessionSecurityHistory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAuthSessionSecurityHistory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAuthSessionSecurityHistory_descriptor(), enum_t_value);
}
inline bool EAuthSessionSecurityHistory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAuthSessionSecurityHistory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAuthSessionSecurityHistory>(
    EAuthSessionSecurityHistory_descriptor(), name, value);
}
enum ETokenRenewalType : int {
  k_ETokenRenewalType_None = 0,
  k_ETokenRenewalType_Allow = 1
};
bool ETokenRenewalType_IsValid(int value);
constexpr ETokenRenewalType ETokenRenewalType_MIN = k_ETokenRenewalType_None;
constexpr ETokenRenewalType ETokenRenewalType_MAX = k_ETokenRenewalType_Allow;
constexpr int ETokenRenewalType_ARRAYSIZE = ETokenRenewalType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETokenRenewalType_descriptor();
template<typename T>
inline const std::string& ETokenRenewalType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETokenRenewalType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETokenRenewalType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETokenRenewalType_descriptor(), enum_t_value);
}
inline bool ETokenRenewalType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETokenRenewalType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETokenRenewalType>(
    ETokenRenewalType_descriptor(), name, value);
}
enum EAuthTokenRevokeAction : int {
  k_EAuthTokenRevokeLogout = 0,
  k_EAuthTokenRevokePermanent = 1,
  k_EAuthTokenRevokeReplaced = 2,
  k_EAuthTokenRevokeSupport = 3,
  k_EAuthTokenRevokeConsume = 4,
  k_EAuthTokenRevokeNonRememberedLogout = 5,
  k_EAuthTokenRevokeNonRememberedPermanent = 6,
  k_EAuthTokenRevokeAutomatic = 7
};
bool EAuthTokenRevokeAction_IsValid(int value);
constexpr EAuthTokenRevokeAction EAuthTokenRevokeAction_MIN = k_EAuthTokenRevokeLogout;
constexpr EAuthTokenRevokeAction EAuthTokenRevokeAction_MAX = k_EAuthTokenRevokeAutomatic;
constexpr int EAuthTokenRevokeAction_ARRAYSIZE = EAuthTokenRevokeAction_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenRevokeAction_descriptor();
template<typename T>
inline const std::string& EAuthTokenRevokeAction_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAuthTokenRevokeAction>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAuthTokenRevokeAction_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAuthTokenRevokeAction_descriptor(), enum_t_value);
}
inline bool EAuthTokenRevokeAction_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAuthTokenRevokeAction* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAuthTokenRevokeAction>(
    EAuthTokenRevokeAction_descriptor(), name, value);
}
enum EAuthTokenState : int {
  k_EAuthTokenState_Invalid = 0,
  k_EAuthTokenState_New = 1,
  k_EAuthTokenState_Confirmed = 2,
  k_EAuthTokenState_Issued = 3,
  k_EAuthTokenState_Denied = 4,
  k_EAuthTokenState_LoggedOut = 5,
  k_EAuthTokenState_Consumed = 6,
  k_EAuthTokenState_Revoked = 99
};
bool EAuthTokenState_IsValid(int value);
constexpr EAuthTokenState EAuthTokenState_MIN = k_EAuthTokenState_Invalid;
constexpr EAuthTokenState EAuthTokenState_MAX = k_EAuthTokenState_Revoked;
constexpr int EAuthTokenState_ARRAYSIZE = EAuthTokenState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenState_descriptor();
template<typename T>
inline const std::string& EAuthTokenState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAuthTokenState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAuthTokenState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAuthTokenState_descriptor(), enum_t_value);
}
inline bool EAuthTokenState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAuthTokenState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAuthTokenState>(
    EAuthTokenState_descriptor(), name, value);
}
// ===================================================================

class CAuthentication_GetPasswordRSAPublicKey_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_GetPasswordRSAPublicKey_Request) */ {
 public:
  inline CAuthentication_GetPasswordRSAPublicKey_Request() : CAuthentication_GetPasswordRSAPublicKey_Request(nullptr) {}
  ~CAuthentication_GetPasswordRSAPublicKey_Request() override;
  explicit constexpr CAuthentication_GetPasswordRSAPublicKey_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetPasswordRSAPublicKey_Request(const CAuthentication_GetPasswordRSAPublicKey_Request& from);
  CAuthentication_GetPasswordRSAPublicKey_Request(CAuthentication_GetPasswordRSAPublicKey_Request&& from) noexcept
    : CAuthentication_GetPasswordRSAPublicKey_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetPasswordRSAPublicKey_Request& operator=(const CAuthentication_GetPasswordRSAPublicKey_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetPasswordRSAPublicKey_Request& operator=(CAuthentication_GetPasswordRSAPublicKey_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetPasswordRSAPublicKey_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetPasswordRSAPublicKey_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetPasswordRSAPublicKey_Request*>(
               &_CAuthentication_GetPasswordRSAPublicKey_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CAuthentication_GetPasswordRSAPublicKey_Request& a, CAuthentication_GetPasswordRSAPublicKey_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetPasswordRSAPublicKey_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetPasswordRSAPublicKey_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetPasswordRSAPublicKey_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetPasswordRSAPublicKey_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_GetPasswordRSAPublicKey_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_GetPasswordRSAPublicKey_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_GetPasswordRSAPublicKey_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetPasswordRSAPublicKey_Request";
  }
  protected:
  explicit CAuthentication_GetPasswordRSAPublicKey_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountNameFieldNumber = 1,
  };
  // optional string account_name = 1 [(.description) = "user-provided account name to get an RSA key for"];
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_GetPasswordRSAPublicKey_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_GetPasswordRSAPublicKey_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_GetPasswordRSAPublicKey_Response) */ {
 public:
  inline CAuthentication_GetPasswordRSAPublicKey_Response() : CAuthentication_GetPasswordRSAPublicKey_Response(nullptr) {}
  ~CAuthentication_GetPasswordRSAPublicKey_Response() override;
  explicit constexpr CAuthentication_GetPasswordRSAPublicKey_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetPasswordRSAPublicKey_Response(const CAuthentication_GetPasswordRSAPublicKey_Response& from);
  CAuthentication_GetPasswordRSAPublicKey_Response(CAuthentication_GetPasswordRSAPublicKey_Response&& from) noexcept
    : CAuthentication_GetPasswordRSAPublicKey_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetPasswordRSAPublicKey_Response& operator=(const CAuthentication_GetPasswordRSAPublicKey_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetPasswordRSAPublicKey_Response& operator=(CAuthentication_GetPasswordRSAPublicKey_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetPasswordRSAPublicKey_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetPasswordRSAPublicKey_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetPasswordRSAPublicKey_Response*>(
               &_CAuthentication_GetPasswordRSAPublicKey_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CAuthentication_GetPasswordRSAPublicKey_Response& a, CAuthentication_GetPasswordRSAPublicKey_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetPasswordRSAPublicKey_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetPasswordRSAPublicKey_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetPasswordRSAPublicKey_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetPasswordRSAPublicKey_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_GetPasswordRSAPublicKey_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_GetPasswordRSAPublicKey_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_GetPasswordRSAPublicKey_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetPasswordRSAPublicKey_Response";
  }
  protected:
  explicit CAuthentication_GetPasswordRSAPublicKey_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublickeyModFieldNumber = 1,
    kPublickeyExpFieldNumber = 2,
    kTimestampFieldNumber = 3,
  };
  // optional string publickey_mod = 1 [(.description) = "the public key modulus"];
  bool has_publickey_mod() const;
  private:
  bool _internal_has_publickey_mod() const;
  public:
  void clear_publickey_mod();
  const std::string& publickey_mod() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey_mod(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey_mod();
  PROTOBUF_NODISCARD std::string* release_publickey_mod();
  void set_allocated_publickey_mod(std::string* publickey_mod);
  private:
  const std::string& _internal_publickey_mod() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey_mod(const std::string& value);
  std::string* _internal_mutable_publickey_mod();
  public:

  // optional string publickey_exp = 2 [(.description) = "the public key exponent"];
  bool has_publickey_exp() const;
  private:
  bool _internal_has_publickey_exp() const;
  public:
  void clear_publickey_exp();
  const std::string& publickey_exp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publickey_exp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publickey_exp();
  PROTOBUF_NODISCARD std::string* release_publickey_exp();
  void set_allocated_publickey_exp(std::string* publickey_exp);
  private:
  const std::string& _internal_publickey_exp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publickey_exp(const std::string& value);
  std::string* _internal_mutable_publickey_exp();
  public:

  // optional uint64 timestamp = 3 [(.description) = "the timestamp the key was generated"];
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint64_t timestamp() const;
  void set_timestamp(uint64_t value);
  private:
  uint64_t _internal_timestamp() const;
  void _internal_set_timestamp(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_GetPasswordRSAPublicKey_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_mod_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publickey_exp_;
  uint64_t timestamp_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_DeviceDetails final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_DeviceDetails) */ {
 public:
  inline CAuthentication_DeviceDetails() : CAuthentication_DeviceDetails(nullptr) {}
  ~CAuthentication_DeviceDetails() override;
  explicit constexpr CAuthentication_DeviceDetails(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_DeviceDetails(const CAuthentication_DeviceDetails& from);
  CAuthentication_DeviceDetails(CAuthentication_DeviceDetails&& from) noexcept
    : CAuthentication_DeviceDetails() {
    *this = ::std::move(from);
  }

  inline CAuthentication_DeviceDetails& operator=(const CAuthentication_DeviceDetails& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_DeviceDetails& operator=(CAuthentication_DeviceDetails&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_DeviceDetails& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_DeviceDetails* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_DeviceDetails*>(
               &_CAuthentication_DeviceDetails_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CAuthentication_DeviceDetails& a, CAuthentication_DeviceDetails& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_DeviceDetails* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_DeviceDetails* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_DeviceDetails* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_DeviceDetails>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_DeviceDetails& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_DeviceDetails& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_DeviceDetails* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_DeviceDetails";
  }
  protected:
  explicit CAuthentication_DeviceDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFriendlyNameFieldNumber = 1,
    kMachineIdFieldNumber = 6,
    kPlatformTypeFieldNumber = 2,
    kOsTypeFieldNumber = 3,
    kGamingDeviceTypeFieldNumber = 4,
    kClientCountFieldNumber = 5,
  };
  // optional string device_friendly_name = 1 [(.description) = "User-supplied, or client-supplied, friendly name of device"];
  bool has_device_friendly_name() const;
  private:
  bool _internal_has_device_friendly_name() const;
  public:
  void clear_device_friendly_name();
  const std::string& device_friendly_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_friendly_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_friendly_name();
  PROTOBUF_NODISCARD std::string* release_device_friendly_name();
  void set_allocated_device_friendly_name(std::string* device_friendly_name);
  private:
  const std::string& _internal_device_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_friendly_name(const std::string& value);
  std::string* _internal_mutable_device_friendly_name();
  public:

  // optional bytes machine_id = 6 [(.description) = "Additional device context"];
  bool has_machine_id() const;
  private:
  bool _internal_has_machine_id() const;
  public:
  void clear_machine_id();
  const std::string& machine_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_machine_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_machine_id();
  PROTOBUF_NODISCARD std::string* release_machine_id();
  void set_allocated_machine_id(std::string* machine_id);
  private:
  const std::string& _internal_machine_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_machine_id(const std::string& value);
  std::string* _internal_mutable_machine_id();
  public:

  // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "EAuthTokenPlatformType, claimed, of device"];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // optional int32 os_type = 3 [(.description) = "EOSType, claimed, of authorized device"];
  bool has_os_type() const;
  private:
  bool _internal_has_os_type() const;
  public:
  void clear_os_type();
  int32_t os_type() const;
  void set_os_type(int32_t value);
  private:
  int32_t _internal_os_type() const;
  void _internal_set_os_type(int32_t value);
  public:

  // optional uint32 gaming_device_type = 4 [(.description) = "EGamingDeviceType, claimed, of authorized device for steam client-type devices"];
  bool has_gaming_device_type() const;
  private:
  bool _internal_has_gaming_device_type() const;
  public:
  void clear_gaming_device_type();
  uint32_t gaming_device_type() const;
  void set_gaming_device_type(uint32_t value);
  private:
  uint32_t _internal_gaming_device_type() const;
  void _internal_set_gaming_device_type(uint32_t value);
  public:

  // optional uint32 client_count = 5 [(.description) = "For desktop clients, quantized number of users in history"];
  bool has_client_count() const;
  private:
  bool _internal_has_client_count() const;
  public:
  void clear_client_count();
  uint32_t client_count() const;
  void set_client_count(uint32_t value);
  private:
  uint32_t _internal_client_count() const;
  void _internal_set_client_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_DeviceDetails)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_friendly_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr machine_id_;
  int platform_type_;
  int32_t os_type_;
  uint32_t gaming_device_type_;
  uint32_t client_count_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_BeginAuthSessionViaQR_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_BeginAuthSessionViaQR_Request) */ {
 public:
  inline CAuthentication_BeginAuthSessionViaQR_Request() : CAuthentication_BeginAuthSessionViaQR_Request(nullptr) {}
  ~CAuthentication_BeginAuthSessionViaQR_Request() override;
  explicit constexpr CAuthentication_BeginAuthSessionViaQR_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_BeginAuthSessionViaQR_Request(const CAuthentication_BeginAuthSessionViaQR_Request& from);
  CAuthentication_BeginAuthSessionViaQR_Request(CAuthentication_BeginAuthSessionViaQR_Request&& from) noexcept
    : CAuthentication_BeginAuthSessionViaQR_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_BeginAuthSessionViaQR_Request& operator=(const CAuthentication_BeginAuthSessionViaQR_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_BeginAuthSessionViaQR_Request& operator=(CAuthentication_BeginAuthSessionViaQR_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_BeginAuthSessionViaQR_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_BeginAuthSessionViaQR_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_BeginAuthSessionViaQR_Request*>(
               &_CAuthentication_BeginAuthSessionViaQR_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CAuthentication_BeginAuthSessionViaQR_Request& a, CAuthentication_BeginAuthSessionViaQR_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_BeginAuthSessionViaQR_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_BeginAuthSessionViaQR_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_BeginAuthSessionViaQR_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_BeginAuthSessionViaQR_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_BeginAuthSessionViaQR_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_BeginAuthSessionViaQR_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_BeginAuthSessionViaQR_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_BeginAuthSessionViaQR_Request";
  }
  protected:
  explicit CAuthentication_BeginAuthSessionViaQR_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFriendlyNameFieldNumber = 1,
    kWebsiteIdFieldNumber = 4,
    kDeviceDetailsFieldNumber = 3,
    kPlatformTypeFieldNumber = 2,
  };
  // optional string device_friendly_name = 1;
  bool has_device_friendly_name() const;
  private:
  bool _internal_has_device_friendly_name() const;
  public:
  void clear_device_friendly_name();
  const std::string& device_friendly_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_friendly_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_friendly_name();
  PROTOBUF_NODISCARD std::string* release_device_friendly_name();
  void set_allocated_device_friendly_name(std::string* device_friendly_name);
  private:
  const std::string& _internal_device_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_friendly_name(const std::string& value);
  std::string* _internal_mutable_device_friendly_name();
  public:

  // optional string website_id = 4 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
  bool has_website_id() const;
  private:
  bool _internal_has_website_id() const;
  public:
  void clear_website_id();
  const std::string& website_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website_id();
  PROTOBUF_NODISCARD std::string* release_website_id();
  void set_allocated_website_id(std::string* website_id);
  private:
  const std::string& _internal_website_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website_id(const std::string& value);
  std::string* _internal_mutable_website_id();
  public:

  // optional .CAuthentication_DeviceDetails device_details = 3 [(.description) = "User-supplied details about the device attempting to sign in"];
  bool has_device_details() const;
  private:
  bool _internal_has_device_details() const;
  public:
  void clear_device_details();
  const ::CAuthentication_DeviceDetails& device_details() const;
  PROTOBUF_NODISCARD ::CAuthentication_DeviceDetails* release_device_details();
  ::CAuthentication_DeviceDetails* mutable_device_details();
  void set_allocated_device_details(::CAuthentication_DeviceDetails* device_details);
  private:
  const ::CAuthentication_DeviceDetails& _internal_device_details() const;
  ::CAuthentication_DeviceDetails* _internal_mutable_device_details();
  public:
  void unsafe_arena_set_allocated_device_details(
      ::CAuthentication_DeviceDetails* device_details);
  ::CAuthentication_DeviceDetails* unsafe_arena_release_device_details();

  // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_BeginAuthSessionViaQR_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_friendly_name_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_website_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_id_;
  ::CAuthentication_DeviceDetails* device_details_;
  int platform_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_AllowedConfirmation final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_AllowedConfirmation) */ {
 public:
  inline CAuthentication_AllowedConfirmation() : CAuthentication_AllowedConfirmation(nullptr) {}
  ~CAuthentication_AllowedConfirmation() override;
  explicit constexpr CAuthentication_AllowedConfirmation(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_AllowedConfirmation(const CAuthentication_AllowedConfirmation& from);
  CAuthentication_AllowedConfirmation(CAuthentication_AllowedConfirmation&& from) noexcept
    : CAuthentication_AllowedConfirmation() {
    *this = ::std::move(from);
  }

  inline CAuthentication_AllowedConfirmation& operator=(const CAuthentication_AllowedConfirmation& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_AllowedConfirmation& operator=(CAuthentication_AllowedConfirmation&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_AllowedConfirmation& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_AllowedConfirmation* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_AllowedConfirmation*>(
               &_CAuthentication_AllowedConfirmation_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CAuthentication_AllowedConfirmation& a, CAuthentication_AllowedConfirmation& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_AllowedConfirmation* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_AllowedConfirmation* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_AllowedConfirmation* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_AllowedConfirmation>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_AllowedConfirmation& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_AllowedConfirmation& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_AllowedConfirmation* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_AllowedConfirmation";
  }
  protected:
  explicit CAuthentication_AllowedConfirmation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssociatedMessageFieldNumber = 2,
    kConfirmationTypeFieldNumber = 1,
  };
  // optional string associated_message = 2 [(.description) = "message to be interpreted depending on the confirmation type. for email confirmation, this might be the redacted email address to which email was sent."];
  bool has_associated_message() const;
  private:
  bool _internal_has_associated_message() const;
  public:
  void clear_associated_message();
  const std::string& associated_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_associated_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_associated_message();
  PROTOBUF_NODISCARD std::string* release_associated_message();
  void set_allocated_associated_message(std::string* associated_message);
  private:
  const std::string& _internal_associated_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_associated_message(const std::string& value);
  std::string* _internal_mutable_associated_message();
  public:

  // optional .EAuthSessionGuardType confirmation_type = 1 [default = k_EAuthSessionGuardType_Unknown, (.description) = "authentication can proceed with this confirmation type"];
  bool has_confirmation_type() const;
  private:
  bool _internal_has_confirmation_type() const;
  public:
  void clear_confirmation_type();
  ::EAuthSessionGuardType confirmation_type() const;
  void set_confirmation_type(::EAuthSessionGuardType value);
  private:
  ::EAuthSessionGuardType _internal_confirmation_type() const;
  void _internal_set_confirmation_type(::EAuthSessionGuardType value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_AllowedConfirmation)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr associated_message_;
  int confirmation_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_BeginAuthSessionViaQR_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_BeginAuthSessionViaQR_Response) */ {
 public:
  inline CAuthentication_BeginAuthSessionViaQR_Response() : CAuthentication_BeginAuthSessionViaQR_Response(nullptr) {}
  ~CAuthentication_BeginAuthSessionViaQR_Response() override;
  explicit constexpr CAuthentication_BeginAuthSessionViaQR_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_BeginAuthSessionViaQR_Response(const CAuthentication_BeginAuthSessionViaQR_Response& from);
  CAuthentication_BeginAuthSessionViaQR_Response(CAuthentication_BeginAuthSessionViaQR_Response&& from) noexcept
    : CAuthentication_BeginAuthSessionViaQR_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_BeginAuthSessionViaQR_Response& operator=(const CAuthentication_BeginAuthSessionViaQR_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_BeginAuthSessionViaQR_Response& operator=(CAuthentication_BeginAuthSessionViaQR_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_BeginAuthSessionViaQR_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_BeginAuthSessionViaQR_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_BeginAuthSessionViaQR_Response*>(
               &_CAuthentication_BeginAuthSessionViaQR_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CAuthentication_BeginAuthSessionViaQR_Response& a, CAuthentication_BeginAuthSessionViaQR_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_BeginAuthSessionViaQR_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_BeginAuthSessionViaQR_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_BeginAuthSessionViaQR_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_BeginAuthSessionViaQR_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_BeginAuthSessionViaQR_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_BeginAuthSessionViaQR_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_BeginAuthSessionViaQR_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_BeginAuthSessionViaQR_Response";
  }
  protected:
  explicit CAuthentication_BeginAuthSessionViaQR_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedConfirmationsFieldNumber = 5,
    kChallengeUrlFieldNumber = 2,
    kRequestIdFieldNumber = 3,
    kClientIdFieldNumber = 1,
    kIntervalFieldNumber = 4,
    kVersionFieldNumber = 6,
  };
  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 5 [(.description) = "the confirmation types that will be able to confirm the request"];
  int allowed_confirmations_size() const;
  private:
  int _internal_allowed_confirmations_size() const;
  public:
  void clear_allowed_confirmations();
  ::CAuthentication_AllowedConfirmation* mutable_allowed_confirmations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >*
      mutable_allowed_confirmations();
  private:
  const ::CAuthentication_AllowedConfirmation& _internal_allowed_confirmations(int index) const;
  ::CAuthentication_AllowedConfirmation* _internal_add_allowed_confirmations();
  public:
  const ::CAuthentication_AllowedConfirmation& allowed_confirmations(int index) const;
  ::CAuthentication_AllowedConfirmation* add_allowed_confirmations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >&
      allowed_confirmations() const;

  // optional string challenge_url = 2 [(.description) = "URL based on client ID, which will be rendered as QR code"];
  bool has_challenge_url() const;
  private:
  bool _internal_has_challenge_url() const;
  public:
  void clear_challenge_url();
  const std::string& challenge_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_challenge_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_challenge_url();
  PROTOBUF_NODISCARD std::string* release_challenge_url();
  void set_allocated_challenge_url(std::string* challenge_url);
  private:
  const std::string& _internal_challenge_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge_url(const std::string& value);
  std::string* _internal_mutable_challenge_url();
  public:

  // optional bytes request_id = 3 [(.description) = "unique request ID to be presented by requestor at poll time - must not be rendered in QR"];
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing, portion of QR code"];
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional float interval = 4 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  float interval() const;
  void set_interval(float value);
  private:
  float _internal_interval() const;
  void _internal_set_interval(float value);
  public:

  // optional int32 version = 6 [(.description) = "version of the QR data"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_BeginAuthSessionViaQR_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation > allowed_confirmations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  uint64_t client_id_;
  float interval_;
  int32_t version_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_BeginAuthSessionViaCredentials_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_BeginAuthSessionViaCredentials_Request) */ {
 public:
  inline CAuthentication_BeginAuthSessionViaCredentials_Request() : CAuthentication_BeginAuthSessionViaCredentials_Request(nullptr) {}
  ~CAuthentication_BeginAuthSessionViaCredentials_Request() override;
  explicit constexpr CAuthentication_BeginAuthSessionViaCredentials_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_BeginAuthSessionViaCredentials_Request(const CAuthentication_BeginAuthSessionViaCredentials_Request& from);
  CAuthentication_BeginAuthSessionViaCredentials_Request(CAuthentication_BeginAuthSessionViaCredentials_Request&& from) noexcept
    : CAuthentication_BeginAuthSessionViaCredentials_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_BeginAuthSessionViaCredentials_Request& operator=(const CAuthentication_BeginAuthSessionViaCredentials_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_BeginAuthSessionViaCredentials_Request& operator=(CAuthentication_BeginAuthSessionViaCredentials_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_BeginAuthSessionViaCredentials_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_BeginAuthSessionViaCredentials_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_BeginAuthSessionViaCredentials_Request*>(
               &_CAuthentication_BeginAuthSessionViaCredentials_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CAuthentication_BeginAuthSessionViaCredentials_Request& a, CAuthentication_BeginAuthSessionViaCredentials_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_BeginAuthSessionViaCredentials_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_BeginAuthSessionViaCredentials_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_BeginAuthSessionViaCredentials_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_BeginAuthSessionViaCredentials_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_BeginAuthSessionViaCredentials_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_BeginAuthSessionViaCredentials_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_BeginAuthSessionViaCredentials_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_BeginAuthSessionViaCredentials_Request";
  }
  protected:
  explicit CAuthentication_BeginAuthSessionViaCredentials_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceFriendlyNameFieldNumber = 1,
    kAccountNameFieldNumber = 2,
    kEncryptedPasswordFieldNumber = 3,
    kWebsiteIdFieldNumber = 8,
    kGuardDataFieldNumber = 10,
    kDeviceDetailsFieldNumber = 9,
    kEncryptionTimestampFieldNumber = 4,
    kRememberLoginFieldNumber = 5,
    kPlatformTypeFieldNumber = 6,
    kLanguageFieldNumber = 11,
    kPersistenceFieldNumber = 7,
    kQosLevelFieldNumber = 12,
  };
  // optional string device_friendly_name = 1;
  bool has_device_friendly_name() const;
  private:
  bool _internal_has_device_friendly_name() const;
  public:
  void clear_device_friendly_name();
  const std::string& device_friendly_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_friendly_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_friendly_name();
  PROTOBUF_NODISCARD std::string* release_device_friendly_name();
  void set_allocated_device_friendly_name(std::string* device_friendly_name);
  private:
  const std::string& _internal_device_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_friendly_name(const std::string& value);
  std::string* _internal_mutable_device_friendly_name();
  public:

  // optional string account_name = 2;
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // optional string encrypted_password = 3 [(.description) = "password, RSA encrypted client side"];
  bool has_encrypted_password() const;
  private:
  bool _internal_has_encrypted_password() const;
  public:
  void clear_encrypted_password();
  const std::string& encrypted_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_password();
  PROTOBUF_NODISCARD std::string* release_encrypted_password();
  void set_allocated_encrypted_password(std::string* encrypted_password);
  private:
  const std::string& _internal_encrypted_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_password(const std::string& value);
  std::string* _internal_mutable_encrypted_password();
  public:

  // optional string website_id = 8 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
  bool has_website_id() const;
  private:
  bool _internal_has_website_id() const;
  public:
  void clear_website_id();
  const std::string& website_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_website_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_website_id();
  PROTOBUF_NODISCARD std::string* release_website_id();
  void set_allocated_website_id(std::string* website_id);
  private:
  const std::string& _internal_website_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_website_id(const std::string& value);
  std::string* _internal_mutable_website_id();
  public:

  // optional string guard_data = 10 [(.description) = "steam guard data for client login"];
  bool has_guard_data() const;
  private:
  bool _internal_has_guard_data() const;
  public:
  void clear_guard_data();
  const std::string& guard_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_guard_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_guard_data();
  PROTOBUF_NODISCARD std::string* release_guard_data();
  void set_allocated_guard_data(std::string* guard_data);
  private:
  const std::string& _internal_guard_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_guard_data(const std::string& value);
  std::string* _internal_mutable_guard_data();
  public:

  // optional .CAuthentication_DeviceDetails device_details = 9 [(.description) = "User-supplied details about the device attempting to sign in"];
  bool has_device_details() const;
  private:
  bool _internal_has_device_details() const;
  public:
  void clear_device_details();
  const ::CAuthentication_DeviceDetails& device_details() const;
  PROTOBUF_NODISCARD ::CAuthentication_DeviceDetails* release_device_details();
  ::CAuthentication_DeviceDetails* mutable_device_details();
  void set_allocated_device_details(::CAuthentication_DeviceDetails* device_details);
  private:
  const ::CAuthentication_DeviceDetails& _internal_device_details() const;
  ::CAuthentication_DeviceDetails* _internal_mutable_device_details();
  public:
  void unsafe_arena_set_allocated_device_details(
      ::CAuthentication_DeviceDetails* device_details);
  ::CAuthentication_DeviceDetails* unsafe_arena_release_device_details();

  // optional uint64 encryption_timestamp = 4 [(.description) = "timestamp to map to a key - STime"];
  bool has_encryption_timestamp() const;
  private:
  bool _internal_has_encryption_timestamp() const;
  public:
  void clear_encryption_timestamp();
  uint64_t encryption_timestamp() const;
  void set_encryption_timestamp(uint64_t value);
  private:
  uint64_t _internal_encryption_timestamp() const;
  void _internal_set_encryption_timestamp(uint64_t value);
  public:

  // optional bool remember_login = 5 [(.description) = "deprecated"];
  bool has_remember_login() const;
  private:
  bool _internal_has_remember_login() const;
  public:
  void clear_remember_login();
  bool remember_login() const;
  void set_remember_login(bool value);
  private:
  bool _internal_remember_login() const;
  void _internal_set_remember_login(bool value);
  public:

  // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // optional uint32 language = 11;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  uint32_t language() const;
  void set_language(uint32_t value);
  private:
  uint32_t _internal_language() const;
  void _internal_set_language(uint32_t value);
  public:

  // optional .ESessionPersistence persistence = 7 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
  bool has_persistence() const;
  private:
  bool _internal_has_persistence() const;
  public:
  void clear_persistence();
  ::ESessionPersistence persistence() const;
  void set_persistence(::ESessionPersistence value);
  private:
  ::ESessionPersistence _internal_persistence() const;
  void _internal_set_persistence(::ESessionPersistence value);
  public:

  // optional int32 qos_level = 12 [default = 2, (.description) = "[ENetQOSLevel] client-specified priority for this auth attempt"];
  bool has_qos_level() const;
  private:
  bool _internal_has_qos_level() const;
  public:
  void clear_qos_level();
  int32_t qos_level() const;
  void set_qos_level(int32_t value);
  private:
  int32_t _internal_qos_level() const;
  void _internal_set_qos_level(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_BeginAuthSessionViaCredentials_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_friendly_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_password_;
  static const ::PROTOBUF_NAMESPACE_ID::internal::LazyString _i_give_permission_to_break_this_code_default_website_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr website_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr guard_data_;
  ::CAuthentication_DeviceDetails* device_details_;
  uint64_t encryption_timestamp_;
  bool remember_login_;
  int platform_type_;
  uint32_t language_;
  int persistence_;
  int32_t qos_level_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_BeginAuthSessionViaCredentials_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_BeginAuthSessionViaCredentials_Response) */ {
 public:
  inline CAuthentication_BeginAuthSessionViaCredentials_Response() : CAuthentication_BeginAuthSessionViaCredentials_Response(nullptr) {}
  ~CAuthentication_BeginAuthSessionViaCredentials_Response() override;
  explicit constexpr CAuthentication_BeginAuthSessionViaCredentials_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_BeginAuthSessionViaCredentials_Response(const CAuthentication_BeginAuthSessionViaCredentials_Response& from);
  CAuthentication_BeginAuthSessionViaCredentials_Response(CAuthentication_BeginAuthSessionViaCredentials_Response&& from) noexcept
    : CAuthentication_BeginAuthSessionViaCredentials_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_BeginAuthSessionViaCredentials_Response& operator=(const CAuthentication_BeginAuthSessionViaCredentials_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_BeginAuthSessionViaCredentials_Response& operator=(CAuthentication_BeginAuthSessionViaCredentials_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_BeginAuthSessionViaCredentials_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_BeginAuthSessionViaCredentials_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_BeginAuthSessionViaCredentials_Response*>(
               &_CAuthentication_BeginAuthSessionViaCredentials_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CAuthentication_BeginAuthSessionViaCredentials_Response& a, CAuthentication_BeginAuthSessionViaCredentials_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_BeginAuthSessionViaCredentials_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_BeginAuthSessionViaCredentials_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_BeginAuthSessionViaCredentials_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_BeginAuthSessionViaCredentials_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_BeginAuthSessionViaCredentials_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_BeginAuthSessionViaCredentials_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_BeginAuthSessionViaCredentials_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_BeginAuthSessionViaCredentials_Response";
  }
  protected:
  explicit CAuthentication_BeginAuthSessionViaCredentials_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAllowedConfirmationsFieldNumber = 4,
    kRequestIdFieldNumber = 2,
    kWeakTokenFieldNumber = 6,
    kAgreementSessionUrlFieldNumber = 7,
    kExtendedErrorMessageFieldNumber = 8,
    kClientIdFieldNumber = 1,
    kSteamidFieldNumber = 5,
    kIntervalFieldNumber = 3,
  };
  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 4 [(.description) = "the confirmation types that will be able to confirm the request"];
  int allowed_confirmations_size() const;
  private:
  int _internal_allowed_confirmations_size() const;
  public:
  void clear_allowed_confirmations();
  ::CAuthentication_AllowedConfirmation* mutable_allowed_confirmations(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >*
      mutable_allowed_confirmations();
  private:
  const ::CAuthentication_AllowedConfirmation& _internal_allowed_confirmations(int index) const;
  ::CAuthentication_AllowedConfirmation* _internal_add_allowed_confirmations();
  public:
  const ::CAuthentication_AllowedConfirmation& allowed_confirmations(int index) const;
  ::CAuthentication_AllowedConfirmation* add_allowed_confirmations();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >&
      allowed_confirmations() const;

  // optional bytes request_id = 2 [(.description) = "unique request ID to be presented by requestor at poll time - must not be transferred or displayed"];
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional string weak_token = 6 [(.description) = "partial-authentication token - limited lifetime and scope, included only if credentials were valid"];
  bool has_weak_token() const;
  private:
  bool _internal_has_weak_token() const;
  public:
  void clear_weak_token();
  const std::string& weak_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_weak_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_weak_token();
  PROTOBUF_NODISCARD std::string* release_weak_token();
  void set_allocated_weak_token(std::string* weak_token);
  private:
  const std::string& _internal_weak_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_weak_token(const std::string& value);
  std::string* _internal_mutable_weak_token();
  public:

  // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
  bool has_agreement_session_url() const;
  private:
  bool _internal_has_agreement_session_url() const;
  public:
  void clear_agreement_session_url();
  const std::string& agreement_session_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agreement_session_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agreement_session_url();
  PROTOBUF_NODISCARD std::string* release_agreement_session_url();
  void set_allocated_agreement_session_url(std::string* agreement_session_url);
  private:
  const std::string& _internal_agreement_session_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agreement_session_url(const std::string& value);
  std::string* _internal_mutable_agreement_session_url();
  public:

  // optional string extended_error_message = 8 [(.description) = "error string to display if supported by the client"];
  bool has_extended_error_message() const;
  private:
  bool _internal_has_extended_error_message() const;
  public:
  void clear_extended_error_message();
  const std::string& extended_error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_extended_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_extended_error_message();
  PROTOBUF_NODISCARD std::string* release_extended_error_message();
  void set_allocated_extended_error_message(std::string* extended_error_message);
  private:
  const std::string& _internal_extended_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_extended_error_message(const std::string& value);
  std::string* _internal_mutable_extended_error_message();
  public:

  // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing"];
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional uint64 steamid = 5 [(.description) = "steamid of the account logging in - will only be included if the credentials were correct"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional float interval = 3 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
  bool has_interval() const;
  private:
  bool _internal_has_interval() const;
  public:
  void clear_interval();
  float interval() const;
  void set_interval(float value);
  private:
  float _internal_interval() const;
  void _internal_set_interval(float value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_BeginAuthSessionViaCredentials_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation > allowed_confirmations_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr weak_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agreement_session_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr extended_error_message_;
  uint64_t client_id_;
  uint64_t steamid_;
  float interval_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_PollAuthSessionStatus_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_PollAuthSessionStatus_Request) */ {
 public:
  inline CAuthentication_PollAuthSessionStatus_Request() : CAuthentication_PollAuthSessionStatus_Request(nullptr) {}
  ~CAuthentication_PollAuthSessionStatus_Request() override;
  explicit constexpr CAuthentication_PollAuthSessionStatus_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_PollAuthSessionStatus_Request(const CAuthentication_PollAuthSessionStatus_Request& from);
  CAuthentication_PollAuthSessionStatus_Request(CAuthentication_PollAuthSessionStatus_Request&& from) noexcept
    : CAuthentication_PollAuthSessionStatus_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_PollAuthSessionStatus_Request& operator=(const CAuthentication_PollAuthSessionStatus_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_PollAuthSessionStatus_Request& operator=(CAuthentication_PollAuthSessionStatus_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_PollAuthSessionStatus_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_PollAuthSessionStatus_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_PollAuthSessionStatus_Request*>(
               &_CAuthentication_PollAuthSessionStatus_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CAuthentication_PollAuthSessionStatus_Request& a, CAuthentication_PollAuthSessionStatus_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_PollAuthSessionStatus_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_PollAuthSessionStatus_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_PollAuthSessionStatus_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_PollAuthSessionStatus_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_PollAuthSessionStatus_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_PollAuthSessionStatus_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_PollAuthSessionStatus_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_PollAuthSessionStatus_Request";
  }
  protected:
  explicit CAuthentication_PollAuthSessionStatus_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 2,
    kClientIdFieldNumber = 1,
    kTokenToRevokeFieldNumber = 3,
  };
  // optional bytes request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  const std::string& request_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_request_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_request_id();
  PROTOBUF_NODISCARD std::string* release_request_id();
  void set_allocated_request_id(std::string* request_id);
  private:
  const std::string& _internal_request_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_request_id(const std::string& value);
  std::string* _internal_mutable_request_id();
  public:

  // optional uint64 client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional fixed64 token_to_revoke = 3 [(.description) = "If this is set to a token owned by this user, that token will be retired"];
  bool has_token_to_revoke() const;
  private:
  bool _internal_has_token_to_revoke() const;
  public:
  void clear_token_to_revoke();
  uint64_t token_to_revoke() const;
  void set_token_to_revoke(uint64_t value);
  private:
  uint64_t _internal_token_to_revoke() const;
  void _internal_set_token_to_revoke(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_PollAuthSessionStatus_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr request_id_;
  uint64_t client_id_;
  uint64_t token_to_revoke_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_PollAuthSessionStatus_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_PollAuthSessionStatus_Response) */ {
 public:
  inline CAuthentication_PollAuthSessionStatus_Response() : CAuthentication_PollAuthSessionStatus_Response(nullptr) {}
  ~CAuthentication_PollAuthSessionStatus_Response() override;
  explicit constexpr CAuthentication_PollAuthSessionStatus_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_PollAuthSessionStatus_Response(const CAuthentication_PollAuthSessionStatus_Response& from);
  CAuthentication_PollAuthSessionStatus_Response(CAuthentication_PollAuthSessionStatus_Response&& from) noexcept
    : CAuthentication_PollAuthSessionStatus_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_PollAuthSessionStatus_Response& operator=(const CAuthentication_PollAuthSessionStatus_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_PollAuthSessionStatus_Response& operator=(CAuthentication_PollAuthSessionStatus_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_PollAuthSessionStatus_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_PollAuthSessionStatus_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_PollAuthSessionStatus_Response*>(
               &_CAuthentication_PollAuthSessionStatus_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CAuthentication_PollAuthSessionStatus_Response& a, CAuthentication_PollAuthSessionStatus_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_PollAuthSessionStatus_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_PollAuthSessionStatus_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_PollAuthSessionStatus_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_PollAuthSessionStatus_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_PollAuthSessionStatus_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_PollAuthSessionStatus_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_PollAuthSessionStatus_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_PollAuthSessionStatus_Response";
  }
  protected:
  explicit CAuthentication_PollAuthSessionStatus_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewChallengeUrlFieldNumber = 2,
    kRefreshTokenFieldNumber = 3,
    kAccessTokenFieldNumber = 4,
    kAccountNameFieldNumber = 6,
    kNewGuardDataFieldNumber = 7,
    kAgreementSessionUrlFieldNumber = 8,
    kNewClientIdFieldNumber = 1,
    kHadRemoteInteractionFieldNumber = 5,
  };
  // optional string new_challenge_url = 2 [(.description) = "if challenge is old, this is the new challenge ID to re-render for mobile confirmation"];
  bool has_new_challenge_url() const;
  private:
  bool _internal_has_new_challenge_url() const;
  public:
  void clear_new_challenge_url();
  const std::string& new_challenge_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_challenge_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_challenge_url();
  PROTOBUF_NODISCARD std::string* release_new_challenge_url();
  void set_allocated_new_challenge_url(std::string* new_challenge_url);
  private:
  const std::string& _internal_new_challenge_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_challenge_url(const std::string& value);
  std::string* _internal_mutable_new_challenge_url();
  public:

  // optional string refresh_token = 3 [(.description) = "if login has been confirmed, this is the requestor\'s new refresh token"];
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // optional string access_token = 4 [(.description) = "if login has been confirmed, this is a new token subordinate to refresh_token"];
  bool has_access_token() const;
  private:
  bool _internal_has_access_token() const;
  public:
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // optional string account_name = 6 [(.description) = "account name of authenticating account, for use by UI layer"];
  bool has_account_name() const;
  private:
  bool _internal_has_account_name() const;
  public:
  void clear_account_name();
  const std::string& account_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account_name();
  PROTOBUF_NODISCARD std::string* release_account_name();
  void set_allocated_account_name(std::string* account_name);
  private:
  const std::string& _internal_account_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account_name(const std::string& value);
  std::string* _internal_mutable_account_name();
  public:

  // optional string new_guard_data = 7 [(.description) = "if login has been confirmed, may contain remembered machine ID for future login"];
  bool has_new_guard_data() const;
  private:
  bool _internal_has_new_guard_data() const;
  public:
  void clear_new_guard_data();
  const std::string& new_guard_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_new_guard_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_new_guard_data();
  PROTOBUF_NODISCARD std::string* release_new_guard_data();
  void set_allocated_new_guard_data(std::string* new_guard_data);
  private:
  const std::string& _internal_new_guard_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_new_guard_data(const std::string& value);
  std::string* _internal_mutable_new_guard_data();
  public:

  // optional string agreement_session_url = 8 [(.description) = "agreement the user needs to agree to"];
  bool has_agreement_session_url() const;
  private:
  bool _internal_has_agreement_session_url() const;
  public:
  void clear_agreement_session_url();
  const std::string& agreement_session_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agreement_session_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agreement_session_url();
  PROTOBUF_NODISCARD std::string* release_agreement_session_url();
  void set_allocated_agreement_session_url(std::string* agreement_session_url);
  private:
  const std::string& _internal_agreement_session_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agreement_session_url(const std::string& value);
  std::string* _internal_mutable_agreement_session_url();
  public:

  // optional uint64 new_client_id = 1 [(.description) = "if challenge is old, this is the new client id"];
  bool has_new_client_id() const;
  private:
  bool _internal_has_new_client_id() const;
  public:
  void clear_new_client_id();
  uint64_t new_client_id() const;
  void set_new_client_id(uint64_t value);
  private:
  uint64_t _internal_new_client_id() const;
  void _internal_set_new_client_id(uint64_t value);
  public:

  // optional bool had_remote_interaction = 5 [(.description) = "whether or not the auth session appears to have had remote interaction from a potential confirmer"];
  bool has_had_remote_interaction() const;
  private:
  bool _internal_has_had_remote_interaction() const;
  public:
  void clear_had_remote_interaction();
  bool had_remote_interaction() const;
  void set_had_remote_interaction(bool value);
  private:
  bool _internal_had_remote_interaction() const;
  void _internal_set_had_remote_interaction(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_PollAuthSessionStatus_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_challenge_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr new_guard_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agreement_session_url_;
  uint64_t new_client_id_;
  bool had_remote_interaction_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_GetAuthSessionInfo_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_GetAuthSessionInfo_Request) */ {
 public:
  inline CAuthentication_GetAuthSessionInfo_Request() : CAuthentication_GetAuthSessionInfo_Request(nullptr) {}
  ~CAuthentication_GetAuthSessionInfo_Request() override;
  explicit constexpr CAuthentication_GetAuthSessionInfo_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetAuthSessionInfo_Request(const CAuthentication_GetAuthSessionInfo_Request& from);
  CAuthentication_GetAuthSessionInfo_Request(CAuthentication_GetAuthSessionInfo_Request&& from) noexcept
    : CAuthentication_GetAuthSessionInfo_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetAuthSessionInfo_Request& operator=(const CAuthentication_GetAuthSessionInfo_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetAuthSessionInfo_Request& operator=(CAuthentication_GetAuthSessionInfo_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetAuthSessionInfo_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetAuthSessionInfo_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetAuthSessionInfo_Request*>(
               &_CAuthentication_GetAuthSessionInfo_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CAuthentication_GetAuthSessionInfo_Request& a, CAuthentication_GetAuthSessionInfo_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetAuthSessionInfo_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetAuthSessionInfo_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetAuthSessionInfo_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetAuthSessionInfo_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_GetAuthSessionInfo_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_GetAuthSessionInfo_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_GetAuthSessionInfo_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetAuthSessionInfo_Request";
  }
  protected:
  explicit CAuthentication_GetAuthSessionInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdFieldNumber = 1,
  };
  // optional uint64 client_id = 1 [(.description) = "client ID from scanned QR Code, used for routing"];
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_GetAuthSessionInfo_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t client_id_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_GetAuthSessionInfo_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_GetAuthSessionInfo_Response) */ {
 public:
  inline CAuthentication_GetAuthSessionInfo_Response() : CAuthentication_GetAuthSessionInfo_Response(nullptr) {}
  ~CAuthentication_GetAuthSessionInfo_Response() override;
  explicit constexpr CAuthentication_GetAuthSessionInfo_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetAuthSessionInfo_Response(const CAuthentication_GetAuthSessionInfo_Response& from);
  CAuthentication_GetAuthSessionInfo_Response(CAuthentication_GetAuthSessionInfo_Response&& from) noexcept
    : CAuthentication_GetAuthSessionInfo_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetAuthSessionInfo_Response& operator=(const CAuthentication_GetAuthSessionInfo_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetAuthSessionInfo_Response& operator=(CAuthentication_GetAuthSessionInfo_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetAuthSessionInfo_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetAuthSessionInfo_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetAuthSessionInfo_Response*>(
               &_CAuthentication_GetAuthSessionInfo_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CAuthentication_GetAuthSessionInfo_Response& a, CAuthentication_GetAuthSessionInfo_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetAuthSessionInfo_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetAuthSessionInfo_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetAuthSessionInfo_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetAuthSessionInfo_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_GetAuthSessionInfo_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_GetAuthSessionInfo_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_GetAuthSessionInfo_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetAuthSessionInfo_Response";
  }
  protected:
  explicit CAuthentication_GetAuthSessionInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kGeolocFieldNumber = 2,
    kCityFieldNumber = 3,
    kStateFieldNumber = 4,
    kCountryFieldNumber = 5,
    kDeviceFriendlyNameFieldNumber = 7,
    kPlatformTypeFieldNumber = 6,
    kVersionFieldNumber = 8,
    kLoginHistoryFieldNumber = 9,
    kRequestorLocationMismatchFieldNumber = 10,
    kHighUsageLoginFieldNumber = 11,
    kRequestedPersistenceFieldNumber = 12,
  };
  // optional string ip = 1 [(.description) = "IP address of requestor"];
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_NODISCARD std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // optional string geoloc = 2 [(.description) = "geoloc info of requestor"];
  bool has_geoloc() const;
  private:
  bool _internal_has_geoloc() const;
  public:
  void clear_geoloc();
  const std::string& geoloc() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_geoloc(ArgT0&& arg0, ArgT... args);
  std::string* mutable_geoloc();
  PROTOBUF_NODISCARD std::string* release_geoloc();
  void set_allocated_geoloc(std::string* geoloc);
  private:
  const std::string& _internal_geoloc() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_geoloc(const std::string& value);
  std::string* _internal_mutable_geoloc();
  public:

  // optional string city = 3 [(.description) = "city of requestor"];
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // optional string state = 4 [(.description) = "state of requestor"];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string country = 5 [(.description) = "country of requestor"];
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string device_friendly_name = 7 [(.description) = "name of requestor device"];
  bool has_device_friendly_name() const;
  private:
  bool _internal_has_device_friendly_name() const;
  public:
  void clear_device_friendly_name();
  const std::string& device_friendly_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_friendly_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_friendly_name();
  PROTOBUF_NODISCARD std::string* release_device_friendly_name();
  void set_allocated_device_friendly_name(std::string* device_friendly_name);
  private:
  const std::string& _internal_device_friendly_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_friendly_name(const std::string& value);
  std::string* _internal_mutable_device_friendly_name();
  public:

  // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "platform type of requestor"];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // optional int32 version = 8 [(.description) = "version field"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // optional .EAuthSessionSecurityHistory login_history = 9 [default = k_EAuthSessionSecurityHistory_Invalid, (.description) = "whether the ip has previuously been used on the account successfully"];
  bool has_login_history() const;
  private:
  bool _internal_has_login_history() const;
  public:
  void clear_login_history();
  ::EAuthSessionSecurityHistory login_history() const;
  void set_login_history(::EAuthSessionSecurityHistory value);
  private:
  ::EAuthSessionSecurityHistory _internal_login_history() const;
  void _internal_set_login_history(::EAuthSessionSecurityHistory value);
  public:

  // optional bool requestor_location_mismatch = 10 [(.description) = "whether the requestor location matches this requests location"];
  bool has_requestor_location_mismatch() const;
  private:
  bool _internal_has_requestor_location_mismatch() const;
  public:
  void clear_requestor_location_mismatch();
  bool requestor_location_mismatch() const;
  void set_requestor_location_mismatch(bool value);
  private:
  bool _internal_requestor_location_mismatch() const;
  void _internal_set_requestor_location_mismatch(bool value);
  public:

  // optional bool high_usage_login = 11 [(.description) = "whether this login has seen high usage recently"];
  bool has_high_usage_login() const;
  private:
  bool _internal_has_high_usage_login() const;
  public:
  void clear_high_usage_login();
  bool high_usage_login() const;
  void set_high_usage_login(bool value);
  private:
  bool _internal_high_usage_login() const;
  void _internal_set_high_usage_login(bool value);
  public:

  // optional .ESessionPersistence requested_persistence = 12 [default = k_ESessionPersistence_Invalid, (.description) = "session persistence requestor has indicated they want"];
  bool has_requested_persistence() const;
  private:
  bool _internal_has_requested_persistence() const;
  public:
  void clear_requested_persistence();
  ::ESessionPersistence requested_persistence() const;
  void set_requested_persistence(::ESessionPersistence value);
  private:
  ::ESessionPersistence _internal_requested_persistence() const;
  void _internal_set_requested_persistence(::ESessionPersistence value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_GetAuthSessionInfo_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr geoloc_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_friendly_name_;
  int platform_type_;
  int32_t version_;
  int login_history_;
  bool requestor_location_mismatch_;
  bool high_usage_login_;
  int requested_persistence_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request) */ {
 public:
  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request() : CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(nullptr) {}
  ~CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request() override;
  explicit constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from);
  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request&& from) noexcept
    : CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& operator=(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& operator=(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request*>(
               &_CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& a, CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request";
  }
  protected:
  explicit CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 4,
    kClientIdFieldNumber = 2,
    kSteamidFieldNumber = 3,
    kVersionFieldNumber = 1,
    kConfirmFieldNumber = 5,
    kPersistenceFieldNumber = 6,
  };
  // optional bytes signature = 4 [(.description) = "HMAC digest over {version,client_id,steamid} via user\'s private key"];
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional uint64 client_id = 2 [(.description) = "pending client ID, from scanned QR Code"];
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional fixed64 steamid = 3 [(.description) = "user who wants to login"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional int32 version = 1 [(.description) = "version field"];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // optional bool confirm = 5 [default = false, (.description) = "Whether to confirm the login (true) or deny the login (false)"];
  bool has_confirm() const;
  private:
  bool _internal_has_confirm() const;
  public:
  void clear_confirm();
  bool confirm() const;
  void set_confirm(bool value);
  private:
  bool _internal_confirm() const;
  void _internal_set_confirm(bool value);
  public:

  // optional .ESessionPersistence persistence = 6 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
  bool has_persistence() const;
  private:
  bool _internal_has_persistence() const;
  public:
  void clear_persistence();
  ::ESessionPersistence persistence() const;
  void set_persistence(::ESessionPersistence value);
  private:
  ::ESessionPersistence _internal_persistence() const;
  void _internal_set_persistence(::ESessionPersistence value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  uint64_t client_id_;
  uint64_t steamid_;
  int32_t version_;
  bool confirm_;
  int persistence_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response) */ {
 public:
  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response() : CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(nullptr) {}
  explicit constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& from);
  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response&& from) noexcept
    : CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& operator=(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& operator=(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response*>(
               &_CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& a, CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response";
  }
  protected:
  explicit CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request) */ {
 public:
  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request() : CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(nullptr) {}
  ~CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request() override;
  explicit constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from);
  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request&& from) noexcept
    : CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& operator=(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& operator=(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request*>(
               &_CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& a, CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request";
  }
  protected:
  explicit CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodeFieldNumber = 3,
    kClientIdFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kCodeTypeFieldNumber = 4,
  };
  // optional string code = 3 [(.description) = "confirmation code"];
  bool has_code() const;
  private:
  bool _internal_has_code() const;
  public:
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_NODISCARD std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // optional uint64 client_id = 1 [(.description) = "pending client ID, from initialized session"];
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional fixed64 steamid = 2 [(.description) = "user who wants to login"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional .EAuthSessionGuardType code_type = 4 [default = k_EAuthSessionGuardType_Unknown, (.description) = "type of confirmation code"];
  bool has_code_type() const;
  private:
  bool _internal_has_code_type() const;
  public:
  void clear_code_type();
  ::EAuthSessionGuardType code_type() const;
  void set_code_type(::EAuthSessionGuardType value);
  private:
  ::EAuthSessionGuardType _internal_code_type() const;
  void _internal_set_code_type(::EAuthSessionGuardType value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  uint64_t client_id_;
  uint64_t steamid_;
  int code_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response) */ {
 public:
  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response() : CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(nullptr) {}
  ~CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response() override;
  explicit constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from);
  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response&& from) noexcept
    : CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& operator=(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& operator=(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response*>(
               &_CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& a, CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response";
  }
  protected:
  explicit CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAgreementSessionUrlFieldNumber = 7,
  };
  // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
  bool has_agreement_session_url() const;
  private:
  bool _internal_has_agreement_session_url() const;
  public:
  void clear_agreement_session_url();
  const std::string& agreement_session_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_agreement_session_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_agreement_session_url();
  PROTOBUF_NODISCARD std::string* release_agreement_session_url();
  void set_allocated_agreement_session_url(std::string* agreement_session_url);
  private:
  const std::string& _internal_agreement_session_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_agreement_session_url(const std::string& value);
  std::string* _internal_mutable_agreement_session_url();
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr agreement_session_url_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_AccessToken_GenerateForApp_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_AccessToken_GenerateForApp_Request) */ {
 public:
  inline CAuthentication_AccessToken_GenerateForApp_Request() : CAuthentication_AccessToken_GenerateForApp_Request(nullptr) {}
  ~CAuthentication_AccessToken_GenerateForApp_Request() override;
  explicit constexpr CAuthentication_AccessToken_GenerateForApp_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_AccessToken_GenerateForApp_Request(const CAuthentication_AccessToken_GenerateForApp_Request& from);
  CAuthentication_AccessToken_GenerateForApp_Request(CAuthentication_AccessToken_GenerateForApp_Request&& from) noexcept
    : CAuthentication_AccessToken_GenerateForApp_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_AccessToken_GenerateForApp_Request& operator=(const CAuthentication_AccessToken_GenerateForApp_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_AccessToken_GenerateForApp_Request& operator=(CAuthentication_AccessToken_GenerateForApp_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_AccessToken_GenerateForApp_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_AccessToken_GenerateForApp_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_AccessToken_GenerateForApp_Request*>(
               &_CAuthentication_AccessToken_GenerateForApp_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CAuthentication_AccessToken_GenerateForApp_Request& a, CAuthentication_AccessToken_GenerateForApp_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_AccessToken_GenerateForApp_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_AccessToken_GenerateForApp_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_AccessToken_GenerateForApp_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_AccessToken_GenerateForApp_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_AccessToken_GenerateForApp_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_AccessToken_GenerateForApp_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_AccessToken_GenerateForApp_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_AccessToken_GenerateForApp_Request";
  }
  protected:
  explicit CAuthentication_AccessToken_GenerateForApp_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokenFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kRenewalTypeFieldNumber = 3,
  };
  // optional string refresh_token = 1;
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // optional fixed64 steamid = 2;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional .ETokenRenewalType renewal_type = 3 [default = k_ETokenRenewalType_None];
  bool has_renewal_type() const;
  private:
  bool _internal_has_renewal_type() const;
  public:
  void clear_renewal_type();
  ::ETokenRenewalType renewal_type() const;
  void set_renewal_type(::ETokenRenewalType value);
  private:
  ::ETokenRenewalType _internal_renewal_type() const;
  void _internal_set_renewal_type(::ETokenRenewalType value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_AccessToken_GenerateForApp_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
  uint64_t steamid_;
  int renewal_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_AccessToken_GenerateForApp_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_AccessToken_GenerateForApp_Response) */ {
 public:
  inline CAuthentication_AccessToken_GenerateForApp_Response() : CAuthentication_AccessToken_GenerateForApp_Response(nullptr) {}
  ~CAuthentication_AccessToken_GenerateForApp_Response() override;
  explicit constexpr CAuthentication_AccessToken_GenerateForApp_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_AccessToken_GenerateForApp_Response(const CAuthentication_AccessToken_GenerateForApp_Response& from);
  CAuthentication_AccessToken_GenerateForApp_Response(CAuthentication_AccessToken_GenerateForApp_Response&& from) noexcept
    : CAuthentication_AccessToken_GenerateForApp_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_AccessToken_GenerateForApp_Response& operator=(const CAuthentication_AccessToken_GenerateForApp_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_AccessToken_GenerateForApp_Response& operator=(CAuthentication_AccessToken_GenerateForApp_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_AccessToken_GenerateForApp_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_AccessToken_GenerateForApp_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_AccessToken_GenerateForApp_Response*>(
               &_CAuthentication_AccessToken_GenerateForApp_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CAuthentication_AccessToken_GenerateForApp_Response& a, CAuthentication_AccessToken_GenerateForApp_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_AccessToken_GenerateForApp_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_AccessToken_GenerateForApp_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_AccessToken_GenerateForApp_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_AccessToken_GenerateForApp_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_AccessToken_GenerateForApp_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_AccessToken_GenerateForApp_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_AccessToken_GenerateForApp_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_AccessToken_GenerateForApp_Response";
  }
  protected:
  explicit CAuthentication_AccessToken_GenerateForApp_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccessTokenFieldNumber = 1,
    kRefreshTokenFieldNumber = 2,
  };
  // optional string access_token = 1;
  bool has_access_token() const;
  private:
  bool _internal_has_access_token() const;
  public:
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // optional string refresh_token = 2;
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_AccessToken_GenerateForApp_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Enumerate_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Enumerate_Request) */ {
 public:
  inline CAuthentication_RefreshToken_Enumerate_Request() : CAuthentication_RefreshToken_Enumerate_Request(nullptr) {}
  explicit constexpr CAuthentication_RefreshToken_Enumerate_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Enumerate_Request(const CAuthentication_RefreshToken_Enumerate_Request& from);
  CAuthentication_RefreshToken_Enumerate_Request(CAuthentication_RefreshToken_Enumerate_Request&& from) noexcept
    : CAuthentication_RefreshToken_Enumerate_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Enumerate_Request& operator=(const CAuthentication_RefreshToken_Enumerate_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Enumerate_Request& operator=(CAuthentication_RefreshToken_Enumerate_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Enumerate_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Enumerate_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Enumerate_Request*>(
               &_CAuthentication_RefreshToken_Enumerate_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CAuthentication_RefreshToken_Enumerate_Request& a, CAuthentication_RefreshToken_Enumerate_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Enumerate_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Enumerate_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Enumerate_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Enumerate_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthentication_RefreshToken_Enumerate_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Enumerate_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Enumerate_Request";
  }
  protected:
  explicit CAuthentication_RefreshToken_Enumerate_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Enumerate_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent) */ {
 public:
  inline CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent() : CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(nullptr) {}
  ~CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent() override;
  explicit constexpr CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from);
  CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&& from) noexcept
    : CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& operator=(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& operator=(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent*>(
               &_CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& a, CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent";
  }
  protected:
  explicit CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLocaleFieldNumber = 3,
    kCountryFieldNumber = 4,
    kStateFieldNumber = 5,
    kCityFieldNumber = 6,
    kIpFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // optional string locale = 3;
  bool has_locale() const;
  private:
  bool _internal_has_locale() const;
  public:
  void clear_locale();
  const std::string& locale() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locale(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locale();
  PROTOBUF_NODISCARD std::string* release_locale();
  void set_allocated_locale(std::string* locale);
  private:
  const std::string& _internal_locale() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locale(const std::string& value);
  std::string* _internal_mutable_locale();
  public:

  // optional string country = 4 [(.description) = "Location (country code) of event, as inferred from IP"];
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string state = 5 [(.description) = "Location (state code) of event, as inferred from IP"];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string city = 6 [(.description) = "Location (city) of event, as inferred from IP"];
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::CMsgIPAddress& ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_ip();
  ::CMsgIPAddress* mutable_ip();
  void set_allocated_ip(::CMsgIPAddress* ip);
  private:
  const ::CMsgIPAddress& _internal_ip() const;
  ::CMsgIPAddress* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::CMsgIPAddress* ip);
  ::CMsgIPAddress* unsafe_arena_release_ip();

  // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locale_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::CMsgIPAddress* ip_;
  uint32_t time_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription) */ {
 public:
  inline CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription() : CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(nullptr) {}
  ~CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription() override;
  explicit constexpr CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from);
  CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription&& from) noexcept
    : CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& operator=(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& operator=(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription*>(
               &_CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& a, CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription";
  }
  protected:
  explicit CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenDescriptionFieldNumber = 2,
    kFirstSeenFieldNumber = 9,
    kLastSeenFieldNumber = 10,
    kTokenIdFieldNumber = 1,
    kTimeUpdatedFieldNumber = 3,
    kPlatformTypeFieldNumber = 4,
    kLoggedInFieldNumber = 5,
    kOsPlatformFieldNumber = 6,
    kAuthTypeFieldNumber = 7,
    kGamingDeviceTypeFieldNumber = 8,
    kOsTypeFieldNumber = 11,
  };
  // optional string token_description = 2 [(.description) = "client-supplied friendly name for the device"];
  bool has_token_description() const;
  private:
  bool _internal_has_token_description() const;
  public:
  void clear_token_description();
  const std::string& token_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_description();
  PROTOBUF_NODISCARD std::string* release_token_description();
  void set_allocated_token_description(std::string* token_description);
  private:
  const std::string& _internal_token_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_description(const std::string& value);
  std::string* _internal_mutable_token_description();
  public:

  // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent first_seen = 9 [(.description) = "Information about original authorization event"];
  bool has_first_seen() const;
  private:
  bool _internal_has_first_seen() const;
  public:
  void clear_first_seen();
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& first_seen() const;
  PROTOBUF_NODISCARD ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* release_first_seen();
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* mutable_first_seen();
  void set_allocated_first_seen(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* first_seen);
  private:
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& _internal_first_seen() const;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* _internal_mutable_first_seen();
  public:
  void unsafe_arena_set_allocated_first_seen(
      ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* first_seen);
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* unsafe_arena_release_first_seen();

  // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent last_seen = 10 [(.description) = "Information about most-recently seen, if known for this device"];
  bool has_last_seen() const;
  private:
  bool _internal_has_last_seen() const;
  public:
  void clear_last_seen();
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& last_seen() const;
  PROTOBUF_NODISCARD ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* release_last_seen();
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* mutable_last_seen();
  void set_allocated_last_seen(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* last_seen);
  private:
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& _internal_last_seen() const;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* _internal_mutable_last_seen();
  public:
  void unsafe_arena_set_allocated_last_seen(
      ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* last_seen);
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* unsafe_arena_release_last_seen();

  // optional fixed64 token_id = 1 [(.description) = "Persistent token/device identifier"];
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // optional uint32 time_updated = 3;
  bool has_time_updated() const;
  private:
  bool _internal_has_time_updated() const;
  public:
  void clear_time_updated();
  uint32_t time_updated() const;
  void set_time_updated(uint32_t value);
  private:
  uint32_t _internal_time_updated() const;
  void _internal_set_time_updated(uint32_t value);
  public:

  // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "gross platform type (mobile/client/browser)"];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // optional bool logged_in = 5 [(.description) = "If true, this token is currently valid. False indicates it is a machine token - ok for steamguard if you know the credential"];
  bool has_logged_in() const;
  private:
  bool _internal_has_logged_in() const;
  public:
  void clear_logged_in();
  bool logged_in() const;
  void set_logged_in(bool value);
  private:
  bool _internal_logged_in() const;
  void _internal_set_logged_in(bool value);
  public:

  // optional uint32 os_platform = 6 [(.description) = "EPlatformType - rough classification of device OS, if known"];
  bool has_os_platform() const;
  private:
  bool _internal_has_os_platform() const;
  public:
  void clear_os_platform();
  uint32_t os_platform() const;
  void set_os_platform(uint32_t value);
  private:
  uint32_t _internal_os_platform() const;
  void _internal_set_os_platform(uint32_t value);
  public:

  // optional uint32 auth_type = 7 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
  bool has_auth_type() const;
  private:
  bool _internal_has_auth_type() const;
  public:
  void clear_auth_type();
  uint32_t auth_type() const;
  void set_auth_type(uint32_t value);
  private:
  uint32_t _internal_auth_type() const;
  void _internal_set_auth_type(uint32_t value);
  public:

  // optional uint32 gaming_device_type = 8 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
  bool has_gaming_device_type() const;
  private:
  bool _internal_has_gaming_device_type() const;
  public:
  void clear_gaming_device_type();
  uint32_t gaming_device_type() const;
  void set_gaming_device_type(uint32_t value);
  private:
  uint32_t _internal_gaming_device_type() const;
  void _internal_set_gaming_device_type(uint32_t value);
  public:

  // optional int32 os_type = 11 [(.description) = "EOSType - specific device OS, if known"];
  bool has_os_type() const;
  private:
  bool _internal_has_os_type() const;
  public:
  void clear_os_type();
  int32_t os_type() const;
  void set_os_type(int32_t value);
  private:
  int32_t _internal_os_type() const;
  void _internal_set_os_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_description_;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* first_seen_;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* last_seen_;
  uint64_t token_id_;
  uint32_t time_updated_;
  int platform_type_;
  bool logged_in_;
  uint32_t os_platform_;
  uint32_t auth_type_;
  uint32_t gaming_device_type_;
  int32_t os_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Enumerate_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Enumerate_Response) */ {
 public:
  inline CAuthentication_RefreshToken_Enumerate_Response() : CAuthentication_RefreshToken_Enumerate_Response(nullptr) {}
  ~CAuthentication_RefreshToken_Enumerate_Response() override;
  explicit constexpr CAuthentication_RefreshToken_Enumerate_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Enumerate_Response(const CAuthentication_RefreshToken_Enumerate_Response& from);
  CAuthentication_RefreshToken_Enumerate_Response(CAuthentication_RefreshToken_Enumerate_Response&& from) noexcept
    : CAuthentication_RefreshToken_Enumerate_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Enumerate_Response& operator=(const CAuthentication_RefreshToken_Enumerate_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Enumerate_Response& operator=(CAuthentication_RefreshToken_Enumerate_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Enumerate_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Enumerate_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Enumerate_Response*>(
               &_CAuthentication_RefreshToken_Enumerate_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CAuthentication_RefreshToken_Enumerate_Response& a, CAuthentication_RefreshToken_Enumerate_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Enumerate_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Enumerate_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Enumerate_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Enumerate_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_RefreshToken_Enumerate_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Enumerate_Response";
  }
  protected:
  explicit CAuthentication_RefreshToken_Enumerate_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent TokenUsageEvent;
  typedef CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription RefreshTokenDescription;

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokensFieldNumber = 1,
    kRequestingTokenFieldNumber = 2,
  };
  // repeated .CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription refresh_tokens = 1;
  int refresh_tokens_size() const;
  private:
  int _internal_refresh_tokens_size() const;
  public:
  void clear_refresh_tokens();
  ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* mutable_refresh_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >*
      mutable_refresh_tokens();
  private:
  const ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& _internal_refresh_tokens(int index) const;
  ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* _internal_add_refresh_tokens();
  public:
  const ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& refresh_tokens(int index) const;
  ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* add_refresh_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >&
      refresh_tokens() const;

  // optional fixed64 requesting_token = 2;
  bool has_requesting_token() const;
  private:
  bool _internal_has_requesting_token() const;
  public:
  void clear_requesting_token();
  uint64_t requesting_token() const;
  void set_requesting_token(uint64_t value);
  private:
  uint64_t _internal_requesting_token() const;
  void _internal_set_requesting_token(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Enumerate_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription > refresh_tokens_;
  uint64_t requesting_token_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_GetAuthSessionsForAccount_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthentication_GetAuthSessionsForAccount_Request) */ {
 public:
  inline CAuthentication_GetAuthSessionsForAccount_Request() : CAuthentication_GetAuthSessionsForAccount_Request(nullptr) {}
  explicit constexpr CAuthentication_GetAuthSessionsForAccount_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetAuthSessionsForAccount_Request(const CAuthentication_GetAuthSessionsForAccount_Request& from);
  CAuthentication_GetAuthSessionsForAccount_Request(CAuthentication_GetAuthSessionsForAccount_Request&& from) noexcept
    : CAuthentication_GetAuthSessionsForAccount_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetAuthSessionsForAccount_Request& operator=(const CAuthentication_GetAuthSessionsForAccount_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetAuthSessionsForAccount_Request& operator=(CAuthentication_GetAuthSessionsForAccount_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetAuthSessionsForAccount_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetAuthSessionsForAccount_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetAuthSessionsForAccount_Request*>(
               &_CAuthentication_GetAuthSessionsForAccount_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CAuthentication_GetAuthSessionsForAccount_Request& a, CAuthentication_GetAuthSessionsForAccount_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetAuthSessionsForAccount_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetAuthSessionsForAccount_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetAuthSessionsForAccount_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetAuthSessionsForAccount_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthentication_GetAuthSessionsForAccount_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthentication_GetAuthSessionsForAccount_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetAuthSessionsForAccount_Request";
  }
  protected:
  explicit CAuthentication_GetAuthSessionsForAccount_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthentication_GetAuthSessionsForAccount_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_GetAuthSessionsForAccount_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_GetAuthSessionsForAccount_Response) */ {
 public:
  inline CAuthentication_GetAuthSessionsForAccount_Response() : CAuthentication_GetAuthSessionsForAccount_Response(nullptr) {}
  ~CAuthentication_GetAuthSessionsForAccount_Response() override;
  explicit constexpr CAuthentication_GetAuthSessionsForAccount_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_GetAuthSessionsForAccount_Response(const CAuthentication_GetAuthSessionsForAccount_Response& from);
  CAuthentication_GetAuthSessionsForAccount_Response(CAuthentication_GetAuthSessionsForAccount_Response&& from) noexcept
    : CAuthentication_GetAuthSessionsForAccount_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_GetAuthSessionsForAccount_Response& operator=(const CAuthentication_GetAuthSessionsForAccount_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_GetAuthSessionsForAccount_Response& operator=(CAuthentication_GetAuthSessionsForAccount_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_GetAuthSessionsForAccount_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_GetAuthSessionsForAccount_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_GetAuthSessionsForAccount_Response*>(
               &_CAuthentication_GetAuthSessionsForAccount_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CAuthentication_GetAuthSessionsForAccount_Response& a, CAuthentication_GetAuthSessionsForAccount_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_GetAuthSessionsForAccount_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_GetAuthSessionsForAccount_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_GetAuthSessionsForAccount_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_GetAuthSessionsForAccount_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_GetAuthSessionsForAccount_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_GetAuthSessionsForAccount_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_GetAuthSessionsForAccount_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_GetAuthSessionsForAccount_Response";
  }
  protected:
  explicit CAuthentication_GetAuthSessionsForAccount_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 1,
  };
  // repeated uint64 client_ids = 1 [(.description) = "unique identifier of requestor, also used for routing"];
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;
  public:
  void clear_client_ids();
  private:
  uint64_t _internal_client_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_client_ids() const;
  void _internal_add_client_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_client_ids();
  public:
  uint64_t client_ids(int index) const;
  void set_client_ids(int index, uint64_t value);
  void add_client_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      client_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_client_ids();

  // @@protoc_insertion_point(class_scope:CAuthentication_GetAuthSessionsForAccount_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > client_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_MigrateMobileSession_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_MigrateMobileSession_Request) */ {
 public:
  inline CAuthentication_MigrateMobileSession_Request() : CAuthentication_MigrateMobileSession_Request(nullptr) {}
  ~CAuthentication_MigrateMobileSession_Request() override;
  explicit constexpr CAuthentication_MigrateMobileSession_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_MigrateMobileSession_Request(const CAuthentication_MigrateMobileSession_Request& from);
  CAuthentication_MigrateMobileSession_Request(CAuthentication_MigrateMobileSession_Request&& from) noexcept
    : CAuthentication_MigrateMobileSession_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_MigrateMobileSession_Request& operator=(const CAuthentication_MigrateMobileSession_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_MigrateMobileSession_Request& operator=(CAuthentication_MigrateMobileSession_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_MigrateMobileSession_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_MigrateMobileSession_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_MigrateMobileSession_Request*>(
               &_CAuthentication_MigrateMobileSession_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CAuthentication_MigrateMobileSession_Request& a, CAuthentication_MigrateMobileSession_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_MigrateMobileSession_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_MigrateMobileSession_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_MigrateMobileSession_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_MigrateMobileSession_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_MigrateMobileSession_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_MigrateMobileSession_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_MigrateMobileSession_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_MigrateMobileSession_Request";
  }
  protected:
  explicit CAuthentication_MigrateMobileSession_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 2,
    kSignatureFieldNumber = 3,
    kSteamidFieldNumber = 1,
  };
  // optional string token = 2 [(.description) = "WG Token to migrate"];
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional string signature = 3 [(.description) = "Signature over the wg token using the user\'s 2FA token"];
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional fixed64 steamid = 1 [(.description) = "Steam ID of the user to migrate"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_MigrateMobileSession_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_MigrateMobileSession_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_MigrateMobileSession_Response) */ {
 public:
  inline CAuthentication_MigrateMobileSession_Response() : CAuthentication_MigrateMobileSession_Response(nullptr) {}
  ~CAuthentication_MigrateMobileSession_Response() override;
  explicit constexpr CAuthentication_MigrateMobileSession_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_MigrateMobileSession_Response(const CAuthentication_MigrateMobileSession_Response& from);
  CAuthentication_MigrateMobileSession_Response(CAuthentication_MigrateMobileSession_Response&& from) noexcept
    : CAuthentication_MigrateMobileSession_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_MigrateMobileSession_Response& operator=(const CAuthentication_MigrateMobileSession_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_MigrateMobileSession_Response& operator=(CAuthentication_MigrateMobileSession_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_MigrateMobileSession_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_MigrateMobileSession_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_MigrateMobileSession_Response*>(
               &_CAuthentication_MigrateMobileSession_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CAuthentication_MigrateMobileSession_Response& a, CAuthentication_MigrateMobileSession_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_MigrateMobileSession_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_MigrateMobileSession_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_MigrateMobileSession_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_MigrateMobileSession_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_MigrateMobileSession_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_MigrateMobileSession_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_MigrateMobileSession_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_MigrateMobileSession_Response";
  }
  protected:
  explicit CAuthentication_MigrateMobileSession_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokenFieldNumber = 1,
    kAccessTokenFieldNumber = 2,
  };
  // optional string refresh_token = 1;
  bool has_refresh_token() const;
  private:
  bool _internal_has_refresh_token() const;
  public:
  void clear_refresh_token();
  const std::string& refresh_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_refresh_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_refresh_token();
  PROTOBUF_NODISCARD std::string* release_refresh_token();
  void set_allocated_refresh_token(std::string* refresh_token);
  private:
  const std::string& _internal_refresh_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_refresh_token(const std::string& value);
  std::string* _internal_mutable_refresh_token();
  public:

  // optional string access_token = 2;
  bool has_access_token() const;
  private:
  bool _internal_has_access_token() const;
  public:
  void clear_access_token();
  const std::string& access_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_access_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_access_token();
  PROTOBUF_NODISCARD std::string* release_access_token();
  void set_allocated_access_token(std::string* access_token);
  private:
  const std::string& _internal_access_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_access_token(const std::string& value);
  std::string* _internal_mutable_access_token();
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_MigrateMobileSession_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr refresh_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr access_token_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_Token_Revoke_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_Token_Revoke_Request) */ {
 public:
  inline CAuthentication_Token_Revoke_Request() : CAuthentication_Token_Revoke_Request(nullptr) {}
  ~CAuthentication_Token_Revoke_Request() override;
  explicit constexpr CAuthentication_Token_Revoke_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_Token_Revoke_Request(const CAuthentication_Token_Revoke_Request& from);
  CAuthentication_Token_Revoke_Request(CAuthentication_Token_Revoke_Request&& from) noexcept
    : CAuthentication_Token_Revoke_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_Token_Revoke_Request& operator=(const CAuthentication_Token_Revoke_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_Token_Revoke_Request& operator=(CAuthentication_Token_Revoke_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_Token_Revoke_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_Token_Revoke_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_Token_Revoke_Request*>(
               &_CAuthentication_Token_Revoke_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CAuthentication_Token_Revoke_Request& a, CAuthentication_Token_Revoke_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_Token_Revoke_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_Token_Revoke_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_Token_Revoke_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_Token_Revoke_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_Token_Revoke_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_Token_Revoke_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_Token_Revoke_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_Token_Revoke_Request";
  }
  protected:
  explicit CAuthentication_Token_Revoke_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kRevokeActionFieldNumber = 2,
  };
  // optional string token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional .EAuthTokenRevokeAction revoke_action = 2 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
  bool has_revoke_action() const;
  private:
  bool _internal_has_revoke_action() const;
  public:
  void clear_revoke_action();
  ::EAuthTokenRevokeAction revoke_action() const;
  void set_revoke_action(::EAuthTokenRevokeAction value);
  private:
  ::EAuthTokenRevokeAction _internal_revoke_action() const;
  void _internal_set_revoke_action(::EAuthTokenRevokeAction value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_Token_Revoke_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  int revoke_action_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_Token_Revoke_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthentication_Token_Revoke_Response) */ {
 public:
  inline CAuthentication_Token_Revoke_Response() : CAuthentication_Token_Revoke_Response(nullptr) {}
  explicit constexpr CAuthentication_Token_Revoke_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_Token_Revoke_Response(const CAuthentication_Token_Revoke_Response& from);
  CAuthentication_Token_Revoke_Response(CAuthentication_Token_Revoke_Response&& from) noexcept
    : CAuthentication_Token_Revoke_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_Token_Revoke_Response& operator=(const CAuthentication_Token_Revoke_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_Token_Revoke_Response& operator=(CAuthentication_Token_Revoke_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_Token_Revoke_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_Token_Revoke_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_Token_Revoke_Response*>(
               &_CAuthentication_Token_Revoke_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CAuthentication_Token_Revoke_Response& a, CAuthentication_Token_Revoke_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_Token_Revoke_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_Token_Revoke_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_Token_Revoke_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_Token_Revoke_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthentication_Token_Revoke_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthentication_Token_Revoke_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_Token_Revoke_Response";
  }
  protected:
  explicit CAuthentication_Token_Revoke_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthentication_Token_Revoke_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Revoke_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Revoke_Request) */ {
 public:
  inline CAuthentication_RefreshToken_Revoke_Request() : CAuthentication_RefreshToken_Revoke_Request(nullptr) {}
  ~CAuthentication_RefreshToken_Revoke_Request() override;
  explicit constexpr CAuthentication_RefreshToken_Revoke_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Revoke_Request(const CAuthentication_RefreshToken_Revoke_Request& from);
  CAuthentication_RefreshToken_Revoke_Request(CAuthentication_RefreshToken_Revoke_Request&& from) noexcept
    : CAuthentication_RefreshToken_Revoke_Request() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Revoke_Request& operator=(const CAuthentication_RefreshToken_Revoke_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Revoke_Request& operator=(CAuthentication_RefreshToken_Revoke_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Revoke_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Revoke_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Revoke_Request*>(
               &_CAuthentication_RefreshToken_Revoke_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CAuthentication_RefreshToken_Revoke_Request& a, CAuthentication_RefreshToken_Revoke_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Revoke_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Revoke_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Revoke_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Revoke_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthentication_RefreshToken_Revoke_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Revoke_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthentication_RefreshToken_Revoke_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Revoke_Request";
  }
  protected:
  explicit CAuthentication_RefreshToken_Revoke_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignatureFieldNumber = 4,
    kTokenIdFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kRevokeActionFieldNumber = 3,
  };
  // optional bytes signature = 4 [(.description) = "required signature over token_id"];
  bool has_signature() const;
  private:
  bool _internal_has_signature() const;
  public:
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_NODISCARD std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // optional fixed64 token_id = 1;
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // optional fixed64 steamid = 2 [(.description) = "Token holder if an admin action on behalf of another user"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional .EAuthTokenRevokeAction revoke_action = 3 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
  bool has_revoke_action() const;
  private:
  bool _internal_has_revoke_action() const;
  public:
  void clear_revoke_action();
  ::EAuthTokenRevokeAction revoke_action() const;
  void set_revoke_action(::EAuthTokenRevokeAction value);
  private:
  ::EAuthTokenRevokeAction _internal_revoke_action() const;
  void _internal_set_revoke_action(::EAuthTokenRevokeAction value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Revoke_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  uint64_t token_id_;
  uint64_t steamid_;
  int revoke_action_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthentication_RefreshToken_Revoke_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthentication_RefreshToken_Revoke_Response) */ {
 public:
  inline CAuthentication_RefreshToken_Revoke_Response() : CAuthentication_RefreshToken_Revoke_Response(nullptr) {}
  explicit constexpr CAuthentication_RefreshToken_Revoke_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthentication_RefreshToken_Revoke_Response(const CAuthentication_RefreshToken_Revoke_Response& from);
  CAuthentication_RefreshToken_Revoke_Response(CAuthentication_RefreshToken_Revoke_Response&& from) noexcept
    : CAuthentication_RefreshToken_Revoke_Response() {
    *this = ::std::move(from);
  }

  inline CAuthentication_RefreshToken_Revoke_Response& operator=(const CAuthentication_RefreshToken_Revoke_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthentication_RefreshToken_Revoke_Response& operator=(CAuthentication_RefreshToken_Revoke_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthentication_RefreshToken_Revoke_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthentication_RefreshToken_Revoke_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthentication_RefreshToken_Revoke_Response*>(
               &_CAuthentication_RefreshToken_Revoke_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CAuthentication_RefreshToken_Revoke_Response& a, CAuthentication_RefreshToken_Revoke_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthentication_RefreshToken_Revoke_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthentication_RefreshToken_Revoke_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthentication_RefreshToken_Revoke_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthentication_RefreshToken_Revoke_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthentication_RefreshToken_Revoke_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthentication_RefreshToken_Revoke_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthentication_RefreshToken_Revoke_Response";
  }
  protected:
  explicit CAuthentication_RefreshToken_Revoke_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthentication_RefreshToken_Revoke_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_QueryRefreshTokensByAccount_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_QueryRefreshTokensByAccount_Request) */ {
 public:
  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Request() : CAuthenticationSupport_QueryRefreshTokensByAccount_Request(nullptr) {}
  ~CAuthenticationSupport_QueryRefreshTokensByAccount_Request() override;
  explicit constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_QueryRefreshTokensByAccount_Request(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from);
  CAuthenticationSupport_QueryRefreshTokensByAccount_Request(CAuthenticationSupport_QueryRefreshTokensByAccount_Request&& from) noexcept
    : CAuthenticationSupport_QueryRefreshTokensByAccount_Request() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Request& operator=(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Request& operator=(CAuthenticationSupport_QueryRefreshTokensByAccount_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_QueryRefreshTokensByAccount_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_QueryRefreshTokensByAccount_Request*>(
               &_CAuthenticationSupport_QueryRefreshTokensByAccount_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CAuthenticationSupport_QueryRefreshTokensByAccount_Request& a, CAuthenticationSupport_QueryRefreshTokensByAccount_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_QueryRefreshTokensByAccount_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_QueryRefreshTokensByAccount_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_QueryRefreshTokensByAccount_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_QueryRefreshTokensByAccount_Request";
  }
  protected:
  explicit CAuthenticationSupport_QueryRefreshTokensByAccount_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
    kIncludeRevokedTokensFieldNumber = 2,
  };
  // optional fixed64 steamid = 1 [(.description) = "SteamID of the account to query (required)"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional bool include_revoked_tokens = 2 [(.description) = "Includes tokens that are revoked or expired in the query"];
  bool has_include_revoked_tokens() const;
  private:
  bool _internal_has_include_revoked_tokens() const;
  public:
  void clear_include_revoked_tokens();
  bool include_revoked_tokens() const;
  void set_include_revoked_tokens(bool value);
  private:
  bool _internal_include_revoked_tokens() const;
  void _internal_set_include_revoked_tokens(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steamid_;
  bool include_revoked_tokens_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSupportRefreshTokenDescription_TokenUsageEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSupportRefreshTokenDescription.TokenUsageEvent) */ {
 public:
  inline CSupportRefreshTokenDescription_TokenUsageEvent() : CSupportRefreshTokenDescription_TokenUsageEvent(nullptr) {}
  ~CSupportRefreshTokenDescription_TokenUsageEvent() override;
  explicit constexpr CSupportRefreshTokenDescription_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSupportRefreshTokenDescription_TokenUsageEvent(const CSupportRefreshTokenDescription_TokenUsageEvent& from);
  CSupportRefreshTokenDescription_TokenUsageEvent(CSupportRefreshTokenDescription_TokenUsageEvent&& from) noexcept
    : CSupportRefreshTokenDescription_TokenUsageEvent() {
    *this = ::std::move(from);
  }

  inline CSupportRefreshTokenDescription_TokenUsageEvent& operator=(const CSupportRefreshTokenDescription_TokenUsageEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSupportRefreshTokenDescription_TokenUsageEvent& operator=(CSupportRefreshTokenDescription_TokenUsageEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSupportRefreshTokenDescription_TokenUsageEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSupportRefreshTokenDescription_TokenUsageEvent* internal_default_instance() {
    return reinterpret_cast<const CSupportRefreshTokenDescription_TokenUsageEvent*>(
               &_CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CSupportRefreshTokenDescription_TokenUsageEvent& a, CSupportRefreshTokenDescription_TokenUsageEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CSupportRefreshTokenDescription_TokenUsageEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSupportRefreshTokenDescription_TokenUsageEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSupportRefreshTokenDescription_TokenUsageEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSupportRefreshTokenDescription_TokenUsageEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSupportRefreshTokenDescription_TokenUsageEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSupportRefreshTokenDescription_TokenUsageEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSupportRefreshTokenDescription_TokenUsageEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSupportRefreshTokenDescription.TokenUsageEvent";
  }
  protected:
  explicit CSupportRefreshTokenDescription_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountryFieldNumber = 3,
    kStateFieldNumber = 4,
    kCityFieldNumber = 5,
    kIpFieldNumber = 2,
    kTimeFieldNumber = 1,
  };
  // optional string country = 3 [(.description) = "Location (country code) of event, as inferred from IP"];
  bool has_country() const;
  private:
  bool _internal_has_country() const;
  public:
  void clear_country();
  const std::string& country() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country();
  PROTOBUF_NODISCARD std::string* release_country();
  void set_allocated_country(std::string* country);
  private:
  const std::string& _internal_country() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country(const std::string& value);
  std::string* _internal_mutable_country();
  public:

  // optional string state = 4 [(.description) = "Location (state code) of event, as inferred from IP"];
  bool has_state() const;
  private:
  bool _internal_has_state() const;
  public:
  void clear_state();
  const std::string& state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_state();
  PROTOBUF_NODISCARD std::string* release_state();
  void set_allocated_state(std::string* state);
  private:
  const std::string& _internal_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_state(const std::string& value);
  std::string* _internal_mutable_state();
  public:

  // optional string city = 5 [(.description) = "Location (city) of event, as inferred from IP"];
  bool has_city() const;
  private:
  bool _internal_has_city() const;
  public:
  void clear_city();
  const std::string& city() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_city(ArgT0&& arg0, ArgT... args);
  std::string* mutable_city();
  PROTOBUF_NODISCARD std::string* release_city();
  void set_allocated_city(std::string* city);
  private:
  const std::string& _internal_city() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_city(const std::string& value);
  std::string* _internal_mutable_city();
  public:

  // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::CMsgIPAddress& ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_ip();
  ::CMsgIPAddress* mutable_ip();
  void set_allocated_ip(::CMsgIPAddress* ip);
  private:
  const ::CMsgIPAddress& _internal_ip() const;
  ::CMsgIPAddress* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::CMsgIPAddress* ip);
  ::CMsgIPAddress* unsafe_arena_release_ip();

  // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSupportRefreshTokenDescription.TokenUsageEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr city_;
  ::CMsgIPAddress* ip_;
  uint32_t time_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSupportRefreshTokenDescription final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSupportRefreshTokenDescription) */ {
 public:
  inline CSupportRefreshTokenDescription() : CSupportRefreshTokenDescription(nullptr) {}
  ~CSupportRefreshTokenDescription() override;
  explicit constexpr CSupportRefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSupportRefreshTokenDescription(const CSupportRefreshTokenDescription& from);
  CSupportRefreshTokenDescription(CSupportRefreshTokenDescription&& from) noexcept
    : CSupportRefreshTokenDescription() {
    *this = ::std::move(from);
  }

  inline CSupportRefreshTokenDescription& operator=(const CSupportRefreshTokenDescription& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSupportRefreshTokenDescription& operator=(CSupportRefreshTokenDescription&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSupportRefreshTokenDescription& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSupportRefreshTokenDescription* internal_default_instance() {
    return reinterpret_cast<const CSupportRefreshTokenDescription*>(
               &_CSupportRefreshTokenDescription_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CSupportRefreshTokenDescription& a, CSupportRefreshTokenDescription& b) {
    a.Swap(&b);
  }
  inline void Swap(CSupportRefreshTokenDescription* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSupportRefreshTokenDescription* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSupportRefreshTokenDescription* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSupportRefreshTokenDescription>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSupportRefreshTokenDescription& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSupportRefreshTokenDescription& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSupportRefreshTokenDescription* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSupportRefreshTokenDescription";
  }
  protected:
  explicit CSupportRefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSupportRefreshTokenDescription_TokenUsageEvent TokenUsageEvent;

  // accessors -------------------------------------------------------

  enum : int {
    kTokenDescriptionFieldNumber = 2,
    kFirstSeenFieldNumber = 11,
    kLastSeenFieldNumber = 12,
    kTokenIdFieldNumber = 1,
    kTimeUpdatedFieldNumber = 3,
    kPlatformTypeFieldNumber = 4,
    kOwnerSteamidFieldNumber = 6,
    kTokenStateFieldNumber = 5,
    kOsPlatformFieldNumber = 7,
    kOsTypeFieldNumber = 8,
    kAuthTypeFieldNumber = 9,
    kGamingDeviceTypeFieldNumber = 10,
  };
  // optional string token_description = 2;
  bool has_token_description() const;
  private:
  bool _internal_has_token_description() const;
  public:
  void clear_token_description();
  const std::string& token_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token_description();
  PROTOBUF_NODISCARD std::string* release_token_description();
  void set_allocated_token_description(std::string* token_description);
  private:
  const std::string& _internal_token_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token_description(const std::string& value);
  std::string* _internal_mutable_token_description();
  public:

  // optional .CSupportRefreshTokenDescription.TokenUsageEvent first_seen = 11 [(.description) = "Information about original authorization event"];
  bool has_first_seen() const;
  private:
  bool _internal_has_first_seen() const;
  public:
  void clear_first_seen();
  const ::CSupportRefreshTokenDescription_TokenUsageEvent& first_seen() const;
  PROTOBUF_NODISCARD ::CSupportRefreshTokenDescription_TokenUsageEvent* release_first_seen();
  ::CSupportRefreshTokenDescription_TokenUsageEvent* mutable_first_seen();
  void set_allocated_first_seen(::CSupportRefreshTokenDescription_TokenUsageEvent* first_seen);
  private:
  const ::CSupportRefreshTokenDescription_TokenUsageEvent& _internal_first_seen() const;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* _internal_mutable_first_seen();
  public:
  void unsafe_arena_set_allocated_first_seen(
      ::CSupportRefreshTokenDescription_TokenUsageEvent* first_seen);
  ::CSupportRefreshTokenDescription_TokenUsageEvent* unsafe_arena_release_first_seen();

  // optional .CSupportRefreshTokenDescription.TokenUsageEvent last_seen = 12 [(.description) = "Information about most-recently seen, if known for this device"];
  bool has_last_seen() const;
  private:
  bool _internal_has_last_seen() const;
  public:
  void clear_last_seen();
  const ::CSupportRefreshTokenDescription_TokenUsageEvent& last_seen() const;
  PROTOBUF_NODISCARD ::CSupportRefreshTokenDescription_TokenUsageEvent* release_last_seen();
  ::CSupportRefreshTokenDescription_TokenUsageEvent* mutable_last_seen();
  void set_allocated_last_seen(::CSupportRefreshTokenDescription_TokenUsageEvent* last_seen);
  private:
  const ::CSupportRefreshTokenDescription_TokenUsageEvent& _internal_last_seen() const;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* _internal_mutable_last_seen();
  public:
  void unsafe_arena_set_allocated_last_seen(
      ::CSupportRefreshTokenDescription_TokenUsageEvent* last_seen);
  ::CSupportRefreshTokenDescription_TokenUsageEvent* unsafe_arena_release_last_seen();

  // optional fixed64 token_id = 1;
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // optional uint32 time_updated = 3;
  bool has_time_updated() const;
  private:
  bool _internal_has_time_updated() const;
  public:
  void clear_time_updated();
  uint32_t time_updated() const;
  void set_time_updated(uint32_t value);
  private:
  uint32_t _internal_time_updated() const;
  void _internal_set_time_updated(uint32_t value);
  public:

  // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown];
  bool has_platform_type() const;
  private:
  bool _internal_has_platform_type() const;
  public:
  void clear_platform_type();
  ::EAuthTokenPlatformType platform_type() const;
  void set_platform_type(::EAuthTokenPlatformType value);
  private:
  ::EAuthTokenPlatformType _internal_platform_type() const;
  void _internal_set_platform_type(::EAuthTokenPlatformType value);
  public:

  // optional fixed64 owner_steamid = 6;
  bool has_owner_steamid() const;
  private:
  bool _internal_has_owner_steamid() const;
  public:
  void clear_owner_steamid();
  uint64_t owner_steamid() const;
  void set_owner_steamid(uint64_t value);
  private:
  uint64_t _internal_owner_steamid() const;
  void _internal_set_owner_steamid(uint64_t value);
  public:

  // optional .EAuthTokenState token_state = 5 [default = k_EAuthTokenState_Invalid];
  bool has_token_state() const;
  private:
  bool _internal_has_token_state() const;
  public:
  void clear_token_state();
  ::EAuthTokenState token_state() const;
  void set_token_state(::EAuthTokenState value);
  private:
  ::EAuthTokenState _internal_token_state() const;
  void _internal_set_token_state(::EAuthTokenState value);
  public:

  // optional uint32 os_platform = 7 [(.description) = "EPlatformType - rough classification of device OS, if known"];
  bool has_os_platform() const;
  private:
  bool _internal_has_os_platform() const;
  public:
  void clear_os_platform();
  uint32_t os_platform() const;
  void set_os_platform(uint32_t value);
  private:
  uint32_t _internal_os_platform() const;
  void _internal_set_os_platform(uint32_t value);
  public:

  // optional int32 os_type = 8 [(.description) = "EOSType - specific device OS, if known"];
  bool has_os_type() const;
  private:
  bool _internal_has_os_type() const;
  public:
  void clear_os_type();
  int32_t os_type() const;
  void set_os_type(int32_t value);
  private:
  int32_t _internal_os_type() const;
  void _internal_set_os_type(int32_t value);
  public:

  // optional uint32 auth_type = 9 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
  bool has_auth_type() const;
  private:
  bool _internal_has_auth_type() const;
  public:
  void clear_auth_type();
  uint32_t auth_type() const;
  void set_auth_type(uint32_t value);
  private:
  uint32_t _internal_auth_type() const;
  void _internal_set_auth_type(uint32_t value);
  public:

  // optional uint32 gaming_device_type = 10 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
  bool has_gaming_device_type() const;
  private:
  bool _internal_has_gaming_device_type() const;
  public:
  void clear_gaming_device_type();
  uint32_t gaming_device_type() const;
  void set_gaming_device_type(uint32_t value);
  private:
  uint32_t _internal_gaming_device_type() const;
  void _internal_set_gaming_device_type(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSupportRefreshTokenDescription)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_description_;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* first_seen_;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* last_seen_;
  uint64_t token_id_;
  uint32_t time_updated_;
  int platform_type_;
  uint64_t owner_steamid_;
  int token_state_;
  uint32_t os_platform_;
  int32_t os_type_;
  uint32_t auth_type_;
  uint32_t gaming_device_type_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_QueryRefreshTokensByAccount_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_QueryRefreshTokensByAccount_Response) */ {
 public:
  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Response() : CAuthenticationSupport_QueryRefreshTokensByAccount_Response(nullptr) {}
  ~CAuthenticationSupport_QueryRefreshTokensByAccount_Response() override;
  explicit constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_QueryRefreshTokensByAccount_Response(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from);
  CAuthenticationSupport_QueryRefreshTokensByAccount_Response(CAuthenticationSupport_QueryRefreshTokensByAccount_Response&& from) noexcept
    : CAuthenticationSupport_QueryRefreshTokensByAccount_Response() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Response& operator=(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_QueryRefreshTokensByAccount_Response& operator=(CAuthenticationSupport_QueryRefreshTokensByAccount_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_QueryRefreshTokensByAccount_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_QueryRefreshTokensByAccount_Response*>(
               &_CAuthenticationSupport_QueryRefreshTokensByAccount_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CAuthenticationSupport_QueryRefreshTokensByAccount_Response& a, CAuthenticationSupport_QueryRefreshTokensByAccount_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_QueryRefreshTokensByAccount_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_QueryRefreshTokensByAccount_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_QueryRefreshTokensByAccount_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_QueryRefreshTokensByAccount_Response";
  }
  protected:
  explicit CAuthenticationSupport_QueryRefreshTokensByAccount_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokensFieldNumber = 1,
    kLastTokenResetFieldNumber = 2,
  };
  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  int refresh_tokens_size() const;
  private:
  int _internal_refresh_tokens_size() const;
  public:
  void clear_refresh_tokens();
  ::CSupportRefreshTokenDescription* mutable_refresh_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >*
      mutable_refresh_tokens();
  private:
  const ::CSupportRefreshTokenDescription& _internal_refresh_tokens(int index) const;
  ::CSupportRefreshTokenDescription* _internal_add_refresh_tokens();
  public:
  const ::CSupportRefreshTokenDescription& refresh_tokens(int index) const;
  ::CSupportRefreshTokenDescription* add_refresh_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >&
      refresh_tokens() const;

  // optional int32 last_token_reset = 2;
  bool has_last_token_reset() const;
  private:
  bool _internal_has_last_token_reset() const;
  public:
  void clear_last_token_reset();
  int32_t last_token_reset() const;
  void set_last_token_reset(int32_t value);
  private:
  int32_t _internal_last_token_reset() const;
  void _internal_set_last_token_reset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription > refresh_tokens_;
  int32_t last_token_reset_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_QueryRefreshTokenByID_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_QueryRefreshTokenByID_Request) */ {
 public:
  inline CAuthenticationSupport_QueryRefreshTokenByID_Request() : CAuthenticationSupport_QueryRefreshTokenByID_Request(nullptr) {}
  ~CAuthenticationSupport_QueryRefreshTokenByID_Request() override;
  explicit constexpr CAuthenticationSupport_QueryRefreshTokenByID_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_QueryRefreshTokenByID_Request(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from);
  CAuthenticationSupport_QueryRefreshTokenByID_Request(CAuthenticationSupport_QueryRefreshTokenByID_Request&& from) noexcept
    : CAuthenticationSupport_QueryRefreshTokenByID_Request() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_QueryRefreshTokenByID_Request& operator=(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_QueryRefreshTokenByID_Request& operator=(CAuthenticationSupport_QueryRefreshTokenByID_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_QueryRefreshTokenByID_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_QueryRefreshTokenByID_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_QueryRefreshTokenByID_Request*>(
               &_CAuthenticationSupport_QueryRefreshTokenByID_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CAuthenticationSupport_QueryRefreshTokenByID_Request& a, CAuthenticationSupport_QueryRefreshTokenByID_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_QueryRefreshTokenByID_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_QueryRefreshTokenByID_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_QueryRefreshTokenByID_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_QueryRefreshTokenByID_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_QueryRefreshTokenByID_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_QueryRefreshTokenByID_Request";
  }
  protected:
  explicit CAuthenticationSupport_QueryRefreshTokenByID_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
  };
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to look up (required)"];
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_QueryRefreshTokenByID_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t token_id_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_QueryRefreshTokenByID_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_QueryRefreshTokenByID_Response) */ {
 public:
  inline CAuthenticationSupport_QueryRefreshTokenByID_Response() : CAuthenticationSupport_QueryRefreshTokenByID_Response(nullptr) {}
  ~CAuthenticationSupport_QueryRefreshTokenByID_Response() override;
  explicit constexpr CAuthenticationSupport_QueryRefreshTokenByID_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_QueryRefreshTokenByID_Response(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from);
  CAuthenticationSupport_QueryRefreshTokenByID_Response(CAuthenticationSupport_QueryRefreshTokenByID_Response&& from) noexcept
    : CAuthenticationSupport_QueryRefreshTokenByID_Response() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_QueryRefreshTokenByID_Response& operator=(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_QueryRefreshTokenByID_Response& operator=(CAuthenticationSupport_QueryRefreshTokenByID_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_QueryRefreshTokenByID_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_QueryRefreshTokenByID_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_QueryRefreshTokenByID_Response*>(
               &_CAuthenticationSupport_QueryRefreshTokenByID_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CAuthenticationSupport_QueryRefreshTokenByID_Response& a, CAuthenticationSupport_QueryRefreshTokenByID_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_QueryRefreshTokenByID_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_QueryRefreshTokenByID_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_QueryRefreshTokenByID_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_QueryRefreshTokenByID_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_QueryRefreshTokenByID_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_QueryRefreshTokenByID_Response";
  }
  protected:
  explicit CAuthenticationSupport_QueryRefreshTokenByID_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRefreshTokensFieldNumber = 1,
  };
  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  int refresh_tokens_size() const;
  private:
  int _internal_refresh_tokens_size() const;
  public:
  void clear_refresh_tokens();
  ::CSupportRefreshTokenDescription* mutable_refresh_tokens(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >*
      mutable_refresh_tokens();
  private:
  const ::CSupportRefreshTokenDescription& _internal_refresh_tokens(int index) const;
  ::CSupportRefreshTokenDescription* _internal_add_refresh_tokens();
  public:
  const ::CSupportRefreshTokenDescription& refresh_tokens(int index) const;
  ::CSupportRefreshTokenDescription* add_refresh_tokens();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >&
      refresh_tokens() const;

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_QueryRefreshTokenByID_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription > refresh_tokens_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_RevokeToken_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_RevokeToken_Request) */ {
 public:
  inline CAuthenticationSupport_RevokeToken_Request() : CAuthenticationSupport_RevokeToken_Request(nullptr) {}
  ~CAuthenticationSupport_RevokeToken_Request() override;
  explicit constexpr CAuthenticationSupport_RevokeToken_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_RevokeToken_Request(const CAuthenticationSupport_RevokeToken_Request& from);
  CAuthenticationSupport_RevokeToken_Request(CAuthenticationSupport_RevokeToken_Request&& from) noexcept
    : CAuthenticationSupport_RevokeToken_Request() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_RevokeToken_Request& operator=(const CAuthenticationSupport_RevokeToken_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_RevokeToken_Request& operator=(CAuthenticationSupport_RevokeToken_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_RevokeToken_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_RevokeToken_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_RevokeToken_Request*>(
               &_CAuthenticationSupport_RevokeToken_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CAuthenticationSupport_RevokeToken_Request& a, CAuthenticationSupport_RevokeToken_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_RevokeToken_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_RevokeToken_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_RevokeToken_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_RevokeToken_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_RevokeToken_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_RevokeToken_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_RevokeToken_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_RevokeToken_Request";
  }
  protected:
  explicit CAuthenticationSupport_RevokeToken_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
    kSteamidFieldNumber = 2,
  };
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to revoke (required)"];
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // optional fixed64 steamid = 2 [(.description) = "Steam ID of the owner of that token (required)"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_RevokeToken_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t token_id_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_RevokeToken_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_RevokeToken_Response) */ {
 public:
  inline CAuthenticationSupport_RevokeToken_Response() : CAuthenticationSupport_RevokeToken_Response(nullptr) {}
  explicit constexpr CAuthenticationSupport_RevokeToken_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_RevokeToken_Response(const CAuthenticationSupport_RevokeToken_Response& from);
  CAuthenticationSupport_RevokeToken_Response(CAuthenticationSupport_RevokeToken_Response&& from) noexcept
    : CAuthenticationSupport_RevokeToken_Response() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_RevokeToken_Response& operator=(const CAuthenticationSupport_RevokeToken_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_RevokeToken_Response& operator=(CAuthenticationSupport_RevokeToken_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_RevokeToken_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_RevokeToken_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_RevokeToken_Response*>(
               &_CAuthenticationSupport_RevokeToken_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CAuthenticationSupport_RevokeToken_Response& a, CAuthenticationSupport_RevokeToken_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_RevokeToken_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_RevokeToken_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_RevokeToken_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_RevokeToken_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CAuthenticationSupport_RevokeToken_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_RevokeToken_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_RevokeToken_Response";
  }
  protected:
  explicit CAuthenticationSupport_RevokeToken_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_RevokeToken_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_GetTokenHistory_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_GetTokenHistory_Request) */ {
 public:
  inline CAuthenticationSupport_GetTokenHistory_Request() : CAuthenticationSupport_GetTokenHistory_Request(nullptr) {}
  ~CAuthenticationSupport_GetTokenHistory_Request() override;
  explicit constexpr CAuthenticationSupport_GetTokenHistory_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_GetTokenHistory_Request(const CAuthenticationSupport_GetTokenHistory_Request& from);
  CAuthenticationSupport_GetTokenHistory_Request(CAuthenticationSupport_GetTokenHistory_Request&& from) noexcept
    : CAuthenticationSupport_GetTokenHistory_Request() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_GetTokenHistory_Request& operator=(const CAuthenticationSupport_GetTokenHistory_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_GetTokenHistory_Request& operator=(CAuthenticationSupport_GetTokenHistory_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_GetTokenHistory_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_GetTokenHistory_Request* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_GetTokenHistory_Request*>(
               &_CAuthenticationSupport_GetTokenHistory_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CAuthenticationSupport_GetTokenHistory_Request& a, CAuthenticationSupport_GetTokenHistory_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_GetTokenHistory_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_GetTokenHistory_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_GetTokenHistory_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_GetTokenHistory_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_GetTokenHistory_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_GetTokenHistory_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_GetTokenHistory_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_GetTokenHistory_Request";
  }
  protected:
  explicit CAuthenticationSupport_GetTokenHistory_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenIdFieldNumber = 1,
  };
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to get history for (required)"];
  bool has_token_id() const;
  private:
  bool _internal_has_token_id() const;
  public:
  void clear_token_id();
  uint64_t token_id() const;
  void set_token_id(uint64_t value);
  private:
  uint64_t _internal_token_id() const;
  void _internal_set_token_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_GetTokenHistory_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t token_id_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSupportRefreshTokenAudit final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSupportRefreshTokenAudit) */ {
 public:
  inline CSupportRefreshTokenAudit() : CSupportRefreshTokenAudit(nullptr) {}
  ~CSupportRefreshTokenAudit() override;
  explicit constexpr CSupportRefreshTokenAudit(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSupportRefreshTokenAudit(const CSupportRefreshTokenAudit& from);
  CSupportRefreshTokenAudit(CSupportRefreshTokenAudit&& from) noexcept
    : CSupportRefreshTokenAudit() {
    *this = ::std::move(from);
  }

  inline CSupportRefreshTokenAudit& operator=(const CSupportRefreshTokenAudit& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSupportRefreshTokenAudit& operator=(CSupportRefreshTokenAudit&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSupportRefreshTokenAudit& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSupportRefreshTokenAudit* internal_default_instance() {
    return reinterpret_cast<const CSupportRefreshTokenAudit*>(
               &_CSupportRefreshTokenAudit_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CSupportRefreshTokenAudit& a, CSupportRefreshTokenAudit& b) {
    a.Swap(&b);
  }
  inline void Swap(CSupportRefreshTokenAudit* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSupportRefreshTokenAudit* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSupportRefreshTokenAudit* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSupportRefreshTokenAudit>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSupportRefreshTokenAudit& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSupportRefreshTokenAudit& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSupportRefreshTokenAudit* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSupportRefreshTokenAudit";
  }
  protected:
  explicit CSupportRefreshTokenAudit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 3,
    kActionFieldNumber = 1,
    kTimeFieldNumber = 2,
    kActorFieldNumber = 4,
  };
  // optional .CMsgIPAddress ip = 3;
  bool has_ip() const;
  private:
  bool _internal_has_ip() const;
  public:
  void clear_ip();
  const ::CMsgIPAddress& ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_ip();
  ::CMsgIPAddress* mutable_ip();
  void set_allocated_ip(::CMsgIPAddress* ip);
  private:
  const ::CMsgIPAddress& _internal_ip() const;
  ::CMsgIPAddress* _internal_mutable_ip();
  public:
  void unsafe_arena_set_allocated_ip(
      ::CMsgIPAddress* ip);
  ::CMsgIPAddress* unsafe_arena_release_ip();

  // optional int32 action = 1;
  bool has_action() const;
  private:
  bool _internal_has_action() const;
  public:
  void clear_action();
  int32_t action() const;
  void set_action(int32_t value);
  private:
  int32_t _internal_action() const;
  void _internal_set_action(int32_t value);
  public:

  // optional uint32 time = 2;
  bool has_time() const;
  private:
  bool _internal_has_time() const;
  public:
  void clear_time();
  uint32_t time() const;
  void set_time(uint32_t value);
  private:
  uint32_t _internal_time() const;
  void _internal_set_time(uint32_t value);
  public:

  // optional fixed64 actor = 4;
  bool has_actor() const;
  private:
  bool _internal_has_actor() const;
  public:
  void clear_actor();
  uint64_t actor() const;
  void set_actor(uint64_t value);
  private:
  uint64_t _internal_actor() const;
  void _internal_set_actor(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSupportRefreshTokenAudit)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CMsgIPAddress* ip_;
  int32_t action_;
  uint32_t time_;
  uint64_t actor_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationSupport_GetTokenHistory_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationSupport_GetTokenHistory_Response) */ {
 public:
  inline CAuthenticationSupport_GetTokenHistory_Response() : CAuthenticationSupport_GetTokenHistory_Response(nullptr) {}
  ~CAuthenticationSupport_GetTokenHistory_Response() override;
  explicit constexpr CAuthenticationSupport_GetTokenHistory_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationSupport_GetTokenHistory_Response(const CAuthenticationSupport_GetTokenHistory_Response& from);
  CAuthenticationSupport_GetTokenHistory_Response(CAuthenticationSupport_GetTokenHistory_Response&& from) noexcept
    : CAuthenticationSupport_GetTokenHistory_Response() {
    *this = ::std::move(from);
  }

  inline CAuthenticationSupport_GetTokenHistory_Response& operator=(const CAuthenticationSupport_GetTokenHistory_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationSupport_GetTokenHistory_Response& operator=(CAuthenticationSupport_GetTokenHistory_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationSupport_GetTokenHistory_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationSupport_GetTokenHistory_Response* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationSupport_GetTokenHistory_Response*>(
               &_CAuthenticationSupport_GetTokenHistory_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CAuthenticationSupport_GetTokenHistory_Response& a, CAuthenticationSupport_GetTokenHistory_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationSupport_GetTokenHistory_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationSupport_GetTokenHistory_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationSupport_GetTokenHistory_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationSupport_GetTokenHistory_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationSupport_GetTokenHistory_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationSupport_GetTokenHistory_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationSupport_GetTokenHistory_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationSupport_GetTokenHistory_Response";
  }
  protected:
  explicit CAuthenticationSupport_GetTokenHistory_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHistoryFieldNumber = 1,
  };
  // repeated .CSupportRefreshTokenAudit history = 1;
  int history_size() const;
  private:
  int _internal_history_size() const;
  public:
  void clear_history();
  ::CSupportRefreshTokenAudit* mutable_history(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenAudit >*
      mutable_history();
  private:
  const ::CSupportRefreshTokenAudit& _internal_history(int index) const;
  ::CSupportRefreshTokenAudit* _internal_add_history();
  public:
  const ::CSupportRefreshTokenAudit& history(int index) const;
  ::CSupportRefreshTokenAudit* add_history();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenAudit >&
      history() const;

  // @@protoc_insertion_point(class_scope:CAuthenticationSupport_GetTokenHistory_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenAudit > history_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CCloudGaming_CreateNonce_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCloudGaming_CreateNonce_Request) */ {
 public:
  inline CCloudGaming_CreateNonce_Request() : CCloudGaming_CreateNonce_Request(nullptr) {}
  ~CCloudGaming_CreateNonce_Request() override;
  explicit constexpr CCloudGaming_CreateNonce_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCloudGaming_CreateNonce_Request(const CCloudGaming_CreateNonce_Request& from);
  CCloudGaming_CreateNonce_Request(CCloudGaming_CreateNonce_Request&& from) noexcept
    : CCloudGaming_CreateNonce_Request() {
    *this = ::std::move(from);
  }

  inline CCloudGaming_CreateNonce_Request& operator=(const CCloudGaming_CreateNonce_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCloudGaming_CreateNonce_Request& operator=(CCloudGaming_CreateNonce_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCloudGaming_CreateNonce_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCloudGaming_CreateNonce_Request* internal_default_instance() {
    return reinterpret_cast<const CCloudGaming_CreateNonce_Request*>(
               &_CCloudGaming_CreateNonce_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CCloudGaming_CreateNonce_Request& a, CCloudGaming_CreateNonce_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CCloudGaming_CreateNonce_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCloudGaming_CreateNonce_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCloudGaming_CreateNonce_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCloudGaming_CreateNonce_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCloudGaming_CreateNonce_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCloudGaming_CreateNonce_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCloudGaming_CreateNonce_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCloudGaming_CreateNonce_Request";
  }
  protected:
  explicit CCloudGaming_CreateNonce_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlatformFieldNumber = 1,
    kAppidFieldNumber = 2,
  };
  // optional string platform = 1;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CCloudGaming_CreateNonce_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CCloudGaming_CreateNonce_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCloudGaming_CreateNonce_Response) */ {
 public:
  inline CCloudGaming_CreateNonce_Response() : CCloudGaming_CreateNonce_Response(nullptr) {}
  ~CCloudGaming_CreateNonce_Response() override;
  explicit constexpr CCloudGaming_CreateNonce_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCloudGaming_CreateNonce_Response(const CCloudGaming_CreateNonce_Response& from);
  CCloudGaming_CreateNonce_Response(CCloudGaming_CreateNonce_Response&& from) noexcept
    : CCloudGaming_CreateNonce_Response() {
    *this = ::std::move(from);
  }

  inline CCloudGaming_CreateNonce_Response& operator=(const CCloudGaming_CreateNonce_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCloudGaming_CreateNonce_Response& operator=(CCloudGaming_CreateNonce_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCloudGaming_CreateNonce_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCloudGaming_CreateNonce_Response* internal_default_instance() {
    return reinterpret_cast<const CCloudGaming_CreateNonce_Response*>(
               &_CCloudGaming_CreateNonce_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CCloudGaming_CreateNonce_Response& a, CCloudGaming_CreateNonce_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CCloudGaming_CreateNonce_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCloudGaming_CreateNonce_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCloudGaming_CreateNonce_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCloudGaming_CreateNonce_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCloudGaming_CreateNonce_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCloudGaming_CreateNonce_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCloudGaming_CreateNonce_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCloudGaming_CreateNonce_Response";
  }
  protected:
  explicit CCloudGaming_CreateNonce_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNonceFieldNumber = 1,
    kExpiryFieldNumber = 2,
  };
  // optional string nonce = 1;
  bool has_nonce() const;
  private:
  bool _internal_has_nonce() const;
  public:
  void clear_nonce();
  const std::string& nonce() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nonce(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nonce();
  PROTOBUF_NODISCARD std::string* release_nonce();
  void set_allocated_nonce(std::string* nonce);
  private:
  const std::string& _internal_nonce() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nonce(const std::string& value);
  std::string* _internal_mutable_nonce();
  public:

  // optional uint32 expiry = 2;
  bool has_expiry() const;
  private:
  bool _internal_has_expiry() const;
  public:
  void clear_expiry();
  uint32_t expiry() const;
  void set_expiry(uint32_t value);
  private:
  uint32_t _internal_expiry() const;
  void _internal_set_expiry(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CCloudGaming_CreateNonce_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nonce_;
  uint32_t expiry_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CCloudGaming_GetTimeRemaining_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCloudGaming_GetTimeRemaining_Request) */ {
 public:
  inline CCloudGaming_GetTimeRemaining_Request() : CCloudGaming_GetTimeRemaining_Request(nullptr) {}
  ~CCloudGaming_GetTimeRemaining_Request() override;
  explicit constexpr CCloudGaming_GetTimeRemaining_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCloudGaming_GetTimeRemaining_Request(const CCloudGaming_GetTimeRemaining_Request& from);
  CCloudGaming_GetTimeRemaining_Request(CCloudGaming_GetTimeRemaining_Request&& from) noexcept
    : CCloudGaming_GetTimeRemaining_Request() {
    *this = ::std::move(from);
  }

  inline CCloudGaming_GetTimeRemaining_Request& operator=(const CCloudGaming_GetTimeRemaining_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCloudGaming_GetTimeRemaining_Request& operator=(CCloudGaming_GetTimeRemaining_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCloudGaming_GetTimeRemaining_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCloudGaming_GetTimeRemaining_Request* internal_default_instance() {
    return reinterpret_cast<const CCloudGaming_GetTimeRemaining_Request*>(
               &_CCloudGaming_GetTimeRemaining_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CCloudGaming_GetTimeRemaining_Request& a, CCloudGaming_GetTimeRemaining_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CCloudGaming_GetTimeRemaining_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCloudGaming_GetTimeRemaining_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCloudGaming_GetTimeRemaining_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCloudGaming_GetTimeRemaining_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCloudGaming_GetTimeRemaining_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCloudGaming_GetTimeRemaining_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCloudGaming_GetTimeRemaining_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCloudGaming_GetTimeRemaining_Request";
  }
  protected:
  explicit CCloudGaming_GetTimeRemaining_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidListFieldNumber = 2,
    kPlatformFieldNumber = 1,
  };
  // repeated uint32 appid_list = 2;
  int appid_list_size() const;
  private:
  int _internal_appid_list_size() const;
  public:
  void clear_appid_list();
  private:
  uint32_t _internal_appid_list(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_appid_list() const;
  void _internal_add_appid_list(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_appid_list();
  public:
  uint32_t appid_list(int index) const;
  void set_appid_list(int index, uint32_t value);
  void add_appid_list(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      appid_list() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_appid_list();

  // optional string platform = 1;
  bool has_platform() const;
  private:
  bool _internal_has_platform() const;
  public:
  void clear_platform();
  const std::string& platform() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_platform(ArgT0&& arg0, ArgT... args);
  std::string* mutable_platform();
  PROTOBUF_NODISCARD std::string* release_platform();
  void set_allocated_platform(std::string* platform);
  private:
  const std::string& _internal_platform() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_platform(const std::string& value);
  std::string* _internal_mutable_platform();
  public:

  // @@protoc_insertion_point(class_scope:CCloudGaming_GetTimeRemaining_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > appid_list_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr platform_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CCloudGaming_TimeRemaining final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCloudGaming_TimeRemaining) */ {
 public:
  inline CCloudGaming_TimeRemaining() : CCloudGaming_TimeRemaining(nullptr) {}
  ~CCloudGaming_TimeRemaining() override;
  explicit constexpr CCloudGaming_TimeRemaining(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCloudGaming_TimeRemaining(const CCloudGaming_TimeRemaining& from);
  CCloudGaming_TimeRemaining(CCloudGaming_TimeRemaining&& from) noexcept
    : CCloudGaming_TimeRemaining() {
    *this = ::std::move(from);
  }

  inline CCloudGaming_TimeRemaining& operator=(const CCloudGaming_TimeRemaining& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCloudGaming_TimeRemaining& operator=(CCloudGaming_TimeRemaining&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCloudGaming_TimeRemaining& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCloudGaming_TimeRemaining* internal_default_instance() {
    return reinterpret_cast<const CCloudGaming_TimeRemaining*>(
               &_CCloudGaming_TimeRemaining_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CCloudGaming_TimeRemaining& a, CCloudGaming_TimeRemaining& b) {
    a.Swap(&b);
  }
  inline void Swap(CCloudGaming_TimeRemaining* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCloudGaming_TimeRemaining* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCloudGaming_TimeRemaining* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCloudGaming_TimeRemaining>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCloudGaming_TimeRemaining& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCloudGaming_TimeRemaining& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCloudGaming_TimeRemaining* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCloudGaming_TimeRemaining";
  }
  protected:
  explicit CCloudGaming_TimeRemaining(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kMinutesRemainingFieldNumber = 2,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 minutes_remaining = 2;
  bool has_minutes_remaining() const;
  private:
  bool _internal_has_minutes_remaining() const;
  public:
  void clear_minutes_remaining();
  uint32_t minutes_remaining() const;
  void set_minutes_remaining(uint32_t value);
  private:
  uint32_t _internal_minutes_remaining() const;
  void _internal_set_minutes_remaining(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CCloudGaming_TimeRemaining)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t minutes_remaining_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CCloudGaming_GetTimeRemaining_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CCloudGaming_GetTimeRemaining_Response) */ {
 public:
  inline CCloudGaming_GetTimeRemaining_Response() : CCloudGaming_GetTimeRemaining_Response(nullptr) {}
  ~CCloudGaming_GetTimeRemaining_Response() override;
  explicit constexpr CCloudGaming_GetTimeRemaining_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CCloudGaming_GetTimeRemaining_Response(const CCloudGaming_GetTimeRemaining_Response& from);
  CCloudGaming_GetTimeRemaining_Response(CCloudGaming_GetTimeRemaining_Response&& from) noexcept
    : CCloudGaming_GetTimeRemaining_Response() {
    *this = ::std::move(from);
  }

  inline CCloudGaming_GetTimeRemaining_Response& operator=(const CCloudGaming_GetTimeRemaining_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CCloudGaming_GetTimeRemaining_Response& operator=(CCloudGaming_GetTimeRemaining_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CCloudGaming_GetTimeRemaining_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CCloudGaming_GetTimeRemaining_Response* internal_default_instance() {
    return reinterpret_cast<const CCloudGaming_GetTimeRemaining_Response*>(
               &_CCloudGaming_GetTimeRemaining_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CCloudGaming_GetTimeRemaining_Response& a, CCloudGaming_GetTimeRemaining_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CCloudGaming_GetTimeRemaining_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CCloudGaming_GetTimeRemaining_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CCloudGaming_GetTimeRemaining_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CCloudGaming_GetTimeRemaining_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CCloudGaming_GetTimeRemaining_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CCloudGaming_GetTimeRemaining_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CCloudGaming_GetTimeRemaining_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CCloudGaming_GetTimeRemaining_Response";
  }
  protected:
  explicit CCloudGaming_GetTimeRemaining_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 2,
  };
  // repeated .CCloudGaming_TimeRemaining entries = 2;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::CCloudGaming_TimeRemaining* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CCloudGaming_TimeRemaining >*
      mutable_entries();
  private:
  const ::CCloudGaming_TimeRemaining& _internal_entries(int index) const;
  ::CCloudGaming_TimeRemaining* _internal_add_entries();
  public:
  const ::CCloudGaming_TimeRemaining& entries(int index) const;
  ::CCloudGaming_TimeRemaining* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CCloudGaming_TimeRemaining >&
      entries() const;

  // @@protoc_insertion_point(class_scope:CCloudGaming_GetTimeRemaining_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CCloudGaming_TimeRemaining > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fauth_2esteamclient_2eproto;
};
// ===================================================================

class Authentication_Stub;

class Authentication : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline Authentication() {};
 public:
  virtual ~Authentication();

  typedef Authentication_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetPasswordRSAPublicKey(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetPasswordRSAPublicKey_Request* request,
                       ::CAuthentication_GetPasswordRSAPublicKey_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void BeginAuthSessionViaQR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_BeginAuthSessionViaQR_Request* request,
                       ::CAuthentication_BeginAuthSessionViaQR_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void BeginAuthSessionViaCredentials(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_BeginAuthSessionViaCredentials_Request* request,
                       ::CAuthentication_BeginAuthSessionViaCredentials_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void PollAuthSessionStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_PollAuthSessionStatus_Request* request,
                       ::CAuthentication_PollAuthSessionStatus_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetAuthSessionInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetAuthSessionInfo_Request* request,
                       ::CAuthentication_GetAuthSessionInfo_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void UpdateAuthSessionWithMobileConfirmation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* request,
                       ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void UpdateAuthSessionWithSteamGuardCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* request,
                       ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GenerateAccessTokenForApp(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_AccessToken_GenerateForApp_Request* request,
                       ::CAuthentication_AccessToken_GenerateForApp_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void EnumerateTokens(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_RefreshToken_Enumerate_Request* request,
                       ::CAuthentication_RefreshToken_Enumerate_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetAuthSessionsForAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetAuthSessionsForAccount_Request* request,
                       ::CAuthentication_GetAuthSessionsForAccount_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void MigrateMobileSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_MigrateMobileSession_Request* request,
                       ::CAuthentication_MigrateMobileSession_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_Token_Revoke_Request* request,
                       ::CAuthentication_Token_Revoke_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void RevokeRefreshToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_RefreshToken_Revoke_Request* request,
                       ::CAuthentication_RefreshToken_Revoke_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Authentication);
};

class Authentication_Stub : public Authentication {
 public:
  Authentication_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  Authentication_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~Authentication_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements Authentication ------------------------------------------

  void GetPasswordRSAPublicKey(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetPasswordRSAPublicKey_Request* request,
                       ::CAuthentication_GetPasswordRSAPublicKey_Response* response,
                       ::google::protobuf::Closure* done);
  void BeginAuthSessionViaQR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_BeginAuthSessionViaQR_Request* request,
                       ::CAuthentication_BeginAuthSessionViaQR_Response* response,
                       ::google::protobuf::Closure* done);
  void BeginAuthSessionViaCredentials(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_BeginAuthSessionViaCredentials_Request* request,
                       ::CAuthentication_BeginAuthSessionViaCredentials_Response* response,
                       ::google::protobuf::Closure* done);
  void PollAuthSessionStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_PollAuthSessionStatus_Request* request,
                       ::CAuthentication_PollAuthSessionStatus_Response* response,
                       ::google::protobuf::Closure* done);
  void GetAuthSessionInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetAuthSessionInfo_Request* request,
                       ::CAuthentication_GetAuthSessionInfo_Response* response,
                       ::google::protobuf::Closure* done);
  void UpdateAuthSessionWithMobileConfirmation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* request,
                       ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* response,
                       ::google::protobuf::Closure* done);
  void UpdateAuthSessionWithSteamGuardCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* request,
                       ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* response,
                       ::google::protobuf::Closure* done);
  void GenerateAccessTokenForApp(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_AccessToken_GenerateForApp_Request* request,
                       ::CAuthentication_AccessToken_GenerateForApp_Response* response,
                       ::google::protobuf::Closure* done);
  void EnumerateTokens(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_RefreshToken_Enumerate_Request* request,
                       ::CAuthentication_RefreshToken_Enumerate_Response* response,
                       ::google::protobuf::Closure* done);
  void GetAuthSessionsForAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_GetAuthSessionsForAccount_Request* request,
                       ::CAuthentication_GetAuthSessionsForAccount_Response* response,
                       ::google::protobuf::Closure* done);
  void MigrateMobileSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_MigrateMobileSession_Request* request,
                       ::CAuthentication_MigrateMobileSession_Response* response,
                       ::google::protobuf::Closure* done);
  void RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_Token_Revoke_Request* request,
                       ::CAuthentication_Token_Revoke_Response* response,
                       ::google::protobuf::Closure* done);
  void RevokeRefreshToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthentication_RefreshToken_Revoke_Request* request,
                       ::CAuthentication_RefreshToken_Revoke_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Authentication_Stub);
};


// -------------------------------------------------------------------

class AuthenticationSupport_Stub;

class AuthenticationSupport : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline AuthenticationSupport() {};
 public:
  virtual ~AuthenticationSupport();

  typedef AuthenticationSupport_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void QueryRefreshTokensByAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request* request,
                       ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void QueryRefreshTokenByID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_QueryRefreshTokenByID_Request* request,
                       ::CAuthenticationSupport_QueryRefreshTokenByID_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_RevokeToken_Request* request,
                       ::CAuthenticationSupport_RevokeToken_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTokenHistory(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_GetTokenHistory_Request* request,
                       ::CAuthenticationSupport_GetTokenHistory_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationSupport);
};

class AuthenticationSupport_Stub : public AuthenticationSupport {
 public:
  AuthenticationSupport_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  AuthenticationSupport_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~AuthenticationSupport_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements AuthenticationSupport ------------------------------------------

  void QueryRefreshTokensByAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request* request,
                       ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response* response,
                       ::google::protobuf::Closure* done);
  void QueryRefreshTokenByID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_QueryRefreshTokenByID_Request* request,
                       ::CAuthenticationSupport_QueryRefreshTokenByID_Response* response,
                       ::google::protobuf::Closure* done);
  void RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_RevokeToken_Request* request,
                       ::CAuthenticationSupport_RevokeToken_Response* response,
                       ::google::protobuf::Closure* done);
  void GetTokenHistory(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CAuthenticationSupport_GetTokenHistory_Request* request,
                       ::CAuthenticationSupport_GetTokenHistory_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(AuthenticationSupport_Stub);
};


// -------------------------------------------------------------------

class CloudGaming_Stub;

class CloudGaming : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline CloudGaming() {};
 public:
  virtual ~CloudGaming();

  typedef CloudGaming_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void CreateNonce(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CCloudGaming_CreateNonce_Request* request,
                       ::CCloudGaming_CreateNonce_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetTimeRemaining(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CCloudGaming_GetTimeRemaining_Request* request,
                       ::CCloudGaming_GetTimeRemaining_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CloudGaming);
};

class CloudGaming_Stub : public CloudGaming {
 public:
  CloudGaming_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  CloudGaming_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~CloudGaming_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements CloudGaming ------------------------------------------

  void CreateNonce(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CCloudGaming_CreateNonce_Request* request,
                       ::CCloudGaming_CreateNonce_Response* response,
                       ::google::protobuf::Closure* done);
  void GetTimeRemaining(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CCloudGaming_GetTimeRemaining_Request* request,
                       ::CCloudGaming_GetTimeRemaining_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(CloudGaming_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CAuthentication_GetPasswordRSAPublicKey_Request

// optional string account_name = 1 [(.description) = "user-provided account name to get an RSA key for"];
inline bool CAuthentication_GetPasswordRSAPublicKey_Request::_internal_has_account_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_GetPasswordRSAPublicKey_Request::has_account_name() const {
  return _internal_has_account_name();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Request::clear_account_name() {
  account_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Request::account_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetPasswordRSAPublicKey_Request.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetPasswordRSAPublicKey_Request::set_account_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetPasswordRSAPublicKey_Request.account_name)
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Request::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetPasswordRSAPublicKey_Request.account_name)
  return _s;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Request::_internal_account_name() const {
  return account_name_.Get();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Request::_internal_set_account_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Request::_internal_mutable_account_name() {
  _has_bits_[0] |= 0x00000001u;
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Request::release_account_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetPasswordRSAPublicKey_Request.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = account_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetPasswordRSAPublicKey_Request::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetPasswordRSAPublicKey_Request.account_name)
}

// -------------------------------------------------------------------

// CAuthentication_GetPasswordRSAPublicKey_Response

// optional string publickey_mod = 1 [(.description) = "the public key modulus"];
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::_internal_has_publickey_mod() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::has_publickey_mod() const {
  return _internal_has_publickey_mod();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::clear_publickey_mod() {
  publickey_mod_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Response::publickey_mod() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod)
  return _internal_publickey_mod();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetPasswordRSAPublicKey_Response::set_publickey_mod(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 publickey_mod_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod)
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::mutable_publickey_mod() {
  std::string* _s = _internal_mutable_publickey_mod();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod)
  return _s;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Response::_internal_publickey_mod() const {
  return publickey_mod_.Get();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::_internal_set_publickey_mod(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  publickey_mod_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::_internal_mutable_publickey_mod() {
  _has_bits_[0] |= 0x00000001u;
  return publickey_mod_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::release_publickey_mod() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod)
  if (!_internal_has_publickey_mod()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = publickey_mod_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publickey_mod_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publickey_mod_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::set_allocated_publickey_mod(std::string* publickey_mod) {
  if (publickey_mod != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  publickey_mod_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey_mod,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publickey_mod_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publickey_mod_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod)
}

// optional string publickey_exp = 2 [(.description) = "the public key exponent"];
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::_internal_has_publickey_exp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::has_publickey_exp() const {
  return _internal_has_publickey_exp();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::clear_publickey_exp() {
  publickey_exp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Response::publickey_exp() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp)
  return _internal_publickey_exp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetPasswordRSAPublicKey_Response::set_publickey_exp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 publickey_exp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp)
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::mutable_publickey_exp() {
  std::string* _s = _internal_mutable_publickey_exp();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp)
  return _s;
}
inline const std::string& CAuthentication_GetPasswordRSAPublicKey_Response::_internal_publickey_exp() const {
  return publickey_exp_.Get();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::_internal_set_publickey_exp(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  publickey_exp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::_internal_mutable_publickey_exp() {
  _has_bits_[0] |= 0x00000002u;
  return publickey_exp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetPasswordRSAPublicKey_Response::release_publickey_exp() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp)
  if (!_internal_has_publickey_exp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = publickey_exp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publickey_exp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publickey_exp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::set_allocated_publickey_exp(std::string* publickey_exp) {
  if (publickey_exp != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  publickey_exp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publickey_exp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publickey_exp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publickey_exp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp)
}

// optional uint64 timestamp = 3 [(.description) = "the timestamp the key was generated"];
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_GetPasswordRSAPublicKey_Response::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::clear_timestamp() {
  timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_GetPasswordRSAPublicKey_Response::_internal_timestamp() const {
  return timestamp_;
}
inline uint64_t CAuthentication_GetPasswordRSAPublicKey_Response::timestamp() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetPasswordRSAPublicKey_Response.timestamp)
  return _internal_timestamp();
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::_internal_set_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  timestamp_ = value;
}
inline void CAuthentication_GetPasswordRSAPublicKey_Response::set_timestamp(uint64_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetPasswordRSAPublicKey_Response.timestamp)
}

// -------------------------------------------------------------------

// CAuthentication_DeviceDetails

// optional string device_friendly_name = 1 [(.description) = "User-supplied, or client-supplied, friendly name of device"];
inline bool CAuthentication_DeviceDetails::_internal_has_device_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_device_friendly_name() const {
  return _internal_has_device_friendly_name();
}
inline void CAuthentication_DeviceDetails::clear_device_friendly_name() {
  device_friendly_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_DeviceDetails::device_friendly_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.device_friendly_name)
  return _internal_device_friendly_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_DeviceDetails::set_device_friendly_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.device_friendly_name)
}
inline std::string* CAuthentication_DeviceDetails::mutable_device_friendly_name() {
  std::string* _s = _internal_mutable_device_friendly_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_DeviceDetails.device_friendly_name)
  return _s;
}
inline const std::string& CAuthentication_DeviceDetails::_internal_device_friendly_name() const {
  return device_friendly_name_.Get();
}
inline void CAuthentication_DeviceDetails::_internal_set_device_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_DeviceDetails::_internal_mutable_device_friendly_name() {
  _has_bits_[0] |= 0x00000001u;
  return device_friendly_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_DeviceDetails::release_device_friendly_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_DeviceDetails.device_friendly_name)
  if (!_internal_has_device_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_friendly_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_DeviceDetails::set_allocated_device_friendly_name(std::string* device_friendly_name) {
  if (device_friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_friendly_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_friendly_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_DeviceDetails.device_friendly_name)
}

// optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "EAuthTokenPlatformType, claimed, of device"];
inline bool CAuthentication_DeviceDetails::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CAuthentication_DeviceDetails::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EAuthTokenPlatformType CAuthentication_DeviceDetails::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CAuthentication_DeviceDetails::platform_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.platform_type)
  return _internal_platform_type();
}
inline void CAuthentication_DeviceDetails::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  platform_type_ = value;
}
inline void CAuthentication_DeviceDetails::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.platform_type)
}

// optional int32 os_type = 3 [(.description) = "EOSType, claimed, of authorized device"];
inline bool CAuthentication_DeviceDetails::_internal_has_os_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_os_type() const {
  return _internal_has_os_type();
}
inline void CAuthentication_DeviceDetails::clear_os_type() {
  os_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CAuthentication_DeviceDetails::_internal_os_type() const {
  return os_type_;
}
inline int32_t CAuthentication_DeviceDetails::os_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.os_type)
  return _internal_os_type();
}
inline void CAuthentication_DeviceDetails::_internal_set_os_type(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  os_type_ = value;
}
inline void CAuthentication_DeviceDetails::set_os_type(int32_t value) {
  _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.os_type)
}

// optional uint32 gaming_device_type = 4 [(.description) = "EGamingDeviceType, claimed, of authorized device for steam client-type devices"];
inline bool CAuthentication_DeviceDetails::_internal_has_gaming_device_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_gaming_device_type() const {
  return _internal_has_gaming_device_type();
}
inline void CAuthentication_DeviceDetails::clear_gaming_device_type() {
  gaming_device_type_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CAuthentication_DeviceDetails::_internal_gaming_device_type() const {
  return gaming_device_type_;
}
inline uint32_t CAuthentication_DeviceDetails::gaming_device_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.gaming_device_type)
  return _internal_gaming_device_type();
}
inline void CAuthentication_DeviceDetails::_internal_set_gaming_device_type(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  gaming_device_type_ = value;
}
inline void CAuthentication_DeviceDetails::set_gaming_device_type(uint32_t value) {
  _internal_set_gaming_device_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.gaming_device_type)
}

// optional uint32 client_count = 5 [(.description) = "For desktop clients, quantized number of users in history"];
inline bool CAuthentication_DeviceDetails::_internal_has_client_count() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_client_count() const {
  return _internal_has_client_count();
}
inline void CAuthentication_DeviceDetails::clear_client_count() {
  client_count_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CAuthentication_DeviceDetails::_internal_client_count() const {
  return client_count_;
}
inline uint32_t CAuthentication_DeviceDetails::client_count() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.client_count)
  return _internal_client_count();
}
inline void CAuthentication_DeviceDetails::_internal_set_client_count(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  client_count_ = value;
}
inline void CAuthentication_DeviceDetails::set_client_count(uint32_t value) {
  _internal_set_client_count(value);
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.client_count)
}

// optional bytes machine_id = 6 [(.description) = "Additional device context"];
inline bool CAuthentication_DeviceDetails::_internal_has_machine_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_DeviceDetails::has_machine_id() const {
  return _internal_has_machine_id();
}
inline void CAuthentication_DeviceDetails::clear_machine_id() {
  machine_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_DeviceDetails::machine_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_DeviceDetails.machine_id)
  return _internal_machine_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_DeviceDetails::set_machine_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 machine_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_DeviceDetails.machine_id)
}
inline std::string* CAuthentication_DeviceDetails::mutable_machine_id() {
  std::string* _s = _internal_mutable_machine_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_DeviceDetails.machine_id)
  return _s;
}
inline const std::string& CAuthentication_DeviceDetails::_internal_machine_id() const {
  return machine_id_.Get();
}
inline void CAuthentication_DeviceDetails::_internal_set_machine_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  machine_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_DeviceDetails::_internal_mutable_machine_id() {
  _has_bits_[0] |= 0x00000002u;
  return machine_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_DeviceDetails::release_machine_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_DeviceDetails.machine_id)
  if (!_internal_has_machine_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = machine_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    machine_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_DeviceDetails::set_allocated_machine_id(std::string* machine_id) {
  if (machine_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  machine_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), machine_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (machine_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    machine_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_DeviceDetails.machine_id)
}

// -------------------------------------------------------------------

// CAuthentication_BeginAuthSessionViaQR_Request

// optional string device_friendly_name = 1;
inline bool CAuthentication_BeginAuthSessionViaQR_Request::_internal_has_device_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Request::has_device_friendly_name() const {
  return _internal_has_device_friendly_name();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::clear_device_friendly_name() {
  device_friendly_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Request::device_friendly_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name)
  return _internal_device_friendly_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaQR_Request::set_device_friendly_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name)
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::mutable_device_friendly_name() {
  std::string* _s = _internal_mutable_device_friendly_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Request::_internal_device_friendly_name() const {
  return device_friendly_name_.Get();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::_internal_set_device_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::_internal_mutable_device_friendly_name() {
  _has_bits_[0] |= 0x00000001u;
  return device_friendly_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::release_device_friendly_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name)
  if (!_internal_has_device_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_friendly_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::set_allocated_device_friendly_name(std::string* device_friendly_name) {
  if (device_friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_friendly_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_friendly_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name)
}

// optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown];
inline bool CAuthentication_BeginAuthSessionViaQR_Request::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Request::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EAuthTokenPlatformType CAuthentication_BeginAuthSessionViaQR_Request::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CAuthentication_BeginAuthSessionViaQR_Request::platform_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Request.platform_type)
  return _internal_platform_type();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  platform_type_ = value;
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Request.platform_type)
}

// optional .CAuthentication_DeviceDetails device_details = 3 [(.description) = "User-supplied details about the device attempting to sign in"];
inline bool CAuthentication_BeginAuthSessionViaQR_Request::_internal_has_device_details() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || device_details_ != nullptr);
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Request::has_device_details() const {
  return _internal_has_device_details();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::clear_device_details() {
  if (device_details_ != nullptr) device_details_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CAuthentication_DeviceDetails& CAuthentication_BeginAuthSessionViaQR_Request::_internal_device_details() const {
  const ::CAuthentication_DeviceDetails* p = device_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::CAuthentication_DeviceDetails&>(
      ::_CAuthentication_DeviceDetails_default_instance_);
}
inline const ::CAuthentication_DeviceDetails& CAuthentication_BeginAuthSessionViaQR_Request::device_details() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Request.device_details)
  return _internal_device_details();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::unsafe_arena_set_allocated_device_details(
    ::CAuthentication_DeviceDetails* device_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_details_);
  }
  device_details_ = device_details;
  if (device_details) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CAuthentication_BeginAuthSessionViaQR_Request.device_details)
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaQR_Request::release_device_details() {
  _has_bits_[0] &= ~0x00000004u;
  ::CAuthentication_DeviceDetails* temp = device_details_;
  device_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaQR_Request::unsafe_arena_release_device_details() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaQR_Request.device_details)
  _has_bits_[0] &= ~0x00000004u;
  ::CAuthentication_DeviceDetails* temp = device_details_;
  device_details_ = nullptr;
  return temp;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaQR_Request::_internal_mutable_device_details() {
  _has_bits_[0] |= 0x00000004u;
  if (device_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::CAuthentication_DeviceDetails>(GetArenaForAllocation());
    device_details_ = p;
  }
  return device_details_;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaQR_Request::mutable_device_details() {
  ::CAuthentication_DeviceDetails* _msg = _internal_mutable_device_details();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Request.device_details)
  return _msg;
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::set_allocated_device_details(::CAuthentication_DeviceDetails* device_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_details_;
  }
  if (device_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CAuthentication_DeviceDetails>::GetOwningArena(device_details);
    if (message_arena != submessage_arena) {
      device_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_details_ = device_details;
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaQR_Request.device_details)
}

// optional string website_id = 4 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
inline bool CAuthentication_BeginAuthSessionViaQR_Request::_internal_has_website_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Request::has_website_id() const {
  return _internal_has_website_id();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::clear_website_id() {
  website_id_.ClearToDefault(::CAuthentication_BeginAuthSessionViaQR_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Request::website_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Request.website_id)
  if (website_id_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_website_id_.get();
  return _internal_website_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaQR_Request::set_website_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Request.website_id)
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::mutable_website_id() {
  std::string* _s = _internal_mutable_website_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Request.website_id)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Request::_internal_website_id() const {
  return website_id_.Get();
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::_internal_set_website_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::_internal_mutable_website_id() {
  _has_bits_[0] |= 0x00000002u;
  return website_id_.Mutable(::CAuthentication_BeginAuthSessionViaQR_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Request::release_website_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaQR_Request.website_id)
  if (!_internal_has_website_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = website_id_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void CAuthentication_BeginAuthSessionViaQR_Request::set_allocated_website_id(std::string* website_id) {
  if (website_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  website_id_.SetAllocated(nullptr, website_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaQR_Request.website_id)
}

// -------------------------------------------------------------------

// CAuthentication_AllowedConfirmation

// optional .EAuthSessionGuardType confirmation_type = 1 [default = k_EAuthSessionGuardType_Unknown, (.description) = "authentication can proceed with this confirmation type"];
inline bool CAuthentication_AllowedConfirmation::_internal_has_confirmation_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_AllowedConfirmation::has_confirmation_type() const {
  return _internal_has_confirmation_type();
}
inline void CAuthentication_AllowedConfirmation::clear_confirmation_type() {
  confirmation_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EAuthSessionGuardType CAuthentication_AllowedConfirmation::_internal_confirmation_type() const {
  return static_cast< ::EAuthSessionGuardType >(confirmation_type_);
}
inline ::EAuthSessionGuardType CAuthentication_AllowedConfirmation::confirmation_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AllowedConfirmation.confirmation_type)
  return _internal_confirmation_type();
}
inline void CAuthentication_AllowedConfirmation::_internal_set_confirmation_type(::EAuthSessionGuardType value) {
  assert(::EAuthSessionGuardType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  confirmation_type_ = value;
}
inline void CAuthentication_AllowedConfirmation::set_confirmation_type(::EAuthSessionGuardType value) {
  _internal_set_confirmation_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_AllowedConfirmation.confirmation_type)
}

// optional string associated_message = 2 [(.description) = "message to be interpreted depending on the confirmation type. for email confirmation, this might be the redacted email address to which email was sent."];
inline bool CAuthentication_AllowedConfirmation::_internal_has_associated_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_AllowedConfirmation::has_associated_message() const {
  return _internal_has_associated_message();
}
inline void CAuthentication_AllowedConfirmation::clear_associated_message() {
  associated_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_AllowedConfirmation::associated_message() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AllowedConfirmation.associated_message)
  return _internal_associated_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_AllowedConfirmation::set_associated_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 associated_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_AllowedConfirmation.associated_message)
}
inline std::string* CAuthentication_AllowedConfirmation::mutable_associated_message() {
  std::string* _s = _internal_mutable_associated_message();
  // @@protoc_insertion_point(field_mutable:CAuthentication_AllowedConfirmation.associated_message)
  return _s;
}
inline const std::string& CAuthentication_AllowedConfirmation::_internal_associated_message() const {
  return associated_message_.Get();
}
inline void CAuthentication_AllowedConfirmation::_internal_set_associated_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  associated_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_AllowedConfirmation::_internal_mutable_associated_message() {
  _has_bits_[0] |= 0x00000001u;
  return associated_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_AllowedConfirmation::release_associated_message() {
  // @@protoc_insertion_point(field_release:CAuthentication_AllowedConfirmation.associated_message)
  if (!_internal_has_associated_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = associated_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (associated_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    associated_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_AllowedConfirmation::set_allocated_associated_message(std::string* associated_message) {
  if (associated_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  associated_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), associated_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (associated_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    associated_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_AllowedConfirmation.associated_message)
}

// -------------------------------------------------------------------

// CAuthentication_BeginAuthSessionViaQR_Response

// optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing, portion of QR code"];
inline bool CAuthentication_BeginAuthSessionViaQR_Response::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Response::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_BeginAuthSessionViaQR_Response::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_BeginAuthSessionViaQR_Response::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.client_id)
  return _internal_client_id();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  client_id_ = value;
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Response.client_id)
}

// optional string challenge_url = 2 [(.description) = "URL based on client ID, which will be rendered as QR code"];
inline bool CAuthentication_BeginAuthSessionViaQR_Response::_internal_has_challenge_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Response::has_challenge_url() const {
  return _internal_has_challenge_url();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_challenge_url() {
  challenge_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Response::challenge_url() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.challenge_url)
  return _internal_challenge_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaQR_Response::set_challenge_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Response.challenge_url)
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::mutable_challenge_url() {
  std::string* _s = _internal_mutable_challenge_url();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Response.challenge_url)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Response::_internal_challenge_url() const {
  return challenge_url_.Get();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::_internal_set_challenge_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::_internal_mutable_challenge_url() {
  _has_bits_[0] |= 0x00000001u;
  return challenge_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::release_challenge_url() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaQR_Response.challenge_url)
  if (!_internal_has_challenge_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = challenge_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (challenge_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::set_allocated_challenge_url(std::string* challenge_url) {
  if (challenge_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  challenge_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), challenge_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (challenge_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaQR_Response.challenge_url)
}

// optional bytes request_id = 3 [(.description) = "unique request ID to be presented by requestor at poll time - must not be rendered in QR"];
inline bool CAuthentication_BeginAuthSessionViaQR_Response::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Response::has_request_id() const {
  return _internal_has_request_id();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_request_id() {
  request_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Response::request_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaQR_Response::set_request_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 request_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Response.request_id)
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Response.request_id)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaQR_Response::_internal_request_id() const {
  return request_id_.Get();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::_internal_set_request_id(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::_internal_mutable_request_id() {
  _has_bits_[0] |= 0x00000002u;
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaQR_Response::release_request_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaQR_Response.request_id)
  if (!_internal_has_request_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = request_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaQR_Response.request_id)
}

// optional float interval = 4 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
inline bool CAuthentication_BeginAuthSessionViaQR_Response::_internal_has_interval() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Response::has_interval() const {
  return _internal_has_interval();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_interval() {
  interval_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CAuthentication_BeginAuthSessionViaQR_Response::_internal_interval() const {
  return interval_;
}
inline float CAuthentication_BeginAuthSessionViaQR_Response::interval() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.interval)
  return _internal_interval();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::_internal_set_interval(float value) {
  _has_bits_[0] |= 0x00000008u;
  interval_ = value;
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::set_interval(float value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Response.interval)
}

// repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 5 [(.description) = "the confirmation types that will be able to confirm the request"];
inline int CAuthentication_BeginAuthSessionViaQR_Response::_internal_allowed_confirmations_size() const {
  return allowed_confirmations_.size();
}
inline int CAuthentication_BeginAuthSessionViaQR_Response::allowed_confirmations_size() const {
  return _internal_allowed_confirmations_size();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_allowed_confirmations() {
  allowed_confirmations_.Clear();
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaQR_Response::mutable_allowed_confirmations(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaQR_Response.allowed_confirmations)
  return allowed_confirmations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >*
CAuthentication_BeginAuthSessionViaQR_Response::mutable_allowed_confirmations() {
  // @@protoc_insertion_point(field_mutable_list:CAuthentication_BeginAuthSessionViaQR_Response.allowed_confirmations)
  return &allowed_confirmations_;
}
inline const ::CAuthentication_AllowedConfirmation& CAuthentication_BeginAuthSessionViaQR_Response::_internal_allowed_confirmations(int index) const {
  return allowed_confirmations_.Get(index);
}
inline const ::CAuthentication_AllowedConfirmation& CAuthentication_BeginAuthSessionViaQR_Response::allowed_confirmations(int index) const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.allowed_confirmations)
  return _internal_allowed_confirmations(index);
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaQR_Response::_internal_add_allowed_confirmations() {
  return allowed_confirmations_.Add();
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaQR_Response::add_allowed_confirmations() {
  ::CAuthentication_AllowedConfirmation* _add = _internal_add_allowed_confirmations();
  // @@protoc_insertion_point(field_add:CAuthentication_BeginAuthSessionViaQR_Response.allowed_confirmations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >&
CAuthentication_BeginAuthSessionViaQR_Response::allowed_confirmations() const {
  // @@protoc_insertion_point(field_list:CAuthentication_BeginAuthSessionViaQR_Response.allowed_confirmations)
  return allowed_confirmations_;
}

// optional int32 version = 6 [(.description) = "version of the QR data"];
inline bool CAuthentication_BeginAuthSessionViaQR_Response::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaQR_Response::has_version() const {
  return _internal_has_version();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CAuthentication_BeginAuthSessionViaQR_Response::_internal_version() const {
  return version_;
}
inline int32_t CAuthentication_BeginAuthSessionViaQR_Response::version() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaQR_Response.version)
  return _internal_version();
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::_internal_set_version(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  version_ = value;
}
inline void CAuthentication_BeginAuthSessionViaQR_Response::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaQR_Response.version)
}

// -------------------------------------------------------------------

// CAuthentication_BeginAuthSessionViaCredentials_Request

// optional string device_friendly_name = 1;
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_device_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_device_friendly_name() const {
  return _internal_has_device_friendly_name();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_device_friendly_name() {
  device_friendly_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::device_friendly_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name)
  return _internal_device_friendly_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Request::set_device_friendly_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_device_friendly_name() {
  std::string* _s = _internal_mutable_device_friendly_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_device_friendly_name() const {
  return device_friendly_name_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_device_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_device_friendly_name() {
  _has_bits_[0] |= 0x00000001u;
  return device_friendly_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::release_device_friendly_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name)
  if (!_internal_has_device_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_friendly_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_device_friendly_name(std::string* device_friendly_name) {
  if (device_friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_friendly_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_friendly_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name)
}

// optional string account_name = 2;
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_account_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_account_name() const {
  return _internal_has_account_name();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_account_name() {
  account_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::account_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Request::set_account_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.account_name)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.account_name)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_account_name() const {
  return account_name_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_account_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_account_name() {
  _has_bits_[0] |= 0x00000002u;
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::release_account_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = account_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.account_name)
}

// optional string encrypted_password = 3 [(.description) = "password, RSA encrypted client side"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_encrypted_password() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_encrypted_password() const {
  return _internal_has_encrypted_password();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_encrypted_password() {
  encrypted_password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::encrypted_password() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password)
  return _internal_encrypted_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Request::set_encrypted_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 encrypted_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_encrypted_password() {
  std::string* _s = _internal_mutable_encrypted_password();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_encrypted_password() const {
  return encrypted_password_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_encrypted_password(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  encrypted_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_encrypted_password() {
  _has_bits_[0] |= 0x00000004u;
  return encrypted_password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::release_encrypted_password() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password)
  if (!_internal_has_encrypted_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = encrypted_password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_encrypted_password(std::string* encrypted_password) {
  if (encrypted_password != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encrypted_password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password)
}

// optional uint64 encryption_timestamp = 4 [(.description) = "timestamp to map to a key - STime"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_encryption_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_encryption_timestamp() const {
  return _internal_has_encryption_timestamp();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_encryption_timestamp() {
  encryption_timestamp_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_encryption_timestamp() const {
  return encryption_timestamp_;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Request::encryption_timestamp() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.encryption_timestamp)
  return _internal_encryption_timestamp();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_encryption_timestamp(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  encryption_timestamp_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_encryption_timestamp(uint64_t value) {
  _internal_set_encryption_timestamp(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.encryption_timestamp)
}

// optional bool remember_login = 5 [(.description) = "deprecated"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_remember_login() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_remember_login() const {
  return _internal_has_remember_login();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_remember_login() {
  remember_login_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_remember_login() const {
  return remember_login_;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::remember_login() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.remember_login)
  return _internal_remember_login();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_remember_login(bool value) {
  _has_bits_[0] |= 0x00000080u;
  remember_login_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_remember_login(bool value) {
  _internal_set_remember_login(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.remember_login)
}

// optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::EAuthTokenPlatformType CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CAuthentication_BeginAuthSessionViaCredentials_Request::platform_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.platform_type)
  return _internal_platform_type();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  platform_type_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.platform_type)
}

// optional .ESessionPersistence persistence = 7 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_persistence() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_persistence() const {
  return _internal_has_persistence();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_persistence() {
  persistence_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::ESessionPersistence CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_persistence() const {
  return static_cast< ::ESessionPersistence >(persistence_);
}
inline ::ESessionPersistence CAuthentication_BeginAuthSessionViaCredentials_Request::persistence() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.persistence)
  return _internal_persistence();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_persistence(::ESessionPersistence value) {
  assert(::ESessionPersistence_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  persistence_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_persistence(::ESessionPersistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.persistence)
}

// optional string website_id = 8 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_website_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_website_id() const {
  return _internal_has_website_id();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_website_id() {
  website_id_.ClearToDefault(::CAuthentication_BeginAuthSessionViaCredentials_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::website_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.website_id)
  if (website_id_.IsDefault(nullptr)) return _i_give_permission_to_break_this_code_default_website_id_.get();
  return _internal_website_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Request::set_website_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.website_id)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_website_id() {
  std::string* _s = _internal_mutable_website_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.website_id)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_website_id() const {
  return website_id_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_website_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_website_id() {
  _has_bits_[0] |= 0x00000008u;
  return website_id_.Mutable(::CAuthentication_BeginAuthSessionViaCredentials_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::release_website_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.website_id)
  if (!_internal_has_website_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = website_id_.ReleaseNonDefault(nullptr, GetArenaForAllocation());
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_website_id(std::string* website_id) {
  if (website_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  website_id_.SetAllocated(nullptr, website_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.website_id)
}

// optional .CAuthentication_DeviceDetails device_details = 9 [(.description) = "User-supplied details about the device attempting to sign in"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_device_details() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || device_details_ != nullptr);
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_device_details() const {
  return _internal_has_device_details();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_device_details() {
  if (device_details_ != nullptr) device_details_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::CAuthentication_DeviceDetails& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_device_details() const {
  const ::CAuthentication_DeviceDetails* p = device_details_;
  return p != nullptr ? *p : reinterpret_cast<const ::CAuthentication_DeviceDetails&>(
      ::_CAuthentication_DeviceDetails_default_instance_);
}
inline const ::CAuthentication_DeviceDetails& CAuthentication_BeginAuthSessionViaCredentials_Request::device_details() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.device_details)
  return _internal_device_details();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::unsafe_arena_set_allocated_device_details(
    ::CAuthentication_DeviceDetails* device_details) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(device_details_);
  }
  device_details_ = device_details;
  if (device_details) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.device_details)
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaCredentials_Request::release_device_details() {
  _has_bits_[0] &= ~0x00000020u;
  ::CAuthentication_DeviceDetails* temp = device_details_;
  device_details_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaCredentials_Request::unsafe_arena_release_device_details() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.device_details)
  _has_bits_[0] &= ~0x00000020u;
  ::CAuthentication_DeviceDetails* temp = device_details_;
  device_details_ = nullptr;
  return temp;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_device_details() {
  _has_bits_[0] |= 0x00000020u;
  if (device_details_ == nullptr) {
    auto* p = CreateMaybeMessage<::CAuthentication_DeviceDetails>(GetArenaForAllocation());
    device_details_ = p;
  }
  return device_details_;
}
inline ::CAuthentication_DeviceDetails* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_device_details() {
  ::CAuthentication_DeviceDetails* _msg = _internal_mutable_device_details();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.device_details)
  return _msg;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_device_details(::CAuthentication_DeviceDetails* device_details) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete device_details_;
  }
  if (device_details) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CAuthentication_DeviceDetails>::GetOwningArena(device_details);
    if (message_arena != submessage_arena) {
      device_details = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, device_details, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  device_details_ = device_details;
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.device_details)
}

// optional string guard_data = 10 [(.description) = "steam guard data for client login"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_guard_data() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_guard_data() const {
  return _internal_has_guard_data();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_guard_data() {
  guard_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::guard_data() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data)
  return _internal_guard_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Request::set_guard_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::mutable_guard_data() {
  std::string* _s = _internal_mutable_guard_data();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_guard_data() const {
  return guard_data_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_guard_data(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_mutable_guard_data() {
  _has_bits_[0] |= 0x00000010u;
  return guard_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Request::release_guard_data() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data)
  if (!_internal_has_guard_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = guard_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guard_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_allocated_guard_data(std::string* guard_data) {
  if (guard_data != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  guard_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), guard_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (guard_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data)
}

// optional uint32 language = 11;
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_language() const {
  return _internal_has_language();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_language() {
  language_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_language() const {
  return language_;
}
inline uint32_t CAuthentication_BeginAuthSessionViaCredentials_Request::language() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.language)
  return _internal_language();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_language(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  language_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_language(uint32_t value) {
  _internal_set_language(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.language)
}

// optional int32 qos_level = 12 [default = 2, (.description) = "[ENetQOSLevel] client-specified priority for this auth attempt"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_has_qos_level() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Request::has_qos_level() const {
  return _internal_has_qos_level();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::clear_qos_level() {
  qos_level_ = 2;
  _has_bits_[0] &= ~0x00000800u;
}
inline int32_t CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_qos_level() const {
  return qos_level_;
}
inline int32_t CAuthentication_BeginAuthSessionViaCredentials_Request::qos_level() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Request.qos_level)
  return _internal_qos_level();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::_internal_set_qos_level(int32_t value) {
  _has_bits_[0] |= 0x00000800u;
  qos_level_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Request::set_qos_level(int32_t value) {
  _internal_set_qos_level(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Request.qos_level)
}

// -------------------------------------------------------------------

// CAuthentication_BeginAuthSessionViaCredentials_Response

// optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Response::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.client_id)
  return _internal_client_id();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  client_id_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.client_id)
}

// optional bytes request_id = 2 [(.description) = "unique request ID to be presented by requestor at poll time - must not be transferred or displayed"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_request_id() const {
  return _internal_has_request_id();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_request_id() {
  request_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::request_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Response::set_request_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 request_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.request_id)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Response.request_id)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_request_id() const {
  return request_id_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_request_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_mutable_request_id() {
  _has_bits_[0] |= 0x00000001u;
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::release_request_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Response.request_id)
  if (!_internal_has_request_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = request_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Response.request_id)
}

// optional float interval = 3 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_interval() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_interval() const {
  return _internal_has_interval();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_interval() {
  interval_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_interval() const {
  return interval_;
}
inline float CAuthentication_BeginAuthSessionViaCredentials_Response::interval() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.interval)
  return _internal_interval();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_interval(float value) {
  _has_bits_[0] |= 0x00000040u;
  interval_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_interval(float value) {
  _internal_set_interval(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.interval)
}

// repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 4 [(.description) = "the confirmation types that will be able to confirm the request"];
inline int CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_allowed_confirmations_size() const {
  return allowed_confirmations_.size();
}
inline int CAuthentication_BeginAuthSessionViaCredentials_Response::allowed_confirmations_size() const {
  return _internal_allowed_confirmations_size();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_allowed_confirmations() {
  allowed_confirmations_.Clear();
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_allowed_confirmations(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Response.allowed_confirmations)
  return allowed_confirmations_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >*
CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_allowed_confirmations() {
  // @@protoc_insertion_point(field_mutable_list:CAuthentication_BeginAuthSessionViaCredentials_Response.allowed_confirmations)
  return &allowed_confirmations_;
}
inline const ::CAuthentication_AllowedConfirmation& CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_allowed_confirmations(int index) const {
  return allowed_confirmations_.Get(index);
}
inline const ::CAuthentication_AllowedConfirmation& CAuthentication_BeginAuthSessionViaCredentials_Response::allowed_confirmations(int index) const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.allowed_confirmations)
  return _internal_allowed_confirmations(index);
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_add_allowed_confirmations() {
  return allowed_confirmations_.Add();
}
inline ::CAuthentication_AllowedConfirmation* CAuthentication_BeginAuthSessionViaCredentials_Response::add_allowed_confirmations() {
  ::CAuthentication_AllowedConfirmation* _add = _internal_add_allowed_confirmations();
  // @@protoc_insertion_point(field_add:CAuthentication_BeginAuthSessionViaCredentials_Response.allowed_confirmations)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_AllowedConfirmation >&
CAuthentication_BeginAuthSessionViaCredentials_Response::allowed_confirmations() const {
  // @@protoc_insertion_point(field_list:CAuthentication_BeginAuthSessionViaCredentials_Response.allowed_confirmations)
  return allowed_confirmations_;
}

// optional uint64 steamid = 5 [(.description) = "steamid of the account logging in - will only be included if the credentials were correct"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_BeginAuthSessionViaCredentials_Response::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.steamid)
  return _internal_steamid();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  steamid_ = value;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.steamid)
}

// optional string weak_token = 6 [(.description) = "partial-authentication token - limited lifetime and scope, included only if credentials were valid"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_weak_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_weak_token() const {
  return _internal_has_weak_token();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_weak_token() {
  weak_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::weak_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token)
  return _internal_weak_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Response::set_weak_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 weak_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_weak_token() {
  std::string* _s = _internal_mutable_weak_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_weak_token() const {
  return weak_token_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_weak_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  weak_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_mutable_weak_token() {
  _has_bits_[0] |= 0x00000002u;
  return weak_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::release_weak_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token)
  if (!_internal_has_weak_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = weak_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weak_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    weak_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_allocated_weak_token(std::string* weak_token) {
  if (weak_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  weak_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), weak_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (weak_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    weak_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token)
}

// optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_agreement_session_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_agreement_session_url() const {
  return _internal_has_agreement_session_url();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_agreement_session_url() {
  agreement_session_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::agreement_session_url() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url)
  return _internal_agreement_session_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Response::set_agreement_session_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_agreement_session_url() {
  std::string* _s = _internal_mutable_agreement_session_url();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_agreement_session_url() const {
  return agreement_session_url_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_agreement_session_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_mutable_agreement_session_url() {
  _has_bits_[0] |= 0x00000004u;
  return agreement_session_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::release_agreement_session_url() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url)
  if (!_internal_has_agreement_session_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = agreement_session_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_allocated_agreement_session_url(std::string* agreement_session_url) {
  if (agreement_session_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  agreement_session_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agreement_session_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url)
}

// optional string extended_error_message = 8 [(.description) = "error string to display if supported by the client"];
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_has_extended_error_message() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_BeginAuthSessionViaCredentials_Response::has_extended_error_message() const {
  return _internal_has_extended_error_message();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::clear_extended_error_message() {
  extended_error_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::extended_error_message() const {
  // @@protoc_insertion_point(field_get:CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message)
  return _internal_extended_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_BeginAuthSessionViaCredentials_Response::set_extended_error_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 extended_error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message)
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::mutable_extended_error_message() {
  std::string* _s = _internal_mutable_extended_error_message();
  // @@protoc_insertion_point(field_mutable:CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message)
  return _s;
}
inline const std::string& CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_extended_error_message() const {
  return extended_error_message_.Get();
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_set_extended_error_message(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  extended_error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::_internal_mutable_extended_error_message() {
  _has_bits_[0] |= 0x00000008u;
  return extended_error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_BeginAuthSessionViaCredentials_Response::release_extended_error_message() {
  // @@protoc_insertion_point(field_release:CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message)
  if (!_internal_has_extended_error_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = extended_error_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extended_error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extended_error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_BeginAuthSessionViaCredentials_Response::set_allocated_extended_error_message(std::string* extended_error_message) {
  if (extended_error_message != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  extended_error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), extended_error_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (extended_error_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    extended_error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message)
}

// -------------------------------------------------------------------

// CAuthentication_PollAuthSessionStatus_Request

// optional uint64 client_id = 1;
inline bool CAuthentication_PollAuthSessionStatus_Request::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Request::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_PollAuthSessionStatus_Request::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Request::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Request::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Request.client_id)
  return _internal_client_id();
}
inline void CAuthentication_PollAuthSessionStatus_Request::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_id_ = value;
}
inline void CAuthentication_PollAuthSessionStatus_Request::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Request.client_id)
}

// optional bytes request_id = 2;
inline bool CAuthentication_PollAuthSessionStatus_Request::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Request::has_request_id() const {
  return _internal_has_request_id();
}
inline void CAuthentication_PollAuthSessionStatus_Request::clear_request_id() {
  request_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Request::request_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Request.request_id)
  return _internal_request_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Request::set_request_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 request_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Request.request_id)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Request::mutable_request_id() {
  std::string* _s = _internal_mutable_request_id();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Request.request_id)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Request::_internal_request_id() const {
  return request_id_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Request::_internal_set_request_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Request::_internal_mutable_request_id() {
  _has_bits_[0] |= 0x00000001u;
  return request_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Request::release_request_id() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Request.request_id)
  if (!_internal_has_request_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = request_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Request::set_allocated_request_id(std::string* request_id) {
  if (request_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  request_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), request_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (request_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Request.request_id)
}

// optional fixed64 token_to_revoke = 3 [(.description) = "If this is set to a token owned by this user, that token will be retired"];
inline bool CAuthentication_PollAuthSessionStatus_Request::_internal_has_token_to_revoke() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Request::has_token_to_revoke() const {
  return _internal_has_token_to_revoke();
}
inline void CAuthentication_PollAuthSessionStatus_Request::clear_token_to_revoke() {
  token_to_revoke_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Request::_internal_token_to_revoke() const {
  return token_to_revoke_;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Request::token_to_revoke() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Request.token_to_revoke)
  return _internal_token_to_revoke();
}
inline void CAuthentication_PollAuthSessionStatus_Request::_internal_set_token_to_revoke(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  token_to_revoke_ = value;
}
inline void CAuthentication_PollAuthSessionStatus_Request::set_token_to_revoke(uint64_t value) {
  _internal_set_token_to_revoke(value);
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Request.token_to_revoke)
}

// -------------------------------------------------------------------

// CAuthentication_PollAuthSessionStatus_Response

// optional uint64 new_client_id = 1 [(.description) = "if challenge is old, this is the new client id"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_new_client_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_new_client_id() const {
  return _internal_has_new_client_id();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_new_client_id() {
  new_client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Response::_internal_new_client_id() const {
  return new_client_id_;
}
inline uint64_t CAuthentication_PollAuthSessionStatus_Response::new_client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.new_client_id)
  return _internal_new_client_id();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_new_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  new_client_id_ = value;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_new_client_id(uint64_t value) {
  _internal_set_new_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.new_client_id)
}

// optional string new_challenge_url = 2 [(.description) = "if challenge is old, this is the new challenge ID to re-render for mobile confirmation"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_new_challenge_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_new_challenge_url() const {
  return _internal_has_new_challenge_url();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_new_challenge_url() {
  new_challenge_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::new_challenge_url() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.new_challenge_url)
  return _internal_new_challenge_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_new_challenge_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 new_challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.new_challenge_url)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_new_challenge_url() {
  std::string* _s = _internal_mutable_new_challenge_url();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.new_challenge_url)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_new_challenge_url() const {
  return new_challenge_url_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_new_challenge_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  new_challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_new_challenge_url() {
  _has_bits_[0] |= 0x00000001u;
  return new_challenge_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_new_challenge_url() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.new_challenge_url)
  if (!_internal_has_new_challenge_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = new_challenge_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_challenge_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_new_challenge_url(std::string* new_challenge_url) {
  if (new_challenge_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  new_challenge_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_challenge_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_challenge_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.new_challenge_url)
}

// optional string refresh_token = 3 [(.description) = "if login has been confirmed, this is the requestor\'s new refresh token"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_refresh_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_refresh_token() {
  refresh_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::refresh_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.refresh_token)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.refresh_token)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_refresh_token() const {
  return refresh_token_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_refresh_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_refresh_token() {
  _has_bits_[0] |= 0x00000002u;
  return refresh_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_refresh_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.refresh_token)
  if (!_internal_has_refresh_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = refresh_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  refresh_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.refresh_token)
}

// optional string access_token = 4 [(.description) = "if login has been confirmed, this is a new token subordinate to refresh_token"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_access_token() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_access_token() const {
  return _internal_has_access_token();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_access_token() {
  access_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::access_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_access_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.access_token)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.access_token)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_access_token() const {
  return access_token_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_access_token(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_access_token() {
  _has_bits_[0] |= 0x00000004u;
  return access_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_access_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.access_token)
  if (!_internal_has_access_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = access_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  access_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.access_token)
}

// optional bool had_remote_interaction = 5 [(.description) = "whether or not the auth session appears to have had remote interaction from a potential confirmer"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_had_remote_interaction() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_had_remote_interaction() const {
  return _internal_has_had_remote_interaction();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_had_remote_interaction() {
  had_remote_interaction_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_had_remote_interaction() const {
  return had_remote_interaction_;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::had_remote_interaction() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.had_remote_interaction)
  return _internal_had_remote_interaction();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_had_remote_interaction(bool value) {
  _has_bits_[0] |= 0x00000080u;
  had_remote_interaction_ = value;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_had_remote_interaction(bool value) {
  _internal_set_had_remote_interaction(value);
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.had_remote_interaction)
}

// optional string account_name = 6 [(.description) = "account name of authenticating account, for use by UI layer"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_account_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_account_name() const {
  return _internal_has_account_name();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_account_name() {
  account_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::account_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.account_name)
  return _internal_account_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_account_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.account_name)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_account_name() {
  std::string* _s = _internal_mutable_account_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.account_name)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_account_name() const {
  return account_name_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_account_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_account_name() {
  _has_bits_[0] |= 0x00000008u;
  return account_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_account_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.account_name)
  if (!_internal_has_account_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = account_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_account_name(std::string* account_name) {
  if (account_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  account_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.account_name)
}

// optional string new_guard_data = 7 [(.description) = "if login has been confirmed, may contain remembered machine ID for future login"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_new_guard_data() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_new_guard_data() const {
  return _internal_has_new_guard_data();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_new_guard_data() {
  new_guard_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::new_guard_data() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.new_guard_data)
  return _internal_new_guard_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_new_guard_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 new_guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.new_guard_data)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_new_guard_data() {
  std::string* _s = _internal_mutable_new_guard_data();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.new_guard_data)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_new_guard_data() const {
  return new_guard_data_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_new_guard_data(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  new_guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_new_guard_data() {
  _has_bits_[0] |= 0x00000010u;
  return new_guard_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_new_guard_data() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.new_guard_data)
  if (!_internal_has_new_guard_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = new_guard_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_guard_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_new_guard_data(std::string* new_guard_data) {
  if (new_guard_data != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  new_guard_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), new_guard_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (new_guard_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    new_guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.new_guard_data)
}

// optional string agreement_session_url = 8 [(.description) = "agreement the user needs to agree to"];
inline bool CAuthentication_PollAuthSessionStatus_Response::_internal_has_agreement_session_url() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_PollAuthSessionStatus_Response::has_agreement_session_url() const {
  return _internal_has_agreement_session_url();
}
inline void CAuthentication_PollAuthSessionStatus_Response::clear_agreement_session_url() {
  agreement_session_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::agreement_session_url() const {
  // @@protoc_insertion_point(field_get:CAuthentication_PollAuthSessionStatus_Response.agreement_session_url)
  return _internal_agreement_session_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_PollAuthSessionStatus_Response::set_agreement_session_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_PollAuthSessionStatus_Response.agreement_session_url)
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::mutable_agreement_session_url() {
  std::string* _s = _internal_mutable_agreement_session_url();
  // @@protoc_insertion_point(field_mutable:CAuthentication_PollAuthSessionStatus_Response.agreement_session_url)
  return _s;
}
inline const std::string& CAuthentication_PollAuthSessionStatus_Response::_internal_agreement_session_url() const {
  return agreement_session_url_.Get();
}
inline void CAuthentication_PollAuthSessionStatus_Response::_internal_set_agreement_session_url(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::_internal_mutable_agreement_session_url() {
  _has_bits_[0] |= 0x00000020u;
  return agreement_session_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_PollAuthSessionStatus_Response::release_agreement_session_url() {
  // @@protoc_insertion_point(field_release:CAuthentication_PollAuthSessionStatus_Response.agreement_session_url)
  if (!_internal_has_agreement_session_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = agreement_session_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_PollAuthSessionStatus_Response::set_allocated_agreement_session_url(std::string* agreement_session_url) {
  if (agreement_session_url != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  agreement_session_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agreement_session_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_PollAuthSessionStatus_Response.agreement_session_url)
}

// -------------------------------------------------------------------

// CAuthentication_GetAuthSessionInfo_Request

// optional uint64 client_id = 1 [(.description) = "client ID from scanned QR Code, used for routing"];
inline bool CAuthentication_GetAuthSessionInfo_Request::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Request::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_GetAuthSessionInfo_Request::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthentication_GetAuthSessionInfo_Request::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_GetAuthSessionInfo_Request::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Request.client_id)
  return _internal_client_id();
}
inline void CAuthentication_GetAuthSessionInfo_Request::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  client_id_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Request::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Request.client_id)
}

// -------------------------------------------------------------------

// CAuthentication_GetAuthSessionInfo_Response

// optional string ip = 1 [(.description) = "IP address of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_ip() const {
  return _internal_has_ip();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_ip() {
  ip_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::ip() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_ip(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.ip)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.ip)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_ip() const {
  return ip_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_ip(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_ip() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.ip)
  if (!_internal_has_ip()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = ip_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (ip_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.ip)
}

// optional string geoloc = 2 [(.description) = "geoloc info of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_geoloc() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_geoloc() const {
  return _internal_has_geoloc();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_geoloc() {
  geoloc_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::geoloc() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.geoloc)
  return _internal_geoloc();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_geoloc(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 geoloc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.geoloc)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_geoloc() {
  std::string* _s = _internal_mutable_geoloc();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.geoloc)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_geoloc() const {
  return geoloc_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_geoloc(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  geoloc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_geoloc() {
  _has_bits_[0] |= 0x00000002u;
  return geoloc_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_geoloc() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.geoloc)
  if (!_internal_has_geoloc()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = geoloc_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (geoloc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    geoloc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_geoloc(std::string* geoloc) {
  if (geoloc != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  geoloc_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), geoloc,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (geoloc_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    geoloc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.geoloc)
}

// optional string city = 3 [(.description) = "city of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_city() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_city() const {
  return _internal_has_city();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_city() {
  city_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::city() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_city(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.city)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.city)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_city() const {
  return city_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_city(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_city() {
  _has_bits_[0] |= 0x00000004u;
  return city_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_city() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.city)
  if (!_internal_has_city()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = city_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  city_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), city,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.city)
}

// optional string state = 4 [(.description) = "state of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_state() const {
  return _internal_has_state();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::state() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.state)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.state)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_state() const {
  return state_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000008u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_state() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.state)
}

// optional string country = 5 [(.description) = "country of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_country() const {
  return _internal_has_country();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::country() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.country)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.country)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_country() const {
  return country_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000010u;
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_country() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.country)
}

// optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "platform type of requestor"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::EAuthTokenPlatformType CAuthentication_GetAuthSessionInfo_Response::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CAuthentication_GetAuthSessionInfo_Response::platform_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.platform_type)
  return _internal_platform_type();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  platform_type_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.platform_type)
}

// optional string device_friendly_name = 7 [(.description) = "name of requestor device"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_device_friendly_name() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_device_friendly_name() const {
  return _internal_has_device_friendly_name();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_device_friendly_name() {
  device_friendly_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::device_friendly_name() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.device_friendly_name)
  return _internal_device_friendly_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_GetAuthSessionInfo_Response::set_device_friendly_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.device_friendly_name)
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::mutable_device_friendly_name() {
  std::string* _s = _internal_mutable_device_friendly_name();
  // @@protoc_insertion_point(field_mutable:CAuthentication_GetAuthSessionInfo_Response.device_friendly_name)
  return _s;
}
inline const std::string& CAuthentication_GetAuthSessionInfo_Response::_internal_device_friendly_name() const {
  return device_friendly_name_.Get();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_device_friendly_name(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::_internal_mutable_device_friendly_name() {
  _has_bits_[0] |= 0x00000020u;
  return device_friendly_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_GetAuthSessionInfo_Response::release_device_friendly_name() {
  // @@protoc_insertion_point(field_release:CAuthentication_GetAuthSessionInfo_Response.device_friendly_name)
  if (!_internal_has_device_friendly_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = device_friendly_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_allocated_device_friendly_name(std::string* device_friendly_name) {
  if (device_friendly_name != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  device_friendly_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_friendly_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_friendly_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_GetAuthSessionInfo_Response.device_friendly_name)
}

// optional int32 version = 8 [(.description) = "version field"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_version() const {
  return _internal_has_version();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t CAuthentication_GetAuthSessionInfo_Response::_internal_version() const {
  return version_;
}
inline int32_t CAuthentication_GetAuthSessionInfo_Response::version() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.version)
  return _internal_version();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_version(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  version_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.version)
}

// optional .EAuthSessionSecurityHistory login_history = 9 [default = k_EAuthSessionSecurityHistory_Invalid, (.description) = "whether the ip has previuously been used on the account successfully"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_login_history() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_login_history() const {
  return _internal_has_login_history();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_login_history() {
  login_history_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::EAuthSessionSecurityHistory CAuthentication_GetAuthSessionInfo_Response::_internal_login_history() const {
  return static_cast< ::EAuthSessionSecurityHistory >(login_history_);
}
inline ::EAuthSessionSecurityHistory CAuthentication_GetAuthSessionInfo_Response::login_history() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.login_history)
  return _internal_login_history();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_login_history(::EAuthSessionSecurityHistory value) {
  assert(::EAuthSessionSecurityHistory_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  login_history_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_login_history(::EAuthSessionSecurityHistory value) {
  _internal_set_login_history(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.login_history)
}

// optional bool requestor_location_mismatch = 10 [(.description) = "whether the requestor location matches this requests location"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_requestor_location_mismatch() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_requestor_location_mismatch() const {
  return _internal_has_requestor_location_mismatch();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_requestor_location_mismatch() {
  requestor_location_mismatch_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_requestor_location_mismatch() const {
  return requestor_location_mismatch_;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::requestor_location_mismatch() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.requestor_location_mismatch)
  return _internal_requestor_location_mismatch();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_requestor_location_mismatch(bool value) {
  _has_bits_[0] |= 0x00000200u;
  requestor_location_mismatch_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_requestor_location_mismatch(bool value) {
  _internal_set_requestor_location_mismatch(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.requestor_location_mismatch)
}

// optional bool high_usage_login = 11 [(.description) = "whether this login has seen high usage recently"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_high_usage_login() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_high_usage_login() const {
  return _internal_has_high_usage_login();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_high_usage_login() {
  high_usage_login_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_high_usage_login() const {
  return high_usage_login_;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::high_usage_login() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.high_usage_login)
  return _internal_high_usage_login();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_high_usage_login(bool value) {
  _has_bits_[0] |= 0x00000400u;
  high_usage_login_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_high_usage_login(bool value) {
  _internal_set_high_usage_login(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.high_usage_login)
}

// optional .ESessionPersistence requested_persistence = 12 [default = k_ESessionPersistence_Invalid, (.description) = "session persistence requestor has indicated they want"];
inline bool CAuthentication_GetAuthSessionInfo_Response::_internal_has_requested_persistence() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CAuthentication_GetAuthSessionInfo_Response::has_requested_persistence() const {
  return _internal_has_requested_persistence();
}
inline void CAuthentication_GetAuthSessionInfo_Response::clear_requested_persistence() {
  requested_persistence_ = -1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::ESessionPersistence CAuthentication_GetAuthSessionInfo_Response::_internal_requested_persistence() const {
  return static_cast< ::ESessionPersistence >(requested_persistence_);
}
inline ::ESessionPersistence CAuthentication_GetAuthSessionInfo_Response::requested_persistence() const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionInfo_Response.requested_persistence)
  return _internal_requested_persistence();
}
inline void CAuthentication_GetAuthSessionInfo_Response::_internal_set_requested_persistence(::ESessionPersistence value) {
  assert(::ESessionPersistence_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  requested_persistence_ = value;
}
inline void CAuthentication_GetAuthSessionInfo_Response::set_requested_persistence(::ESessionPersistence value) {
  _internal_set_requested_persistence(value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionInfo_Response.requested_persistence)
}

// -------------------------------------------------------------------

// CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request

// optional int32 version = 1 [(.description) = "version field"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_version() const {
  return _internal_has_version();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_version() const {
  return version_;
}
inline int32_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::version() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.version)
  return _internal_version();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_version(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  version_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.version)
}

// optional uint64 client_id = 2 [(.description) = "pending client ID, from scanned QR Code"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.client_id)
  return _internal_client_id();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_id_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.client_id)
}

// optional fixed64 steamid = 3 [(.description) = "user who wants to login"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.steamid)
  return _internal_steamid();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.steamid)
}

// optional bytes signature = 4 [(.description) = "HMAC digest over {version,client_id,steamid} via user\'s private key"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_signature() const {
  return _internal_has_signature();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::signature() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.signature)
}
inline std::string* CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.signature)
  return _s;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_signature() const {
  return signature_.Get();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::release_signature() {
  // @@protoc_insertion_point(field_release:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.signature)
}

// optional bool confirm = 5 [default = false, (.description) = "Whether to confirm the login (true) or deny the login (false)"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_confirm() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_confirm() const {
  return _internal_has_confirm();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_confirm() {
  confirm_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_confirm() const {
  return confirm_;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::confirm() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.confirm)
  return _internal_confirm();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_confirm(bool value) {
  _has_bits_[0] |= 0x00000010u;
  confirm_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_confirm(bool value) {
  _internal_set_confirm(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.confirm)
}

// optional .ESessionPersistence persistence = 6 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_has_persistence() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::has_persistence() const {
  return _internal_has_persistence();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::clear_persistence() {
  persistence_ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::ESessionPersistence CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_persistence() const {
  return static_cast< ::ESessionPersistence >(persistence_);
}
inline ::ESessionPersistence CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::persistence() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.persistence)
  return _internal_persistence();
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_internal_set_persistence(::ESessionPersistence value) {
  assert(::ESessionPersistence_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  persistence_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::set_persistence(::ESessionPersistence value) {
  _internal_set_persistence(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request.persistence)
}

// -------------------------------------------------------------------

// CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response

// -------------------------------------------------------------------

// CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request

// optional uint64 client_id = 1 [(.description) = "pending client ID, from initialized session"];
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::has_client_id() const {
  return _internal_has_client_id();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::client_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.client_id)
  return _internal_client_id();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_id_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.client_id)
}

// optional fixed64 steamid = 2 [(.description) = "user who wants to login"];
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.steamid)
  return _internal_steamid();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.steamid)
}

// optional string code = 3 [(.description) = "confirmation code"];
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_has_code() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::has_code() const {
  return _internal_has_code();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::clear_code() {
  code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::code() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::set_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code)
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code)
  return _s;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_code() const {
  return code_.Get();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_set_code(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_mutable_code() {
  _has_bits_[0] |= 0x00000001u;
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::release_code() {
  // @@protoc_insertion_point(field_release:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code)
  if (!_internal_has_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code)
}

// optional .EAuthSessionGuardType code_type = 4 [default = k_EAuthSessionGuardType_Unknown, (.description) = "type of confirmation code"];
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_has_code_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::has_code_type() const {
  return _internal_has_code_type();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::clear_code_type() {
  code_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EAuthSessionGuardType CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_code_type() const {
  return static_cast< ::EAuthSessionGuardType >(code_type_);
}
inline ::EAuthSessionGuardType CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::code_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code_type)
  return _internal_code_type();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_internal_set_code_type(::EAuthSessionGuardType value) {
  assert(::EAuthSessionGuardType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  code_type_ = value;
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::set_code_type(::EAuthSessionGuardType value) {
  _internal_set_code_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code_type)
}

// -------------------------------------------------------------------

// CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response

// optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_internal_has_agreement_session_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::has_agreement_session_url() const {
  return _internal_has_agreement_session_url();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::clear_agreement_session_url() {
  agreement_session_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::agreement_session_url() const {
  // @@protoc_insertion_point(field_get:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url)
  return _internal_agreement_session_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::set_agreement_session_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url)
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::mutable_agreement_session_url() {
  std::string* _s = _internal_mutable_agreement_session_url();
  // @@protoc_insertion_point(field_mutable:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url)
  return _s;
}
inline const std::string& CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_internal_agreement_session_url() const {
  return agreement_session_url_.Get();
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_internal_set_agreement_session_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_internal_mutable_agreement_session_url() {
  _has_bits_[0] |= 0x00000001u;
  return agreement_session_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::release_agreement_session_url() {
  // @@protoc_insertion_point(field_release:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url)
  if (!_internal_has_agreement_session_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = agreement_session_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::set_allocated_agreement_session_url(std::string* agreement_session_url) {
  if (agreement_session_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  agreement_session_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), agreement_session_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (agreement_session_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url)
}

// -------------------------------------------------------------------

// CAuthentication_AccessToken_GenerateForApp_Request

// optional string refresh_token = 1;
inline bool CAuthentication_AccessToken_GenerateForApp_Request::_internal_has_refresh_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_AccessToken_GenerateForApp_Request::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::clear_refresh_token() {
  refresh_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Request::refresh_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AccessToken_GenerateForApp_Request.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_AccessToken_GenerateForApp_Request::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_AccessToken_GenerateForApp_Request.refresh_token)
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Request::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_AccessToken_GenerateForApp_Request.refresh_token)
  return _s;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Request::_internal_refresh_token() const {
  return refresh_token_.Get();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::_internal_set_refresh_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Request::_internal_mutable_refresh_token() {
  _has_bits_[0] |= 0x00000001u;
  return refresh_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Request::release_refresh_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_AccessToken_GenerateForApp_Request.refresh_token)
  if (!_internal_has_refresh_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = refresh_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  refresh_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_AccessToken_GenerateForApp_Request.refresh_token)
}

// optional fixed64 steamid = 2;
inline bool CAuthentication_AccessToken_GenerateForApp_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_AccessToken_GenerateForApp_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthentication_AccessToken_GenerateForApp_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_AccessToken_GenerateForApp_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AccessToken_GenerateForApp_Request.steamid)
  return _internal_steamid();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_AccessToken_GenerateForApp_Request.steamid)
}

// optional .ETokenRenewalType renewal_type = 3 [default = k_ETokenRenewalType_None];
inline bool CAuthentication_AccessToken_GenerateForApp_Request::_internal_has_renewal_type() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_AccessToken_GenerateForApp_Request::has_renewal_type() const {
  return _internal_has_renewal_type();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::clear_renewal_type() {
  renewal_type_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::ETokenRenewalType CAuthentication_AccessToken_GenerateForApp_Request::_internal_renewal_type() const {
  return static_cast< ::ETokenRenewalType >(renewal_type_);
}
inline ::ETokenRenewalType CAuthentication_AccessToken_GenerateForApp_Request::renewal_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AccessToken_GenerateForApp_Request.renewal_type)
  return _internal_renewal_type();
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::_internal_set_renewal_type(::ETokenRenewalType value) {
  assert(::ETokenRenewalType_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  renewal_type_ = value;
}
inline void CAuthentication_AccessToken_GenerateForApp_Request::set_renewal_type(::ETokenRenewalType value) {
  _internal_set_renewal_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_AccessToken_GenerateForApp_Request.renewal_type)
}

// -------------------------------------------------------------------

// CAuthentication_AccessToken_GenerateForApp_Response

// optional string access_token = 1;
inline bool CAuthentication_AccessToken_GenerateForApp_Response::_internal_has_access_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_AccessToken_GenerateForApp_Response::has_access_token() const {
  return _internal_has_access_token();
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::clear_access_token() {
  access_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Response::access_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AccessToken_GenerateForApp_Response.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_AccessToken_GenerateForApp_Response::set_access_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_AccessToken_GenerateForApp_Response.access_token)
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_AccessToken_GenerateForApp_Response.access_token)
  return _s;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Response::_internal_access_token() const {
  return access_token_.Get();
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::_internal_set_access_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::_internal_mutable_access_token() {
  _has_bits_[0] |= 0x00000001u;
  return access_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::release_access_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_AccessToken_GenerateForApp_Response.access_token)
  if (!_internal_has_access_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = access_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  access_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_AccessToken_GenerateForApp_Response.access_token)
}

// optional string refresh_token = 2;
inline bool CAuthentication_AccessToken_GenerateForApp_Response::_internal_has_refresh_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_AccessToken_GenerateForApp_Response::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::clear_refresh_token() {
  refresh_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Response::refresh_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_AccessToken_GenerateForApp_Response.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_AccessToken_GenerateForApp_Response::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_AccessToken_GenerateForApp_Response.refresh_token)
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_AccessToken_GenerateForApp_Response.refresh_token)
  return _s;
}
inline const std::string& CAuthentication_AccessToken_GenerateForApp_Response::_internal_refresh_token() const {
  return refresh_token_.Get();
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::_internal_set_refresh_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::_internal_mutable_refresh_token() {
  _has_bits_[0] |= 0x00000002u;
  return refresh_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_AccessToken_GenerateForApp_Response::release_refresh_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_AccessToken_GenerateForApp_Response.refresh_token)
  if (!_internal_has_refresh_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = refresh_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_AccessToken_GenerateForApp_Response::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  refresh_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_AccessToken_GenerateForApp_Response.refresh_token)
}

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Enumerate_Request

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent

// optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_time() const {
  return _internal_has_time();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_time() const {
  return time_;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::time() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.time)
  return _internal_time();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_set_time(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  time_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.time)
}

// optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || ip_ != nullptr);
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_ip() const {
  return _internal_has_ip();
}
inline const ::CMsgIPAddress& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_ip() const {
  const ::CMsgIPAddress* p = ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::ip() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.ip)
  return _internal_ip();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::unsafe_arena_set_allocated_ip(
    ::CMsgIPAddress* ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  ip_ = ip;
  if (ip) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.ip)
}
inline ::CMsgIPAddress* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::release_ip() {
  _has_bits_[0] &= ~0x00000010u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.ip)
  _has_bits_[0] &= ~0x00000010u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000010u;
  if (ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    ip_ = p;
  }
  return ip_;
}
inline ::CMsgIPAddress* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::mutable_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.ip)
  return _msg;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_allocated_ip(::CMsgIPAddress* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip));
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.ip)
}

// optional string locale = 3;
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_locale() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_locale() const {
  return _internal_has_locale();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_locale() {
  locale_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::locale() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale)
  return _internal_locale();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_locale(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale)
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::mutable_locale() {
  std::string* _s = _internal_mutable_locale();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_locale() const {
  return locale_.Get();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_set_locale(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_mutable_locale() {
  _has_bits_[0] |= 0x00000001u;
  return locale_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::release_locale() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale)
  if (!_internal_has_locale()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = locale_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_allocated_locale(std::string* locale) {
  if (locale != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  locale_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locale,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (locale_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale)
}

// optional string country = 4 [(.description) = "Location (country code) of event, as inferred from IP"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_country() const {
  return _internal_has_country();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::country() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country)
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_country() const {
  return country_.Get();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000002u;
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::release_country() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country)
}

// optional string state = 5 [(.description) = "Location (state code) of event, as inferred from IP"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_state() const {
  return _internal_has_state();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::state() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state)
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_state() const {
  return state_.Get();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000004u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::release_state() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state)
}

// optional string city = 6 [(.description) = "Location (city) of event, as inferred from IP"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_has_city() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::has_city() const {
  return _internal_has_city();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_city() {
  city_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::city() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_city(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city)
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_city() const {
  return city_.Get();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_set_city(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_internal_mutable_city() {
  _has_bits_[0] |= 0x00000008u;
  return city_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::release_city() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city)
  if (!_internal_has_city()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = city_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  city_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), city,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city)
}

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription

// optional fixed64 token_id = 1 [(.description) = "Persistent token/device identifier"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_token_id() const {
  return _internal_has_token_id();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::token_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_id)
  return _internal_token_id();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  token_id_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_id)
}

// optional string token_description = 2 [(.description) = "client-supplied friendly name for the device"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_token_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_token_description() const {
  return _internal_has_token_description();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_token_description() {
  token_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::token_description() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description)
  return _internal_token_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_token_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description)
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::mutable_token_description() {
  std::string* _s = _internal_mutable_token_description();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_token_description() const {
  return token_description_.Get();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_token_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_mutable_token_description() {
  _has_bits_[0] |= 0x00000001u;
  return token_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::release_token_description() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description)
  if (!_internal_has_token_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_allocated_token_description(std::string* token_description) {
  if (token_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description)
}

// optional uint32 time_updated = 3;
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_time_updated() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_time_updated() const {
  return _internal_has_time_updated();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_time_updated() {
  time_updated_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_time_updated() const {
  return time_updated_;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::time_updated() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.time_updated)
  return _internal_time_updated();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_time_updated(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  time_updated_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_time_updated(uint32_t value) {
  _internal_set_time_updated(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.time_updated)
}

// optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "gross platform type (mobile/client/browser)"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::EAuthTokenPlatformType CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::platform_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.platform_type)
  return _internal_platform_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  platform_type_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.platform_type)
}

// optional bool logged_in = 5 [(.description) = "If true, this token is currently valid. False indicates it is a machine token - ok for steamguard if you know the credential"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_logged_in() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_logged_in() const {
  return _internal_has_logged_in();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_logged_in() {
  logged_in_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_logged_in() const {
  return logged_in_;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::logged_in() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.logged_in)
  return _internal_logged_in();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_logged_in(bool value) {
  _has_bits_[0] |= 0x00000040u;
  logged_in_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_logged_in(bool value) {
  _internal_set_logged_in(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.logged_in)
}

// optional uint32 os_platform = 6 [(.description) = "EPlatformType - rough classification of device OS, if known"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_os_platform() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_os_platform() const {
  return _internal_has_os_platform();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_os_platform() {
  os_platform_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_os_platform() const {
  return os_platform_;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::os_platform() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.os_platform)
  return _internal_os_platform();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_os_platform(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  os_platform_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_os_platform(uint32_t value) {
  _internal_set_os_platform(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.os_platform)
}

// optional uint32 auth_type = 7 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_auth_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_auth_type() const {
  return _internal_has_auth_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_auth_type() {
  auth_type_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_auth_type() const {
  return auth_type_;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::auth_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.auth_type)
  return _internal_auth_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_auth_type(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  auth_type_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_auth_type(uint32_t value) {
  _internal_set_auth_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.auth_type)
}

// optional uint32 gaming_device_type = 8 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_gaming_device_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_gaming_device_type() const {
  return _internal_has_gaming_device_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_gaming_device_type() {
  gaming_device_type_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_gaming_device_type() const {
  return gaming_device_type_;
}
inline uint32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::gaming_device_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.gaming_device_type)
  return _internal_gaming_device_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_gaming_device_type(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  gaming_device_type_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_gaming_device_type(uint32_t value) {
  _internal_set_gaming_device_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.gaming_device_type)
}

// optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent first_seen = 9 [(.description) = "Information about original authorization event"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_first_seen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || first_seen_ != nullptr);
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_first_seen() const {
  return _internal_has_first_seen();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_first_seen() {
  if (first_seen_ != nullptr) first_seen_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_first_seen() const {
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* p = first_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&>(
      ::_CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_);
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::first_seen() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.first_seen)
  return _internal_first_seen();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::unsafe_arena_set_allocated_first_seen(
    ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* first_seen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_seen_);
  }
  first_seen_ = first_seen;
  if (first_seen) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.first_seen)
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::release_first_seen() {
  _has_bits_[0] &= ~0x00000002u;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* temp = first_seen_;
  first_seen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::unsafe_arena_release_first_seen() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.first_seen)
  _has_bits_[0] &= ~0x00000002u;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* temp = first_seen_;
  first_seen_ = nullptr;
  return temp;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_mutable_first_seen() {
  _has_bits_[0] |= 0x00000002u;
  if (first_seen_ == nullptr) {
    auto* p = CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>(GetArenaForAllocation());
    first_seen_ = p;
  }
  return first_seen_;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::mutable_first_seen() {
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* _msg = _internal_mutable_first_seen();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.first_seen)
  return _msg;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_allocated_first_seen(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* first_seen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete first_seen_;
  }
  if (first_seen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>::GetOwningArena(first_seen);
    if (message_arena != submessage_arena) {
      first_seen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_seen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  first_seen_ = first_seen;
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.first_seen)
}

// optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent last_seen = 10 [(.description) = "Information about most-recently seen, if known for this device"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_last_seen() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || last_seen_ != nullptr);
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_last_seen() const {
  return _internal_has_last_seen();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_last_seen() {
  if (last_seen_ != nullptr) last_seen_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_last_seen() const {
  const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* p = last_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&>(
      ::_CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_);
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::last_seen() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.last_seen)
  return _internal_last_seen();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::unsafe_arena_set_allocated_last_seen(
    ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* last_seen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_seen_);
  }
  last_seen_ = last_seen;
  if (last_seen) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.last_seen)
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::release_last_seen() {
  _has_bits_[0] &= ~0x00000004u;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* temp = last_seen_;
  last_seen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::unsafe_arena_release_last_seen() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.last_seen)
  _has_bits_[0] &= ~0x00000004u;
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* temp = last_seen_;
  last_seen_ = nullptr;
  return temp;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_mutable_last_seen() {
  _has_bits_[0] |= 0x00000004u;
  if (last_seen_ == nullptr) {
    auto* p = CreateMaybeMessage<::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>(GetArenaForAllocation());
    last_seen_ = p;
  }
  return last_seen_;
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::mutable_last_seen() {
  ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* _msg = _internal_mutable_last_seen();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.last_seen)
  return _msg;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_allocated_last_seen(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* last_seen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete last_seen_;
  }
  if (last_seen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>::GetOwningArena(last_seen);
    if (message_arena != submessage_arena) {
      last_seen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_seen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  last_seen_ = last_seen;
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.last_seen)
}

// optional int32 os_type = 11 [(.description) = "EOSType - specific device OS, if known"];
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_has_os_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::has_os_type() const {
  return _internal_has_os_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::clear_os_type() {
  os_type_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_os_type() const {
  return os_type_;
}
inline int32_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::os_type() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.os_type)
  return _internal_os_type();
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_internal_set_os_type(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  os_type_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::set_os_type(int32_t value) {
  _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.os_type)
}

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Enumerate_Response

// repeated .CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription refresh_tokens = 1;
inline int CAuthentication_RefreshToken_Enumerate_Response::_internal_refresh_tokens_size() const {
  return refresh_tokens_.size();
}
inline int CAuthentication_RefreshToken_Enumerate_Response::refresh_tokens_size() const {
  return _internal_refresh_tokens_size();
}
inline void CAuthentication_RefreshToken_Enumerate_Response::clear_refresh_tokens() {
  refresh_tokens_.Clear();
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* CAuthentication_RefreshToken_Enumerate_Response::mutable_refresh_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Enumerate_Response.refresh_tokens)
  return refresh_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >*
CAuthentication_RefreshToken_Enumerate_Response::mutable_refresh_tokens() {
  // @@protoc_insertion_point(field_mutable_list:CAuthentication_RefreshToken_Enumerate_Response.refresh_tokens)
  return &refresh_tokens_;
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& CAuthentication_RefreshToken_Enumerate_Response::_internal_refresh_tokens(int index) const {
  return refresh_tokens_.Get(index);
}
inline const ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& CAuthentication_RefreshToken_Enumerate_Response::refresh_tokens(int index) const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.refresh_tokens)
  return _internal_refresh_tokens(index);
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* CAuthentication_RefreshToken_Enumerate_Response::_internal_add_refresh_tokens() {
  return refresh_tokens_.Add();
}
inline ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* CAuthentication_RefreshToken_Enumerate_Response::add_refresh_tokens() {
  ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* _add = _internal_add_refresh_tokens();
  // @@protoc_insertion_point(field_add:CAuthentication_RefreshToken_Enumerate_Response.refresh_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >&
CAuthentication_RefreshToken_Enumerate_Response::refresh_tokens() const {
  // @@protoc_insertion_point(field_list:CAuthentication_RefreshToken_Enumerate_Response.refresh_tokens)
  return refresh_tokens_;
}

// optional fixed64 requesting_token = 2;
inline bool CAuthentication_RefreshToken_Enumerate_Response::_internal_has_requesting_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Enumerate_Response::has_requesting_token() const {
  return _internal_has_requesting_token();
}
inline void CAuthentication_RefreshToken_Enumerate_Response::clear_requesting_token() {
  requesting_token_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthentication_RefreshToken_Enumerate_Response::_internal_requesting_token() const {
  return requesting_token_;
}
inline uint64_t CAuthentication_RefreshToken_Enumerate_Response::requesting_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Enumerate_Response.requesting_token)
  return _internal_requesting_token();
}
inline void CAuthentication_RefreshToken_Enumerate_Response::_internal_set_requesting_token(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  requesting_token_ = value;
}
inline void CAuthentication_RefreshToken_Enumerate_Response::set_requesting_token(uint64_t value) {
  _internal_set_requesting_token(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Enumerate_Response.requesting_token)
}

// -------------------------------------------------------------------

// CAuthentication_GetAuthSessionsForAccount_Request

// -------------------------------------------------------------------

// CAuthentication_GetAuthSessionsForAccount_Response

// repeated uint64 client_ids = 1 [(.description) = "unique identifier of requestor, also used for routing"];
inline int CAuthentication_GetAuthSessionsForAccount_Response::_internal_client_ids_size() const {
  return client_ids_.size();
}
inline int CAuthentication_GetAuthSessionsForAccount_Response::client_ids_size() const {
  return _internal_client_ids_size();
}
inline void CAuthentication_GetAuthSessionsForAccount_Response::clear_client_ids() {
  client_ids_.Clear();
}
inline uint64_t CAuthentication_GetAuthSessionsForAccount_Response::_internal_client_ids(int index) const {
  return client_ids_.Get(index);
}
inline uint64_t CAuthentication_GetAuthSessionsForAccount_Response::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:CAuthentication_GetAuthSessionsForAccount_Response.client_ids)
  return _internal_client_ids(index);
}
inline void CAuthentication_GetAuthSessionsForAccount_Response::set_client_ids(int index, uint64_t value) {
  client_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CAuthentication_GetAuthSessionsForAccount_Response.client_ids)
}
inline void CAuthentication_GetAuthSessionsForAccount_Response::_internal_add_client_ids(uint64_t value) {
  client_ids_.Add(value);
}
inline void CAuthentication_GetAuthSessionsForAccount_Response::add_client_ids(uint64_t value) {
  _internal_add_client_ids(value);
  // @@protoc_insertion_point(field_add:CAuthentication_GetAuthSessionsForAccount_Response.client_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CAuthentication_GetAuthSessionsForAccount_Response::_internal_client_ids() const {
  return client_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CAuthentication_GetAuthSessionsForAccount_Response::client_ids() const {
  // @@protoc_insertion_point(field_list:CAuthentication_GetAuthSessionsForAccount_Response.client_ids)
  return _internal_client_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CAuthentication_GetAuthSessionsForAccount_Response::_internal_mutable_client_ids() {
  return &client_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CAuthentication_GetAuthSessionsForAccount_Response::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:CAuthentication_GetAuthSessionsForAccount_Response.client_ids)
  return _internal_mutable_client_ids();
}

// -------------------------------------------------------------------

// CAuthentication_MigrateMobileSession_Request

// optional fixed64 steamid = 1 [(.description) = "Steam ID of the user to migrate"];
inline bool CAuthentication_MigrateMobileSession_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_MigrateMobileSession_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_MigrateMobileSession_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_MigrateMobileSession_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_MigrateMobileSession_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_MigrateMobileSession_Request.steamid)
  return _internal_steamid();
}
inline void CAuthentication_MigrateMobileSession_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CAuthentication_MigrateMobileSession_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_MigrateMobileSession_Request.steamid)
}

// optional string token = 2 [(.description) = "WG Token to migrate"];
inline bool CAuthentication_MigrateMobileSession_Request::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_MigrateMobileSession_Request::has_token() const {
  return _internal_has_token();
}
inline void CAuthentication_MigrateMobileSession_Request::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_MigrateMobileSession_Request::token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_MigrateMobileSession_Request.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_MigrateMobileSession_Request::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_MigrateMobileSession_Request.token)
}
inline std::string* CAuthentication_MigrateMobileSession_Request::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_MigrateMobileSession_Request.token)
  return _s;
}
inline const std::string& CAuthentication_MigrateMobileSession_Request::_internal_token() const {
  return token_.Get();
}
inline void CAuthentication_MigrateMobileSession_Request::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Request::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Request::release_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_MigrateMobileSession_Request.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_MigrateMobileSession_Request::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_MigrateMobileSession_Request.token)
}

// optional string signature = 3 [(.description) = "Signature over the wg token using the user\'s 2FA token"];
inline bool CAuthentication_MigrateMobileSession_Request::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_MigrateMobileSession_Request::has_signature() const {
  return _internal_has_signature();
}
inline void CAuthentication_MigrateMobileSession_Request::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_MigrateMobileSession_Request::signature() const {
  // @@protoc_insertion_point(field_get:CAuthentication_MigrateMobileSession_Request.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_MigrateMobileSession_Request::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_MigrateMobileSession_Request.signature)
}
inline std::string* CAuthentication_MigrateMobileSession_Request::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:CAuthentication_MigrateMobileSession_Request.signature)
  return _s;
}
inline const std::string& CAuthentication_MigrateMobileSession_Request::_internal_signature() const {
  return signature_.Get();
}
inline void CAuthentication_MigrateMobileSession_Request::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Request::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000002u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Request::release_signature() {
  // @@protoc_insertion_point(field_release:CAuthentication_MigrateMobileSession_Request.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_MigrateMobileSession_Request::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_MigrateMobileSession_Request.signature)
}

// -------------------------------------------------------------------

// CAuthentication_MigrateMobileSession_Response

// optional string refresh_token = 1;
inline bool CAuthentication_MigrateMobileSession_Response::_internal_has_refresh_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_MigrateMobileSession_Response::has_refresh_token() const {
  return _internal_has_refresh_token();
}
inline void CAuthentication_MigrateMobileSession_Response::clear_refresh_token() {
  refresh_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_MigrateMobileSession_Response::refresh_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_MigrateMobileSession_Response.refresh_token)
  return _internal_refresh_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_MigrateMobileSession_Response::set_refresh_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_MigrateMobileSession_Response.refresh_token)
}
inline std::string* CAuthentication_MigrateMobileSession_Response::mutable_refresh_token() {
  std::string* _s = _internal_mutable_refresh_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_MigrateMobileSession_Response.refresh_token)
  return _s;
}
inline const std::string& CAuthentication_MigrateMobileSession_Response::_internal_refresh_token() const {
  return refresh_token_.Get();
}
inline void CAuthentication_MigrateMobileSession_Response::_internal_set_refresh_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Response::_internal_mutable_refresh_token() {
  _has_bits_[0] |= 0x00000001u;
  return refresh_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Response::release_refresh_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_MigrateMobileSession_Response.refresh_token)
  if (!_internal_has_refresh_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = refresh_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_MigrateMobileSession_Response::set_allocated_refresh_token(std::string* refresh_token) {
  if (refresh_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  refresh_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), refresh_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (refresh_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_MigrateMobileSession_Response.refresh_token)
}

// optional string access_token = 2;
inline bool CAuthentication_MigrateMobileSession_Response::_internal_has_access_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_MigrateMobileSession_Response::has_access_token() const {
  return _internal_has_access_token();
}
inline void CAuthentication_MigrateMobileSession_Response::clear_access_token() {
  access_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CAuthentication_MigrateMobileSession_Response::access_token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_MigrateMobileSession_Response.access_token)
  return _internal_access_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_MigrateMobileSession_Response::set_access_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_MigrateMobileSession_Response.access_token)
}
inline std::string* CAuthentication_MigrateMobileSession_Response::mutable_access_token() {
  std::string* _s = _internal_mutable_access_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_MigrateMobileSession_Response.access_token)
  return _s;
}
inline const std::string& CAuthentication_MigrateMobileSession_Response::_internal_access_token() const {
  return access_token_.Get();
}
inline void CAuthentication_MigrateMobileSession_Response::_internal_set_access_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Response::_internal_mutable_access_token() {
  _has_bits_[0] |= 0x00000002u;
  return access_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_MigrateMobileSession_Response::release_access_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_MigrateMobileSession_Response.access_token)
  if (!_internal_has_access_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = access_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_MigrateMobileSession_Response::set_allocated_access_token(std::string* access_token) {
  if (access_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  access_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), access_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (access_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_MigrateMobileSession_Response.access_token)
}

// -------------------------------------------------------------------

// CAuthentication_Token_Revoke_Request

// optional string token = 1;
inline bool CAuthentication_Token_Revoke_Request::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_Token_Revoke_Request::has_token() const {
  return _internal_has_token();
}
inline void CAuthentication_Token_Revoke_Request::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_Token_Revoke_Request::token() const {
  // @@protoc_insertion_point(field_get:CAuthentication_Token_Revoke_Request.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_Token_Revoke_Request::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_Token_Revoke_Request.token)
}
inline std::string* CAuthentication_Token_Revoke_Request::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CAuthentication_Token_Revoke_Request.token)
  return _s;
}
inline const std::string& CAuthentication_Token_Revoke_Request::_internal_token() const {
  return token_.Get();
}
inline void CAuthentication_Token_Revoke_Request::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_Token_Revoke_Request::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_Token_Revoke_Request::release_token() {
  // @@protoc_insertion_point(field_release:CAuthentication_Token_Revoke_Request.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_Token_Revoke_Request::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_Token_Revoke_Request.token)
}

// optional .EAuthTokenRevokeAction revoke_action = 2 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
inline bool CAuthentication_Token_Revoke_Request::_internal_has_revoke_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_Token_Revoke_Request::has_revoke_action() const {
  return _internal_has_revoke_action();
}
inline void CAuthentication_Token_Revoke_Request::clear_revoke_action() {
  revoke_action_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EAuthTokenRevokeAction CAuthentication_Token_Revoke_Request::_internal_revoke_action() const {
  return static_cast< ::EAuthTokenRevokeAction >(revoke_action_);
}
inline ::EAuthTokenRevokeAction CAuthentication_Token_Revoke_Request::revoke_action() const {
  // @@protoc_insertion_point(field_get:CAuthentication_Token_Revoke_Request.revoke_action)
  return _internal_revoke_action();
}
inline void CAuthentication_Token_Revoke_Request::_internal_set_revoke_action(::EAuthTokenRevokeAction value) {
  assert(::EAuthTokenRevokeAction_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  revoke_action_ = value;
}
inline void CAuthentication_Token_Revoke_Request::set_revoke_action(::EAuthTokenRevokeAction value) {
  _internal_set_revoke_action(value);
  // @@protoc_insertion_point(field_set:CAuthentication_Token_Revoke_Request.revoke_action)
}

// -------------------------------------------------------------------

// CAuthentication_Token_Revoke_Response

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Revoke_Request

// optional fixed64 token_id = 1;
inline bool CAuthentication_RefreshToken_Revoke_Request::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Revoke_Request::has_token_id() const {
  return _internal_has_token_id();
}
inline void CAuthentication_RefreshToken_Revoke_Request::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthentication_RefreshToken_Revoke_Request::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CAuthentication_RefreshToken_Revoke_Request::token_id() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Revoke_Request.token_id)
  return _internal_token_id();
}
inline void CAuthentication_RefreshToken_Revoke_Request::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  token_id_ = value;
}
inline void CAuthentication_RefreshToken_Revoke_Request::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Revoke_Request.token_id)
}

// optional fixed64 steamid = 2 [(.description) = "Token holder if an admin action on behalf of another user"];
inline bool CAuthentication_RefreshToken_Revoke_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Revoke_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthentication_RefreshToken_Revoke_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CAuthentication_RefreshToken_Revoke_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthentication_RefreshToken_Revoke_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Revoke_Request.steamid)
  return _internal_steamid();
}
inline void CAuthentication_RefreshToken_Revoke_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CAuthentication_RefreshToken_Revoke_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Revoke_Request.steamid)
}

// optional .EAuthTokenRevokeAction revoke_action = 3 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
inline bool CAuthentication_RefreshToken_Revoke_Request::_internal_has_revoke_action() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Revoke_Request::has_revoke_action() const {
  return _internal_has_revoke_action();
}
inline void CAuthentication_RefreshToken_Revoke_Request::clear_revoke_action() {
  revoke_action_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EAuthTokenRevokeAction CAuthentication_RefreshToken_Revoke_Request::_internal_revoke_action() const {
  return static_cast< ::EAuthTokenRevokeAction >(revoke_action_);
}
inline ::EAuthTokenRevokeAction CAuthentication_RefreshToken_Revoke_Request::revoke_action() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Revoke_Request.revoke_action)
  return _internal_revoke_action();
}
inline void CAuthentication_RefreshToken_Revoke_Request::_internal_set_revoke_action(::EAuthTokenRevokeAction value) {
  assert(::EAuthTokenRevokeAction_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  revoke_action_ = value;
}
inline void CAuthentication_RefreshToken_Revoke_Request::set_revoke_action(::EAuthTokenRevokeAction value) {
  _internal_set_revoke_action(value);
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Revoke_Request.revoke_action)
}

// optional bytes signature = 4 [(.description) = "required signature over token_id"];
inline bool CAuthentication_RefreshToken_Revoke_Request::_internal_has_signature() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthentication_RefreshToken_Revoke_Request::has_signature() const {
  return _internal_has_signature();
}
inline void CAuthentication_RefreshToken_Revoke_Request::clear_signature() {
  signature_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthentication_RefreshToken_Revoke_Request::signature() const {
  // @@protoc_insertion_point(field_get:CAuthentication_RefreshToken_Revoke_Request.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthentication_RefreshToken_Revoke_Request::set_signature(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthentication_RefreshToken_Revoke_Request.signature)
}
inline std::string* CAuthentication_RefreshToken_Revoke_Request::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:CAuthentication_RefreshToken_Revoke_Request.signature)
  return _s;
}
inline const std::string& CAuthentication_RefreshToken_Revoke_Request::_internal_signature() const {
  return signature_.Get();
}
inline void CAuthentication_RefreshToken_Revoke_Request::_internal_set_signature(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Revoke_Request::_internal_mutable_signature() {
  _has_bits_[0] |= 0x00000001u;
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthentication_RefreshToken_Revoke_Request::release_signature() {
  // @@protoc_insertion_point(field_release:CAuthentication_RefreshToken_Revoke_Request.signature)
  if (!_internal_has_signature()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = signature_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthentication_RefreshToken_Revoke_Request::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (signature_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthentication_RefreshToken_Revoke_Request.signature)
}

// -------------------------------------------------------------------

// CAuthentication_RefreshToken_Revoke_Response

// -------------------------------------------------------------------

// CAuthenticationSupport_QueryRefreshTokensByAccount_Request

// optional fixed64 steamid = 1 [(.description) = "SteamID of the account to query (required)"];
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthenticationSupport_QueryRefreshTokensByAccount_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokensByAccount_Request.steamid)
  return _internal_steamid();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = value;
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_QueryRefreshTokensByAccount_Request.steamid)
}

// optional bool include_revoked_tokens = 2 [(.description) = "Includes tokens that are revoked or expired in the query"];
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_has_include_revoked_tokens() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::has_include_revoked_tokens() const {
  return _internal_has_include_revoked_tokens();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::clear_include_revoked_tokens() {
  include_revoked_tokens_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_include_revoked_tokens() const {
  return include_revoked_tokens_;
}
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::include_revoked_tokens() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokensByAccount_Request.include_revoked_tokens)
  return _internal_include_revoked_tokens();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_internal_set_include_revoked_tokens(bool value) {
  _has_bits_[0] |= 0x00000002u;
  include_revoked_tokens_ = value;
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::set_include_revoked_tokens(bool value) {
  _internal_set_include_revoked_tokens(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_QueryRefreshTokensByAccount_Request.include_revoked_tokens)
}

// -------------------------------------------------------------------

// CSupportRefreshTokenDescription_TokenUsageEvent

// optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::has_time() const {
  return _internal_has_time();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSupportRefreshTokenDescription_TokenUsageEvent::_internal_time() const {
  return time_;
}
inline uint32_t CSupportRefreshTokenDescription_TokenUsageEvent::time() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.TokenUsageEvent.time)
  return _internal_time();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::_internal_set_time(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  time_ = value;
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.TokenUsageEvent.time)
}

// optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || ip_ != nullptr);
  return value;
}
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::has_ip() const {
  return _internal_has_ip();
}
inline const ::CMsgIPAddress& CSupportRefreshTokenDescription_TokenUsageEvent::_internal_ip() const {
  const ::CMsgIPAddress* p = ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CSupportRefreshTokenDescription_TokenUsageEvent::ip() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.TokenUsageEvent.ip)
  return _internal_ip();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::unsafe_arena_set_allocated_ip(
    ::CMsgIPAddress* ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  ip_ = ip;
  if (ip) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSupportRefreshTokenDescription.TokenUsageEvent.ip)
}
inline ::CMsgIPAddress* CSupportRefreshTokenDescription_TokenUsageEvent::release_ip() {
  _has_bits_[0] &= ~0x00000008u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CSupportRefreshTokenDescription_TokenUsageEvent::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.TokenUsageEvent.ip)
  _has_bits_[0] &= ~0x00000008u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CSupportRefreshTokenDescription_TokenUsageEvent::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000008u;
  if (ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    ip_ = p;
  }
  return ip_;
}
inline ::CMsgIPAddress* CSupportRefreshTokenDescription_TokenUsageEvent::mutable_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.TokenUsageEvent.ip)
  return _msg;
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::set_allocated_ip(::CMsgIPAddress* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip));
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.TokenUsageEvent.ip)
}

// optional string country = 3 [(.description) = "Location (country code) of event, as inferred from IP"];
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::_internal_has_country() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::has_country() const {
  return _internal_has_country();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::clear_country() {
  country_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::country() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.TokenUsageEvent.country)
  return _internal_country();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSupportRefreshTokenDescription_TokenUsageEvent::set_country(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.TokenUsageEvent.country)
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::mutable_country() {
  std::string* _s = _internal_mutable_country();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.TokenUsageEvent.country)
  return _s;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::_internal_country() const {
  return country_.Get();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::_internal_set_country(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::_internal_mutable_country() {
  _has_bits_[0] |= 0x00000001u;
  return country_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::release_country() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.TokenUsageEvent.country)
  if (!_internal_has_country()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = country_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::set_allocated_country(std::string* country) {
  if (country != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  country_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.TokenUsageEvent.country)
}

// optional string state = 4 [(.description) = "Location (state code) of event, as inferred from IP"];
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::_internal_has_state() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::has_state() const {
  return _internal_has_state();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::clear_state() {
  state_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::state() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.TokenUsageEvent.state)
  return _internal_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSupportRefreshTokenDescription_TokenUsageEvent::set_state(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.TokenUsageEvent.state)
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::mutable_state() {
  std::string* _s = _internal_mutable_state();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.TokenUsageEvent.state)
  return _s;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::_internal_state() const {
  return state_.Get();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::_internal_set_state(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::_internal_mutable_state() {
  _has_bits_[0] |= 0x00000002u;
  return state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::release_state() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.TokenUsageEvent.state)
  if (!_internal_has_state()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = state_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::set_allocated_state(std::string* state) {
  if (state != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.TokenUsageEvent.state)
}

// optional string city = 5 [(.description) = "Location (city) of event, as inferred from IP"];
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::_internal_has_city() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription_TokenUsageEvent::has_city() const {
  return _internal_has_city();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::clear_city() {
  city_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::city() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.TokenUsageEvent.city)
  return _internal_city();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSupportRefreshTokenDescription_TokenUsageEvent::set_city(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.TokenUsageEvent.city)
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::mutable_city() {
  std::string* _s = _internal_mutable_city();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.TokenUsageEvent.city)
  return _s;
}
inline const std::string& CSupportRefreshTokenDescription_TokenUsageEvent::_internal_city() const {
  return city_.Get();
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::_internal_set_city(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::_internal_mutable_city() {
  _has_bits_[0] |= 0x00000004u;
  return city_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription_TokenUsageEvent::release_city() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.TokenUsageEvent.city)
  if (!_internal_has_city()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = city_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSupportRefreshTokenDescription_TokenUsageEvent::set_allocated_city(std::string* city) {
  if (city != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  city_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), city,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (city_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.TokenUsageEvent.city)
}

// -------------------------------------------------------------------

// CSupportRefreshTokenDescription

// optional fixed64 token_id = 1;
inline bool CSupportRefreshTokenDescription::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_token_id() const {
  return _internal_has_token_id();
}
inline void CSupportRefreshTokenDescription::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CSupportRefreshTokenDescription::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CSupportRefreshTokenDescription::token_id() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.token_id)
  return _internal_token_id();
}
inline void CSupportRefreshTokenDescription::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  token_id_ = value;
}
inline void CSupportRefreshTokenDescription::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.token_id)
}

// optional string token_description = 2;
inline bool CSupportRefreshTokenDescription::_internal_has_token_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_token_description() const {
  return _internal_has_token_description();
}
inline void CSupportRefreshTokenDescription::clear_token_description() {
  token_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSupportRefreshTokenDescription::token_description() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.token_description)
  return _internal_token_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSupportRefreshTokenDescription::set_token_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.token_description)
}
inline std::string* CSupportRefreshTokenDescription::mutable_token_description() {
  std::string* _s = _internal_mutable_token_description();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.token_description)
  return _s;
}
inline const std::string& CSupportRefreshTokenDescription::_internal_token_description() const {
  return token_description_.Get();
}
inline void CSupportRefreshTokenDescription::_internal_set_token_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription::_internal_mutable_token_description() {
  _has_bits_[0] |= 0x00000001u;
  return token_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSupportRefreshTokenDescription::release_token_description() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.token_description)
  if (!_internal_has_token_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSupportRefreshTokenDescription::set_allocated_token_description(std::string* token_description) {
  if (token_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.token_description)
}

// optional uint32 time_updated = 3;
inline bool CSupportRefreshTokenDescription::_internal_has_time_updated() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_time_updated() const {
  return _internal_has_time_updated();
}
inline void CSupportRefreshTokenDescription::clear_time_updated() {
  time_updated_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSupportRefreshTokenDescription::_internal_time_updated() const {
  return time_updated_;
}
inline uint32_t CSupportRefreshTokenDescription::time_updated() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.time_updated)
  return _internal_time_updated();
}
inline void CSupportRefreshTokenDescription::_internal_set_time_updated(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  time_updated_ = value;
}
inline void CSupportRefreshTokenDescription::set_time_updated(uint32_t value) {
  _internal_set_time_updated(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.time_updated)
}

// optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown];
inline bool CSupportRefreshTokenDescription::_internal_has_platform_type() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_platform_type() const {
  return _internal_has_platform_type();
}
inline void CSupportRefreshTokenDescription::clear_platform_type() {
  platform_type_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::EAuthTokenPlatformType CSupportRefreshTokenDescription::_internal_platform_type() const {
  return static_cast< ::EAuthTokenPlatformType >(platform_type_);
}
inline ::EAuthTokenPlatformType CSupportRefreshTokenDescription::platform_type() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.platform_type)
  return _internal_platform_type();
}
inline void CSupportRefreshTokenDescription::_internal_set_platform_type(::EAuthTokenPlatformType value) {
  assert(::EAuthTokenPlatformType_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  platform_type_ = value;
}
inline void CSupportRefreshTokenDescription::set_platform_type(::EAuthTokenPlatformType value) {
  _internal_set_platform_type(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.platform_type)
}

// optional .EAuthTokenState token_state = 5 [default = k_EAuthTokenState_Invalid];
inline bool CSupportRefreshTokenDescription::_internal_has_token_state() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_token_state() const {
  return _internal_has_token_state();
}
inline void CSupportRefreshTokenDescription::clear_token_state() {
  token_state_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::EAuthTokenState CSupportRefreshTokenDescription::_internal_token_state() const {
  return static_cast< ::EAuthTokenState >(token_state_);
}
inline ::EAuthTokenState CSupportRefreshTokenDescription::token_state() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.token_state)
  return _internal_token_state();
}
inline void CSupportRefreshTokenDescription::_internal_set_token_state(::EAuthTokenState value) {
  assert(::EAuthTokenState_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  token_state_ = value;
}
inline void CSupportRefreshTokenDescription::set_token_state(::EAuthTokenState value) {
  _internal_set_token_state(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.token_state)
}

// optional fixed64 owner_steamid = 6;
inline bool CSupportRefreshTokenDescription::_internal_has_owner_steamid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_owner_steamid() const {
  return _internal_has_owner_steamid();
}
inline void CSupportRefreshTokenDescription::clear_owner_steamid() {
  owner_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CSupportRefreshTokenDescription::_internal_owner_steamid() const {
  return owner_steamid_;
}
inline uint64_t CSupportRefreshTokenDescription::owner_steamid() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.owner_steamid)
  return _internal_owner_steamid();
}
inline void CSupportRefreshTokenDescription::_internal_set_owner_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  owner_steamid_ = value;
}
inline void CSupportRefreshTokenDescription::set_owner_steamid(uint64_t value) {
  _internal_set_owner_steamid(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.owner_steamid)
}

// optional uint32 os_platform = 7 [(.description) = "EPlatformType - rough classification of device OS, if known"];
inline bool CSupportRefreshTokenDescription::_internal_has_os_platform() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_os_platform() const {
  return _internal_has_os_platform();
}
inline void CSupportRefreshTokenDescription::clear_os_platform() {
  os_platform_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CSupportRefreshTokenDescription::_internal_os_platform() const {
  return os_platform_;
}
inline uint32_t CSupportRefreshTokenDescription::os_platform() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.os_platform)
  return _internal_os_platform();
}
inline void CSupportRefreshTokenDescription::_internal_set_os_platform(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  os_platform_ = value;
}
inline void CSupportRefreshTokenDescription::set_os_platform(uint32_t value) {
  _internal_set_os_platform(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.os_platform)
}

// optional int32 os_type = 8 [(.description) = "EOSType - specific device OS, if known"];
inline bool CSupportRefreshTokenDescription::_internal_has_os_type() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_os_type() const {
  return _internal_has_os_type();
}
inline void CSupportRefreshTokenDescription::clear_os_type() {
  os_type_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t CSupportRefreshTokenDescription::_internal_os_type() const {
  return os_type_;
}
inline int32_t CSupportRefreshTokenDescription::os_type() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.os_type)
  return _internal_os_type();
}
inline void CSupportRefreshTokenDescription::_internal_set_os_type(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  os_type_ = value;
}
inline void CSupportRefreshTokenDescription::set_os_type(int32_t value) {
  _internal_set_os_type(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.os_type)
}

// optional uint32 auth_type = 9 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
inline bool CSupportRefreshTokenDescription::_internal_has_auth_type() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_auth_type() const {
  return _internal_has_auth_type();
}
inline void CSupportRefreshTokenDescription::clear_auth_type() {
  auth_type_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CSupportRefreshTokenDescription::_internal_auth_type() const {
  return auth_type_;
}
inline uint32_t CSupportRefreshTokenDescription::auth_type() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.auth_type)
  return _internal_auth_type();
}
inline void CSupportRefreshTokenDescription::_internal_set_auth_type(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  auth_type_ = value;
}
inline void CSupportRefreshTokenDescription::set_auth_type(uint32_t value) {
  _internal_set_auth_type(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.auth_type)
}

// optional uint32 gaming_device_type = 10 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
inline bool CSupportRefreshTokenDescription::_internal_has_gaming_device_type() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CSupportRefreshTokenDescription::has_gaming_device_type() const {
  return _internal_has_gaming_device_type();
}
inline void CSupportRefreshTokenDescription::clear_gaming_device_type() {
  gaming_device_type_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CSupportRefreshTokenDescription::_internal_gaming_device_type() const {
  return gaming_device_type_;
}
inline uint32_t CSupportRefreshTokenDescription::gaming_device_type() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.gaming_device_type)
  return _internal_gaming_device_type();
}
inline void CSupportRefreshTokenDescription::_internal_set_gaming_device_type(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  gaming_device_type_ = value;
}
inline void CSupportRefreshTokenDescription::set_gaming_device_type(uint32_t value) {
  _internal_set_gaming_device_type(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenDescription.gaming_device_type)
}

// optional .CSupportRefreshTokenDescription.TokenUsageEvent first_seen = 11 [(.description) = "Information about original authorization event"];
inline bool CSupportRefreshTokenDescription::_internal_has_first_seen() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || first_seen_ != nullptr);
  return value;
}
inline bool CSupportRefreshTokenDescription::has_first_seen() const {
  return _internal_has_first_seen();
}
inline void CSupportRefreshTokenDescription::clear_first_seen() {
  if (first_seen_ != nullptr) first_seen_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CSupportRefreshTokenDescription_TokenUsageEvent& CSupportRefreshTokenDescription::_internal_first_seen() const {
  const ::CSupportRefreshTokenDescription_TokenUsageEvent* p = first_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSupportRefreshTokenDescription_TokenUsageEvent&>(
      ::_CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_);
}
inline const ::CSupportRefreshTokenDescription_TokenUsageEvent& CSupportRefreshTokenDescription::first_seen() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.first_seen)
  return _internal_first_seen();
}
inline void CSupportRefreshTokenDescription::unsafe_arena_set_allocated_first_seen(
    ::CSupportRefreshTokenDescription_TokenUsageEvent* first_seen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_seen_);
  }
  first_seen_ = first_seen;
  if (first_seen) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSupportRefreshTokenDescription.first_seen)
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::release_first_seen() {
  _has_bits_[0] &= ~0x00000002u;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* temp = first_seen_;
  first_seen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::unsafe_arena_release_first_seen() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.first_seen)
  _has_bits_[0] &= ~0x00000002u;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* temp = first_seen_;
  first_seen_ = nullptr;
  return temp;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::_internal_mutable_first_seen() {
  _has_bits_[0] |= 0x00000002u;
  if (first_seen_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSupportRefreshTokenDescription_TokenUsageEvent>(GetArenaForAllocation());
    first_seen_ = p;
  }
  return first_seen_;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::mutable_first_seen() {
  ::CSupportRefreshTokenDescription_TokenUsageEvent* _msg = _internal_mutable_first_seen();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.first_seen)
  return _msg;
}
inline void CSupportRefreshTokenDescription::set_allocated_first_seen(::CSupportRefreshTokenDescription_TokenUsageEvent* first_seen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete first_seen_;
  }
  if (first_seen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSupportRefreshTokenDescription_TokenUsageEvent>::GetOwningArena(first_seen);
    if (message_arena != submessage_arena) {
      first_seen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_seen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  first_seen_ = first_seen;
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.first_seen)
}

// optional .CSupportRefreshTokenDescription.TokenUsageEvent last_seen = 12 [(.description) = "Information about most-recently seen, if known for this device"];
inline bool CSupportRefreshTokenDescription::_internal_has_last_seen() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || last_seen_ != nullptr);
  return value;
}
inline bool CSupportRefreshTokenDescription::has_last_seen() const {
  return _internal_has_last_seen();
}
inline void CSupportRefreshTokenDescription::clear_last_seen() {
  if (last_seen_ != nullptr) last_seen_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CSupportRefreshTokenDescription_TokenUsageEvent& CSupportRefreshTokenDescription::_internal_last_seen() const {
  const ::CSupportRefreshTokenDescription_TokenUsageEvent* p = last_seen_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSupportRefreshTokenDescription_TokenUsageEvent&>(
      ::_CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_);
}
inline const ::CSupportRefreshTokenDescription_TokenUsageEvent& CSupportRefreshTokenDescription::last_seen() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenDescription.last_seen)
  return _internal_last_seen();
}
inline void CSupportRefreshTokenDescription::unsafe_arena_set_allocated_last_seen(
    ::CSupportRefreshTokenDescription_TokenUsageEvent* last_seen) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_seen_);
  }
  last_seen_ = last_seen;
  if (last_seen) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSupportRefreshTokenDescription.last_seen)
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::release_last_seen() {
  _has_bits_[0] &= ~0x00000004u;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* temp = last_seen_;
  last_seen_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::unsafe_arena_release_last_seen() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenDescription.last_seen)
  _has_bits_[0] &= ~0x00000004u;
  ::CSupportRefreshTokenDescription_TokenUsageEvent* temp = last_seen_;
  last_seen_ = nullptr;
  return temp;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::_internal_mutable_last_seen() {
  _has_bits_[0] |= 0x00000004u;
  if (last_seen_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSupportRefreshTokenDescription_TokenUsageEvent>(GetArenaForAllocation());
    last_seen_ = p;
  }
  return last_seen_;
}
inline ::CSupportRefreshTokenDescription_TokenUsageEvent* CSupportRefreshTokenDescription::mutable_last_seen() {
  ::CSupportRefreshTokenDescription_TokenUsageEvent* _msg = _internal_mutable_last_seen();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenDescription.last_seen)
  return _msg;
}
inline void CSupportRefreshTokenDescription::set_allocated_last_seen(::CSupportRefreshTokenDescription_TokenUsageEvent* last_seen) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete last_seen_;
  }
  if (last_seen) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSupportRefreshTokenDescription_TokenUsageEvent>::GetOwningArena(last_seen);
    if (message_arena != submessage_arena) {
      last_seen = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_seen, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  last_seen_ = last_seen;
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenDescription.last_seen)
}

// -------------------------------------------------------------------

// CAuthenticationSupport_QueryRefreshTokensByAccount_Response

// repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
inline int CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_refresh_tokens_size() const {
  return refresh_tokens_.size();
}
inline int CAuthenticationSupport_QueryRefreshTokensByAccount_Response::refresh_tokens_size() const {
  return _internal_refresh_tokens_size();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::clear_refresh_tokens() {
  refresh_tokens_.Clear();
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokensByAccount_Response::mutable_refresh_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.refresh_tokens)
  return refresh_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >*
CAuthenticationSupport_QueryRefreshTokensByAccount_Response::mutable_refresh_tokens() {
  // @@protoc_insertion_point(field_mutable_list:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.refresh_tokens)
  return &refresh_tokens_;
}
inline const ::CSupportRefreshTokenDescription& CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_refresh_tokens(int index) const {
  return refresh_tokens_.Get(index);
}
inline const ::CSupportRefreshTokenDescription& CAuthenticationSupport_QueryRefreshTokensByAccount_Response::refresh_tokens(int index) const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.refresh_tokens)
  return _internal_refresh_tokens(index);
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_add_refresh_tokens() {
  return refresh_tokens_.Add();
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokensByAccount_Response::add_refresh_tokens() {
  ::CSupportRefreshTokenDescription* _add = _internal_add_refresh_tokens();
  // @@protoc_insertion_point(field_add:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.refresh_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >&
CAuthenticationSupport_QueryRefreshTokensByAccount_Response::refresh_tokens() const {
  // @@protoc_insertion_point(field_list:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.refresh_tokens)
  return refresh_tokens_;
}

// optional int32 last_token_reset = 2;
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_has_last_token_reset() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationSupport_QueryRefreshTokensByAccount_Response::has_last_token_reset() const {
  return _internal_has_last_token_reset();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::clear_last_token_reset() {
  last_token_reset_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_last_token_reset() const {
  return last_token_reset_;
}
inline int32_t CAuthenticationSupport_QueryRefreshTokensByAccount_Response::last_token_reset() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.last_token_reset)
  return _internal_last_token_reset();
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_internal_set_last_token_reset(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  last_token_reset_ = value;
}
inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::set_last_token_reset(int32_t value) {
  _internal_set_last_token_reset(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_QueryRefreshTokensByAccount_Response.last_token_reset)
}

// -------------------------------------------------------------------

// CAuthenticationSupport_QueryRefreshTokenByID_Request

// optional fixed64 token_id = 1 [(.description) = "Token ID of the token to look up (required)"];
inline bool CAuthenticationSupport_QueryRefreshTokenByID_Request::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationSupport_QueryRefreshTokenByID_Request::has_token_id() const {
  return _internal_has_token_id();
}
inline void CAuthenticationSupport_QueryRefreshTokenByID_Request::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthenticationSupport_QueryRefreshTokenByID_Request::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CAuthenticationSupport_QueryRefreshTokenByID_Request::token_id() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokenByID_Request.token_id)
  return _internal_token_id();
}
inline void CAuthenticationSupport_QueryRefreshTokenByID_Request::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  token_id_ = value;
}
inline void CAuthenticationSupport_QueryRefreshTokenByID_Request::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_QueryRefreshTokenByID_Request.token_id)
}

// -------------------------------------------------------------------

// CAuthenticationSupport_QueryRefreshTokenByID_Response

// repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
inline int CAuthenticationSupport_QueryRefreshTokenByID_Response::_internal_refresh_tokens_size() const {
  return refresh_tokens_.size();
}
inline int CAuthenticationSupport_QueryRefreshTokenByID_Response::refresh_tokens_size() const {
  return _internal_refresh_tokens_size();
}
inline void CAuthenticationSupport_QueryRefreshTokenByID_Response::clear_refresh_tokens() {
  refresh_tokens_.Clear();
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokenByID_Response::mutable_refresh_tokens(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthenticationSupport_QueryRefreshTokenByID_Response.refresh_tokens)
  return refresh_tokens_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >*
CAuthenticationSupport_QueryRefreshTokenByID_Response::mutable_refresh_tokens() {
  // @@protoc_insertion_point(field_mutable_list:CAuthenticationSupport_QueryRefreshTokenByID_Response.refresh_tokens)
  return &refresh_tokens_;
}
inline const ::CSupportRefreshTokenDescription& CAuthenticationSupport_QueryRefreshTokenByID_Response::_internal_refresh_tokens(int index) const {
  return refresh_tokens_.Get(index);
}
inline const ::CSupportRefreshTokenDescription& CAuthenticationSupport_QueryRefreshTokenByID_Response::refresh_tokens(int index) const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_QueryRefreshTokenByID_Response.refresh_tokens)
  return _internal_refresh_tokens(index);
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokenByID_Response::_internal_add_refresh_tokens() {
  return refresh_tokens_.Add();
}
inline ::CSupportRefreshTokenDescription* CAuthenticationSupport_QueryRefreshTokenByID_Response::add_refresh_tokens() {
  ::CSupportRefreshTokenDescription* _add = _internal_add_refresh_tokens();
  // @@protoc_insertion_point(field_add:CAuthenticationSupport_QueryRefreshTokenByID_Response.refresh_tokens)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenDescription >&
CAuthenticationSupport_QueryRefreshTokenByID_Response::refresh_tokens() const {
  // @@protoc_insertion_point(field_list:CAuthenticationSupport_QueryRefreshTokenByID_Response.refresh_tokens)
  return refresh_tokens_;
}

// -------------------------------------------------------------------

// CAuthenticationSupport_RevokeToken_Request

// optional fixed64 token_id = 1 [(.description) = "Token ID of the token to revoke (required)"];
inline bool CAuthenticationSupport_RevokeToken_Request::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationSupport_RevokeToken_Request::has_token_id() const {
  return _internal_has_token_id();
}
inline void CAuthenticationSupport_RevokeToken_Request::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthenticationSupport_RevokeToken_Request::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CAuthenticationSupport_RevokeToken_Request::token_id() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_RevokeToken_Request.token_id)
  return _internal_token_id();
}
inline void CAuthenticationSupport_RevokeToken_Request::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  token_id_ = value;
}
inline void CAuthenticationSupport_RevokeToken_Request::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_RevokeToken_Request.token_id)
}

// optional fixed64 steamid = 2 [(.description) = "Steam ID of the owner of that token (required)"];
inline bool CAuthenticationSupport_RevokeToken_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthenticationSupport_RevokeToken_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthenticationSupport_RevokeToken_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthenticationSupport_RevokeToken_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthenticationSupport_RevokeToken_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_RevokeToken_Request.steamid)
  return _internal_steamid();
}
inline void CAuthenticationSupport_RevokeToken_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CAuthenticationSupport_RevokeToken_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_RevokeToken_Request.steamid)
}

// -------------------------------------------------------------------

// CAuthenticationSupport_RevokeToken_Response

// -------------------------------------------------------------------

// CAuthenticationSupport_GetTokenHistory_Request

// optional fixed64 token_id = 1 [(.description) = "Token ID of the token to get history for (required)"];
inline bool CAuthenticationSupport_GetTokenHistory_Request::_internal_has_token_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationSupport_GetTokenHistory_Request::has_token_id() const {
  return _internal_has_token_id();
}
inline void CAuthenticationSupport_GetTokenHistory_Request::clear_token_id() {
  token_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CAuthenticationSupport_GetTokenHistory_Request::_internal_token_id() const {
  return token_id_;
}
inline uint64_t CAuthenticationSupport_GetTokenHistory_Request::token_id() const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_GetTokenHistory_Request.token_id)
  return _internal_token_id();
}
inline void CAuthenticationSupport_GetTokenHistory_Request::_internal_set_token_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  token_id_ = value;
}
inline void CAuthenticationSupport_GetTokenHistory_Request::set_token_id(uint64_t value) {
  _internal_set_token_id(value);
  // @@protoc_insertion_point(field_set:CAuthenticationSupport_GetTokenHistory_Request.token_id)
}

// -------------------------------------------------------------------

// CSupportRefreshTokenAudit

// optional int32 action = 1;
inline bool CSupportRefreshTokenAudit::_internal_has_action() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSupportRefreshTokenAudit::has_action() const {
  return _internal_has_action();
}
inline void CSupportRefreshTokenAudit::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CSupportRefreshTokenAudit::_internal_action() const {
  return action_;
}
inline int32_t CSupportRefreshTokenAudit::action() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenAudit.action)
  return _internal_action();
}
inline void CSupportRefreshTokenAudit::_internal_set_action(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
}
inline void CSupportRefreshTokenAudit::set_action(int32_t value) {
  _internal_set_action(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenAudit.action)
}

// optional uint32 time = 2;
inline bool CSupportRefreshTokenAudit::_internal_has_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSupportRefreshTokenAudit::has_time() const {
  return _internal_has_time();
}
inline void CSupportRefreshTokenAudit::clear_time() {
  time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSupportRefreshTokenAudit::_internal_time() const {
  return time_;
}
inline uint32_t CSupportRefreshTokenAudit::time() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenAudit.time)
  return _internal_time();
}
inline void CSupportRefreshTokenAudit::_internal_set_time(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  time_ = value;
}
inline void CSupportRefreshTokenAudit::set_time(uint32_t value) {
  _internal_set_time(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenAudit.time)
}

// optional .CMsgIPAddress ip = 3;
inline bool CSupportRefreshTokenAudit::_internal_has_ip() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || ip_ != nullptr);
  return value;
}
inline bool CSupportRefreshTokenAudit::has_ip() const {
  return _internal_has_ip();
}
inline const ::CMsgIPAddress& CSupportRefreshTokenAudit::_internal_ip() const {
  const ::CMsgIPAddress* p = ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CSupportRefreshTokenAudit::ip() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenAudit.ip)
  return _internal_ip();
}
inline void CSupportRefreshTokenAudit::unsafe_arena_set_allocated_ip(
    ::CMsgIPAddress* ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  ip_ = ip;
  if (ip) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSupportRefreshTokenAudit.ip)
}
inline ::CMsgIPAddress* CSupportRefreshTokenAudit::release_ip() {
  _has_bits_[0] &= ~0x00000001u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CSupportRefreshTokenAudit::unsafe_arena_release_ip() {
  // @@protoc_insertion_point(field_release:CSupportRefreshTokenAudit.ip)
  _has_bits_[0] &= ~0x00000001u;
  ::CMsgIPAddress* temp = ip_;
  ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CSupportRefreshTokenAudit::_internal_mutable_ip() {
  _has_bits_[0] |= 0x00000001u;
  if (ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    ip_ = p;
  }
  return ip_;
}
inline ::CMsgIPAddress* CSupportRefreshTokenAudit::mutable_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:CSupportRefreshTokenAudit.ip)
  return _msg;
}
inline void CSupportRefreshTokenAudit::set_allocated_ip(::CMsgIPAddress* ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip_);
  }
  if (ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ip));
    if (message_arena != submessage_arena) {
      ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ip_ = ip;
  // @@protoc_insertion_point(field_set_allocated:CSupportRefreshTokenAudit.ip)
}

// optional fixed64 actor = 4;
inline bool CSupportRefreshTokenAudit::_internal_has_actor() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSupportRefreshTokenAudit::has_actor() const {
  return _internal_has_actor();
}
inline void CSupportRefreshTokenAudit::clear_actor() {
  actor_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CSupportRefreshTokenAudit::_internal_actor() const {
  return actor_;
}
inline uint64_t CSupportRefreshTokenAudit::actor() const {
  // @@protoc_insertion_point(field_get:CSupportRefreshTokenAudit.actor)
  return _internal_actor();
}
inline void CSupportRefreshTokenAudit::_internal_set_actor(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  actor_ = value;
}
inline void CSupportRefreshTokenAudit::set_actor(uint64_t value) {
  _internal_set_actor(value);
  // @@protoc_insertion_point(field_set:CSupportRefreshTokenAudit.actor)
}

// -------------------------------------------------------------------

// CAuthenticationSupport_GetTokenHistory_Response

// repeated .CSupportRefreshTokenAudit history = 1;
inline int CAuthenticationSupport_GetTokenHistory_Response::_internal_history_size() const {
  return history_.size();
}
inline int CAuthenticationSupport_GetTokenHistory_Response::history_size() const {
  return _internal_history_size();
}
inline void CAuthenticationSupport_GetTokenHistory_Response::clear_history() {
  history_.Clear();
}
inline ::CSupportRefreshTokenAudit* CAuthenticationSupport_GetTokenHistory_Response::mutable_history(int index) {
  // @@protoc_insertion_point(field_mutable:CAuthenticationSupport_GetTokenHistory_Response.history)
  return history_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenAudit >*
CAuthenticationSupport_GetTokenHistory_Response::mutable_history() {
  // @@protoc_insertion_point(field_mutable_list:CAuthenticationSupport_GetTokenHistory_Response.history)
  return &history_;
}
inline const ::CSupportRefreshTokenAudit& CAuthenticationSupport_GetTokenHistory_Response::_internal_history(int index) const {
  return history_.Get(index);
}
inline const ::CSupportRefreshTokenAudit& CAuthenticationSupport_GetTokenHistory_Response::history(int index) const {
  // @@protoc_insertion_point(field_get:CAuthenticationSupport_GetTokenHistory_Response.history)
  return _internal_history(index);
}
inline ::CSupportRefreshTokenAudit* CAuthenticationSupport_GetTokenHistory_Response::_internal_add_history() {
  return history_.Add();
}
inline ::CSupportRefreshTokenAudit* CAuthenticationSupport_GetTokenHistory_Response::add_history() {
  ::CSupportRefreshTokenAudit* _add = _internal_add_history();
  // @@protoc_insertion_point(field_add:CAuthenticationSupport_GetTokenHistory_Response.history)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSupportRefreshTokenAudit >&
CAuthenticationSupport_GetTokenHistory_Response::history() const {
  // @@protoc_insertion_point(field_list:CAuthenticationSupport_GetTokenHistory_Response.history)
  return history_;
}

// -------------------------------------------------------------------

// CCloudGaming_CreateNonce_Request

// optional string platform = 1;
inline bool CCloudGaming_CreateNonce_Request::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CCloudGaming_CreateNonce_Request::has_platform() const {
  return _internal_has_platform();
}
inline void CCloudGaming_CreateNonce_Request::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CCloudGaming_CreateNonce_Request::platform() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_CreateNonce_Request.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CCloudGaming_CreateNonce_Request::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CCloudGaming_CreateNonce_Request.platform)
}
inline std::string* CCloudGaming_CreateNonce_Request::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:CCloudGaming_CreateNonce_Request.platform)
  return _s;
}
inline const std::string& CCloudGaming_CreateNonce_Request::_internal_platform() const {
  return platform_.Get();
}
inline void CCloudGaming_CreateNonce_Request::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CCloudGaming_CreateNonce_Request::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000001u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CCloudGaming_CreateNonce_Request::release_platform() {
  // @@protoc_insertion_point(field_release:CCloudGaming_CreateNonce_Request.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CCloudGaming_CreateNonce_Request::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CCloudGaming_CreateNonce_Request.platform)
}

// optional uint32 appid = 2;
inline bool CCloudGaming_CreateNonce_Request::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CCloudGaming_CreateNonce_Request::has_appid() const {
  return _internal_has_appid();
}
inline void CCloudGaming_CreateNonce_Request::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CCloudGaming_CreateNonce_Request::_internal_appid() const {
  return appid_;
}
inline uint32_t CCloudGaming_CreateNonce_Request::appid() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_CreateNonce_Request.appid)
  return _internal_appid();
}
inline void CCloudGaming_CreateNonce_Request::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CCloudGaming_CreateNonce_Request::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CCloudGaming_CreateNonce_Request.appid)
}

// -------------------------------------------------------------------

// CCloudGaming_CreateNonce_Response

// optional string nonce = 1;
inline bool CCloudGaming_CreateNonce_Response::_internal_has_nonce() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CCloudGaming_CreateNonce_Response::has_nonce() const {
  return _internal_has_nonce();
}
inline void CCloudGaming_CreateNonce_Response::clear_nonce() {
  nonce_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CCloudGaming_CreateNonce_Response::nonce() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_CreateNonce_Response.nonce)
  return _internal_nonce();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CCloudGaming_CreateNonce_Response::set_nonce(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 nonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CCloudGaming_CreateNonce_Response.nonce)
}
inline std::string* CCloudGaming_CreateNonce_Response::mutable_nonce() {
  std::string* _s = _internal_mutable_nonce();
  // @@protoc_insertion_point(field_mutable:CCloudGaming_CreateNonce_Response.nonce)
  return _s;
}
inline const std::string& CCloudGaming_CreateNonce_Response::_internal_nonce() const {
  return nonce_.Get();
}
inline void CCloudGaming_CreateNonce_Response::_internal_set_nonce(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  nonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CCloudGaming_CreateNonce_Response::_internal_mutable_nonce() {
  _has_bits_[0] |= 0x00000001u;
  return nonce_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CCloudGaming_CreateNonce_Response::release_nonce() {
  // @@protoc_insertion_point(field_release:CCloudGaming_CreateNonce_Response.nonce)
  if (!_internal_has_nonce()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = nonce_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CCloudGaming_CreateNonce_Response::set_allocated_nonce(std::string* nonce) {
  if (nonce != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  nonce_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nonce,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nonce_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CCloudGaming_CreateNonce_Response.nonce)
}

// optional uint32 expiry = 2;
inline bool CCloudGaming_CreateNonce_Response::_internal_has_expiry() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CCloudGaming_CreateNonce_Response::has_expiry() const {
  return _internal_has_expiry();
}
inline void CCloudGaming_CreateNonce_Response::clear_expiry() {
  expiry_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CCloudGaming_CreateNonce_Response::_internal_expiry() const {
  return expiry_;
}
inline uint32_t CCloudGaming_CreateNonce_Response::expiry() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_CreateNonce_Response.expiry)
  return _internal_expiry();
}
inline void CCloudGaming_CreateNonce_Response::_internal_set_expiry(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  expiry_ = value;
}
inline void CCloudGaming_CreateNonce_Response::set_expiry(uint32_t value) {
  _internal_set_expiry(value);
  // @@protoc_insertion_point(field_set:CCloudGaming_CreateNonce_Response.expiry)
}

// -------------------------------------------------------------------

// CCloudGaming_GetTimeRemaining_Request

// optional string platform = 1;
inline bool CCloudGaming_GetTimeRemaining_Request::_internal_has_platform() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CCloudGaming_GetTimeRemaining_Request::has_platform() const {
  return _internal_has_platform();
}
inline void CCloudGaming_GetTimeRemaining_Request::clear_platform() {
  platform_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CCloudGaming_GetTimeRemaining_Request::platform() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_GetTimeRemaining_Request.platform)
  return _internal_platform();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CCloudGaming_GetTimeRemaining_Request::set_platform(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CCloudGaming_GetTimeRemaining_Request.platform)
}
inline std::string* CCloudGaming_GetTimeRemaining_Request::mutable_platform() {
  std::string* _s = _internal_mutable_platform();
  // @@protoc_insertion_point(field_mutable:CCloudGaming_GetTimeRemaining_Request.platform)
  return _s;
}
inline const std::string& CCloudGaming_GetTimeRemaining_Request::_internal_platform() const {
  return platform_.Get();
}
inline void CCloudGaming_GetTimeRemaining_Request::_internal_set_platform(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CCloudGaming_GetTimeRemaining_Request::_internal_mutable_platform() {
  _has_bits_[0] |= 0x00000001u;
  return platform_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CCloudGaming_GetTimeRemaining_Request::release_platform() {
  // @@protoc_insertion_point(field_release:CCloudGaming_GetTimeRemaining_Request.platform)
  if (!_internal_has_platform()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = platform_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CCloudGaming_GetTimeRemaining_Request::set_allocated_platform(std::string* platform) {
  if (platform != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  platform_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), platform,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (platform_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CCloudGaming_GetTimeRemaining_Request.platform)
}

// repeated uint32 appid_list = 2;
inline int CCloudGaming_GetTimeRemaining_Request::_internal_appid_list_size() const {
  return appid_list_.size();
}
inline int CCloudGaming_GetTimeRemaining_Request::appid_list_size() const {
  return _internal_appid_list_size();
}
inline void CCloudGaming_GetTimeRemaining_Request::clear_appid_list() {
  appid_list_.Clear();
}
inline uint32_t CCloudGaming_GetTimeRemaining_Request::_internal_appid_list(int index) const {
  return appid_list_.Get(index);
}
inline uint32_t CCloudGaming_GetTimeRemaining_Request::appid_list(int index) const {
  // @@protoc_insertion_point(field_get:CCloudGaming_GetTimeRemaining_Request.appid_list)
  return _internal_appid_list(index);
}
inline void CCloudGaming_GetTimeRemaining_Request::set_appid_list(int index, uint32_t value) {
  appid_list_.Set(index, value);
  // @@protoc_insertion_point(field_set:CCloudGaming_GetTimeRemaining_Request.appid_list)
}
inline void CCloudGaming_GetTimeRemaining_Request::_internal_add_appid_list(uint32_t value) {
  appid_list_.Add(value);
}
inline void CCloudGaming_GetTimeRemaining_Request::add_appid_list(uint32_t value) {
  _internal_add_appid_list(value);
  // @@protoc_insertion_point(field_add:CCloudGaming_GetTimeRemaining_Request.appid_list)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CCloudGaming_GetTimeRemaining_Request::_internal_appid_list() const {
  return appid_list_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CCloudGaming_GetTimeRemaining_Request::appid_list() const {
  // @@protoc_insertion_point(field_list:CCloudGaming_GetTimeRemaining_Request.appid_list)
  return _internal_appid_list();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CCloudGaming_GetTimeRemaining_Request::_internal_mutable_appid_list() {
  return &appid_list_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CCloudGaming_GetTimeRemaining_Request::mutable_appid_list() {
  // @@protoc_insertion_point(field_mutable_list:CCloudGaming_GetTimeRemaining_Request.appid_list)
  return _internal_mutable_appid_list();
}

// -------------------------------------------------------------------

// CCloudGaming_TimeRemaining

// optional uint32 appid = 1;
inline bool CCloudGaming_TimeRemaining::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CCloudGaming_TimeRemaining::has_appid() const {
  return _internal_has_appid();
}
inline void CCloudGaming_TimeRemaining::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CCloudGaming_TimeRemaining::_internal_appid() const {
  return appid_;
}
inline uint32_t CCloudGaming_TimeRemaining::appid() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_TimeRemaining.appid)
  return _internal_appid();
}
inline void CCloudGaming_TimeRemaining::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CCloudGaming_TimeRemaining::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CCloudGaming_TimeRemaining.appid)
}

// optional uint32 minutes_remaining = 2;
inline bool CCloudGaming_TimeRemaining::_internal_has_minutes_remaining() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CCloudGaming_TimeRemaining::has_minutes_remaining() const {
  return _internal_has_minutes_remaining();
}
inline void CCloudGaming_TimeRemaining::clear_minutes_remaining() {
  minutes_remaining_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CCloudGaming_TimeRemaining::_internal_minutes_remaining() const {
  return minutes_remaining_;
}
inline uint32_t CCloudGaming_TimeRemaining::minutes_remaining() const {
  // @@protoc_insertion_point(field_get:CCloudGaming_TimeRemaining.minutes_remaining)
  return _internal_minutes_remaining();
}
inline void CCloudGaming_TimeRemaining::_internal_set_minutes_remaining(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  minutes_remaining_ = value;
}
inline void CCloudGaming_TimeRemaining::set_minutes_remaining(uint32_t value) {
  _internal_set_minutes_remaining(value);
  // @@protoc_insertion_point(field_set:CCloudGaming_TimeRemaining.minutes_remaining)
}

// -------------------------------------------------------------------

// CCloudGaming_GetTimeRemaining_Response

// repeated .CCloudGaming_TimeRemaining entries = 2;
inline int CCloudGaming_GetTimeRemaining_Response::_internal_entries_size() const {
  return entries_.size();
}
inline int CCloudGaming_GetTimeRemaining_Response::entries_size() const {
  return _internal_entries_size();
}
inline void CCloudGaming_GetTimeRemaining_Response::clear_entries() {
  entries_.Clear();
}
inline ::CCloudGaming_TimeRemaining* CCloudGaming_GetTimeRemaining_Response::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CCloudGaming_GetTimeRemaining_Response.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CCloudGaming_TimeRemaining >*
CCloudGaming_GetTimeRemaining_Response::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:CCloudGaming_GetTimeRemaining_Response.entries)
  return &entries_;
}
inline const ::CCloudGaming_TimeRemaining& CCloudGaming_GetTimeRemaining_Response::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::CCloudGaming_TimeRemaining& CCloudGaming_GetTimeRemaining_Response::entries(int index) const {
  // @@protoc_insertion_point(field_get:CCloudGaming_GetTimeRemaining_Response.entries)
  return _internal_entries(index);
}
inline ::CCloudGaming_TimeRemaining* CCloudGaming_GetTimeRemaining_Response::_internal_add_entries() {
  return entries_.Add();
}
inline ::CCloudGaming_TimeRemaining* CCloudGaming_GetTimeRemaining_Response::add_entries() {
  ::CCloudGaming_TimeRemaining* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:CCloudGaming_GetTimeRemaining_Response.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CCloudGaming_TimeRemaining >&
CCloudGaming_GetTimeRemaining_Response::entries() const {
  // @@protoc_insertion_point(field_list:CCloudGaming_GetTimeRemaining_Response.entries)
  return entries_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EAuthTokenPlatformType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAuthTokenPlatformType>() {
  return ::EAuthTokenPlatformType_descriptor();
}
template <> struct is_proto_enum< ::EAuthSessionGuardType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAuthSessionGuardType>() {
  return ::EAuthSessionGuardType_descriptor();
}
template <> struct is_proto_enum< ::EAuthSessionSecurityHistory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAuthSessionSecurityHistory>() {
  return ::EAuthSessionSecurityHistory_descriptor();
}
template <> struct is_proto_enum< ::ETokenRenewalType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETokenRenewalType>() {
  return ::ETokenRenewalType_descriptor();
}
template <> struct is_proto_enum< ::EAuthTokenRevokeAction> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAuthTokenRevokeAction>() {
  return ::EAuthTokenRevokeAction_descriptor();
}
template <> struct is_proto_enum< ::EAuthTokenState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAuthTokenState>() {
  return ::EAuthTokenState_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fauth_2esteamclient_2eproto
