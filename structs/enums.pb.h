// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: enums.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_enums_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include "steammessages_base.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_enums_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_enums_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_enums_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE

enum EPublishedFileQueryType : int {
  k_PublishedFileQueryType_RankedByVote = 0,
  k_PublishedFileQueryType_RankedByPublicationDate = 1,
  k_PublishedFileQueryType_AcceptedForGameRankedByAcceptanceDate = 2,
  k_PublishedFileQueryType_RankedByTrend = 3,
  k_PublishedFileQueryType_FavoritedByFriendsRankedByPublicationDate = 4,
  k_PublishedFileQueryType_CreatedByFriendsRankedByPublicationDate = 5,
  k_PublishedFileQueryType_RankedByNumTimesReported = 6,
  k_PublishedFileQueryType_CreatedByFollowedUsersRankedByPublicationDate = 7,
  k_PublishedFileQueryType_NotYetRated = 8,
  k_PublishedFileQueryType_RankedByTotalUniqueSubscriptions = 9,
  k_PublishedFileQueryType_RankedByTotalVotesAsc = 10,
  k_PublishedFileQueryType_RankedByVotesUp = 11,
  k_PublishedFileQueryType_RankedByTextSearch = 12,
  k_PublishedFileQueryType_RankedByPlaytimeTrend = 13,
  k_PublishedFileQueryType_RankedByTotalPlaytime = 14,
  k_PublishedFileQueryType_RankedByAveragePlaytimeTrend = 15,
  k_PublishedFileQueryType_RankedByLifetimeAveragePlaytime = 16,
  k_PublishedFileQueryType_RankedByPlaytimeSessionsTrend = 17,
  k_PublishedFileQueryType_RankedByLifetimePlaytimeSessions = 18,
  k_PublishedFileQueryType_RankedByInappropriateContentRating = 19,
  k_PublishedFileQueryType_RankedByBanContentCheck = 20,
  k_PublishedFileQueryType_RankedByLastUpdatedDate = 21
};
bool EPublishedFileQueryType_IsValid(int value);
constexpr EPublishedFileQueryType EPublishedFileQueryType_MIN = k_PublishedFileQueryType_RankedByVote;
constexpr EPublishedFileQueryType EPublishedFileQueryType_MAX = k_PublishedFileQueryType_RankedByLastUpdatedDate;
constexpr int EPublishedFileQueryType_ARRAYSIZE = EPublishedFileQueryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileQueryType_descriptor();
template<typename T>
inline const std::string& EPublishedFileQueryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileQueryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileQueryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileQueryType_descriptor(), enum_t_value);
}
inline bool EPublishedFileQueryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileQueryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileQueryType>(
    EPublishedFileQueryType_descriptor(), name, value);
}
enum EPublishedFileInappropriateProvider : int {
  k_EPublishedFileInappropriateProvider_Invalid = 0,
  k_EPublishedFileInappropriateProvider_Google = 1,
  k_EPublishedFileInappropriateProvider_Amazon = 2
};
bool EPublishedFileInappropriateProvider_IsValid(int value);
constexpr EPublishedFileInappropriateProvider EPublishedFileInappropriateProvider_MIN = k_EPublishedFileInappropriateProvider_Invalid;
constexpr EPublishedFileInappropriateProvider EPublishedFileInappropriateProvider_MAX = k_EPublishedFileInappropriateProvider_Amazon;
constexpr int EPublishedFileInappropriateProvider_ARRAYSIZE = EPublishedFileInappropriateProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileInappropriateProvider_descriptor();
template<typename T>
inline const std::string& EPublishedFileInappropriateProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileInappropriateProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileInappropriateProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileInappropriateProvider_descriptor(), enum_t_value);
}
inline bool EPublishedFileInappropriateProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileInappropriateProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileInappropriateProvider>(
    EPublishedFileInappropriateProvider_descriptor(), name, value);
}
enum EPublishedFileInappropriateResult : int {
  k_EPublishedFileInappropriateResult_NotScanned = 0,
  k_EPublishedFileInappropriateResult_VeryUnlikely = 1,
  k_EPublishedFileInappropriateResult_Unlikely = 30,
  k_EPublishedFileInappropriateResult_Possible = 50,
  k_EPublishedFileInappropriateResult_Likely = 75,
  k_EPublishedFileInappropriateResult_VeryLikely = 100
};
bool EPublishedFileInappropriateResult_IsValid(int value);
constexpr EPublishedFileInappropriateResult EPublishedFileInappropriateResult_MIN = k_EPublishedFileInappropriateResult_NotScanned;
constexpr EPublishedFileInappropriateResult EPublishedFileInappropriateResult_MAX = k_EPublishedFileInappropriateResult_VeryLikely;
constexpr int EPublishedFileInappropriateResult_ARRAYSIZE = EPublishedFileInappropriateResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileInappropriateResult_descriptor();
template<typename T>
inline const std::string& EPublishedFileInappropriateResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileInappropriateResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileInappropriateResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileInappropriateResult_descriptor(), enum_t_value);
}
inline bool EPublishedFileInappropriateResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileInappropriateResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileInappropriateResult>(
    EPublishedFileInappropriateResult_descriptor(), name, value);
}
enum EPersonaStateFlag : int {
  k_EPersonaStateFlag_HasRichPresence = 1,
  k_EPersonaStateFlag_InJoinableGame = 2,
  k_EPersonaStateFlag_Golden = 4,
  k_EPersonaStateFlag_RemotePlayTogether = 8,
  k_EPersonaStateFlag_ClientTypeWeb = 256,
  k_EPersonaStateFlag_ClientTypeMobile = 512,
  k_EPersonaStateFlag_ClientTypeTenfoot = 1024,
  k_EPersonaStateFlag_ClientTypeVR = 2048,
  k_EPersonaStateFlag_LaunchTypeGamepad = 4096,
  k_EPersonaStateFlag_LaunchTypeCompatTool = 8192
};
bool EPersonaStateFlag_IsValid(int value);
constexpr EPersonaStateFlag EPersonaStateFlag_MIN = k_EPersonaStateFlag_HasRichPresence;
constexpr EPersonaStateFlag EPersonaStateFlag_MAX = k_EPersonaStateFlag_LaunchTypeCompatTool;
constexpr int EPersonaStateFlag_ARRAYSIZE = EPersonaStateFlag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPersonaStateFlag_descriptor();
template<typename T>
inline const std::string& EPersonaStateFlag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPersonaStateFlag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPersonaStateFlag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPersonaStateFlag_descriptor(), enum_t_value);
}
inline bool EPersonaStateFlag_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPersonaStateFlag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPersonaStateFlag>(
    EPersonaStateFlag_descriptor(), name, value);
}
enum EContentCheckProvider : int {
  k_EContentCheckProvider_Invalid = 0,
  k_EContentCheckProvider_Google = 1,
  k_EContentCheckProvider_Amazon = 2,
  k_EContentCheckProvider_Local = 3
};
bool EContentCheckProvider_IsValid(int value);
constexpr EContentCheckProvider EContentCheckProvider_MIN = k_EContentCheckProvider_Invalid;
constexpr EContentCheckProvider EContentCheckProvider_MAX = k_EContentCheckProvider_Local;
constexpr int EContentCheckProvider_ARRAYSIZE = EContentCheckProvider_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EContentCheckProvider_descriptor();
template<typename T>
inline const std::string& EContentCheckProvider_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EContentCheckProvider>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EContentCheckProvider_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EContentCheckProvider_descriptor(), enum_t_value);
}
inline bool EContentCheckProvider_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EContentCheckProvider* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EContentCheckProvider>(
    EContentCheckProvider_descriptor(), name, value);
}
enum EProfileCustomizationType : int {
  k_EProfileCustomizationTypeInvalid = 0,
  k_EProfileCustomizationTypeRareAchievementShowcase = 1,
  k_EProfileCustomizationTypeGameCollector = 2,
  k_EProfileCustomizationTypeItemShowcase = 3,
  k_EProfileCustomizationTypeTradeShowcase = 4,
  k_EProfileCustomizationTypeBadges = 5,
  k_EProfileCustomizationTypeFavoriteGame = 6,
  k_EProfileCustomizationTypeScreenshotShowcase = 7,
  k_EProfileCustomizationTypeCustomText = 8,
  k_EProfileCustomizationTypeFavoriteGroup = 9,
  k_EProfileCustomizationTypeRecommendation = 10,
  k_EProfileCustomizationTypeWorkshopItem = 11,
  k_EProfileCustomizationTypeMyWorkshop = 12,
  k_EProfileCustomizationTypeArtworkShowcase = 13,
  k_EProfileCustomizationTypeVideoShowcase = 14,
  k_EProfileCustomizationTypeGuides = 15,
  k_EProfileCustomizationTypeMyGuides = 16,
  k_EProfileCustomizationTypeAchievements = 17,
  k_EProfileCustomizationTypeGreenlight = 18,
  k_EProfileCustomizationTypeMyGreenlight = 19,
  k_EProfileCustomizationTypeSalien = 20,
  k_EProfileCustomizationTypeLoyaltyRewardReactions = 21,
  k_EProfileCustomizationTypeSingleArtworkShowcase = 22,
  k_EProfileCustomizationTypeAchievementsCompletionist = 23,
  k_EProfileCustomizationTypeReplay = 24
};
bool EProfileCustomizationType_IsValid(int value);
constexpr EProfileCustomizationType EProfileCustomizationType_MIN = k_EProfileCustomizationTypeInvalid;
constexpr EProfileCustomizationType EProfileCustomizationType_MAX = k_EProfileCustomizationTypeReplay;
constexpr int EProfileCustomizationType_ARRAYSIZE = EProfileCustomizationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProfileCustomizationType_descriptor();
template<typename T>
inline const std::string& EProfileCustomizationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EProfileCustomizationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EProfileCustomizationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EProfileCustomizationType_descriptor(), enum_t_value);
}
inline bool EProfileCustomizationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EProfileCustomizationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EProfileCustomizationType>(
    EProfileCustomizationType_descriptor(), name, value);
}
enum EPublishedFileStorageSystem : int {
  k_EPublishedFileStorageSystemInvalid = 0,
  k_EPublishedFileStorageSystemLegacyCloud = 1,
  k_EPublishedFileStorageSystemDepot = 2,
  k_EPublishedFileStorageSystemUGCCloud = 3
};
bool EPublishedFileStorageSystem_IsValid(int value);
constexpr EPublishedFileStorageSystem EPublishedFileStorageSystem_MIN = k_EPublishedFileStorageSystemInvalid;
constexpr EPublishedFileStorageSystem EPublishedFileStorageSystem_MAX = k_EPublishedFileStorageSystemUGCCloud;
constexpr int EPublishedFileStorageSystem_ARRAYSIZE = EPublishedFileStorageSystem_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EPublishedFileStorageSystem_descriptor();
template<typename T>
inline const std::string& EPublishedFileStorageSystem_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EPublishedFileStorageSystem>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EPublishedFileStorageSystem_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EPublishedFileStorageSystem_descriptor(), enum_t_value);
}
inline bool EPublishedFileStorageSystem_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EPublishedFileStorageSystem* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EPublishedFileStorageSystem>(
    EPublishedFileStorageSystem_descriptor(), name, value);
}
enum ECloudStoragePersistState : int {
  k_ECloudStoragePersistStatePersisted = 0,
  k_ECloudStoragePersistStateForgotten = 1,
  k_ECloudStoragePersistStateDeleted = 2
};
bool ECloudStoragePersistState_IsValid(int value);
constexpr ECloudStoragePersistState ECloudStoragePersistState_MIN = k_ECloudStoragePersistStatePersisted;
constexpr ECloudStoragePersistState ECloudStoragePersistState_MAX = k_ECloudStoragePersistStateDeleted;
constexpr int ECloudStoragePersistState_ARRAYSIZE = ECloudStoragePersistState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECloudStoragePersistState_descriptor();
template<typename T>
inline const std::string& ECloudStoragePersistState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECloudStoragePersistState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECloudStoragePersistState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECloudStoragePersistState_descriptor(), enum_t_value);
}
inline bool ECloudStoragePersistState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECloudStoragePersistState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECloudStoragePersistState>(
    ECloudStoragePersistState_descriptor(), name, value);
}
enum ESDCardFormatStage : int {
  k_ESDCardFormatStage_Invalid = 0,
  k_ESDCardFormatStage_Starting = 1,
  k_ESDCardFormatStage_Testing = 2,
  k_ESDCardFormatStage_Rescuing = 3,
  k_ESDCardFormatStage_Formatting = 4,
  k_ESDCardFormatStage_Finalizing = 5
};
bool ESDCardFormatStage_IsValid(int value);
constexpr ESDCardFormatStage ESDCardFormatStage_MIN = k_ESDCardFormatStage_Invalid;
constexpr ESDCardFormatStage ESDCardFormatStage_MAX = k_ESDCardFormatStage_Finalizing;
constexpr int ESDCardFormatStage_ARRAYSIZE = ESDCardFormatStage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESDCardFormatStage_descriptor();
template<typename T>
inline const std::string& ESDCardFormatStage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESDCardFormatStage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESDCardFormatStage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESDCardFormatStage_descriptor(), enum_t_value);
}
inline bool ESDCardFormatStage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESDCardFormatStage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESDCardFormatStage>(
    ESDCardFormatStage_descriptor(), name, value);
}
enum ESystemFanControlMode : int {
  k_SystemFanControlMode_Invalid = 0,
  k_SystemFanControlMode_Disabled = 1,
  k_SystemFanControlMode_Default = 2
};
bool ESystemFanControlMode_IsValid(int value);
constexpr ESystemFanControlMode ESystemFanControlMode_MIN = k_SystemFanControlMode_Invalid;
constexpr ESystemFanControlMode ESystemFanControlMode_MAX = k_SystemFanControlMode_Default;
constexpr int ESystemFanControlMode_ARRAYSIZE = ESystemFanControlMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemFanControlMode_descriptor();
template<typename T>
inline const std::string& ESystemFanControlMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemFanControlMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemFanControlMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemFanControlMode_descriptor(), enum_t_value);
}
inline bool ESystemFanControlMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemFanControlMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemFanControlMode>(
    ESystemFanControlMode_descriptor(), name, value);
}
enum EBluetoothDeviceType : int {
  k_BluetoothDeviceType_Invalid = 0,
  k_BluetoothDeviceType_Unknown = 1,
  k_BluetoothDeviceType_Phone = 2,
  k_BluetoothDeviceType_Computer = 3,
  k_BluetoothDeviceType_Headset = 4,
  k_BluetoothDeviceType_Headphones = 5,
  k_BluetoothDeviceType_Speakers = 6,
  k_BluetoothDeviceType_OtherAudio = 7,
  k_BluetoothDeviceType_Mouse = 8,
  k_BluetoothDeviceType_Joystick = 9,
  k_BluetoothDeviceType_Gamepad = 10,
  k_BluetoothDeviceType_Keyboard = 11
};
bool EBluetoothDeviceType_IsValid(int value);
constexpr EBluetoothDeviceType EBluetoothDeviceType_MIN = k_BluetoothDeviceType_Invalid;
constexpr EBluetoothDeviceType EBluetoothDeviceType_MAX = k_BluetoothDeviceType_Keyboard;
constexpr int EBluetoothDeviceType_ARRAYSIZE = EBluetoothDeviceType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBluetoothDeviceType_descriptor();
template<typename T>
inline const std::string& EBluetoothDeviceType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBluetoothDeviceType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBluetoothDeviceType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBluetoothDeviceType_descriptor(), enum_t_value);
}
inline bool EBluetoothDeviceType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBluetoothDeviceType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBluetoothDeviceType>(
    EBluetoothDeviceType_descriptor(), name, value);
}
enum ESystemAudioDirection : int {
  k_SystemAudioDirection_Invalid = 0,
  k_SystemAudioDirection_Input = 1,
  k_SystemAudioDirection_Output = 2
};
bool ESystemAudioDirection_IsValid(int value);
constexpr ESystemAudioDirection ESystemAudioDirection_MIN = k_SystemAudioDirection_Invalid;
constexpr ESystemAudioDirection ESystemAudioDirection_MAX = k_SystemAudioDirection_Output;
constexpr int ESystemAudioDirection_ARRAYSIZE = ESystemAudioDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioDirection_descriptor();
template<typename T>
inline const std::string& ESystemAudioDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioDirection_descriptor(), enum_t_value);
}
inline bool ESystemAudioDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioDirection>(
    ESystemAudioDirection_descriptor(), name, value);
}
enum ESystemAudioChannel : int {
  k_SystemAudioChannel_Invalid = 0,
  k_SystemAudioChannel_Aggregated = 1,
  k_SystemAudioChannel_FrontLeft = 2,
  k_SystemAudioChannel_FrontRight = 3,
  k_SystemAudioChannel_LFE = 4,
  k_SystemAudioChannel_BackLeft = 5,
  k_SystemAudioChannel_BackRight = 6,
  k_SystemAudioChannel_FrontCenter = 7,
  k_SystemAudioChannel_Unknown = 8,
  k_SystemAudioChannel_Mono = 9
};
bool ESystemAudioChannel_IsValid(int value);
constexpr ESystemAudioChannel ESystemAudioChannel_MIN = k_SystemAudioChannel_Invalid;
constexpr ESystemAudioChannel ESystemAudioChannel_MAX = k_SystemAudioChannel_Mono;
constexpr int ESystemAudioChannel_ARRAYSIZE = ESystemAudioChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioChannel_descriptor();
template<typename T>
inline const std::string& ESystemAudioChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioChannel_descriptor(), enum_t_value);
}
inline bool ESystemAudioChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioChannel>(
    ESystemAudioChannel_descriptor(), name, value);
}
enum ESystemAudioPortType : int {
  k_SystemAudioPortType_Invalid = 0,
  k_SystemAudioPortType_Unknown = 1,
  k_SystemAudioPortType_Audio32f = 2,
  k_SystemAudioPortType_Midi8b = 3,
  k_SystemAudioPortType_Video32RGBA = 4
};
bool ESystemAudioPortType_IsValid(int value);
constexpr ESystemAudioPortType ESystemAudioPortType_MIN = k_SystemAudioPortType_Invalid;
constexpr ESystemAudioPortType ESystemAudioPortType_MAX = k_SystemAudioPortType_Video32RGBA;
constexpr int ESystemAudioPortType_ARRAYSIZE = ESystemAudioPortType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioPortType_descriptor();
template<typename T>
inline const std::string& ESystemAudioPortType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioPortType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioPortType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioPortType_descriptor(), enum_t_value);
}
inline bool ESystemAudioPortType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioPortType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioPortType>(
    ESystemAudioPortType_descriptor(), name, value);
}
enum ESystemAudioPortDirection : int {
  k_SystemAudioPortDirection_Invalid = 0,
  k_SystemAudioPortDirection_Input = 1,
  k_SystemAudioPortDirection_Output = 2
};
bool ESystemAudioPortDirection_IsValid(int value);
constexpr ESystemAudioPortDirection ESystemAudioPortDirection_MIN = k_SystemAudioPortDirection_Invalid;
constexpr ESystemAudioPortDirection ESystemAudioPortDirection_MAX = k_SystemAudioPortDirection_Output;
constexpr int ESystemAudioPortDirection_ARRAYSIZE = ESystemAudioPortDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemAudioPortDirection_descriptor();
template<typename T>
inline const std::string& ESystemAudioPortDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemAudioPortDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemAudioPortDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemAudioPortDirection_descriptor(), enum_t_value);
}
inline bool ESystemAudioPortDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemAudioPortDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemAudioPortDirection>(
    ESystemAudioPortDirection_descriptor(), name, value);
}
enum ESystemServiceState : int {
  k_ESystemServiceState_Unavailable = 0,
  k_ESystemServiceState_Disabled = 1,
  k_ESystemServiceState_Enabled = 2
};
bool ESystemServiceState_IsValid(int value);
constexpr ESystemServiceState ESystemServiceState_MIN = k_ESystemServiceState_Unavailable;
constexpr ESystemServiceState ESystemServiceState_MAX = k_ESystemServiceState_Enabled;
constexpr int ESystemServiceState_ARRAYSIZE = ESystemServiceState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemServiceState_descriptor();
template<typename T>
inline const std::string& ESystemServiceState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemServiceState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemServiceState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemServiceState_descriptor(), enum_t_value);
}
inline bool ESystemServiceState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemServiceState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemServiceState>(
    ESystemServiceState_descriptor(), name, value);
}
enum EGraphicsPerfOverlayLevel : int {
  k_EGraphicsPerfOverlayLevel_Hidden = 0,
  k_EGraphicsPerfOverlayLevel_Basic = 1,
  k_EGraphicsPerfOverlayLevel_Medium = 2,
  k_EGraphicsPerfOverlayLevel_Full = 3,
  k_EGraphicsPerfOverlayLevel_Minimal = 4
};
bool EGraphicsPerfOverlayLevel_IsValid(int value);
constexpr EGraphicsPerfOverlayLevel EGraphicsPerfOverlayLevel_MIN = k_EGraphicsPerfOverlayLevel_Hidden;
constexpr EGraphicsPerfOverlayLevel EGraphicsPerfOverlayLevel_MAX = k_EGraphicsPerfOverlayLevel_Minimal;
constexpr int EGraphicsPerfOverlayLevel_ARRAYSIZE = EGraphicsPerfOverlayLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGraphicsPerfOverlayLevel_descriptor();
template<typename T>
inline const std::string& EGraphicsPerfOverlayLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGraphicsPerfOverlayLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGraphicsPerfOverlayLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGraphicsPerfOverlayLevel_descriptor(), enum_t_value);
}
inline bool EGraphicsPerfOverlayLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGraphicsPerfOverlayLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGraphicsPerfOverlayLevel>(
    EGraphicsPerfOverlayLevel_descriptor(), name, value);
}
enum EGPUPerformanceLevel : int {
  k_EGPUPerformanceLevel_Invalid = 0,
  k_EGPUPerformanceLevel_Auto = 1,
  k_EGPUPerformanceLevel_Manual = 2,
  k_EGPUPerformanceLevel_Low = 3,
  k_EGPUPerformanceLevel_High = 4,
  k_EGPUPerformanceLevel_Profiling = 5
};
bool EGPUPerformanceLevel_IsValid(int value);
constexpr EGPUPerformanceLevel EGPUPerformanceLevel_MIN = k_EGPUPerformanceLevel_Invalid;
constexpr EGPUPerformanceLevel EGPUPerformanceLevel_MAX = k_EGPUPerformanceLevel_Profiling;
constexpr int EGPUPerformanceLevel_ARRAYSIZE = EGPUPerformanceLevel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGPUPerformanceLevel_descriptor();
template<typename T>
inline const std::string& EGPUPerformanceLevel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGPUPerformanceLevel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGPUPerformanceLevel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGPUPerformanceLevel_descriptor(), enum_t_value);
}
inline bool EGPUPerformanceLevel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGPUPerformanceLevel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGPUPerformanceLevel>(
    EGPUPerformanceLevel_descriptor(), name, value);
}
enum EScalingFilter : int {
  k_EScalingFilter_Invalid = 0,
  k_EScalingFilter_FSR = 1,
  k_EScalingFilter_Nearest = 2,
  k_EScalingFilter_Integer = 3,
  k_EScalingFilter_Linear = 4,
  k_EScalingFilter_NIS = 5
};
bool EScalingFilter_IsValid(int value);
constexpr EScalingFilter EScalingFilter_MIN = k_EScalingFilter_Invalid;
constexpr EScalingFilter EScalingFilter_MAX = k_EScalingFilter_NIS;
constexpr int EScalingFilter_ARRAYSIZE = EScalingFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EScalingFilter_descriptor();
template<typename T>
inline const std::string& EScalingFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EScalingFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EScalingFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EScalingFilter_descriptor(), enum_t_value);
}
inline bool EScalingFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EScalingFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EScalingFilter>(
    EScalingFilter_descriptor(), name, value);
}
enum ESplitScalingFilter : int {
  k_ESplitScalingFilter_Invalid = 0,
  k_ESplitScalingFilter_Linear = 1,
  k_ESplitScalingFilter_Nearest = 2,
  k_ESplitScalingFilter_FSR = 3,
  k_ESplitScalingFilter_NIS = 4
};
bool ESplitScalingFilter_IsValid(int value);
constexpr ESplitScalingFilter ESplitScalingFilter_MIN = k_ESplitScalingFilter_Invalid;
constexpr ESplitScalingFilter ESplitScalingFilter_MAX = k_ESplitScalingFilter_NIS;
constexpr int ESplitScalingFilter_ARRAYSIZE = ESplitScalingFilter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScalingFilter_descriptor();
template<typename T>
inline const std::string& ESplitScalingFilter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESplitScalingFilter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESplitScalingFilter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESplitScalingFilter_descriptor(), enum_t_value);
}
inline bool ESplitScalingFilter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESplitScalingFilter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESplitScalingFilter>(
    ESplitScalingFilter_descriptor(), name, value);
}
enum ESplitScalingScaler : int {
  k_ESplitScalingScaler_Invalid = 0,
  k_ESplitScalingScaler_Auto = 1,
  k_ESplitScalingScaler_Integer = 2,
  k_ESplitScalingScaler_Fit = 3,
  k_ESplitScalingScaler_Fill = 4,
  k_ESplitScalingScaler_Stretch = 5
};
bool ESplitScalingScaler_IsValid(int value);
constexpr ESplitScalingScaler ESplitScalingScaler_MIN = k_ESplitScalingScaler_Invalid;
constexpr ESplitScalingScaler ESplitScalingScaler_MAX = k_ESplitScalingScaler_Stretch;
constexpr int ESplitScalingScaler_ARRAYSIZE = ESplitScalingScaler_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScalingScaler_descriptor();
template<typename T>
inline const std::string& ESplitScalingScaler_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESplitScalingScaler>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESplitScalingScaler_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESplitScalingScaler_descriptor(), enum_t_value);
}
inline bool ESplitScalingScaler_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESplitScalingScaler* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESplitScalingScaler>(
    ESplitScalingScaler_descriptor(), name, value);
}
enum EHDRToneMapOperator : int {
  k_EHDRToneMapOperator_Invalid = 0,
  k_EHDRToneMapOperator_Uncharted = 1,
  k_EHDRToneMapOperator_Reinhard = 2
};
bool EHDRToneMapOperator_IsValid(int value);
constexpr EHDRToneMapOperator EHDRToneMapOperator_MIN = k_EHDRToneMapOperator_Invalid;
constexpr EHDRToneMapOperator EHDRToneMapOperator_MAX = k_EHDRToneMapOperator_Reinhard;
constexpr int EHDRToneMapOperator_ARRAYSIZE = EHDRToneMapOperator_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EHDRToneMapOperator_descriptor();
template<typename T>
inline const std::string& EHDRToneMapOperator_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EHDRToneMapOperator>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EHDRToneMapOperator_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EHDRToneMapOperator_descriptor(), enum_t_value);
}
inline bool EHDRToneMapOperator_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EHDRToneMapOperator* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EHDRToneMapOperator>(
    EHDRToneMapOperator_descriptor(), name, value);
}
enum ECPUGovernor : int {
  k_ECPUGovernor_Invalid = 0,
  k_ECPUGovernor_Perf = 1,
  k_ECPUGovernor_Powersave = 2,
  k_ECPUGovernor_Manual = 3
};
bool ECPUGovernor_IsValid(int value);
constexpr ECPUGovernor ECPUGovernor_MIN = k_ECPUGovernor_Invalid;
constexpr ECPUGovernor ECPUGovernor_MAX = k_ECPUGovernor_Manual;
constexpr int ECPUGovernor_ARRAYSIZE = ECPUGovernor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECPUGovernor_descriptor();
template<typename T>
inline const std::string& ECPUGovernor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECPUGovernor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECPUGovernor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECPUGovernor_descriptor(), enum_t_value);
}
inline bool ECPUGovernor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECPUGovernor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECPUGovernor>(
    ECPUGovernor_descriptor(), name, value);
}
enum EUpdaterType : int {
  k_EUpdaterType_Invalid = 0,
  k_EUpdaterType_Client = 1,
  k_EUpdaterType_OS = 2,
  k_EUpdaterType_BIOS = 3,
  k_EUpdaterType_Aggregated = 4,
  k_EUpdaterType_Test1 = 5,
  k_EUpdaterType_Test2 = 6,
  k_EUpdaterType_Dummy = 7
};
bool EUpdaterType_IsValid(int value);
constexpr EUpdaterType EUpdaterType_MIN = k_EUpdaterType_Invalid;
constexpr EUpdaterType EUpdaterType_MAX = k_EUpdaterType_Dummy;
constexpr int EUpdaterType_ARRAYSIZE = EUpdaterType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUpdaterType_descriptor();
template<typename T>
inline const std::string& EUpdaterType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EUpdaterType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EUpdaterType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EUpdaterType_descriptor(), enum_t_value);
}
inline bool EUpdaterType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUpdaterType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EUpdaterType>(
    EUpdaterType_descriptor(), name, value);
}
enum EUpdaterState : int {
  k_EUpdaterState_Invalid = 0,
  k_EUpdaterState_UpToDate = 2,
  k_EUpdaterState_Checking = 3,
  k_EUpdaterState_Available = 4,
  k_EUpdaterState_Applying = 5,
  k_EUpdaterState_ClientRestartPending = 6,
  k_EUpdaterState_SystemRestartPending = 7
};
bool EUpdaterState_IsValid(int value);
constexpr EUpdaterState EUpdaterState_MIN = k_EUpdaterState_Invalid;
constexpr EUpdaterState EUpdaterState_MAX = k_EUpdaterState_SystemRestartPending;
constexpr int EUpdaterState_ARRAYSIZE = EUpdaterState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUpdaterState_descriptor();
template<typename T>
inline const std::string& EUpdaterState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EUpdaterState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EUpdaterState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EUpdaterState_descriptor(), enum_t_value);
}
inline bool EUpdaterState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUpdaterState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EUpdaterState>(
    EUpdaterState_descriptor(), name, value);
}
enum EStorageBlockContentType : int {
  k_EStorageBlockContentType_Invalid = 0,
  k_EStorageBlockContentType_Unknown = 1,
  k_EStorageBlockContentType_FileSystem = 2,
  k_EStorageBlockContentType_Crypto = 3,
  k_EStorageBlockContentType_Raid = 4
};
bool EStorageBlockContentType_IsValid(int value);
constexpr EStorageBlockContentType EStorageBlockContentType_MIN = k_EStorageBlockContentType_Invalid;
constexpr EStorageBlockContentType EStorageBlockContentType_MAX = k_EStorageBlockContentType_Raid;
constexpr int EStorageBlockContentType_ARRAYSIZE = EStorageBlockContentType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageBlockContentType_descriptor();
template<typename T>
inline const std::string& EStorageBlockContentType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageBlockContentType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageBlockContentType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageBlockContentType_descriptor(), enum_t_value);
}
inline bool EStorageBlockContentType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageBlockContentType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageBlockContentType>(
    EStorageBlockContentType_descriptor(), name, value);
}
enum EStorageBlockFileSystemType : int {
  k_EStorageBlockFileSystemType_Invalid = 0,
  k_EStorageBlockFileSystemType_Unknown = 1,
  k_EStorageBlockFileSystemType_VFat = 2,
  k_EStorageBlockFileSystemType_Ext4 = 3
};
bool EStorageBlockFileSystemType_IsValid(int value);
constexpr EStorageBlockFileSystemType EStorageBlockFileSystemType_MIN = k_EStorageBlockFileSystemType_Invalid;
constexpr EStorageBlockFileSystemType EStorageBlockFileSystemType_MAX = k_EStorageBlockFileSystemType_Ext4;
constexpr int EStorageBlockFileSystemType_ARRAYSIZE = EStorageBlockFileSystemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageBlockFileSystemType_descriptor();
template<typename T>
inline const std::string& EStorageBlockFileSystemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageBlockFileSystemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageBlockFileSystemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageBlockFileSystemType_descriptor(), enum_t_value);
}
inline bool EStorageBlockFileSystemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageBlockFileSystemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageBlockFileSystemType>(
    EStorageBlockFileSystemType_descriptor(), name, value);
}
enum EStorageDriveMediaType : int {
  k_EStorageDriveMediaType_Invalid = 0,
  k_EStorageDriveMediaType_Unknown = 1,
  k_EStorageDriveMediaType_HDD = 2,
  k_EStorageDriveMediaType_SSD = 3,
  k_EStorageDriveMediaType_Removable = 4
};
bool EStorageDriveMediaType_IsValid(int value);
constexpr EStorageDriveMediaType EStorageDriveMediaType_MIN = k_EStorageDriveMediaType_Invalid;
constexpr EStorageDriveMediaType EStorageDriveMediaType_MAX = k_EStorageDriveMediaType_Removable;
constexpr int EStorageDriveMediaType_ARRAYSIZE = EStorageDriveMediaType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStorageDriveMediaType_descriptor();
template<typename T>
inline const std::string& EStorageDriveMediaType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStorageDriveMediaType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStorageDriveMediaType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStorageDriveMediaType_descriptor(), enum_t_value);
}
inline bool EStorageDriveMediaType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStorageDriveMediaType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStorageDriveMediaType>(
    EStorageDriveMediaType_descriptor(), name, value);
}
enum ESystemDisplayCompatibilityMode : int {
  k_ESystemDisplayCompatibilityMode_Invalid = 0,
  k_ESystemDisplayCompatibilityMode_None = 1,
  k_ESystemDisplayCompatibilityMode_MinimalBandwith = 2
};
bool ESystemDisplayCompatibilityMode_IsValid(int value);
constexpr ESystemDisplayCompatibilityMode ESystemDisplayCompatibilityMode_MIN = k_ESystemDisplayCompatibilityMode_Invalid;
constexpr ESystemDisplayCompatibilityMode ESystemDisplayCompatibilityMode_MAX = k_ESystemDisplayCompatibilityMode_MinimalBandwith;
constexpr int ESystemDisplayCompatibilityMode_ARRAYSIZE = ESystemDisplayCompatibilityMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemDisplayCompatibilityMode_descriptor();
template<typename T>
inline const std::string& ESystemDisplayCompatibilityMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemDisplayCompatibilityMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemDisplayCompatibilityMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemDisplayCompatibilityMode_descriptor(), enum_t_value);
}
inline bool ESystemDisplayCompatibilityMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemDisplayCompatibilityMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemDisplayCompatibilityMode>(
    ESystemDisplayCompatibilityMode_descriptor(), name, value);
}
enum ESteamDeckCompatibilityCategory : int {
  k_ESteamDeckCompatibilityCategory_Unknown = 0,
  k_ESteamDeckCompatibilityCategory_Unsupported = 1,
  k_ESteamDeckCompatibilityCategory_Playable = 2,
  k_ESteamDeckCompatibilityCategory_Verified = 3
};
bool ESteamDeckCompatibilityCategory_IsValid(int value);
constexpr ESteamDeckCompatibilityCategory ESteamDeckCompatibilityCategory_MIN = k_ESteamDeckCompatibilityCategory_Unknown;
constexpr ESteamDeckCompatibilityCategory ESteamDeckCompatibilityCategory_MAX = k_ESteamDeckCompatibilityCategory_Verified;
constexpr int ESteamDeckCompatibilityCategory_ARRAYSIZE = ESteamDeckCompatibilityCategory_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityCategory_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityCategory_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityCategory>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityCategory_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityCategory_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityCategory_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityCategory* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityCategory>(
    ESteamDeckCompatibilityCategory_descriptor(), name, value);
}
enum ESteamDeckCompatibilityResultDisplayType : int {
  k_ESteamDeckCompatibilityResultDisplayType_Invisible = 0,
  k_ESteamDeckCompatibilityResultDisplayType_Informational = 1,
  k_ESteamDeckCompatibilityResultDisplayType_Unsupported = 2,
  k_ESteamDeckCompatibilityResultDisplayType_Playable = 3,
  k_ESteamDeckCompatibilityResultDisplayType_Verified = 4
};
bool ESteamDeckCompatibilityResultDisplayType_IsValid(int value);
constexpr ESteamDeckCompatibilityResultDisplayType ESteamDeckCompatibilityResultDisplayType_MIN = k_ESteamDeckCompatibilityResultDisplayType_Invisible;
constexpr ESteamDeckCompatibilityResultDisplayType ESteamDeckCompatibilityResultDisplayType_MAX = k_ESteamDeckCompatibilityResultDisplayType_Verified;
constexpr int ESteamDeckCompatibilityResultDisplayType_ARRAYSIZE = ESteamDeckCompatibilityResultDisplayType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityResultDisplayType_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityResultDisplayType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityResultDisplayType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityResultDisplayType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityResultDisplayType_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityResultDisplayType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityResultDisplayType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityResultDisplayType>(
    ESteamDeckCompatibilityResultDisplayType_descriptor(), name, value);
}
enum EACState : int {
  k_EACState_Unknown = 0,
  k_EACState_Disconnected = 1,
  k_EACState_Connected = 2,
  k_EACState_ConnectedSlow = 3
};
bool EACState_IsValid(int value);
constexpr EACState EACState_MIN = k_EACState_Unknown;
constexpr EACState EACState_MAX = k_EACState_ConnectedSlow;
constexpr int EACState_ARRAYSIZE = EACState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EACState_descriptor();
template<typename T>
inline const std::string& EACState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EACState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EACState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EACState_descriptor(), enum_t_value);
}
inline bool EACState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EACState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EACState>(
    EACState_descriptor(), name, value);
}
enum EBatteryState : int {
  k_EBatteryState_Unknown = 0,
  k_EBatteryState_Discharging = 1,
  k_EBatteryState_Charging = 2,
  k_EBatteryState_Full = 3
};
bool EBatteryState_IsValid(int value);
constexpr EBatteryState EBatteryState_MIN = k_EBatteryState_Unknown;
constexpr EBatteryState EBatteryState_MAX = k_EBatteryState_Full;
constexpr int EBatteryState_ARRAYSIZE = EBatteryState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBatteryState_descriptor();
template<typename T>
inline const std::string& EBatteryState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBatteryState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBatteryState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBatteryState_descriptor(), enum_t_value);
}
inline bool EBatteryState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBatteryState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBatteryState>(
    EBatteryState_descriptor(), name, value);
}
enum EOSBranch : int {
  k_EOSBranch_Unknown = 0,
  k_EOSBranch_Release = 1,
  k_EOSBranch_ReleaseCandidate = 2,
  k_EOSBranch_Beta = 3,
  k_EOSBranch_BetaCandidate = 4,
  k_EOSBranch_Main = 5,
  k_EOSBranch_Staging = 6
};
bool EOSBranch_IsValid(int value);
constexpr EOSBranch EOSBranch_MIN = k_EOSBranch_Unknown;
constexpr EOSBranch EOSBranch_MAX = k_EOSBranch_Staging;
constexpr int EOSBranch_ARRAYSIZE = EOSBranch_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EOSBranch_descriptor();
template<typename T>
inline const std::string& EOSBranch_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EOSBranch>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EOSBranch_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EOSBranch_descriptor(), enum_t_value);
}
inline bool EOSBranch_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EOSBranch* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EOSBranch>(
    EOSBranch_descriptor(), name, value);
}
enum ECommunityItemClass : int {
  k_ECommunityItemClass_Invalid = 0,
  k_ECommunityItemClass_Badge = 1,
  k_ECommunityItemClass_GameCard = 2,
  k_ECommunityItemClass_ProfileBackground = 3,
  k_ECommunityItemClass_Emoticon = 4,
  k_ECommunityItemClass_BoosterPack = 5,
  k_ECommunityItemClass_Consumable = 6,
  k_ECommunityItemClass_GameGoo = 7,
  k_ECommunityItemClass_ProfileModifier = 8,
  k_ECommunityItemClass_Scene = 9,
  k_ECommunityItemClass_SalienItem = 10,
  k_ECommunityItemClass_Sticker = 11,
  k_ECommunityItemClass_ChatEffect = 12,
  k_ECommunityItemClass_MiniProfileBackground = 13,
  k_ECommunityItemClass_AvatarFrame = 14,
  k_ECommunityItemClass_AnimatedAvatar = 15,
  k_ECommunityItemClass_SteamDeckKeyboardSkin = 16,
  k_ECommunityItemClass_SteamDeckStartupMovie = 17
};
bool ECommunityItemClass_IsValid(int value);
constexpr ECommunityItemClass ECommunityItemClass_MIN = k_ECommunityItemClass_Invalid;
constexpr ECommunityItemClass ECommunityItemClass_MAX = k_ECommunityItemClass_SteamDeckStartupMovie;
constexpr int ECommunityItemClass_ARRAYSIZE = ECommunityItemClass_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECommunityItemClass_descriptor();
template<typename T>
inline const std::string& ECommunityItemClass_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECommunityItemClass>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECommunityItemClass_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECommunityItemClass_descriptor(), enum_t_value);
}
inline bool ECommunityItemClass_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECommunityItemClass* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECommunityItemClass>(
    ECommunityItemClass_descriptor(), name, value);
}
enum ESteamDeckCompatibilityFeedback : int {
  k_ESteamDeckCompatibilityFeedback_Unset = 0,
  k_ESteamDeckCompatibilityFeedback_Agree = 1,
  k_ESteamDeckCompatibilityFeedback_Disagree = 2,
  k_ESteamDeckCompatibilityFeedback_Ignore = 3
};
bool ESteamDeckCompatibilityFeedback_IsValid(int value);
constexpr ESteamDeckCompatibilityFeedback ESteamDeckCompatibilityFeedback_MIN = k_ESteamDeckCompatibilityFeedback_Unset;
constexpr ESteamDeckCompatibilityFeedback ESteamDeckCompatibilityFeedback_MAX = k_ESteamDeckCompatibilityFeedback_Ignore;
constexpr int ESteamDeckCompatibilityFeedback_ARRAYSIZE = ESteamDeckCompatibilityFeedback_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckCompatibilityFeedback_descriptor();
template<typename T>
inline const std::string& ESteamDeckCompatibilityFeedback_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamDeckCompatibilityFeedback>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamDeckCompatibilityFeedback_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamDeckCompatibilityFeedback_descriptor(), enum_t_value);
}
inline bool ESteamDeckCompatibilityFeedback_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamDeckCompatibilityFeedback* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamDeckCompatibilityFeedback>(
    ESteamDeckCompatibilityFeedback_descriptor(), name, value);
}
enum EProvideDeckFeedbackPreference : int {
  k_EProvideDeckFeedbackPreference_Unset = 0,
  k_EProvideDeckFeedbackPreference_Yes = 1,
  k_EProvideDeckFeedbackPreference_No = 2
};
bool EProvideDeckFeedbackPreference_IsValid(int value);
constexpr EProvideDeckFeedbackPreference EProvideDeckFeedbackPreference_MIN = k_EProvideDeckFeedbackPreference_Unset;
constexpr EProvideDeckFeedbackPreference EProvideDeckFeedbackPreference_MAX = k_EProvideDeckFeedbackPreference_No;
constexpr int EProvideDeckFeedbackPreference_ARRAYSIZE = EProvideDeckFeedbackPreference_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EProvideDeckFeedbackPreference_descriptor();
template<typename T>
inline const std::string& EProvideDeckFeedbackPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EProvideDeckFeedbackPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EProvideDeckFeedbackPreference_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EProvideDeckFeedbackPreference_descriptor(), enum_t_value);
}
inline bool EProvideDeckFeedbackPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EProvideDeckFeedbackPreference* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EProvideDeckFeedbackPreference>(
    EProvideDeckFeedbackPreference_descriptor(), name, value);
}
enum ETouchGesture : int {
  k_ETouchGestureNone = 0,
  k_ETouchGestureTouch = 1,
  k_ETouchGestureTap = 2,
  k_ETouchGestureDoubleTap = 3,
  k_ETouchGestureShortPress = 4,
  k_ETouchGestureLongPress = 5,
  k_ETouchGestureLongTap = 6,
  k_ETouchGestureTwoFingerTap = 7,
  k_ETouchGestureTapCancelled = 8,
  k_ETouchGesturePinchBegin = 9,
  k_ETouchGesturePinchUpdate = 10,
  k_ETouchGesturePinchEnd = 11,
  k_ETouchGestureFlingStart = 12,
  k_ETouchGestureFlingCancelled = 13
};
bool ETouchGesture_IsValid(int value);
constexpr ETouchGesture ETouchGesture_MIN = k_ETouchGestureNone;
constexpr ETouchGesture ETouchGesture_MAX = k_ETouchGestureFlingCancelled;
constexpr int ETouchGesture_ARRAYSIZE = ETouchGesture_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETouchGesture_descriptor();
template<typename T>
inline const std::string& ETouchGesture_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ETouchGesture>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ETouchGesture_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ETouchGesture_descriptor(), enum_t_value);
}
inline bool ETouchGesture_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ETouchGesture* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ETouchGesture>(
    ETouchGesture_descriptor(), name, value);
}
enum ESessionPersistence : int {
  k_ESessionPersistence_Invalid = -1,
  k_ESessionPersistence_Ephemeral = 0,
  k_ESessionPersistence_Persistent = 1
};
bool ESessionPersistence_IsValid(int value);
constexpr ESessionPersistence ESessionPersistence_MIN = k_ESessionPersistence_Invalid;
constexpr ESessionPersistence ESessionPersistence_MAX = k_ESessionPersistence_Persistent;
constexpr int ESessionPersistence_ARRAYSIZE = ESessionPersistence_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESessionPersistence_descriptor();
template<typename T>
inline const std::string& ESessionPersistence_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESessionPersistence>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESessionPersistence_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESessionPersistence_descriptor(), enum_t_value);
}
inline bool ESessionPersistence_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESessionPersistence* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESessionPersistence>(
    ESessionPersistence_descriptor(), name, value);
}
enum ENewSteamAnnouncementState : int {
  k_ENewSteamAnnouncementState_Invalid = 0,
  k_ENewSteamAnnouncementState_AllRead = 1,
  k_ENewSteamAnnouncementState_NewAnnouncement = 2,
  k_ENewSteamAnnouncementState_FeaturedAnnouncement = 3
};
bool ENewSteamAnnouncementState_IsValid(int value);
constexpr ENewSteamAnnouncementState ENewSteamAnnouncementState_MIN = k_ENewSteamAnnouncementState_Invalid;
constexpr ENewSteamAnnouncementState ENewSteamAnnouncementState_MAX = k_ENewSteamAnnouncementState_FeaturedAnnouncement;
constexpr int ENewSteamAnnouncementState_ARRAYSIZE = ENewSteamAnnouncementState_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ENewSteamAnnouncementState_descriptor();
template<typename T>
inline const std::string& ENewSteamAnnouncementState_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ENewSteamAnnouncementState>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ENewSteamAnnouncementState_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ENewSteamAnnouncementState_descriptor(), enum_t_value);
}
inline bool ENewSteamAnnouncementState_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ENewSteamAnnouncementState* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ENewSteamAnnouncementState>(
    ENewSteamAnnouncementState_descriptor(), name, value);
}
enum ECommentThreadType : int {
  k_ECommentThreadTypeInvalid = 0,
  k_ECommentThreadTypeScreenshot_Deprecated = 1,
  k_ECommentThreadTypeWorkshopAccount_Developer = 2,
  k_ECommentThreadTypeWorkshopAccount_Public = 3,
  k_ECommentThreadTypePublishedFile_Developer = 4,
  k_ECommentThreadTypePublishedFile_Public = 5,
  k_ECommentThreadTypeTest = 6,
  k_ECommentThreadTypeForumTopic = 7,
  k_ECommentThreadTypeRecommendation = 8,
  k_ECommentThreadTypeVideo_Deprecated = 9,
  k_ECommentThreadTypeProfile = 10,
  k_ECommentThreadTypeNewsPost = 11,
  k_ECommentThreadTypeClan = 12,
  k_ECommentThreadTypeClanAnnouncement = 13,
  k_ECommentThreadTypeClanEvent = 14,
  k_ECommentThreadTypeUserStatusPublished = 15,
  k_ECommentThreadTypeUserReceivedNewGame = 16,
  k_ECommentThreadTypePublishedFile_Announcement = 17,
  k_ECommentThreadTypeModeratorMessage = 18,
  k_ECommentThreadTypeClanCuratedApp = 19,
  k_ECommentThreadTypeQAndASession = 20,
  k_ECommentThreadTypeMax = 21
};
bool ECommentThreadType_IsValid(int value);
constexpr ECommentThreadType ECommentThreadType_MIN = k_ECommentThreadTypeInvalid;
constexpr ECommentThreadType ECommentThreadType_MAX = k_ECommentThreadTypeMax;
constexpr int ECommentThreadType_ARRAYSIZE = ECommentThreadType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECommentThreadType_descriptor();
template<typename T>
inline const std::string& ECommentThreadType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECommentThreadType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECommentThreadType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECommentThreadType_descriptor(), enum_t_value);
}
inline bool ECommentThreadType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECommentThreadType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECommentThreadType>(
    ECommentThreadType_descriptor(), name, value);
}
enum EBroadcastPermission : int {
  k_EBroadcastPermissionDisabled = 0,
  k_EBroadcastPermissionFriendsApprove = 1,
  k_EBroadcastPermissionFriendsAllowed = 2,
  k_EBroadcastPermissionPublic = 3,
  k_EBroadcastPermissionSubscribers = 4
};
bool EBroadcastPermission_IsValid(int value);
constexpr EBroadcastPermission EBroadcastPermission_MIN = k_EBroadcastPermissionDisabled;
constexpr EBroadcastPermission EBroadcastPermission_MAX = k_EBroadcastPermissionSubscribers;
constexpr int EBroadcastPermission_ARRAYSIZE = EBroadcastPermission_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastPermission_descriptor();
template<typename T>
inline const std::string& EBroadcastPermission_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastPermission>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastPermission_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastPermission_descriptor(), enum_t_value);
}
inline bool EBroadcastPermission_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastPermission* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastPermission>(
    EBroadcastPermission_descriptor(), name, value);
}
enum EBroadcastEncoderSetting : int {
  k_EBroadcastEncoderBestQuality = 0,
  k_EBroadcastEncoderBestPerformance = 1
};
bool EBroadcastEncoderSetting_IsValid(int value);
constexpr EBroadcastEncoderSetting EBroadcastEncoderSetting_MIN = k_EBroadcastEncoderBestQuality;
constexpr EBroadcastEncoderSetting EBroadcastEncoderSetting_MAX = k_EBroadcastEncoderBestPerformance;
constexpr int EBroadcastEncoderSetting_ARRAYSIZE = EBroadcastEncoderSetting_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastEncoderSetting_descriptor();
template<typename T>
inline const std::string& EBroadcastEncoderSetting_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastEncoderSetting>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastEncoderSetting_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastEncoderSetting_descriptor(), enum_t_value);
}
inline bool EBroadcastEncoderSetting_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastEncoderSetting* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastEncoderSetting>(
    EBroadcastEncoderSetting_descriptor(), name, value);
}
enum ECloudGamingPlatform : int {
  k_ECloudGamingPlatformNone = 0,
  k_ECloudGamingPlatformValve = 1,
  k_ECloudGamingPlatformNVIDIA = 2
};
bool ECloudGamingPlatform_IsValid(int value);
constexpr ECloudGamingPlatform ECloudGamingPlatform_MIN = k_ECloudGamingPlatformNone;
constexpr ECloudGamingPlatform ECloudGamingPlatform_MAX = k_ECloudGamingPlatformNVIDIA;
constexpr int ECloudGamingPlatform_ARRAYSIZE = ECloudGamingPlatform_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECloudGamingPlatform_descriptor();
template<typename T>
inline const std::string& ECloudGamingPlatform_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ECloudGamingPlatform>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ECloudGamingPlatform_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ECloudGamingPlatform_descriptor(), enum_t_value);
}
inline bool ECloudGamingPlatform_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ECloudGamingPlatform* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ECloudGamingPlatform>(
    ECloudGamingPlatform_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EPublishedFileQueryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileQueryType>() {
  return ::EPublishedFileQueryType_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileInappropriateProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileInappropriateProvider>() {
  return ::EPublishedFileInappropriateProvider_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileInappropriateResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileInappropriateResult>() {
  return ::EPublishedFileInappropriateResult_descriptor();
}
template <> struct is_proto_enum< ::EPersonaStateFlag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPersonaStateFlag>() {
  return ::EPersonaStateFlag_descriptor();
}
template <> struct is_proto_enum< ::EContentCheckProvider> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EContentCheckProvider>() {
  return ::EContentCheckProvider_descriptor();
}
template <> struct is_proto_enum< ::EProfileCustomizationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EProfileCustomizationType>() {
  return ::EProfileCustomizationType_descriptor();
}
template <> struct is_proto_enum< ::EPublishedFileStorageSystem> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EPublishedFileStorageSystem>() {
  return ::EPublishedFileStorageSystem_descriptor();
}
template <> struct is_proto_enum< ::ECloudStoragePersistState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECloudStoragePersistState>() {
  return ::ECloudStoragePersistState_descriptor();
}
template <> struct is_proto_enum< ::ESDCardFormatStage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESDCardFormatStage>() {
  return ::ESDCardFormatStage_descriptor();
}
template <> struct is_proto_enum< ::ESystemFanControlMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemFanControlMode>() {
  return ::ESystemFanControlMode_descriptor();
}
template <> struct is_proto_enum< ::EBluetoothDeviceType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBluetoothDeviceType>() {
  return ::EBluetoothDeviceType_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioDirection>() {
  return ::ESystemAudioDirection_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioChannel>() {
  return ::ESystemAudioChannel_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioPortType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioPortType>() {
  return ::ESystemAudioPortType_descriptor();
}
template <> struct is_proto_enum< ::ESystemAudioPortDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemAudioPortDirection>() {
  return ::ESystemAudioPortDirection_descriptor();
}
template <> struct is_proto_enum< ::ESystemServiceState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemServiceState>() {
  return ::ESystemServiceState_descriptor();
}
template <> struct is_proto_enum< ::EGraphicsPerfOverlayLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGraphicsPerfOverlayLevel>() {
  return ::EGraphicsPerfOverlayLevel_descriptor();
}
template <> struct is_proto_enum< ::EGPUPerformanceLevel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGPUPerformanceLevel>() {
  return ::EGPUPerformanceLevel_descriptor();
}
template <> struct is_proto_enum< ::EScalingFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EScalingFilter>() {
  return ::EScalingFilter_descriptor();
}
template <> struct is_proto_enum< ::ESplitScalingFilter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESplitScalingFilter>() {
  return ::ESplitScalingFilter_descriptor();
}
template <> struct is_proto_enum< ::ESplitScalingScaler> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESplitScalingScaler>() {
  return ::ESplitScalingScaler_descriptor();
}
template <> struct is_proto_enum< ::EHDRToneMapOperator> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EHDRToneMapOperator>() {
  return ::EHDRToneMapOperator_descriptor();
}
template <> struct is_proto_enum< ::ECPUGovernor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECPUGovernor>() {
  return ::ECPUGovernor_descriptor();
}
template <> struct is_proto_enum< ::EUpdaterType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EUpdaterType>() {
  return ::EUpdaterType_descriptor();
}
template <> struct is_proto_enum< ::EUpdaterState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EUpdaterState>() {
  return ::EUpdaterState_descriptor();
}
template <> struct is_proto_enum< ::EStorageBlockContentType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageBlockContentType>() {
  return ::EStorageBlockContentType_descriptor();
}
template <> struct is_proto_enum< ::EStorageBlockFileSystemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageBlockFileSystemType>() {
  return ::EStorageBlockFileSystemType_descriptor();
}
template <> struct is_proto_enum< ::EStorageDriveMediaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStorageDriveMediaType>() {
  return ::EStorageDriveMediaType_descriptor();
}
template <> struct is_proto_enum< ::ESystemDisplayCompatibilityMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemDisplayCompatibilityMode>() {
  return ::ESystemDisplayCompatibilityMode_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityCategory> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityCategory>() {
  return ::ESteamDeckCompatibilityCategory_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityResultDisplayType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityResultDisplayType>() {
  return ::ESteamDeckCompatibilityResultDisplayType_descriptor();
}
template <> struct is_proto_enum< ::EACState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EACState>() {
  return ::EACState_descriptor();
}
template <> struct is_proto_enum< ::EBatteryState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBatteryState>() {
  return ::EBatteryState_descriptor();
}
template <> struct is_proto_enum< ::EOSBranch> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EOSBranch>() {
  return ::EOSBranch_descriptor();
}
template <> struct is_proto_enum< ::ECommunityItemClass> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECommunityItemClass>() {
  return ::ECommunityItemClass_descriptor();
}
template <> struct is_proto_enum< ::ESteamDeckCompatibilityFeedback> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamDeckCompatibilityFeedback>() {
  return ::ESteamDeckCompatibilityFeedback_descriptor();
}
template <> struct is_proto_enum< ::EProvideDeckFeedbackPreference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EProvideDeckFeedbackPreference>() {
  return ::EProvideDeckFeedbackPreference_descriptor();
}
template <> struct is_proto_enum< ::ETouchGesture> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ETouchGesture>() {
  return ::ETouchGesture_descriptor();
}
template <> struct is_proto_enum< ::ESessionPersistence> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESessionPersistence>() {
  return ::ESessionPersistence_descriptor();
}
template <> struct is_proto_enum< ::ENewSteamAnnouncementState> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ENewSteamAnnouncementState>() {
  return ::ENewSteamAnnouncementState_descriptor();
}
template <> struct is_proto_enum< ::ECommentThreadType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECommentThreadType>() {
  return ::ECommentThreadType_descriptor();
}
template <> struct is_proto_enum< ::EBroadcastPermission> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBroadcastPermission>() {
  return ::EBroadcastPermission_descriptor();
}
template <> struct is_proto_enum< ::EBroadcastEncoderSetting> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBroadcastEncoderSetting>() {
  return ::EBroadcastEncoderSetting_descriptor();
}
template <> struct is_proto_enum< ::ECloudGamingPlatform> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ECloudGamingPlatform>() {
  return ::ECloudGamingPlatform_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_enums_2eproto
