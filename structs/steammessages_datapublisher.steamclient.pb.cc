// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_datapublisher.steamclient.proto

#include "steammessages_datapublisher.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CDataPublisher_ClientContentCorruptionReport_Notification::CDataPublisher_ClientContentCorruptionReport_Notification(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : download_source_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , objectid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , depotid_(0u)
  , cellid_(0u)
  , corruption_type_(0u)
  , object_size_(uint64_t{0u})
  , is_manifest_(false)
  , used_https_(false)
  , oc_proxy_detected_(false){}
struct CDataPublisher_ClientContentCorruptionReport_NotificationDefaultTypeInternal {
  constexpr CDataPublisher_ClientContentCorruptionReport_NotificationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_ClientContentCorruptionReport_NotificationDefaultTypeInternal() {}
  union {
    CDataPublisher_ClientContentCorruptionReport_Notification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_ClientContentCorruptionReport_NotificationDefaultTypeInternal _CDataPublisher_ClientContentCorruptionReport_Notification_default_instance_;
constexpr CDataPublisher_ClientUpdateAppJob_Notification::CDataPublisher_ClientUpdateAppJob_Notification(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : depot_ids_()
  , error_details_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , branch_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , app_id_(0u)
  , app_state_(0u)
  , job_app_error_(0u)
  , job_duration_(0u)
  , job_bytes_downloaded_(uint64_t{0u})
  , job_bytes_staged_(uint64_t{0u})
  , files_validation_failed_(0u)
  , start_app_state_(0u)
  , bytes_comitted_(uint64_t{0u})
  , stats_machine_id_(uint64_t{0u})
  , total_bytes_downloaded_(uint64_t{0u})
  , total_bytes_staged_(uint64_t{0u})
  , total_bytes_restored_(uint64_t{0u})
  , is_borrowed_(false)
  , is_free_weekend_(false)
  , cell_id_(0u)
  , total_bytes_patched_(uint64_t{0u})
  , total_bytes_saved_(uint64_t{0u}){}
struct CDataPublisher_ClientUpdateAppJob_NotificationDefaultTypeInternal {
  constexpr CDataPublisher_ClientUpdateAppJob_NotificationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_ClientUpdateAppJob_NotificationDefaultTypeInternal() {}
  union {
    CDataPublisher_ClientUpdateAppJob_Notification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_ClientUpdateAppJob_NotificationDefaultTypeInternal _CDataPublisher_ClientUpdateAppJob_Notification_default_instance_;
constexpr CDataPublisher_GetVRDeviceInfo_Request::CDataPublisher_GetVRDeviceInfo_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : month_count_(0u){}
struct CDataPublisher_GetVRDeviceInfo_RequestDefaultTypeInternal {
  constexpr CDataPublisher_GetVRDeviceInfo_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_GetVRDeviceInfo_RequestDefaultTypeInternal() {}
  union {
    CDataPublisher_GetVRDeviceInfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_GetVRDeviceInfo_RequestDefaultTypeInternal _CDataPublisher_GetVRDeviceInfo_Request_default_instance_;
constexpr CDataPublisher_GetVRDeviceInfo_Response_Device::CDataPublisher_GetVRDeviceInfo_Response_Device(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , driver_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ref_(0u)
  , aggregation_ref_(0u)
  , total_(0u)
  , device_class_(0){}
struct CDataPublisher_GetVRDeviceInfo_Response_DeviceDefaultTypeInternal {
  constexpr CDataPublisher_GetVRDeviceInfo_Response_DeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_GetVRDeviceInfo_Response_DeviceDefaultTypeInternal() {}
  union {
    CDataPublisher_GetVRDeviceInfo_Response_Device _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_GetVRDeviceInfo_Response_DeviceDefaultTypeInternal _CDataPublisher_GetVRDeviceInfo_Response_Device_default_instance_;
constexpr CDataPublisher_GetVRDeviceInfo_Response::CDataPublisher_GetVRDeviceInfo_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_(){}
struct CDataPublisher_GetVRDeviceInfo_ResponseDefaultTypeInternal {
  constexpr CDataPublisher_GetVRDeviceInfo_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_GetVRDeviceInfo_ResponseDefaultTypeInternal() {}
  union {
    CDataPublisher_GetVRDeviceInfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_GetVRDeviceInfo_ResponseDefaultTypeInternal _CDataPublisher_GetVRDeviceInfo_Response_default_instance_;
constexpr CDataPublisher_SetVRDeviceInfoAggregationReference_Request::CDataPublisher_SetVRDeviceInfoAggregationReference_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ref_(0u)
  , aggregation_ref_(0u){}
struct CDataPublisher_SetVRDeviceInfoAggregationReference_RequestDefaultTypeInternal {
  constexpr CDataPublisher_SetVRDeviceInfoAggregationReference_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_SetVRDeviceInfoAggregationReference_RequestDefaultTypeInternal() {}
  union {
    CDataPublisher_SetVRDeviceInfoAggregationReference_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_SetVRDeviceInfoAggregationReference_RequestDefaultTypeInternal _CDataPublisher_SetVRDeviceInfoAggregationReference_Request_default_instance_;
constexpr CDataPublisher_SetVRDeviceInfoAggregationReference_Response::CDataPublisher_SetVRDeviceInfoAggregationReference_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(0u){}
struct CDataPublisher_SetVRDeviceInfoAggregationReference_ResponseDefaultTypeInternal {
  constexpr CDataPublisher_SetVRDeviceInfoAggregationReference_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_SetVRDeviceInfoAggregationReference_ResponseDefaultTypeInternal() {}
  union {
    CDataPublisher_SetVRDeviceInfoAggregationReference_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_SetVRDeviceInfoAggregationReference_ResponseDefaultTypeInternal _CDataPublisher_SetVRDeviceInfoAggregationReference_Response_default_instance_;
constexpr CDataPublisher_AddVRDeviceInfo_Request::CDataPublisher_AddVRDeviceInfo_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : manufacturer_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , model_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , driver_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controller_type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_class_(0){}
struct CDataPublisher_AddVRDeviceInfo_RequestDefaultTypeInternal {
  constexpr CDataPublisher_AddVRDeviceInfo_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_AddVRDeviceInfo_RequestDefaultTypeInternal() {}
  union {
    CDataPublisher_AddVRDeviceInfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_AddVRDeviceInfo_RequestDefaultTypeInternal _CDataPublisher_AddVRDeviceInfo_Request_default_instance_;
constexpr CDataPublisher_AddVRDeviceInfo_Response::CDataPublisher_AddVRDeviceInfo_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(0u)
  , ref_(0u){}
struct CDataPublisher_AddVRDeviceInfo_ResponseDefaultTypeInternal {
  constexpr CDataPublisher_AddVRDeviceInfo_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDataPublisher_AddVRDeviceInfo_ResponseDefaultTypeInternal() {}
  union {
    CDataPublisher_AddVRDeviceInfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDataPublisher_AddVRDeviceInfo_ResponseDefaultTypeInternal _CDataPublisher_AddVRDeviceInfo_Response_default_instance_;
constexpr CValveHWSurvey_GetSurveySchedule_Request::CValveHWSurvey_GetSurveySchedule_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : surveydatetoken_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , surveydatetokenversion_(uint64_t{0u}){}
struct CValveHWSurvey_GetSurveySchedule_RequestDefaultTypeInternal {
  constexpr CValveHWSurvey_GetSurveySchedule_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CValveHWSurvey_GetSurveySchedule_RequestDefaultTypeInternal() {}
  union {
    CValveHWSurvey_GetSurveySchedule_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CValveHWSurvey_GetSurveySchedule_RequestDefaultTypeInternal _CValveHWSurvey_GetSurveySchedule_Request_default_instance_;
constexpr CValveHWSurvey_GetSurveySchedule_Response::CValveHWSurvey_GetSurveySchedule_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : surveydatetokenversion_(uint64_t{0u})
  , surveydatetoken_(0u){}
struct CValveHWSurvey_GetSurveySchedule_ResponseDefaultTypeInternal {
  constexpr CValveHWSurvey_GetSurveySchedule_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CValveHWSurvey_GetSurveySchedule_ResponseDefaultTypeInternal() {}
  union {
    CValveHWSurvey_GetSurveySchedule_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CValveHWSurvey_GetSurveySchedule_ResponseDefaultTypeInternal _CValveHWSurvey_GetSurveySchedule_Response_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[11];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto = nullptr;
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto[2];

const uint32_t TableStruct_steammessages_5fdatapublisher_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, appid_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, depotid_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, download_source_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, objectid_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, cellid_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, is_manifest_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, object_size_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, corruption_type_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, used_https_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientContentCorruptionReport_Notification, oc_proxy_detected_),
  2,
  3,
  0,
  1,
  4,
  7,
  6,
  5,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, app_id_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, depot_ids_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, app_state_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, job_app_error_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, error_details_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, job_duration_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, files_validation_failed_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, job_bytes_downloaded_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, job_bytes_staged_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, bytes_comitted_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, start_app_state_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, stats_machine_id_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, branch_name_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_downloaded_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_staged_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_restored_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, is_borrowed_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, is_free_weekend_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_patched_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_saved_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_ClientUpdateAppJob_Notification, cell_id_),
  2,
  ~0u,
  3,
  4,
  0,
  5,
  8,
  6,
  7,
  10,
  9,
  11,
  1,
  12,
  13,
  14,
  15,
  16,
  18,
  19,
  17,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Request, month_count_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, name_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, ref_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, aggregation_ref_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, total_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, driver_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response_Device, device_class_),
  0,
  2,
  3,
  4,
  1,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_GetVRDeviceInfo_Response, device_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Request, ref_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Request, aggregation_ref_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_SetVRDeviceInfoAggregationReference_Response, result_),
  0,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, manufacturer_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, model_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, driver_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, controller_type_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Request, device_class_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Response, result_),
  PROTOBUF_FIELD_OFFSET(::CDataPublisher_AddVRDeviceInfo_Response, ref_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Request, surveydatetoken_),
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Request, surveydatetokenversion_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Response, surveydatetoken_),
  PROTOBUF_FIELD_OFFSET(::CValveHWSurvey_GetSurveySchedule_Response, surveydatetokenversion_),
  1,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 16, -1, sizeof(::CDataPublisher_ClientContentCorruptionReport_Notification)},
  { 26, 53, -1, sizeof(::CDataPublisher_ClientUpdateAppJob_Notification)},
  { 74, 81, -1, sizeof(::CDataPublisher_GetVRDeviceInfo_Request)},
  { 82, 94, -1, sizeof(::CDataPublisher_GetVRDeviceInfo_Response_Device)},
  { 100, -1, -1, sizeof(::CDataPublisher_GetVRDeviceInfo_Response)},
  { 107, 115, -1, sizeof(::CDataPublisher_SetVRDeviceInfoAggregationReference_Request)},
  { 117, 124, -1, sizeof(::CDataPublisher_SetVRDeviceInfoAggregationReference_Response)},
  { 125, 136, -1, sizeof(::CDataPublisher_AddVRDeviceInfo_Request)},
  { 141, 149, -1, sizeof(::CDataPublisher_AddVRDeviceInfo_Response)},
  { 151, 159, -1, sizeof(::CValveHWSurvey_GetSurveySchedule_Request)},
  { 161, 169, -1, sizeof(::CValveHWSurvey_GetSurveySchedule_Response)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_ClientContentCorruptionReport_Notification_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_ClientUpdateAppJob_Notification_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_GetVRDeviceInfo_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_GetVRDeviceInfo_Response_Device_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_GetVRDeviceInfo_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_SetVRDeviceInfoAggregationReference_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_SetVRDeviceInfoAggregationReference_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_AddVRDeviceInfo_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDataPublisher_AddVRDeviceInfo_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CValveHWSurvey_GetSurveySchedule_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CValveHWSurvey_GetSurveySchedule_Response_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fdatapublisher_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n-steammessages_datapublisher.steamclien"
  "t.proto\032\030steammessages_base.proto\032,steam"
  "messages_unified_base.steamclient.proto\""
  "\375\003\n9CDataPublisher_ClientContentCorrupti"
  "onReport_Notification\022\r\n\005appid\030\001 \001(\r\022\017\n\007"
  "depotid\030\002 \001(\r\0229\n\017download_source\030\003 \001(\tB "
  "\202\265\030\034host name of download source\022.\n\010obje"
  "ctid\030\004 \001(\tB\034\202\265\030\030Chunk SHA or Manifest ID"
  "\022\"\n\006cellid\030\005 \001(\rB\022\202\265\030\016Client Cell ID\022>\n\013"
  "is_manifest\030\006 \001(\010B)\202\265\030%The object is a m"
  "anifest, not a chunk\022-\n\013object_size\030\007 \001("
  "\004B\030\202\265\030\024object size in bytes\0227\n\017corruptio"
  "n_type\030\010 \001(\rB\036\202\265\030\032See EContentCorruption"
  "Type\022-\n\nused_https\030\t \001(\010B\031\202\265\030\025the reques"
  "t was HTTPS\022:\n\021oc_proxy_detected\030\n \001(\010B\037"
  "\202\265\030\033detected an OpenCache proxy\"\264\004\n.CDat"
  "aPublisher_ClientUpdateAppJob_Notificati"
  "on\022\016\n\006app_id\030\001 \001(\r\022\021\n\tdepot_ids\030\002 \003(\r\022\021\n"
  "\tapp_state\030\003 \001(\r\022\025\n\rjob_app_error\030\004 \001(\r\022"
  "\025\n\rerror_details\030\005 \001(\t\022\024\n\014job_duration\030\006"
  " \001(\r\022\037\n\027files_validation_failed\030\007 \001(\r\022\034\n"
  "\024job_bytes_downloaded\030\010 \001(\004\022\030\n\020job_bytes"
  "_staged\030\t \001(\004\022\026\n\016bytes_comitted\030\n \001(\004\022\027\n"
  "\017start_app_state\030\013 \001(\r\022\030\n\020stats_machine_"
  "id\030\014 \001(\006\022\023\n\013branch_name\030\r \001(\t\022\036\n\026total_b"
  "ytes_downloaded\030\016 \001(\004\022\032\n\022total_bytes_sta"
  "ged\030\017 \001(\004\022\034\n\024total_bytes_restored\030\020 \001(\004\022"
  "\023\n\013is_borrowed\030\021 \001(\010\022\027\n\017is_free_weekend\030"
  "\022 \001(\010\022\033\n\023total_bytes_patched\030\024 \001(\004\022\031\n\021to"
  "tal_bytes_saved\030\025 \001(\004\022\017\n\007cell_id\030\026 \001(\r\"r"
  "\n&CDataPublisher_GetVRDeviceInfo_Request"
  "\022H\n\013month_count\030\001 \001(\rB3\202\265\030/Number of mon"
  "ths for which to generate a report\"\361\003\n\'C"
  "DataPublisher_GetVRDeviceInfo_Response\022S"
  "\n\006device\030\001 \003(\0132/.CDataPublisher_GetVRDev"
  "iceInfo_Response.DeviceB\022\202\265\030\016Result devi"
  "ces\032\360\002\n\006Device\022.\n\004name\030\001 \001(\tB \202\265\030\034Name t"
  "o show for this device\0221\n\003ref\030\002 \001(\rB$\202\265\030"
  " Reference number for this device\022L\n\017agg"
  "regation_ref\030\003 \001(\rB3\202\265\030/Reference number"
  " to aggregate this device under\022(\n\005total"
  "\030\004 \001(\rB\031\202\265\030\025Sum of all the counts\0224\n\006dri"
  "ver\030\005 \001(\tB$\202\265\030 driver name reported by t"
  "he user\022U\n\014device_class\030\006 \001(\005B\?\202\265\030;Class"
  " of the device. HMD=1, controller=2, tra"
  "cker=3, base=4\"\314\001\n:CDataPublisher_SetVRD"
  "eviceInfoAggregationReference_Request\022P\n"
  "\003ref\030\001 \001(\rBC\202\265\030\?Reference number in the "
  "VRDeviceInfo table for the entry to set\022"
  "<\n\017aggregation_ref\030\002 \001(\rB#\202\265\030\037Aggregatio"
  "n to set the entry to\"d\n;CDataPublisher_"
  "SetVRDeviceInfoAggregationReference_Resp"
  "onse\022%\n\006result\030\001 \001(\rB\025\202\265\030\021k_EResultOK, e"
  "tc.\"\266\003\n&CDataPublisher_AddVRDeviceInfo_R"
  "equest\0229\n\014manufacturer\030\001 \001(\tB#\202\265\030\037Manufa"
  "cturer for the new device\022+\n\005model\030\002 \001(\t"
  "B\034\202\265\030\030Model for the new device\022]\n\006driver"
  "\030\003 \001(\tBM\202\265\030Idriver name (not including d"
  "river_). e.g. lighthouse, oculus, hologr"
  "aphic\022n\n\017controller_type\030\004 \001(\tBU\202\265\030Qcont"
  "roller type for the device. Can be an em"
  "pty string for devices with no inputs\022U\n"
  "\014device_class\030\005 \001(\005B\?\202\265\030;Class of the de"
  "vice. HMD=1, controller=2, tracker=3, ba"
  "se=4\"\216\001\n\'CDataPublisher_AddVRDeviceInfo_"
  "Response\022%\n\006result\030\001 \001(\rB\025\202\265\030\021k_EResultO"
  "K, etc.\022<\n\003ref\030\002 \001(\rB/\202\265\030+The reference "
  "number of the inserted device\"c\n(CValveH"
  "WSurvey_GetSurveySchedule_Request\022\027\n\017sur"
  "veydatetoken\030\001 \001(\t\022\036\n\026surveydatetokenver"
  "sion\030\002 \001(\006\"d\n)CValveHWSurvey_GetSurveySc"
  "hedule_Response\022\027\n\017surveydatetoken\030\001 \001(\r"
  "\022\036\n\026surveydatetokenversion\030\002 \001(\0062\245\006\n\rDat"
  "aPublisher\022h\n\035ClientContentCorruptionRep"
  "ort\022:.CDataPublisher_ClientContentCorrup"
  "tionReport_Notification\032\013.NoResponse\022X\n\030"
  "ClientUpdateAppJobReport\022/.CDataPublishe"
  "r_ClientUpdateAppJob_Notification\032\013.NoRe"
  "sponse\022\243\001\n\017GetVRDeviceInfo\022\'.CDataPublis"
  "her_GetVRDeviceInfo_Request\032(.CDataPubli"
  "sher_GetVRDeviceInfo_Response\"=\202\265\0309Gener"
  "ate a debug report of what devices are i"
  "n the survey\022\324\001\n#SetVRDeviceInfoAggregat"
  "ionReference\022;.CDataPublisher_SetVRDevic"
  "eInfoAggregationReference_Request\032<.CDat"
  "aPublisher_SetVRDeviceInfoAggregationRef"
  "erence_Response\"2\202\265\030.Set the rollup refe"
  "rence of a single VR device\022\251\001\n\017AddVRDev"
  "iceInfo\022\'.CDataPublisher_AddVRDeviceInfo"
  "_Request\032(.CDataPublisher_AddVRDeviceInf"
  "o_Response\"C\202\265\030\?Adds a device to the VRD"
  "eviceInfo table for the hardware survey\032"
  "\'\202\265\030#Data Publisher (DP) server services"
  "2\254\001\n\rValveHWSurvey\022\207\001\n\021GetSurveySchedule"
  "\022).CValveHWSurvey_GetSurveySchedule_Requ"
  "est\032*.CValveHWSurvey_GetSurveySchedule_R"
  "esponse\"\033\202\265\030\027Should I run the survey\032\021\202\265"
  "\030\rValveHWSurveyB\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_deps[2] = {
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto = {
  false, false, 3900, descriptor_table_protodef_steammessages_5fdatapublisher_2esteamclient_2eproto, "steammessages_datapublisher.steamclient.proto", 
  &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once, descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_deps, 2, 11,
  schemas, file_default_instances, TableStruct_steammessages_5fdatapublisher_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter() {
  return &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fdatapublisher_2esteamclient_2eproto(&descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto);

// ===================================================================

class CDataPublisher_ClientContentCorruptionReport_Notification::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_ClientContentCorruptionReport_Notification>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_depotid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_download_source(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_objectid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cellid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_object_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_corruption_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_used_https(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_oc_proxy_detected(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

CDataPublisher_ClientContentCorruptionReport_Notification::CDataPublisher_ClientContentCorruptionReport_Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_ClientContentCorruptionReport_Notification)
}
CDataPublisher_ClientContentCorruptionReport_Notification::CDataPublisher_ClientContentCorruptionReport_Notification(const CDataPublisher_ClientContentCorruptionReport_Notification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  download_source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    download_source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_download_source()) {
    download_source_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_download_source(), 
      GetArenaForAllocation());
  }
  objectid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    objectid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_objectid()) {
    objectid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_objectid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&oc_proxy_detected_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(oc_proxy_detected_));
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_ClientContentCorruptionReport_Notification)
}

inline void CDataPublisher_ClientContentCorruptionReport_Notification::SharedCtor() {
download_source_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  download_source_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
objectid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  objectid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&oc_proxy_detected_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(oc_proxy_detected_));
}

CDataPublisher_ClientContentCorruptionReport_Notification::~CDataPublisher_ClientContentCorruptionReport_Notification() {
  // @@protoc_insertion_point(destructor:CDataPublisher_ClientContentCorruptionReport_Notification)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_ClientContentCorruptionReport_Notification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  download_source_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  objectid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDataPublisher_ClientContentCorruptionReport_Notification::ArenaDtor(void* object) {
  CDataPublisher_ClientContentCorruptionReport_Notification* _this = reinterpret_cast< CDataPublisher_ClientContentCorruptionReport_Notification* >(object);
  (void)_this;
}
void CDataPublisher_ClientContentCorruptionReport_Notification::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_ClientContentCorruptionReport_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_ClientContentCorruptionReport_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_ClientContentCorruptionReport_Notification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      download_source_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      objectid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_manifest_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(is_manifest_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&used_https_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&oc_proxy_detected_) -
        reinterpret_cast<char*>(&used_https_)) + sizeof(oc_proxy_detected_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_ClientContentCorruptionReport_Notification::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 depotid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_depotid(&has_bits);
          depotid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string download_source = 3 [(.description) = "host name of download source"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_download_source();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_ClientContentCorruptionReport_Notification.download_source");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string objectid = 4 [(.description) = "Chunk SHA or Manifest ID"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_objectid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_ClientContentCorruptionReport_Notification.objectid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cellid = 5 [(.description) = "Client Cell ID"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_cellid(&has_bits);
          cellid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_manifest = 6 [(.description) = "The object is a manifest, not a chunk"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_manifest(&has_bits);
          is_manifest_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 object_size = 7 [(.description) = "object size in bytes"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_object_size(&has_bits);
          object_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 corruption_type = 8 [(.description) = "See EContentCorruptionType"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_corruption_type(&has_bits);
          corruption_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool used_https = 9 [(.description) = "the request was HTTPS"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_used_https(&has_bits);
          used_https_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool oc_proxy_detected = 10 [(.description) = "detected an OpenCache proxy"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_oc_proxy_detected(&has_bits);
          oc_proxy_detected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_ClientContentCorruptionReport_Notification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_ClientContentCorruptionReport_Notification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 depotid = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_depotid(), target);
  }

  // optional string download_source = 3 [(.description) = "host name of download source"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_download_source().data(), static_cast<int>(this->_internal_download_source().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_ClientContentCorruptionReport_Notification.download_source");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_download_source(), target);
  }

  // optional string objectid = 4 [(.description) = "Chunk SHA or Manifest ID"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_objectid().data(), static_cast<int>(this->_internal_objectid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_ClientContentCorruptionReport_Notification.objectid");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_objectid(), target);
  }

  // optional uint32 cellid = 5 [(.description) = "Client Cell ID"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_cellid(), target);
  }

  // optional bool is_manifest = 6 [(.description) = "The object is a manifest, not a chunk"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_manifest(), target);
  }

  // optional uint64 object_size = 7 [(.description) = "object size in bytes"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(7, this->_internal_object_size(), target);
  }

  // optional uint32 corruption_type = 8 [(.description) = "See EContentCorruptionType"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_corruption_type(), target);
  }

  // optional bool used_https = 9 [(.description) = "the request was HTTPS"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_used_https(), target);
  }

  // optional bool oc_proxy_detected = 10 [(.description) = "detected an OpenCache proxy"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_oc_proxy_detected(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_ClientContentCorruptionReport_Notification)
  return target;
}

size_t CDataPublisher_ClientContentCorruptionReport_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_ClientContentCorruptionReport_Notification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string download_source = 3 [(.description) = "host name of download source"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_download_source());
    }

    // optional string objectid = 4 [(.description) = "Chunk SHA or Manifest ID"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_objectid());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 depotid = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_depotid());
    }

    // optional uint32 cellid = 5 [(.description) = "Client Cell ID"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cellid());
    }

    // optional uint32 corruption_type = 8 [(.description) = "See EContentCorruptionType"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_corruption_type());
    }

    // optional uint64 object_size = 7 [(.description) = "object size in bytes"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_object_size());
    }

    // optional bool is_manifest = 6 [(.description) = "The object is a manifest, not a chunk"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool used_https = 9 [(.description) = "the request was HTTPS"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool oc_proxy_detected = 10 [(.description) = "detected an OpenCache proxy"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_ClientContentCorruptionReport_Notification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_ClientContentCorruptionReport_Notification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_ClientContentCorruptionReport_Notification::GetClassData() const { return &_class_data_; }

void CDataPublisher_ClientContentCorruptionReport_Notification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_ClientContentCorruptionReport_Notification *>(to)->MergeFrom(
      static_cast<const CDataPublisher_ClientContentCorruptionReport_Notification &>(from));
}


void CDataPublisher_ClientContentCorruptionReport_Notification::MergeFrom(const CDataPublisher_ClientContentCorruptionReport_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_ClientContentCorruptionReport_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_download_source(from._internal_download_source());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_objectid(from._internal_objectid());
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      depotid_ = from.depotid_;
    }
    if (cached_has_bits & 0x00000010u) {
      cellid_ = from.cellid_;
    }
    if (cached_has_bits & 0x00000020u) {
      corruption_type_ = from.corruption_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      object_size_ = from.object_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_manifest_ = from.is_manifest_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      used_https_ = from.used_https_;
    }
    if (cached_has_bits & 0x00000200u) {
      oc_proxy_detected_ = from.oc_proxy_detected_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_ClientContentCorruptionReport_Notification::CopyFrom(const CDataPublisher_ClientContentCorruptionReport_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_ClientContentCorruptionReport_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_ClientContentCorruptionReport_Notification::IsInitialized() const {
  return true;
}

void CDataPublisher_ClientContentCorruptionReport_Notification::InternalSwap(CDataPublisher_ClientContentCorruptionReport_Notification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &download_source_, lhs_arena,
      &other->download_source_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &objectid_, lhs_arena,
      &other->objectid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDataPublisher_ClientContentCorruptionReport_Notification, oc_proxy_detected_)
      + sizeof(CDataPublisher_ClientContentCorruptionReport_Notification::oc_proxy_detected_)
      - PROTOBUF_FIELD_OFFSET(CDataPublisher_ClientContentCorruptionReport_Notification, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_ClientContentCorruptionReport_Notification::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[0]);
}

// ===================================================================

class CDataPublisher_ClientUpdateAppJob_Notification::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_ClientUpdateAppJob_Notification>()._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_app_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_job_app_error(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_error_details(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_job_duration(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_files_validation_failed(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_job_bytes_downloaded(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_job_bytes_staged(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_bytes_comitted(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_start_app_state(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_stats_machine_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_branch_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_total_bytes_downloaded(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_total_bytes_staged(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_total_bytes_restored(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_borrowed(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_free_weekend(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_total_bytes_patched(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_total_bytes_saved(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

CDataPublisher_ClientUpdateAppJob_Notification::CDataPublisher_ClientUpdateAppJob_Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  depot_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_ClientUpdateAppJob_Notification)
}
CDataPublisher_ClientUpdateAppJob_Notification::CDataPublisher_ClientUpdateAppJob_Notification(const CDataPublisher_ClientUpdateAppJob_Notification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      depot_ids_(from.depot_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  error_details_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    error_details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_error_details()) {
    error_details_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_error_details(), 
      GetArenaForAllocation());
  }
  branch_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    branch_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_branch_name()) {
    branch_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_branch_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&app_id_, &from.app_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&total_bytes_saved_) -
    reinterpret_cast<char*>(&app_id_)) + sizeof(total_bytes_saved_));
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_ClientUpdateAppJob_Notification)
}

inline void CDataPublisher_ClientUpdateAppJob_Notification::SharedCtor() {
error_details_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  error_details_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
branch_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  branch_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&app_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&total_bytes_saved_) -
    reinterpret_cast<char*>(&app_id_)) + sizeof(total_bytes_saved_));
}

CDataPublisher_ClientUpdateAppJob_Notification::~CDataPublisher_ClientUpdateAppJob_Notification() {
  // @@protoc_insertion_point(destructor:CDataPublisher_ClientUpdateAppJob_Notification)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_ClientUpdateAppJob_Notification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  error_details_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  branch_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDataPublisher_ClientUpdateAppJob_Notification::ArenaDtor(void* object) {
  CDataPublisher_ClientUpdateAppJob_Notification* _this = reinterpret_cast< CDataPublisher_ClientUpdateAppJob_Notification* >(object);
  (void)_this;
}
void CDataPublisher_ClientUpdateAppJob_Notification::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_ClientUpdateAppJob_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_ClientUpdateAppJob_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_ClientUpdateAppJob_Notification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  depot_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      error_details_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      branch_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&app_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&job_bytes_staged_) -
        reinterpret_cast<char*>(&app_id_)) + sizeof(job_bytes_staged_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&files_validation_failed_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_borrowed_) -
        reinterpret_cast<char*>(&files_validation_failed_)) + sizeof(is_borrowed_));
  }
  if (cached_has_bits & 0x000f0000u) {
    ::memset(&is_free_weekend_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&total_bytes_saved_) -
        reinterpret_cast<char*>(&is_free_weekend_)) + sizeof(total_bytes_saved_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_ClientUpdateAppJob_Notification::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_id(&has_bits);
          app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 depot_ids = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_depot_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_depot_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_app_state(&has_bits);
          app_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 job_app_error = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_job_app_error(&has_bits);
          job_app_error_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string error_details = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_error_details();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_ClientUpdateAppJob_Notification.error_details");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 job_duration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_job_duration(&has_bits);
          job_duration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 files_validation_failed = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_files_validation_failed(&has_bits);
          files_validation_failed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 job_bytes_downloaded = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_job_bytes_downloaded(&has_bits);
          job_bytes_downloaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 job_bytes_staged = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_job_bytes_staged(&has_bits);
          job_bytes_staged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 bytes_comitted = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_bytes_comitted(&has_bits);
          bytes_comitted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 start_app_state = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_start_app_state(&has_bits);
          start_app_state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 stats_machine_id = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 97)) {
          _Internal::set_has_stats_machine_id(&has_bits);
          stats_machine_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string branch_name = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_branch_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_ClientUpdateAppJob_Notification.branch_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_bytes_downloaded = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_total_bytes_downloaded(&has_bits);
          total_bytes_downloaded_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_bytes_staged = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_total_bytes_staged(&has_bits);
          total_bytes_staged_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_bytes_restored = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_total_bytes_restored(&has_bits);
          total_bytes_restored_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_borrowed = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_borrowed(&has_bits);
          is_borrowed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_free_weekend = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_free_weekend(&has_bits);
          is_free_weekend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_bytes_patched = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_total_bytes_patched(&has_bits);
          total_bytes_patched_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_bytes_saved = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_total_bytes_saved(&has_bits);
          total_bytes_saved_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 cell_id = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_cell_id(&has_bits);
          cell_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_ClientUpdateAppJob_Notification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_ClientUpdateAppJob_Notification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 app_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_app_id(), target);
  }

  // repeated uint32 depot_ids = 2;
  for (int i = 0, n = this->_internal_depot_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_depot_ids(i), target);
  }

  // optional uint32 app_state = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_app_state(), target);
  }

  // optional uint32 job_app_error = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_job_app_error(), target);
  }

  // optional string error_details = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_error_details().data(), static_cast<int>(this->_internal_error_details().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_ClientUpdateAppJob_Notification.error_details");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_error_details(), target);
  }

  // optional uint32 job_duration = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_job_duration(), target);
  }

  // optional uint32 files_validation_failed = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_files_validation_failed(), target);
  }

  // optional uint64 job_bytes_downloaded = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(8, this->_internal_job_bytes_downloaded(), target);
  }

  // optional uint64 job_bytes_staged = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->_internal_job_bytes_staged(), target);
  }

  // optional uint64 bytes_comitted = 10;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(10, this->_internal_bytes_comitted(), target);
  }

  // optional uint32 start_app_state = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_start_app_state(), target);
  }

  // optional fixed64 stats_machine_id = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(12, this->_internal_stats_machine_id(), target);
  }

  // optional string branch_name = 13;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_branch_name().data(), static_cast<int>(this->_internal_branch_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_ClientUpdateAppJob_Notification.branch_name");
    target = stream->WriteStringMaybeAliased(
        13, this->_internal_branch_name(), target);
  }

  // optional uint64 total_bytes_downloaded = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(14, this->_internal_total_bytes_downloaded(), target);
  }

  // optional uint64 total_bytes_staged = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(15, this->_internal_total_bytes_staged(), target);
  }

  // optional uint64 total_bytes_restored = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(16, this->_internal_total_bytes_restored(), target);
  }

  // optional bool is_borrowed = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_is_borrowed(), target);
  }

  // optional bool is_free_weekend = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_is_free_weekend(), target);
  }

  // optional uint64 total_bytes_patched = 20;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(20, this->_internal_total_bytes_patched(), target);
  }

  // optional uint64 total_bytes_saved = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(21, this->_internal_total_bytes_saved(), target);
  }

  // optional uint32 cell_id = 22;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(22, this->_internal_cell_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_ClientUpdateAppJob_Notification)
  return target;
}

size_t CDataPublisher_ClientUpdateAppJob_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_ClientUpdateAppJob_Notification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 depot_ids = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->depot_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_depot_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string error_details = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_error_details());
    }

    // optional string branch_name = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_branch_name());
    }

    // optional uint32 app_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional uint32 app_state = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_app_state());
    }

    // optional uint32 job_app_error = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_job_app_error());
    }

    // optional uint32 job_duration = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_job_duration());
    }

    // optional uint64 job_bytes_downloaded = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_job_bytes_downloaded());
    }

    // optional uint64 job_bytes_staged = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_job_bytes_staged());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 files_validation_failed = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_files_validation_failed());
    }

    // optional uint32 start_app_state = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_start_app_state());
    }

    // optional uint64 bytes_comitted = 10;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_bytes_comitted());
    }

    // optional fixed64 stats_machine_id = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 8;
    }

    // optional uint64 total_bytes_downloaded = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_total_bytes_downloaded());
    }

    // optional uint64 total_bytes_staged = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_total_bytes_staged());
    }

    // optional uint64 total_bytes_restored = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_total_bytes_restored());
    }

    // optional bool is_borrowed = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x000f0000u) {
    // optional bool is_free_weekend = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional uint32 cell_id = 22;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_cell_id());
    }

    // optional uint64 total_bytes_patched = 20;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_total_bytes_patched());
    }

    // optional uint64 total_bytes_saved = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->_internal_total_bytes_saved());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_ClientUpdateAppJob_Notification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_ClientUpdateAppJob_Notification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_ClientUpdateAppJob_Notification::GetClassData() const { return &_class_data_; }

void CDataPublisher_ClientUpdateAppJob_Notification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_ClientUpdateAppJob_Notification *>(to)->MergeFrom(
      static_cast<const CDataPublisher_ClientUpdateAppJob_Notification &>(from));
}


void CDataPublisher_ClientUpdateAppJob_Notification::MergeFrom(const CDataPublisher_ClientUpdateAppJob_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_ClientUpdateAppJob_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  depot_ids_.MergeFrom(from.depot_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_error_details(from._internal_error_details());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_branch_name(from._internal_branch_name());
    }
    if (cached_has_bits & 0x00000004u) {
      app_id_ = from.app_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      app_state_ = from.app_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      job_app_error_ = from.job_app_error_;
    }
    if (cached_has_bits & 0x00000020u) {
      job_duration_ = from.job_duration_;
    }
    if (cached_has_bits & 0x00000040u) {
      job_bytes_downloaded_ = from.job_bytes_downloaded_;
    }
    if (cached_has_bits & 0x00000080u) {
      job_bytes_staged_ = from.job_bytes_staged_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      files_validation_failed_ = from.files_validation_failed_;
    }
    if (cached_has_bits & 0x00000200u) {
      start_app_state_ = from.start_app_state_;
    }
    if (cached_has_bits & 0x00000400u) {
      bytes_comitted_ = from.bytes_comitted_;
    }
    if (cached_has_bits & 0x00000800u) {
      stats_machine_id_ = from.stats_machine_id_;
    }
    if (cached_has_bits & 0x00001000u) {
      total_bytes_downloaded_ = from.total_bytes_downloaded_;
    }
    if (cached_has_bits & 0x00002000u) {
      total_bytes_staged_ = from.total_bytes_staged_;
    }
    if (cached_has_bits & 0x00004000u) {
      total_bytes_restored_ = from.total_bytes_restored_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_borrowed_ = from.is_borrowed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x000f0000u) {
    if (cached_has_bits & 0x00010000u) {
      is_free_weekend_ = from.is_free_weekend_;
    }
    if (cached_has_bits & 0x00020000u) {
      cell_id_ = from.cell_id_;
    }
    if (cached_has_bits & 0x00040000u) {
      total_bytes_patched_ = from.total_bytes_patched_;
    }
    if (cached_has_bits & 0x00080000u) {
      total_bytes_saved_ = from.total_bytes_saved_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_ClientUpdateAppJob_Notification::CopyFrom(const CDataPublisher_ClientUpdateAppJob_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_ClientUpdateAppJob_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_ClientUpdateAppJob_Notification::IsInitialized() const {
  return true;
}

void CDataPublisher_ClientUpdateAppJob_Notification::InternalSwap(CDataPublisher_ClientUpdateAppJob_Notification* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  depot_ids_.InternalSwap(&other->depot_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &error_details_, lhs_arena,
      &other->error_details_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &branch_name_, lhs_arena,
      &other->branch_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDataPublisher_ClientUpdateAppJob_Notification, total_bytes_saved_)
      + sizeof(CDataPublisher_ClientUpdateAppJob_Notification::total_bytes_saved_)
      - PROTOBUF_FIELD_OFFSET(CDataPublisher_ClientUpdateAppJob_Notification, app_id_)>(
          reinterpret_cast<char*>(&app_id_),
          reinterpret_cast<char*>(&other->app_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_ClientUpdateAppJob_Notification::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[1]);
}

// ===================================================================

class CDataPublisher_GetVRDeviceInfo_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_GetVRDeviceInfo_Request>()._has_bits_);
  static void set_has_month_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDataPublisher_GetVRDeviceInfo_Request::CDataPublisher_GetVRDeviceInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_GetVRDeviceInfo_Request)
}
CDataPublisher_GetVRDeviceInfo_Request::CDataPublisher_GetVRDeviceInfo_Request(const CDataPublisher_GetVRDeviceInfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  month_count_ = from.month_count_;
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_GetVRDeviceInfo_Request)
}

inline void CDataPublisher_GetVRDeviceInfo_Request::SharedCtor() {
month_count_ = 0u;
}

CDataPublisher_GetVRDeviceInfo_Request::~CDataPublisher_GetVRDeviceInfo_Request() {
  // @@protoc_insertion_point(destructor:CDataPublisher_GetVRDeviceInfo_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_GetVRDeviceInfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDataPublisher_GetVRDeviceInfo_Request::ArenaDtor(void* object) {
  CDataPublisher_GetVRDeviceInfo_Request* _this = reinterpret_cast< CDataPublisher_GetVRDeviceInfo_Request* >(object);
  (void)_this;
}
void CDataPublisher_GetVRDeviceInfo_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_GetVRDeviceInfo_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_GetVRDeviceInfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_GetVRDeviceInfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  month_count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_GetVRDeviceInfo_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 month_count = 1 [(.description) = "Number of months for which to generate a report"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_month_count(&has_bits);
          month_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_GetVRDeviceInfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_GetVRDeviceInfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 month_count = 1 [(.description) = "Number of months for which to generate a report"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_month_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_GetVRDeviceInfo_Request)
  return target;
}

size_t CDataPublisher_GetVRDeviceInfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_GetVRDeviceInfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 month_count = 1 [(.description) = "Number of months for which to generate a report"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_month_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_GetVRDeviceInfo_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_GetVRDeviceInfo_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_GetVRDeviceInfo_Request::GetClassData() const { return &_class_data_; }

void CDataPublisher_GetVRDeviceInfo_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_GetVRDeviceInfo_Request *>(to)->MergeFrom(
      static_cast<const CDataPublisher_GetVRDeviceInfo_Request &>(from));
}


void CDataPublisher_GetVRDeviceInfo_Request::MergeFrom(const CDataPublisher_GetVRDeviceInfo_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_GetVRDeviceInfo_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_month_count()) {
    _internal_set_month_count(from._internal_month_count());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_GetVRDeviceInfo_Request::CopyFrom(const CDataPublisher_GetVRDeviceInfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_GetVRDeviceInfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_GetVRDeviceInfo_Request::IsInitialized() const {
  return true;
}

void CDataPublisher_GetVRDeviceInfo_Request::InternalSwap(CDataPublisher_GetVRDeviceInfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(month_count_, other->month_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_GetVRDeviceInfo_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[2]);
}

// ===================================================================

class CDataPublisher_GetVRDeviceInfo_Response_Device::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_GetVRDeviceInfo_Response_Device>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_aggregation_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_device_class(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CDataPublisher_GetVRDeviceInfo_Response_Device::CDataPublisher_GetVRDeviceInfo_Response_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_GetVRDeviceInfo_Response.Device)
}
CDataPublisher_GetVRDeviceInfo_Response_Device::CDataPublisher_GetVRDeviceInfo_Response_Device(const CDataPublisher_GetVRDeviceInfo_Response_Device& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  driver_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    driver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    driver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_driver(), 
      GetArenaForAllocation());
  }
  ::memcpy(&ref_, &from.ref_,
    static_cast<size_t>(reinterpret_cast<char*>(&device_class_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(device_class_));
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_GetVRDeviceInfo_Response.Device)
}

inline void CDataPublisher_GetVRDeviceInfo_Response_Device::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
driver_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  driver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ref_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_class_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(device_class_));
}

CDataPublisher_GetVRDeviceInfo_Response_Device::~CDataPublisher_GetVRDeviceInfo_Response_Device() {
  // @@protoc_insertion_point(destructor:CDataPublisher_GetVRDeviceInfo_Response.Device)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_GetVRDeviceInfo_Response_Device::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  driver_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDataPublisher_GetVRDeviceInfo_Response_Device::ArenaDtor(void* object) {
  CDataPublisher_GetVRDeviceInfo_Response_Device* _this = reinterpret_cast< CDataPublisher_GetVRDeviceInfo_Response_Device* >(object);
  (void)_this;
}
void CDataPublisher_GetVRDeviceInfo_Response_Device::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_GetVRDeviceInfo_Response_Device::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_GetVRDeviceInfo_Response_Device::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_GetVRDeviceInfo_Response.Device)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      driver_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&ref_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&device_class_) -
        reinterpret_cast<char*>(&ref_)) + sizeof(device_class_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_GetVRDeviceInfo_Response_Device::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1 [(.description) = "Name to show for this device"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_GetVRDeviceInfo_Response.Device.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ref = 2 [(.description) = "Reference number for this device"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ref(&has_bits);
          ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 aggregation_ref = 3 [(.description) = "Reference number to aggregate this device under"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_aggregation_ref(&has_bits);
          aggregation_ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 total = 4 [(.description) = "Sum of all the counts"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_total(&has_bits);
          total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver = 5 [(.description) = "driver name reported by the user"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_driver();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_GetVRDeviceInfo_Response.Device.driver");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 device_class = 6 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_device_class(&has_bits);
          device_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_GetVRDeviceInfo_Response_Device::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_GetVRDeviceInfo_Response.Device)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1 [(.description) = "Name to show for this device"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_GetVRDeviceInfo_Response.Device.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional uint32 ref = 2 [(.description) = "Reference number for this device"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ref(), target);
  }

  // optional uint32 aggregation_ref = 3 [(.description) = "Reference number to aggregate this device under"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_aggregation_ref(), target);
  }

  // optional uint32 total = 4 [(.description) = "Sum of all the counts"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_total(), target);
  }

  // optional string driver = 5 [(.description) = "driver name reported by the user"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_driver().data(), static_cast<int>(this->_internal_driver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_GetVRDeviceInfo_Response.Device.driver");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_driver(), target);
  }

  // optional int32 device_class = 6 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_device_class(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_GetVRDeviceInfo_Response.Device)
  return target;
}

size_t CDataPublisher_GetVRDeviceInfo_Response_Device::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_GetVRDeviceInfo_Response.Device)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 1 [(.description) = "Name to show for this device"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string driver = 5 [(.description) = "driver name reported by the user"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver());
    }

    // optional uint32 ref = 2 [(.description) = "Reference number for this device"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ref());
    }

    // optional uint32 aggregation_ref = 3 [(.description) = "Reference number to aggregate this device under"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_aggregation_ref());
    }

    // optional uint32 total = 4 [(.description) = "Sum of all the counts"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_total());
    }

    // optional int32 device_class = 6 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_device_class());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_GetVRDeviceInfo_Response_Device::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_GetVRDeviceInfo_Response_Device::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_GetVRDeviceInfo_Response_Device::GetClassData() const { return &_class_data_; }

void CDataPublisher_GetVRDeviceInfo_Response_Device::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_GetVRDeviceInfo_Response_Device *>(to)->MergeFrom(
      static_cast<const CDataPublisher_GetVRDeviceInfo_Response_Device &>(from));
}


void CDataPublisher_GetVRDeviceInfo_Response_Device::MergeFrom(const CDataPublisher_GetVRDeviceInfo_Response_Device& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_GetVRDeviceInfo_Response.Device)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000004u) {
      ref_ = from.ref_;
    }
    if (cached_has_bits & 0x00000008u) {
      aggregation_ref_ = from.aggregation_ref_;
    }
    if (cached_has_bits & 0x00000010u) {
      total_ = from.total_;
    }
    if (cached_has_bits & 0x00000020u) {
      device_class_ = from.device_class_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_GetVRDeviceInfo_Response_Device::CopyFrom(const CDataPublisher_GetVRDeviceInfo_Response_Device& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_GetVRDeviceInfo_Response.Device)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_GetVRDeviceInfo_Response_Device::IsInitialized() const {
  return true;
}

void CDataPublisher_GetVRDeviceInfo_Response_Device::InternalSwap(CDataPublisher_GetVRDeviceInfo_Response_Device* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &driver_, lhs_arena,
      &other->driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDataPublisher_GetVRDeviceInfo_Response_Device, device_class_)
      + sizeof(CDataPublisher_GetVRDeviceInfo_Response_Device::device_class_)
      - PROTOBUF_FIELD_OFFSET(CDataPublisher_GetVRDeviceInfo_Response_Device, ref_)>(
          reinterpret_cast<char*>(&ref_),
          reinterpret_cast<char*>(&other->ref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_GetVRDeviceInfo_Response_Device::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[3]);
}

// ===================================================================

class CDataPublisher_GetVRDeviceInfo_Response::_Internal {
 public:
};

CDataPublisher_GetVRDeviceInfo_Response::CDataPublisher_GetVRDeviceInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  device_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_GetVRDeviceInfo_Response)
}
CDataPublisher_GetVRDeviceInfo_Response::CDataPublisher_GetVRDeviceInfo_Response(const CDataPublisher_GetVRDeviceInfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      device_(from.device_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_GetVRDeviceInfo_Response)
}

inline void CDataPublisher_GetVRDeviceInfo_Response::SharedCtor() {
}

CDataPublisher_GetVRDeviceInfo_Response::~CDataPublisher_GetVRDeviceInfo_Response() {
  // @@protoc_insertion_point(destructor:CDataPublisher_GetVRDeviceInfo_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_GetVRDeviceInfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDataPublisher_GetVRDeviceInfo_Response::ArenaDtor(void* object) {
  CDataPublisher_GetVRDeviceInfo_Response* _this = reinterpret_cast< CDataPublisher_GetVRDeviceInfo_Response* >(object);
  (void)_this;
}
void CDataPublisher_GetVRDeviceInfo_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_GetVRDeviceInfo_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_GetVRDeviceInfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_GetVRDeviceInfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_GetVRDeviceInfo_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CDataPublisher_GetVRDeviceInfo_Response.Device device = 1 [(.description) = "Result devices"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_device(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_GetVRDeviceInfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_GetVRDeviceInfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CDataPublisher_GetVRDeviceInfo_Response.Device device = 1 [(.description) = "Result devices"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_device_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_device(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_GetVRDeviceInfo_Response)
  return target;
}

size_t CDataPublisher_GetVRDeviceInfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_GetVRDeviceInfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CDataPublisher_GetVRDeviceInfo_Response.Device device = 1 [(.description) = "Result devices"];
  total_size += 1UL * this->_internal_device_size();
  for (const auto& msg : this->device_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_GetVRDeviceInfo_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_GetVRDeviceInfo_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_GetVRDeviceInfo_Response::GetClassData() const { return &_class_data_; }

void CDataPublisher_GetVRDeviceInfo_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_GetVRDeviceInfo_Response *>(to)->MergeFrom(
      static_cast<const CDataPublisher_GetVRDeviceInfo_Response &>(from));
}


void CDataPublisher_GetVRDeviceInfo_Response::MergeFrom(const CDataPublisher_GetVRDeviceInfo_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_GetVRDeviceInfo_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  device_.MergeFrom(from.device_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_GetVRDeviceInfo_Response::CopyFrom(const CDataPublisher_GetVRDeviceInfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_GetVRDeviceInfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_GetVRDeviceInfo_Response::IsInitialized() const {
  return true;
}

void CDataPublisher_GetVRDeviceInfo_Response::InternalSwap(CDataPublisher_GetVRDeviceInfo_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  device_.InternalSwap(&other->device_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_GetVRDeviceInfo_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[4]);
}

// ===================================================================

class CDataPublisher_SetVRDeviceInfoAggregationReference_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_SetVRDeviceInfoAggregationReference_Request>()._has_bits_);
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_aggregation_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDataPublisher_SetVRDeviceInfoAggregationReference_Request::CDataPublisher_SetVRDeviceInfoAggregationReference_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
}
CDataPublisher_SetVRDeviceInfoAggregationReference_Request::CDataPublisher_SetVRDeviceInfoAggregationReference_Request(const CDataPublisher_SetVRDeviceInfoAggregationReference_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ref_, &from.ref_,
    static_cast<size_t>(reinterpret_cast<char*>(&aggregation_ref_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(aggregation_ref_));
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
}

inline void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ref_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&aggregation_ref_) -
    reinterpret_cast<char*>(&ref_)) + sizeof(aggregation_ref_));
}

CDataPublisher_SetVRDeviceInfoAggregationReference_Request::~CDataPublisher_SetVRDeviceInfoAggregationReference_Request() {
  // @@protoc_insertion_point(destructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::ArenaDtor(void* object) {
  CDataPublisher_SetVRDeviceInfoAggregationReference_Request* _this = reinterpret_cast< CDataPublisher_SetVRDeviceInfoAggregationReference_Request* >(object);
  (void)_this;
}
void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ref_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&aggregation_ref_) -
        reinterpret_cast<char*>(&ref_)) + sizeof(aggregation_ref_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_SetVRDeviceInfoAggregationReference_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ref = 1 [(.description) = "Reference number in the VRDeviceInfo table for the entry to set"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ref(&has_bits);
          ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 aggregation_ref = 2 [(.description) = "Aggregation to set the entry to"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_aggregation_ref(&has_bits);
          aggregation_ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_SetVRDeviceInfoAggregationReference_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 ref = 1 [(.description) = "Reference number in the VRDeviceInfo table for the entry to set"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ref(), target);
  }

  // optional uint32 aggregation_ref = 2 [(.description) = "Aggregation to set the entry to"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_aggregation_ref(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  return target;
}

size_t CDataPublisher_SetVRDeviceInfoAggregationReference_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 ref = 1 [(.description) = "Reference number in the VRDeviceInfo table for the entry to set"];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ref());
    }

    // optional uint32 aggregation_ref = 2 [(.description) = "Aggregation to set the entry to"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_aggregation_ref());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_SetVRDeviceInfoAggregationReference_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_SetVRDeviceInfoAggregationReference_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_SetVRDeviceInfoAggregationReference_Request::GetClassData() const { return &_class_data_; }

void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_SetVRDeviceInfoAggregationReference_Request *>(to)->MergeFrom(
      static_cast<const CDataPublisher_SetVRDeviceInfoAggregationReference_Request &>(from));
}


void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::MergeFrom(const CDataPublisher_SetVRDeviceInfoAggregationReference_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ref_ = from.ref_;
    }
    if (cached_has_bits & 0x00000002u) {
      aggregation_ref_ = from.aggregation_ref_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::CopyFrom(const CDataPublisher_SetVRDeviceInfoAggregationReference_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_SetVRDeviceInfoAggregationReference_Request::IsInitialized() const {
  return true;
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Request::InternalSwap(CDataPublisher_SetVRDeviceInfoAggregationReference_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDataPublisher_SetVRDeviceInfoAggregationReference_Request, aggregation_ref_)
      + sizeof(CDataPublisher_SetVRDeviceInfoAggregationReference_Request::aggregation_ref_)
      - PROTOBUF_FIELD_OFFSET(CDataPublisher_SetVRDeviceInfoAggregationReference_Request, ref_)>(
          reinterpret_cast<char*>(&ref_),
          reinterpret_cast<char*>(&other->ref_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_SetVRDeviceInfoAggregationReference_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[5]);
}

// ===================================================================

class CDataPublisher_SetVRDeviceInfoAggregationReference_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_SetVRDeviceInfoAggregationReference_Response>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDataPublisher_SetVRDeviceInfoAggregationReference_Response::CDataPublisher_SetVRDeviceInfoAggregationReference_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
}
CDataPublisher_SetVRDeviceInfoAggregationReference_Response::CDataPublisher_SetVRDeviceInfoAggregationReference_Response(const CDataPublisher_SetVRDeviceInfoAggregationReference_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  result_ = from.result_;
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
}

inline void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::SharedCtor() {
result_ = 0u;
}

CDataPublisher_SetVRDeviceInfoAggregationReference_Response::~CDataPublisher_SetVRDeviceInfoAggregationReference_Response() {
  // @@protoc_insertion_point(destructor:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::ArenaDtor(void* object) {
  CDataPublisher_SetVRDeviceInfoAggregationReference_Response* _this = reinterpret_cast< CDataPublisher_SetVRDeviceInfoAggregationReference_Response* >(object);
  (void)_this;
}
void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  result_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_SetVRDeviceInfoAggregationReference_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_SetVRDeviceInfoAggregationReference_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_result(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  return target;
}

size_t CDataPublisher_SetVRDeviceInfoAggregationReference_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_SetVRDeviceInfoAggregationReference_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_SetVRDeviceInfoAggregationReference_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_SetVRDeviceInfoAggregationReference_Response::GetClassData() const { return &_class_data_; }

void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_SetVRDeviceInfoAggregationReference_Response *>(to)->MergeFrom(
      static_cast<const CDataPublisher_SetVRDeviceInfoAggregationReference_Response &>(from));
}


void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::MergeFrom(const CDataPublisher_SetVRDeviceInfoAggregationReference_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_result()) {
    _internal_set_result(from._internal_result());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::CopyFrom(const CDataPublisher_SetVRDeviceInfoAggregationReference_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_SetVRDeviceInfoAggregationReference_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_SetVRDeviceInfoAggregationReference_Response::IsInitialized() const {
  return true;
}

void CDataPublisher_SetVRDeviceInfoAggregationReference_Response::InternalSwap(CDataPublisher_SetVRDeviceInfoAggregationReference_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(result_, other->result_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_SetVRDeviceInfoAggregationReference_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[6]);
}

// ===================================================================

class CDataPublisher_AddVRDeviceInfo_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_AddVRDeviceInfo_Request>()._has_bits_);
  static void set_has_manufacturer(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_driver(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_controller_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_class(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CDataPublisher_AddVRDeviceInfo_Request::CDataPublisher_AddVRDeviceInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_AddVRDeviceInfo_Request)
}
CDataPublisher_AddVRDeviceInfo_Request::CDataPublisher_AddVRDeviceInfo_Request(const CDataPublisher_AddVRDeviceInfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    manufacturer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_manufacturer()) {
    manufacturer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_manufacturer(), 
      GetArenaForAllocation());
  }
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model(), 
      GetArenaForAllocation());
  }
  driver_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    driver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_driver()) {
    driver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_driver(), 
      GetArenaForAllocation());
  }
  controller_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controller_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_type()) {
    controller_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controller_type(), 
      GetArenaForAllocation());
  }
  device_class_ = from.device_class_;
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_AddVRDeviceInfo_Request)
}

inline void CDataPublisher_AddVRDeviceInfo_Request::SharedCtor() {
manufacturer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  manufacturer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
driver_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  driver_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
controller_type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controller_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_class_ = 0;
}

CDataPublisher_AddVRDeviceInfo_Request::~CDataPublisher_AddVRDeviceInfo_Request() {
  // @@protoc_insertion_point(destructor:CDataPublisher_AddVRDeviceInfo_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_AddVRDeviceInfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  manufacturer_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  driver_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  controller_type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDataPublisher_AddVRDeviceInfo_Request::ArenaDtor(void* object) {
  CDataPublisher_AddVRDeviceInfo_Request* _this = reinterpret_cast< CDataPublisher_AddVRDeviceInfo_Request* >(object);
  (void)_this;
}
void CDataPublisher_AddVRDeviceInfo_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_AddVRDeviceInfo_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_AddVRDeviceInfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_AddVRDeviceInfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      manufacturer_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      driver_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      controller_type_.ClearNonDefaultToEmpty();
    }
  }
  device_class_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_AddVRDeviceInfo_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string manufacturer = 1 [(.description) = "Manufacturer for the new device"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_manufacturer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_AddVRDeviceInfo_Request.manufacturer");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 2 [(.description) = "Model for the new device"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_AddVRDeviceInfo_Request.model");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string driver = 3 [(.description) = "driver name (not including driver_). e.g. lighthouse, oculus, holographic"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_driver();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_AddVRDeviceInfo_Request.driver");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controller_type = 4 [(.description) = "controller type for the device. Can be an empty string for devices with no inputs"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_controller_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CDataPublisher_AddVRDeviceInfo_Request.controller_type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 device_class = 5 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_device_class(&has_bits);
          device_class_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_AddVRDeviceInfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_AddVRDeviceInfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string manufacturer = 1 [(.description) = "Manufacturer for the new device"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_manufacturer().data(), static_cast<int>(this->_internal_manufacturer().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_AddVRDeviceInfo_Request.manufacturer");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_manufacturer(), target);
  }

  // optional string model = 2 [(.description) = "Model for the new device"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_AddVRDeviceInfo_Request.model");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  // optional string driver = 3 [(.description) = "driver name (not including driver_). e.g. lighthouse, oculus, holographic"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_driver().data(), static_cast<int>(this->_internal_driver().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_AddVRDeviceInfo_Request.driver");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_driver(), target);
  }

  // optional string controller_type = 4 [(.description) = "controller type for the device. Can be an empty string for devices with no inputs"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controller_type().data(), static_cast<int>(this->_internal_controller_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CDataPublisher_AddVRDeviceInfo_Request.controller_type");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_controller_type(), target);
  }

  // optional int32 device_class = 5 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_device_class(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_AddVRDeviceInfo_Request)
  return target;
}

size_t CDataPublisher_AddVRDeviceInfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_AddVRDeviceInfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string manufacturer = 1 [(.description) = "Manufacturer for the new device"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_manufacturer());
    }

    // optional string model = 2 [(.description) = "Model for the new device"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional string driver = 3 [(.description) = "driver name (not including driver_). e.g. lighthouse, oculus, holographic"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_driver());
    }

    // optional string controller_type = 4 [(.description) = "controller type for the device. Can be an empty string for devices with no inputs"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_type());
    }

    // optional int32 device_class = 5 [(.description) = "Class of the device. HMD=1, controller=2, tracker=3, base=4"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_device_class());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_AddVRDeviceInfo_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_AddVRDeviceInfo_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_AddVRDeviceInfo_Request::GetClassData() const { return &_class_data_; }

void CDataPublisher_AddVRDeviceInfo_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_AddVRDeviceInfo_Request *>(to)->MergeFrom(
      static_cast<const CDataPublisher_AddVRDeviceInfo_Request &>(from));
}


void CDataPublisher_AddVRDeviceInfo_Request::MergeFrom(const CDataPublisher_AddVRDeviceInfo_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_AddVRDeviceInfo_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_manufacturer(from._internal_manufacturer());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_driver(from._internal_driver());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_controller_type(from._internal_controller_type());
    }
    if (cached_has_bits & 0x00000010u) {
      device_class_ = from.device_class_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_AddVRDeviceInfo_Request::CopyFrom(const CDataPublisher_AddVRDeviceInfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_AddVRDeviceInfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_AddVRDeviceInfo_Request::IsInitialized() const {
  return true;
}

void CDataPublisher_AddVRDeviceInfo_Request::InternalSwap(CDataPublisher_AddVRDeviceInfo_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &manufacturer_, lhs_arena,
      &other->manufacturer_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &driver_, lhs_arena,
      &other->driver_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controller_type_, lhs_arena,
      &other->controller_type_, rhs_arena
  );
  swap(device_class_, other->device_class_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_AddVRDeviceInfo_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[7]);
}

// ===================================================================

class CDataPublisher_AddVRDeviceInfo_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CDataPublisher_AddVRDeviceInfo_Response>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ref(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDataPublisher_AddVRDeviceInfo_Response::CDataPublisher_AddVRDeviceInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDataPublisher_AddVRDeviceInfo_Response)
}
CDataPublisher_AddVRDeviceInfo_Response::CDataPublisher_AddVRDeviceInfo_Response(const CDataPublisher_AddVRDeviceInfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&result_, &from.result_,
    static_cast<size_t>(reinterpret_cast<char*>(&ref_) -
    reinterpret_cast<char*>(&result_)) + sizeof(ref_));
  // @@protoc_insertion_point(copy_constructor:CDataPublisher_AddVRDeviceInfo_Response)
}

inline void CDataPublisher_AddVRDeviceInfo_Response::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&ref_) -
    reinterpret_cast<char*>(&result_)) + sizeof(ref_));
}

CDataPublisher_AddVRDeviceInfo_Response::~CDataPublisher_AddVRDeviceInfo_Response() {
  // @@protoc_insertion_point(destructor:CDataPublisher_AddVRDeviceInfo_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDataPublisher_AddVRDeviceInfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDataPublisher_AddVRDeviceInfo_Response::ArenaDtor(void* object) {
  CDataPublisher_AddVRDeviceInfo_Response* _this = reinterpret_cast< CDataPublisher_AddVRDeviceInfo_Response* >(object);
  (void)_this;
}
void CDataPublisher_AddVRDeviceInfo_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDataPublisher_AddVRDeviceInfo_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDataPublisher_AddVRDeviceInfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CDataPublisher_AddVRDeviceInfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&result_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&ref_) -
        reinterpret_cast<char*>(&result_)) + sizeof(ref_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDataPublisher_AddVRDeviceInfo_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_result(&has_bits);
          result_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 ref = 2 [(.description) = "The reference number of the inserted device"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_ref(&has_bits);
          ref_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDataPublisher_AddVRDeviceInfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDataPublisher_AddVRDeviceInfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_result(), target);
  }

  // optional uint32 ref = 2 [(.description) = "The reference number of the inserted device"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_ref(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDataPublisher_AddVRDeviceInfo_Response)
  return target;
}

size_t CDataPublisher_AddVRDeviceInfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDataPublisher_AddVRDeviceInfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 result = 1 [(.description) = "k_EResultOK, etc."];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_result());
    }

    // optional uint32 ref = 2 [(.description) = "The reference number of the inserted device"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ref());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDataPublisher_AddVRDeviceInfo_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDataPublisher_AddVRDeviceInfo_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDataPublisher_AddVRDeviceInfo_Response::GetClassData() const { return &_class_data_; }

void CDataPublisher_AddVRDeviceInfo_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDataPublisher_AddVRDeviceInfo_Response *>(to)->MergeFrom(
      static_cast<const CDataPublisher_AddVRDeviceInfo_Response &>(from));
}


void CDataPublisher_AddVRDeviceInfo_Response::MergeFrom(const CDataPublisher_AddVRDeviceInfo_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDataPublisher_AddVRDeviceInfo_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      result_ = from.result_;
    }
    if (cached_has_bits & 0x00000002u) {
      ref_ = from.ref_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDataPublisher_AddVRDeviceInfo_Response::CopyFrom(const CDataPublisher_AddVRDeviceInfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDataPublisher_AddVRDeviceInfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDataPublisher_AddVRDeviceInfo_Response::IsInitialized() const {
  return true;
}

void CDataPublisher_AddVRDeviceInfo_Response::InternalSwap(CDataPublisher_AddVRDeviceInfo_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDataPublisher_AddVRDeviceInfo_Response, ref_)
      + sizeof(CDataPublisher_AddVRDeviceInfo_Response::ref_)
      - PROTOBUF_FIELD_OFFSET(CDataPublisher_AddVRDeviceInfo_Response, result_)>(
          reinterpret_cast<char*>(&result_),
          reinterpret_cast<char*>(&other->result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDataPublisher_AddVRDeviceInfo_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[8]);
}

// ===================================================================

class CValveHWSurvey_GetSurveySchedule_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CValveHWSurvey_GetSurveySchedule_Request>()._has_bits_);
  static void set_has_surveydatetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_surveydatetokenversion(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CValveHWSurvey_GetSurveySchedule_Request::CValveHWSurvey_GetSurveySchedule_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CValveHWSurvey_GetSurveySchedule_Request)
}
CValveHWSurvey_GetSurveySchedule_Request::CValveHWSurvey_GetSurveySchedule_Request(const CValveHWSurvey_GetSurveySchedule_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  surveydatetoken_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    surveydatetoken_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_surveydatetoken()) {
    surveydatetoken_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_surveydatetoken(), 
      GetArenaForAllocation());
  }
  surveydatetokenversion_ = from.surveydatetokenversion_;
  // @@protoc_insertion_point(copy_constructor:CValveHWSurvey_GetSurveySchedule_Request)
}

inline void CValveHWSurvey_GetSurveySchedule_Request::SharedCtor() {
surveydatetoken_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  surveydatetoken_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
surveydatetokenversion_ = uint64_t{0u};
}

CValveHWSurvey_GetSurveySchedule_Request::~CValveHWSurvey_GetSurveySchedule_Request() {
  // @@protoc_insertion_point(destructor:CValveHWSurvey_GetSurveySchedule_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CValveHWSurvey_GetSurveySchedule_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  surveydatetoken_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CValveHWSurvey_GetSurveySchedule_Request::ArenaDtor(void* object) {
  CValveHWSurvey_GetSurveySchedule_Request* _this = reinterpret_cast< CValveHWSurvey_GetSurveySchedule_Request* >(object);
  (void)_this;
}
void CValveHWSurvey_GetSurveySchedule_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CValveHWSurvey_GetSurveySchedule_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CValveHWSurvey_GetSurveySchedule_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CValveHWSurvey_GetSurveySchedule_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    surveydatetoken_.ClearNonDefaultToEmpty();
  }
  surveydatetokenversion_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CValveHWSurvey_GetSurveySchedule_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string surveydatetoken = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_surveydatetoken();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CValveHWSurvey_GetSurveySchedule_Request.surveydatetoken");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 surveydatetokenversion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_surveydatetokenversion(&has_bits);
          surveydatetokenversion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CValveHWSurvey_GetSurveySchedule_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CValveHWSurvey_GetSurveySchedule_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string surveydatetoken = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_surveydatetoken().data(), static_cast<int>(this->_internal_surveydatetoken().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CValveHWSurvey_GetSurveySchedule_Request.surveydatetoken");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_surveydatetoken(), target);
  }

  // optional fixed64 surveydatetokenversion = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_surveydatetokenversion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CValveHWSurvey_GetSurveySchedule_Request)
  return target;
}

size_t CValveHWSurvey_GetSurveySchedule_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CValveHWSurvey_GetSurveySchedule_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string surveydatetoken = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_surveydatetoken());
    }

    // optional fixed64 surveydatetokenversion = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CValveHWSurvey_GetSurveySchedule_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CValveHWSurvey_GetSurveySchedule_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CValveHWSurvey_GetSurveySchedule_Request::GetClassData() const { return &_class_data_; }

void CValveHWSurvey_GetSurveySchedule_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CValveHWSurvey_GetSurveySchedule_Request *>(to)->MergeFrom(
      static_cast<const CValveHWSurvey_GetSurveySchedule_Request &>(from));
}


void CValveHWSurvey_GetSurveySchedule_Request::MergeFrom(const CValveHWSurvey_GetSurveySchedule_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CValveHWSurvey_GetSurveySchedule_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_surveydatetoken(from._internal_surveydatetoken());
    }
    if (cached_has_bits & 0x00000002u) {
      surveydatetokenversion_ = from.surveydatetokenversion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CValveHWSurvey_GetSurveySchedule_Request::CopyFrom(const CValveHWSurvey_GetSurveySchedule_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CValveHWSurvey_GetSurveySchedule_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CValveHWSurvey_GetSurveySchedule_Request::IsInitialized() const {
  return true;
}

void CValveHWSurvey_GetSurveySchedule_Request::InternalSwap(CValveHWSurvey_GetSurveySchedule_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &surveydatetoken_, lhs_arena,
      &other->surveydatetoken_, rhs_arena
  );
  swap(surveydatetokenversion_, other->surveydatetokenversion_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CValveHWSurvey_GetSurveySchedule_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[9]);
}

// ===================================================================

class CValveHWSurvey_GetSurveySchedule_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CValveHWSurvey_GetSurveySchedule_Response>()._has_bits_);
  static void set_has_surveydatetoken(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_surveydatetokenversion(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CValveHWSurvey_GetSurveySchedule_Response::CValveHWSurvey_GetSurveySchedule_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CValveHWSurvey_GetSurveySchedule_Response)
}
CValveHWSurvey_GetSurveySchedule_Response::CValveHWSurvey_GetSurveySchedule_Response(const CValveHWSurvey_GetSurveySchedule_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&surveydatetokenversion_, &from.surveydatetokenversion_,
    static_cast<size_t>(reinterpret_cast<char*>(&surveydatetoken_) -
    reinterpret_cast<char*>(&surveydatetokenversion_)) + sizeof(surveydatetoken_));
  // @@protoc_insertion_point(copy_constructor:CValveHWSurvey_GetSurveySchedule_Response)
}

inline void CValveHWSurvey_GetSurveySchedule_Response::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&surveydatetokenversion_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&surveydatetoken_) -
    reinterpret_cast<char*>(&surveydatetokenversion_)) + sizeof(surveydatetoken_));
}

CValveHWSurvey_GetSurveySchedule_Response::~CValveHWSurvey_GetSurveySchedule_Response() {
  // @@protoc_insertion_point(destructor:CValveHWSurvey_GetSurveySchedule_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CValveHWSurvey_GetSurveySchedule_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CValveHWSurvey_GetSurveySchedule_Response::ArenaDtor(void* object) {
  CValveHWSurvey_GetSurveySchedule_Response* _this = reinterpret_cast< CValveHWSurvey_GetSurveySchedule_Response* >(object);
  (void)_this;
}
void CValveHWSurvey_GetSurveySchedule_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CValveHWSurvey_GetSurveySchedule_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CValveHWSurvey_GetSurveySchedule_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CValveHWSurvey_GetSurveySchedule_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&surveydatetokenversion_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&surveydatetoken_) -
        reinterpret_cast<char*>(&surveydatetokenversion_)) + sizeof(surveydatetoken_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CValveHWSurvey_GetSurveySchedule_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 surveydatetoken = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_surveydatetoken(&has_bits);
          surveydatetoken_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 surveydatetokenversion = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_surveydatetokenversion(&has_bits);
          surveydatetokenversion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CValveHWSurvey_GetSurveySchedule_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CValveHWSurvey_GetSurveySchedule_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 surveydatetoken = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_surveydatetoken(), target);
  }

  // optional fixed64 surveydatetokenversion = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_surveydatetokenversion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CValveHWSurvey_GetSurveySchedule_Response)
  return target;
}

size_t CValveHWSurvey_GetSurveySchedule_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CValveHWSurvey_GetSurveySchedule_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 surveydatetokenversion = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 surveydatetoken = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_surveydatetoken());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CValveHWSurvey_GetSurveySchedule_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CValveHWSurvey_GetSurveySchedule_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CValveHWSurvey_GetSurveySchedule_Response::GetClassData() const { return &_class_data_; }

void CValveHWSurvey_GetSurveySchedule_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CValveHWSurvey_GetSurveySchedule_Response *>(to)->MergeFrom(
      static_cast<const CValveHWSurvey_GetSurveySchedule_Response &>(from));
}


void CValveHWSurvey_GetSurveySchedule_Response::MergeFrom(const CValveHWSurvey_GetSurveySchedule_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CValveHWSurvey_GetSurveySchedule_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      surveydatetokenversion_ = from.surveydatetokenversion_;
    }
    if (cached_has_bits & 0x00000002u) {
      surveydatetoken_ = from.surveydatetoken_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CValveHWSurvey_GetSurveySchedule_Response::CopyFrom(const CValveHWSurvey_GetSurveySchedule_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CValveHWSurvey_GetSurveySchedule_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CValveHWSurvey_GetSurveySchedule_Response::IsInitialized() const {
  return true;
}

void CValveHWSurvey_GetSurveySchedule_Response::InternalSwap(CValveHWSurvey_GetSurveySchedule_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CValveHWSurvey_GetSurveySchedule_Response, surveydatetoken_)
      + sizeof(CValveHWSurvey_GetSurveySchedule_Response::surveydatetoken_)
      - PROTOBUF_FIELD_OFFSET(CValveHWSurvey_GetSurveySchedule_Response, surveydatetokenversion_)>(
          reinterpret_cast<char*>(&surveydatetokenversion_),
          reinterpret_cast<char*>(&other->surveydatetokenversion_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CValveHWSurvey_GetSurveySchedule_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fdatapublisher_2esteamclient_2eproto[10]);
}

// ===================================================================

DataPublisher::~DataPublisher() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* DataPublisher::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* DataPublisher::GetDescriptor() {
  return descriptor();
}

void DataPublisher::ClientContentCorruptionReport(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CDataPublisher_ClientContentCorruptionReport_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method ClientContentCorruptionReport() not implemented.");
  done->Run();
}

void DataPublisher::ClientUpdateAppJobReport(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CDataPublisher_ClientUpdateAppJob_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method ClientUpdateAppJobReport() not implemented.");
  done->Run();
}

void DataPublisher::GetVRDeviceInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CDataPublisher_GetVRDeviceInfo_Request*,
                         ::CDataPublisher_GetVRDeviceInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetVRDeviceInfo() not implemented.");
  done->Run();
}

void DataPublisher::SetVRDeviceInfoAggregationReference(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request*,
                         ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method SetVRDeviceInfoAggregationReference() not implemented.");
  done->Run();
}

void DataPublisher::AddVRDeviceInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CDataPublisher_AddVRDeviceInfo_Request*,
                         ::CDataPublisher_AddVRDeviceInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method AddVRDeviceInfo() not implemented.");
  done->Run();
}

void DataPublisher::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      ClientContentCorruptionReport(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CDataPublisher_ClientContentCorruptionReport_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 1:
      ClientUpdateAppJobReport(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CDataPublisher_ClientUpdateAppJob_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 2:
      GetVRDeviceInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CDataPublisher_GetVRDeviceInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CDataPublisher_GetVRDeviceInfo_Response*>(
                 response),
             done);
      break;
    case 3:
      SetVRDeviceInfoAggregationReference(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CDataPublisher_SetVRDeviceInfoAggregationReference_Response*>(
                 response),
             done);
      break;
    case 4:
      AddVRDeviceInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CDataPublisher_AddVRDeviceInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CDataPublisher_AddVRDeviceInfo_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& DataPublisher::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CDataPublisher_ClientContentCorruptionReport_Notification::default_instance();
    case 1:
      return ::CDataPublisher_ClientUpdateAppJob_Notification::default_instance();
    case 2:
      return ::CDataPublisher_GetVRDeviceInfo_Request::default_instance();
    case 3:
      return ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request::default_instance();
    case 4:
      return ::CDataPublisher_AddVRDeviceInfo_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& DataPublisher::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::NoResponse::default_instance();
    case 1:
      return ::NoResponse::default_instance();
    case 2:
      return ::CDataPublisher_GetVRDeviceInfo_Response::default_instance();
    case 3:
      return ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response::default_instance();
    case 4:
      return ::CDataPublisher_AddVRDeviceInfo_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

DataPublisher_Stub::DataPublisher_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
DataPublisher_Stub::DataPublisher_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
DataPublisher_Stub::~DataPublisher_Stub() {
  if (owns_channel_) delete channel_;
}

void DataPublisher_Stub::ClientContentCorruptionReport(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CDataPublisher_ClientContentCorruptionReport_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void DataPublisher_Stub::ClientUpdateAppJobReport(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CDataPublisher_ClientUpdateAppJob_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void DataPublisher_Stub::GetVRDeviceInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CDataPublisher_GetVRDeviceInfo_Request* request,
                              ::CDataPublisher_GetVRDeviceInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void DataPublisher_Stub::SetVRDeviceInfoAggregationReference(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request* request,
                              ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void DataPublisher_Stub::AddVRDeviceInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CDataPublisher_AddVRDeviceInfo_Request* request,
                              ::CDataPublisher_AddVRDeviceInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
// ===================================================================

ValveHWSurvey::~ValveHWSurvey() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* ValveHWSurvey::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fdatapublisher_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto[1];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* ValveHWSurvey::GetDescriptor() {
  return descriptor();
}

void ValveHWSurvey::GetSurveySchedule(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CValveHWSurvey_GetSurveySchedule_Request*,
                         ::CValveHWSurvey_GetSurveySchedule_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetSurveySchedule() not implemented.");
  done->Run();
}

void ValveHWSurvey::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fdatapublisher_2esteamclient_2eproto[1]);
  switch(method->index()) {
    case 0:
      GetSurveySchedule(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CValveHWSurvey_GetSurveySchedule_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CValveHWSurvey_GetSurveySchedule_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& ValveHWSurvey::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CValveHWSurvey_GetSurveySchedule_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& ValveHWSurvey::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CValveHWSurvey_GetSurveySchedule_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

ValveHWSurvey_Stub::ValveHWSurvey_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
ValveHWSurvey_Stub::ValveHWSurvey_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
ValveHWSurvey_Stub::~ValveHWSurvey_Stub() {
  if (owns_channel_) delete channel_;
}

void ValveHWSurvey_Stub::GetSurveySchedule(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CValveHWSurvey_GetSurveySchedule_Request* request,
                              ::CValveHWSurvey_GetSurveySchedule_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CDataPublisher_ClientContentCorruptionReport_Notification* Arena::CreateMaybeMessage< ::CDataPublisher_ClientContentCorruptionReport_Notification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_ClientContentCorruptionReport_Notification >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_ClientUpdateAppJob_Notification* Arena::CreateMaybeMessage< ::CDataPublisher_ClientUpdateAppJob_Notification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_ClientUpdateAppJob_Notification >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_GetVRDeviceInfo_Request* Arena::CreateMaybeMessage< ::CDataPublisher_GetVRDeviceInfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_GetVRDeviceInfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_GetVRDeviceInfo_Response_Device* Arena::CreateMaybeMessage< ::CDataPublisher_GetVRDeviceInfo_Response_Device >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_GetVRDeviceInfo_Response_Device >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_GetVRDeviceInfo_Response* Arena::CreateMaybeMessage< ::CDataPublisher_GetVRDeviceInfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_GetVRDeviceInfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request* Arena::CreateMaybeMessage< ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_SetVRDeviceInfoAggregationReference_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response* Arena::CreateMaybeMessage< ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_SetVRDeviceInfoAggregationReference_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_AddVRDeviceInfo_Request* Arena::CreateMaybeMessage< ::CDataPublisher_AddVRDeviceInfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_AddVRDeviceInfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CDataPublisher_AddVRDeviceInfo_Response* Arena::CreateMaybeMessage< ::CDataPublisher_AddVRDeviceInfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDataPublisher_AddVRDeviceInfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CValveHWSurvey_GetSurveySchedule_Request* Arena::CreateMaybeMessage< ::CValveHWSurvey_GetSurveySchedule_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CValveHWSurvey_GetSurveySchedule_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CValveHWSurvey_GetSurveySchedule_Response* Arena::CreateMaybeMessage< ::CValveHWSurvey_GetSurveySchedule_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CValveHWSurvey_GetSurveySchedule_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
