// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_steamtv.steamclient.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fsteamtv_2esteamclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fsteamtv_2esteamclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
#include "steammessages_unified_base.steamclient.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fsteamtv_2esteamclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[84]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fsteamtv_2esteamclient_2eproto;
class CSteamTV_AddChatBan_Request;
struct CSteamTV_AddChatBan_RequestDefaultTypeInternal;
extern CSteamTV_AddChatBan_RequestDefaultTypeInternal _CSteamTV_AddChatBan_Request_default_instance_;
class CSteamTV_AddChatBan_Response;
struct CSteamTV_AddChatBan_ResponseDefaultTypeInternal;
extern CSteamTV_AddChatBan_ResponseDefaultTypeInternal _CSteamTV_AddChatBan_Response_default_instance_;
class CSteamTV_AddChatModerator_Request;
struct CSteamTV_AddChatModerator_RequestDefaultTypeInternal;
extern CSteamTV_AddChatModerator_RequestDefaultTypeInternal _CSteamTV_AddChatModerator_Request_default_instance_;
class CSteamTV_AddChatModerator_Response;
struct CSteamTV_AddChatModerator_ResponseDefaultTypeInternal;
extern CSteamTV_AddChatModerator_ResponseDefaultTypeInternal _CSteamTV_AddChatModerator_Response_default_instance_;
class CSteamTV_AddWordBan_Request;
struct CSteamTV_AddWordBan_RequestDefaultTypeInternal;
extern CSteamTV_AddWordBan_RequestDefaultTypeInternal _CSteamTV_AddWordBan_Request_default_instance_;
class CSteamTV_AddWordBan_Response;
struct CSteamTV_AddWordBan_ResponseDefaultTypeInternal;
extern CSteamTV_AddWordBan_ResponseDefaultTypeInternal _CSteamTV_AddWordBan_Response_default_instance_;
class CSteamTV_AppCheer_Request;
struct CSteamTV_AppCheer_RequestDefaultTypeInternal;
extern CSteamTV_AppCheer_RequestDefaultTypeInternal _CSteamTV_AppCheer_Request_default_instance_;
class CSteamTV_AppCheer_Response;
struct CSteamTV_AppCheer_ResponseDefaultTypeInternal;
extern CSteamTV_AppCheer_ResponseDefaultTypeInternal _CSteamTV_AppCheer_Response_default_instance_;
class CSteamTV_AppCheer_SingleCheerType;
struct CSteamTV_AppCheer_SingleCheerTypeDefaultTypeInternal;
extern CSteamTV_AppCheer_SingleCheerTypeDefaultTypeInternal _CSteamTV_AppCheer_SingleCheerType_default_instance_;
class CSteamTV_BroadcastClipInfo;
struct CSteamTV_BroadcastClipInfoDefaultTypeInternal;
extern CSteamTV_BroadcastClipInfoDefaultTypeInternal _CSteamTV_BroadcastClipInfo_default_instance_;
class CSteamTV_ChatBan;
struct CSteamTV_ChatBanDefaultTypeInternal;
extern CSteamTV_ChatBanDefaultTypeInternal _CSteamTV_ChatBan_default_instance_;
class CSteamTV_ChatModerator;
struct CSteamTV_ChatModeratorDefaultTypeInternal;
extern CSteamTV_ChatModeratorDefaultTypeInternal _CSteamTV_ChatModerator_default_instance_;
class CSteamTV_CreateBroadcastChannel_Request;
struct CSteamTV_CreateBroadcastChannel_RequestDefaultTypeInternal;
extern CSteamTV_CreateBroadcastChannel_RequestDefaultTypeInternal _CSteamTV_CreateBroadcastChannel_Request_default_instance_;
class CSteamTV_CreateBroadcastChannel_Response;
struct CSteamTV_CreateBroadcastChannel_ResponseDefaultTypeInternal;
extern CSteamTV_CreateBroadcastChannel_ResponseDefaultTypeInternal _CSteamTV_CreateBroadcastChannel_Response_default_instance_;
class CSteamTV_FollowBroadcastChannel_Request;
struct CSteamTV_FollowBroadcastChannel_RequestDefaultTypeInternal;
extern CSteamTV_FollowBroadcastChannel_RequestDefaultTypeInternal _CSteamTV_FollowBroadcastChannel_Request_default_instance_;
class CSteamTV_FollowBroadcastChannel_Response;
struct CSteamTV_FollowBroadcastChannel_ResponseDefaultTypeInternal;
extern CSteamTV_FollowBroadcastChannel_ResponseDefaultTypeInternal _CSteamTV_FollowBroadcastChannel_Response_default_instance_;
class CSteamTV_Game;
struct CSteamTV_GameDefaultTypeInternal;
extern CSteamTV_GameDefaultTypeInternal _CSteamTV_Game_default_instance_;
class CSteamTV_GetBroadcastChannelBroadcasters_Request;
struct CSteamTV_GetBroadcastChannelBroadcasters_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelBroadcasters_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelBroadcasters_Request_default_instance_;
class CSteamTV_GetBroadcastChannelBroadcasters_Response;
struct CSteamTV_GetBroadcastChannelBroadcasters_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelBroadcasters_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelBroadcasters_Response_default_instance_;
class CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster;
struct CSteamTV_GetBroadcastChannelBroadcasters_Response_BroadcasterDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelBroadcasters_Response_BroadcasterDefaultTypeInternal _CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster_default_instance_;
class CSteamTV_GetBroadcastChannelClips_Request;
struct CSteamTV_GetBroadcastChannelClips_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelClips_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelClips_Request_default_instance_;
class CSteamTV_GetBroadcastChannelClips_Response;
struct CSteamTV_GetBroadcastChannelClips_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelClips_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelClips_Response_default_instance_;
class CSteamTV_GetBroadcastChannelID_Request;
struct CSteamTV_GetBroadcastChannelID_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelID_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelID_Request_default_instance_;
class CSteamTV_GetBroadcastChannelID_Response;
struct CSteamTV_GetBroadcastChannelID_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelID_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelID_Response_default_instance_;
class CSteamTV_GetBroadcastChannelImages_Request;
struct CSteamTV_GetBroadcastChannelImages_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelImages_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelImages_Request_default_instance_;
class CSteamTV_GetBroadcastChannelImages_Response;
struct CSteamTV_GetBroadcastChannelImages_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelImages_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelImages_Response_default_instance_;
class CSteamTV_GetBroadcastChannelImages_Response_Images;
struct CSteamTV_GetBroadcastChannelImages_Response_ImagesDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelImages_Response_ImagesDefaultTypeInternal _CSteamTV_GetBroadcastChannelImages_Response_Images_default_instance_;
class CSteamTV_GetBroadcastChannelInteraction_Request;
struct CSteamTV_GetBroadcastChannelInteraction_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelInteraction_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelInteraction_Request_default_instance_;
class CSteamTV_GetBroadcastChannelInteraction_Response;
struct CSteamTV_GetBroadcastChannelInteraction_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelInteraction_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelInteraction_Response_default_instance_;
class CSteamTV_GetBroadcastChannelLinks_Request;
struct CSteamTV_GetBroadcastChannelLinks_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelLinks_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelLinks_Request_default_instance_;
class CSteamTV_GetBroadcastChannelLinks_Response;
struct CSteamTV_GetBroadcastChannelLinks_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelLinks_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelLinks_Response_default_instance_;
class CSteamTV_GetBroadcastChannelLinks_Response_Links;
struct CSteamTV_GetBroadcastChannelLinks_Response_LinksDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelLinks_Response_LinksDefaultTypeInternal _CSteamTV_GetBroadcastChannelLinks_Response_Links_default_instance_;
class CSteamTV_GetBroadcastChannelProfile_Request;
struct CSteamTV_GetBroadcastChannelProfile_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelProfile_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelProfile_Request_default_instance_;
class CSteamTV_GetBroadcastChannelProfile_Response;
struct CSteamTV_GetBroadcastChannelProfile_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelProfile_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelProfile_Response_default_instance_;
class CSteamTV_GetBroadcastChannelStatus_Request;
struct CSteamTV_GetBroadcastChannelStatus_RequestDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelStatus_RequestDefaultTypeInternal _CSteamTV_GetBroadcastChannelStatus_Request_default_instance_;
class CSteamTV_GetBroadcastChannelStatus_Response;
struct CSteamTV_GetBroadcastChannelStatus_ResponseDefaultTypeInternal;
extern CSteamTV_GetBroadcastChannelStatus_ResponseDefaultTypeInternal _CSteamTV_GetBroadcastChannelStatus_Response_default_instance_;
class CSteamTV_GetChannels_Request;
struct CSteamTV_GetChannels_RequestDefaultTypeInternal;
extern CSteamTV_GetChannels_RequestDefaultTypeInternal _CSteamTV_GetChannels_Request_default_instance_;
class CSteamTV_GetChannels_Response;
struct CSteamTV_GetChannels_ResponseDefaultTypeInternal;
extern CSteamTV_GetChannels_ResponseDefaultTypeInternal _CSteamTV_GetChannels_Response_default_instance_;
class CSteamTV_GetChatBans_Request;
struct CSteamTV_GetChatBans_RequestDefaultTypeInternal;
extern CSteamTV_GetChatBans_RequestDefaultTypeInternal _CSteamTV_GetChatBans_Request_default_instance_;
class CSteamTV_GetChatBans_Response;
struct CSteamTV_GetChatBans_ResponseDefaultTypeInternal;
extern CSteamTV_GetChatBans_ResponseDefaultTypeInternal _CSteamTV_GetChatBans_Response_default_instance_;
class CSteamTV_GetChatModerators_Request;
struct CSteamTV_GetChatModerators_RequestDefaultTypeInternal;
extern CSteamTV_GetChatModerators_RequestDefaultTypeInternal _CSteamTV_GetChatModerators_Request_default_instance_;
class CSteamTV_GetChatModerators_Response;
struct CSteamTV_GetChatModerators_ResponseDefaultTypeInternal;
extern CSteamTV_GetChatModerators_ResponseDefaultTypeInternal _CSteamTV_GetChatModerators_Response_default_instance_;
class CSteamTV_GetFollowedChannels_Request;
struct CSteamTV_GetFollowedChannels_RequestDefaultTypeInternal;
extern CSteamTV_GetFollowedChannels_RequestDefaultTypeInternal _CSteamTV_GetFollowedChannels_Request_default_instance_;
class CSteamTV_GetFollowedChannels_Response;
struct CSteamTV_GetFollowedChannels_ResponseDefaultTypeInternal;
extern CSteamTV_GetFollowedChannels_ResponseDefaultTypeInternal _CSteamTV_GetFollowedChannels_Response_default_instance_;
class CSteamTV_GetGames_Request;
struct CSteamTV_GetGames_RequestDefaultTypeInternal;
extern CSteamTV_GetGames_RequestDefaultTypeInternal _CSteamTV_GetGames_Request_default_instance_;
class CSteamTV_GetGames_Response;
struct CSteamTV_GetGames_ResponseDefaultTypeInternal;
extern CSteamTV_GetGames_ResponseDefaultTypeInternal _CSteamTV_GetGames_Response_default_instance_;
class CSteamTV_GetHomePageContents_Request;
struct CSteamTV_GetHomePageContents_RequestDefaultTypeInternal;
extern CSteamTV_GetHomePageContents_RequestDefaultTypeInternal _CSteamTV_GetHomePageContents_Request_default_instance_;
class CSteamTV_GetHomePageContents_Response;
struct CSteamTV_GetHomePageContents_ResponseDefaultTypeInternal;
extern CSteamTV_GetHomePageContents_ResponseDefaultTypeInternal _CSteamTV_GetHomePageContents_Response_default_instance_;
class CSteamTV_GetMyBroadcastChannels_Request;
struct CSteamTV_GetMyBroadcastChannels_RequestDefaultTypeInternal;
extern CSteamTV_GetMyBroadcastChannels_RequestDefaultTypeInternal _CSteamTV_GetMyBroadcastChannels_Request_default_instance_;
class CSteamTV_GetMyBroadcastChannels_Response;
struct CSteamTV_GetMyBroadcastChannels_ResponseDefaultTypeInternal;
extern CSteamTV_GetMyBroadcastChannels_ResponseDefaultTypeInternal _CSteamTV_GetMyBroadcastChannels_Response_default_instance_;
class CSteamTV_GetSteamTVUserSettings_Request;
struct CSteamTV_GetSteamTVUserSettings_RequestDefaultTypeInternal;
extern CSteamTV_GetSteamTVUserSettings_RequestDefaultTypeInternal _CSteamTV_GetSteamTVUserSettings_Request_default_instance_;
class CSteamTV_GetSteamTVUserSettings_Response;
struct CSteamTV_GetSteamTVUserSettings_ResponseDefaultTypeInternal;
extern CSteamTV_GetSteamTVUserSettings_ResponseDefaultTypeInternal _CSteamTV_GetSteamTVUserSettings_Response_default_instance_;
class CSteamTV_GetSubscribedChannels_Request;
struct CSteamTV_GetSubscribedChannels_RequestDefaultTypeInternal;
extern CSteamTV_GetSubscribedChannels_RequestDefaultTypeInternal _CSteamTV_GetSubscribedChannels_Request_default_instance_;
class CSteamTV_GetSubscribedChannels_Response;
struct CSteamTV_GetSubscribedChannels_ResponseDefaultTypeInternal;
extern CSteamTV_GetSubscribedChannels_ResponseDefaultTypeInternal _CSteamTV_GetSubscribedChannels_Response_default_instance_;
class CSteamTV_GetWordBans_Request;
struct CSteamTV_GetWordBans_RequestDefaultTypeInternal;
extern CSteamTV_GetWordBans_RequestDefaultTypeInternal _CSteamTV_GetWordBans_Request_default_instance_;
class CSteamTV_GetWordBans_Response;
struct CSteamTV_GetWordBans_ResponseDefaultTypeInternal;
extern CSteamTV_GetWordBans_ResponseDefaultTypeInternal _CSteamTV_GetWordBans_Response_default_instance_;
class CSteamTV_HomePageContentRow;
struct CSteamTV_HomePageContentRowDefaultTypeInternal;
extern CSteamTV_HomePageContentRowDefaultTypeInternal _CSteamTV_HomePageContentRow_default_instance_;
class CSteamTV_HomePageTemplate_ConveyorBelt;
struct CSteamTV_HomePageTemplate_ConveyorBeltDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_ConveyorBeltDefaultTypeInternal _CSteamTV_HomePageTemplate_ConveyorBelt_default_instance_;
class CSteamTV_HomePageTemplate_Developer;
struct CSteamTV_HomePageTemplate_DeveloperDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_DeveloperDefaultTypeInternal _CSteamTV_HomePageTemplate_Developer_default_instance_;
class CSteamTV_HomePageTemplate_Event;
struct CSteamTV_HomePageTemplate_EventDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_EventDefaultTypeInternal _CSteamTV_HomePageTemplate_Event_default_instance_;
class CSteamTV_HomePageTemplate_GameList;
struct CSteamTV_HomePageTemplate_GameListDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_GameListDefaultTypeInternal _CSteamTV_HomePageTemplate_GameList_default_instance_;
class CSteamTV_HomePageTemplate_QuickExplore;
struct CSteamTV_HomePageTemplate_QuickExploreDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_QuickExploreDefaultTypeInternal _CSteamTV_HomePageTemplate_QuickExplore_default_instance_;
class CSteamTV_HomePageTemplate_SingleGame;
struct CSteamTV_HomePageTemplate_SingleGameDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_SingleGameDefaultTypeInternal _CSteamTV_HomePageTemplate_SingleGame_default_instance_;
class CSteamTV_HomePageTemplate_Takeover;
struct CSteamTV_HomePageTemplate_TakeoverDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_TakeoverDefaultTypeInternal _CSteamTV_HomePageTemplate_Takeover_default_instance_;
class CSteamTV_HomePageTemplate_WatchParty;
struct CSteamTV_HomePageTemplate_WatchPartyDefaultTypeInternal;
extern CSteamTV_HomePageTemplate_WatchPartyDefaultTypeInternal _CSteamTV_HomePageTemplate_WatchParty_default_instance_;
class CSteamTV_JoinChat_Request;
struct CSteamTV_JoinChat_RequestDefaultTypeInternal;
extern CSteamTV_JoinChat_RequestDefaultTypeInternal _CSteamTV_JoinChat_Request_default_instance_;
class CSteamTV_JoinChat_Response;
struct CSteamTV_JoinChat_ResponseDefaultTypeInternal;
extern CSteamTV_JoinChat_ResponseDefaultTypeInternal _CSteamTV_JoinChat_Response_default_instance_;
class CSteamTV_ReportBroadcastChannel_Request;
struct CSteamTV_ReportBroadcastChannel_RequestDefaultTypeInternal;
extern CSteamTV_ReportBroadcastChannel_RequestDefaultTypeInternal _CSteamTV_ReportBroadcastChannel_Request_default_instance_;
class CSteamTV_ReportBroadcastChannel_Response;
struct CSteamTV_ReportBroadcastChannel_ResponseDefaultTypeInternal;
extern CSteamTV_ReportBroadcastChannel_ResponseDefaultTypeInternal _CSteamTV_ReportBroadcastChannel_Response_default_instance_;
class CSteamTV_Search_Request;
struct CSteamTV_Search_RequestDefaultTypeInternal;
extern CSteamTV_Search_RequestDefaultTypeInternal _CSteamTV_Search_Request_default_instance_;
class CSteamTV_Search_Response;
struct CSteamTV_Search_ResponseDefaultTypeInternal;
extern CSteamTV_Search_ResponseDefaultTypeInternal _CSteamTV_Search_Response_default_instance_;
class CSteamTV_SetBroadcastChannelImage_Request;
struct CSteamTV_SetBroadcastChannelImage_RequestDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelImage_RequestDefaultTypeInternal _CSteamTV_SetBroadcastChannelImage_Request_default_instance_;
class CSteamTV_SetBroadcastChannelImage_Response;
struct CSteamTV_SetBroadcastChannelImage_ResponseDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelImage_ResponseDefaultTypeInternal _CSteamTV_SetBroadcastChannelImage_Response_default_instance_;
class CSteamTV_SetBroadcastChannelLinkRegions_Request;
struct CSteamTV_SetBroadcastChannelLinkRegions_RequestDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelLinkRegions_RequestDefaultTypeInternal _CSteamTV_SetBroadcastChannelLinkRegions_Request_default_instance_;
class CSteamTV_SetBroadcastChannelLinkRegions_Request_Links;
struct CSteamTV_SetBroadcastChannelLinkRegions_Request_LinksDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelLinkRegions_Request_LinksDefaultTypeInternal _CSteamTV_SetBroadcastChannelLinkRegions_Request_Links_default_instance_;
class CSteamTV_SetBroadcastChannelLinkRegions_Response;
struct CSteamTV_SetBroadcastChannelLinkRegions_ResponseDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelLinkRegions_ResponseDefaultTypeInternal _CSteamTV_SetBroadcastChannelLinkRegions_Response_default_instance_;
class CSteamTV_SetBroadcastChannelProfile_Request;
struct CSteamTV_SetBroadcastChannelProfile_RequestDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelProfile_RequestDefaultTypeInternal _CSteamTV_SetBroadcastChannelProfile_Request_default_instance_;
class CSteamTV_SetBroadcastChannelProfile_Response;
struct CSteamTV_SetBroadcastChannelProfile_ResponseDefaultTypeInternal;
extern CSteamTV_SetBroadcastChannelProfile_ResponseDefaultTypeInternal _CSteamTV_SetBroadcastChannelProfile_Response_default_instance_;
class CSteamTV_SetSteamTVUserSettings_Request;
struct CSteamTV_SetSteamTVUserSettings_RequestDefaultTypeInternal;
extern CSteamTV_SetSteamTVUserSettings_RequestDefaultTypeInternal _CSteamTV_SetSteamTVUserSettings_Request_default_instance_;
class CSteamTV_SetSteamTVUserSettings_Response;
struct CSteamTV_SetSteamTVUserSettings_ResponseDefaultTypeInternal;
extern CSteamTV_SetSteamTVUserSettings_ResponseDefaultTypeInternal _CSteamTV_SetSteamTVUserSettings_Response_default_instance_;
class CSteamTV_SubscribeBroadcastChannel_Request;
struct CSteamTV_SubscribeBroadcastChannel_RequestDefaultTypeInternal;
extern CSteamTV_SubscribeBroadcastChannel_RequestDefaultTypeInternal _CSteamTV_SubscribeBroadcastChannel_Request_default_instance_;
class CSteamTV_SubscribeBroadcastChannel_Response;
struct CSteamTV_SubscribeBroadcastChannel_ResponseDefaultTypeInternal;
extern CSteamTV_SubscribeBroadcastChannel_ResponseDefaultTypeInternal _CSteamTV_SubscribeBroadcastChannel_Response_default_instance_;
class GameListEntry;
struct GameListEntryDefaultTypeInternal;
extern GameListEntryDefaultTypeInternal _GameListEntry_default_instance_;
class GetBroadcastChannelEntry;
struct GetBroadcastChannelEntryDefaultTypeInternal;
extern GetBroadcastChannelEntryDefaultTypeInternal _GetBroadcastChannelEntry_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CSteamTV_AddChatBan_Request* Arena::CreateMaybeMessage<::CSteamTV_AddChatBan_Request>(Arena*);
template<> ::CSteamTV_AddChatBan_Response* Arena::CreateMaybeMessage<::CSteamTV_AddChatBan_Response>(Arena*);
template<> ::CSteamTV_AddChatModerator_Request* Arena::CreateMaybeMessage<::CSteamTV_AddChatModerator_Request>(Arena*);
template<> ::CSteamTV_AddChatModerator_Response* Arena::CreateMaybeMessage<::CSteamTV_AddChatModerator_Response>(Arena*);
template<> ::CSteamTV_AddWordBan_Request* Arena::CreateMaybeMessage<::CSteamTV_AddWordBan_Request>(Arena*);
template<> ::CSteamTV_AddWordBan_Response* Arena::CreateMaybeMessage<::CSteamTV_AddWordBan_Response>(Arena*);
template<> ::CSteamTV_AppCheer_Request* Arena::CreateMaybeMessage<::CSteamTV_AppCheer_Request>(Arena*);
template<> ::CSteamTV_AppCheer_Response* Arena::CreateMaybeMessage<::CSteamTV_AppCheer_Response>(Arena*);
template<> ::CSteamTV_AppCheer_SingleCheerType* Arena::CreateMaybeMessage<::CSteamTV_AppCheer_SingleCheerType>(Arena*);
template<> ::CSteamTV_BroadcastClipInfo* Arena::CreateMaybeMessage<::CSteamTV_BroadcastClipInfo>(Arena*);
template<> ::CSteamTV_ChatBan* Arena::CreateMaybeMessage<::CSteamTV_ChatBan>(Arena*);
template<> ::CSteamTV_ChatModerator* Arena::CreateMaybeMessage<::CSteamTV_ChatModerator>(Arena*);
template<> ::CSteamTV_CreateBroadcastChannel_Request* Arena::CreateMaybeMessage<::CSteamTV_CreateBroadcastChannel_Request>(Arena*);
template<> ::CSteamTV_CreateBroadcastChannel_Response* Arena::CreateMaybeMessage<::CSteamTV_CreateBroadcastChannel_Response>(Arena*);
template<> ::CSteamTV_FollowBroadcastChannel_Request* Arena::CreateMaybeMessage<::CSteamTV_FollowBroadcastChannel_Request>(Arena*);
template<> ::CSteamTV_FollowBroadcastChannel_Response* Arena::CreateMaybeMessage<::CSteamTV_FollowBroadcastChannel_Response>(Arena*);
template<> ::CSteamTV_Game* Arena::CreateMaybeMessage<::CSteamTV_Game>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelBroadcasters_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelBroadcasters_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelBroadcasters_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelBroadcasters_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelClips_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelClips_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelClips_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelClips_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelID_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelID_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelID_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelID_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelImages_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelImages_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelImages_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelImages_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelImages_Response_Images* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelImages_Response_Images>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelInteraction_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelInteraction_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelInteraction_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelInteraction_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelLinks_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelLinks_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelLinks_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelLinks_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelLinks_Response_Links* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelLinks_Response_Links>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelProfile_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelProfile_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelProfile_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelProfile_Response>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelStatus_Request* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelStatus_Request>(Arena*);
template<> ::CSteamTV_GetBroadcastChannelStatus_Response* Arena::CreateMaybeMessage<::CSteamTV_GetBroadcastChannelStatus_Response>(Arena*);
template<> ::CSteamTV_GetChannels_Request* Arena::CreateMaybeMessage<::CSteamTV_GetChannels_Request>(Arena*);
template<> ::CSteamTV_GetChannels_Response* Arena::CreateMaybeMessage<::CSteamTV_GetChannels_Response>(Arena*);
template<> ::CSteamTV_GetChatBans_Request* Arena::CreateMaybeMessage<::CSteamTV_GetChatBans_Request>(Arena*);
template<> ::CSteamTV_GetChatBans_Response* Arena::CreateMaybeMessage<::CSteamTV_GetChatBans_Response>(Arena*);
template<> ::CSteamTV_GetChatModerators_Request* Arena::CreateMaybeMessage<::CSteamTV_GetChatModerators_Request>(Arena*);
template<> ::CSteamTV_GetChatModerators_Response* Arena::CreateMaybeMessage<::CSteamTV_GetChatModerators_Response>(Arena*);
template<> ::CSteamTV_GetFollowedChannels_Request* Arena::CreateMaybeMessage<::CSteamTV_GetFollowedChannels_Request>(Arena*);
template<> ::CSteamTV_GetFollowedChannels_Response* Arena::CreateMaybeMessage<::CSteamTV_GetFollowedChannels_Response>(Arena*);
template<> ::CSteamTV_GetGames_Request* Arena::CreateMaybeMessage<::CSteamTV_GetGames_Request>(Arena*);
template<> ::CSteamTV_GetGames_Response* Arena::CreateMaybeMessage<::CSteamTV_GetGames_Response>(Arena*);
template<> ::CSteamTV_GetHomePageContents_Request* Arena::CreateMaybeMessage<::CSteamTV_GetHomePageContents_Request>(Arena*);
template<> ::CSteamTV_GetHomePageContents_Response* Arena::CreateMaybeMessage<::CSteamTV_GetHomePageContents_Response>(Arena*);
template<> ::CSteamTV_GetMyBroadcastChannels_Request* Arena::CreateMaybeMessage<::CSteamTV_GetMyBroadcastChannels_Request>(Arena*);
template<> ::CSteamTV_GetMyBroadcastChannels_Response* Arena::CreateMaybeMessage<::CSteamTV_GetMyBroadcastChannels_Response>(Arena*);
template<> ::CSteamTV_GetSteamTVUserSettings_Request* Arena::CreateMaybeMessage<::CSteamTV_GetSteamTVUserSettings_Request>(Arena*);
template<> ::CSteamTV_GetSteamTVUserSettings_Response* Arena::CreateMaybeMessage<::CSteamTV_GetSteamTVUserSettings_Response>(Arena*);
template<> ::CSteamTV_GetSubscribedChannels_Request* Arena::CreateMaybeMessage<::CSteamTV_GetSubscribedChannels_Request>(Arena*);
template<> ::CSteamTV_GetSubscribedChannels_Response* Arena::CreateMaybeMessage<::CSteamTV_GetSubscribedChannels_Response>(Arena*);
template<> ::CSteamTV_GetWordBans_Request* Arena::CreateMaybeMessage<::CSteamTV_GetWordBans_Request>(Arena*);
template<> ::CSteamTV_GetWordBans_Response* Arena::CreateMaybeMessage<::CSteamTV_GetWordBans_Response>(Arena*);
template<> ::CSteamTV_HomePageContentRow* Arena::CreateMaybeMessage<::CSteamTV_HomePageContentRow>(Arena*);
template<> ::CSteamTV_HomePageTemplate_ConveyorBelt* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_ConveyorBelt>(Arena*);
template<> ::CSteamTV_HomePageTemplate_Developer* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_Developer>(Arena*);
template<> ::CSteamTV_HomePageTemplate_Event* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_Event>(Arena*);
template<> ::CSteamTV_HomePageTemplate_GameList* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_GameList>(Arena*);
template<> ::CSteamTV_HomePageTemplate_QuickExplore* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_QuickExplore>(Arena*);
template<> ::CSteamTV_HomePageTemplate_SingleGame* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_SingleGame>(Arena*);
template<> ::CSteamTV_HomePageTemplate_Takeover* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_Takeover>(Arena*);
template<> ::CSteamTV_HomePageTemplate_WatchParty* Arena::CreateMaybeMessage<::CSteamTV_HomePageTemplate_WatchParty>(Arena*);
template<> ::CSteamTV_JoinChat_Request* Arena::CreateMaybeMessage<::CSteamTV_JoinChat_Request>(Arena*);
template<> ::CSteamTV_JoinChat_Response* Arena::CreateMaybeMessage<::CSteamTV_JoinChat_Response>(Arena*);
template<> ::CSteamTV_ReportBroadcastChannel_Request* Arena::CreateMaybeMessage<::CSteamTV_ReportBroadcastChannel_Request>(Arena*);
template<> ::CSteamTV_ReportBroadcastChannel_Response* Arena::CreateMaybeMessage<::CSteamTV_ReportBroadcastChannel_Response>(Arena*);
template<> ::CSteamTV_Search_Request* Arena::CreateMaybeMessage<::CSteamTV_Search_Request>(Arena*);
template<> ::CSteamTV_Search_Response* Arena::CreateMaybeMessage<::CSteamTV_Search_Response>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelImage_Request* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelImage_Request>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelImage_Response* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelImage_Response>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelLinkRegions_Request* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelLinkRegions_Request>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelLinkRegions_Response* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelLinkRegions_Response>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelProfile_Request* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelProfile_Request>(Arena*);
template<> ::CSteamTV_SetBroadcastChannelProfile_Response* Arena::CreateMaybeMessage<::CSteamTV_SetBroadcastChannelProfile_Response>(Arena*);
template<> ::CSteamTV_SetSteamTVUserSettings_Request* Arena::CreateMaybeMessage<::CSteamTV_SetSteamTVUserSettings_Request>(Arena*);
template<> ::CSteamTV_SetSteamTVUserSettings_Response* Arena::CreateMaybeMessage<::CSteamTV_SetSteamTVUserSettings_Response>(Arena*);
template<> ::CSteamTV_SubscribeBroadcastChannel_Request* Arena::CreateMaybeMessage<::CSteamTV_SubscribeBroadcastChannel_Request>(Arena*);
template<> ::CSteamTV_SubscribeBroadcastChannel_Response* Arena::CreateMaybeMessage<::CSteamTV_SubscribeBroadcastChannel_Response>(Arena*);
template<> ::GameListEntry* Arena::CreateMaybeMessage<::GameListEntry>(Arena*);
template<> ::GetBroadcastChannelEntry* Arena::CreateMaybeMessage<::GetBroadcastChannelEntry>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EBroadcastImageType : int {
  k_EBroadcastImageType_None = 0,
  k_EBroadcastImageType_Offline = 1,
  k_EBroadcastImageType_Standby = 2,
  k_EBroadcastImageType_Avatar = 3,
  k_EBroadcastImageType_Summary = 4,
  k_EBroadcastImageType_Background = 5,
  k_EBroadcastImageType_Emoticon = 6
};
bool EBroadcastImageType_IsValid(int value);
constexpr EBroadcastImageType EBroadcastImageType_MIN = k_EBroadcastImageType_None;
constexpr EBroadcastImageType EBroadcastImageType_MAX = k_EBroadcastImageType_Emoticon;
constexpr int EBroadcastImageType_ARRAYSIZE = EBroadcastImageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EBroadcastImageType_descriptor();
template<typename T>
inline const std::string& EBroadcastImageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EBroadcastImageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EBroadcastImageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EBroadcastImageType_descriptor(), enum_t_value);
}
inline bool EBroadcastImageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EBroadcastImageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EBroadcastImageType>(
    EBroadcastImageType_descriptor(), name, value);
}
enum EGetGamesAlgorithm : int {
  k_EGetGamesAlgorithm_Default = 1,
  k_EGetGamesAlgorithm_MostPlayed = 2,
  k_EGetGamesAlgorithm_PopularNew = 3
};
bool EGetGamesAlgorithm_IsValid(int value);
constexpr EGetGamesAlgorithm EGetGamesAlgorithm_MIN = k_EGetGamesAlgorithm_Default;
constexpr EGetGamesAlgorithm EGetGamesAlgorithm_MAX = k_EGetGamesAlgorithm_PopularNew;
constexpr int EGetGamesAlgorithm_ARRAYSIZE = EGetGamesAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGetGamesAlgorithm_descriptor();
template<typename T>
inline const std::string& EGetGamesAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGetGamesAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGetGamesAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGetGamesAlgorithm_descriptor(), enum_t_value);
}
inline bool EGetGamesAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGetGamesAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGetGamesAlgorithm>(
    EGetGamesAlgorithm_descriptor(), name, value);
}
enum EGetChannelsAlgorithm : int {
  k_EGetChannelsAlgorithm_Default = 1,
  k_EGetChannelsAlgorithm_Friends = 2,
  k_EGetChannelsAlgorithm_Featured = 3,
  k_EGetChannelsAlgorithm_Developer = 4,
  k_EGetChannelsAlgorithm_Following = 5
};
bool EGetChannelsAlgorithm_IsValid(int value);
constexpr EGetChannelsAlgorithm EGetChannelsAlgorithm_MIN = k_EGetChannelsAlgorithm_Default;
constexpr EGetChannelsAlgorithm EGetChannelsAlgorithm_MAX = k_EGetChannelsAlgorithm_Following;
constexpr int EGetChannelsAlgorithm_ARRAYSIZE = EGetChannelsAlgorithm_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGetChannelsAlgorithm_descriptor();
template<typename T>
inline const std::string& EGetChannelsAlgorithm_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGetChannelsAlgorithm>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGetChannelsAlgorithm_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGetChannelsAlgorithm_descriptor(), enum_t_value);
}
inline bool EGetChannelsAlgorithm_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGetChannelsAlgorithm* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGetChannelsAlgorithm>(
    EGetChannelsAlgorithm_descriptor(), name, value);
}
enum ESteamTVContentTemplate : int {
  k_ESteamTVContentTemplate_Invalid = 0,
  k_ESteamTVContentTemplate_Takeover = 1,
  k_ESteamTVContentTemplate_SingleGame = 2,
  k_ESteamTVContentTemplate_GameList = 3,
  k_ESteamTVContentTemplate_QuickExplore = 4,
  k_ESteamTVContentTemplate_ConveyorBelt = 5,
  k_ESteamTVContentTemplate_WatchParty = 6,
  k_ESteamTVContentTemplate_Developer = 7,
  k_ESteamTVContentTemplate_Event = 8
};
bool ESteamTVContentTemplate_IsValid(int value);
constexpr ESteamTVContentTemplate ESteamTVContentTemplate_MIN = k_ESteamTVContentTemplate_Invalid;
constexpr ESteamTVContentTemplate ESteamTVContentTemplate_MAX = k_ESteamTVContentTemplate_Event;
constexpr int ESteamTVContentTemplate_ARRAYSIZE = ESteamTVContentTemplate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamTVContentTemplate_descriptor();
template<typename T>
inline const std::string& ESteamTVContentTemplate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESteamTVContentTemplate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESteamTVContentTemplate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESteamTVContentTemplate_descriptor(), enum_t_value);
}
inline bool ESteamTVContentTemplate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESteamTVContentTemplate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESteamTVContentTemplate>(
    ESteamTVContentTemplate_descriptor(), name, value);
}
// ===================================================================

class CSteamTV_CreateBroadcastChannel_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_CreateBroadcastChannel_Request) */ {
 public:
  inline CSteamTV_CreateBroadcastChannel_Request() : CSteamTV_CreateBroadcastChannel_Request(nullptr) {}
  ~CSteamTV_CreateBroadcastChannel_Request() override;
  explicit constexpr CSteamTV_CreateBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_CreateBroadcastChannel_Request(const CSteamTV_CreateBroadcastChannel_Request& from);
  CSteamTV_CreateBroadcastChannel_Request(CSteamTV_CreateBroadcastChannel_Request&& from) noexcept
    : CSteamTV_CreateBroadcastChannel_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_CreateBroadcastChannel_Request& operator=(const CSteamTV_CreateBroadcastChannel_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_CreateBroadcastChannel_Request& operator=(CSteamTV_CreateBroadcastChannel_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_CreateBroadcastChannel_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_CreateBroadcastChannel_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_CreateBroadcastChannel_Request*>(
               &_CSteamTV_CreateBroadcastChannel_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CSteamTV_CreateBroadcastChannel_Request& a, CSteamTV_CreateBroadcastChannel_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_CreateBroadcastChannel_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_CreateBroadcastChannel_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_CreateBroadcastChannel_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_CreateBroadcastChannel_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_CreateBroadcastChannel_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_CreateBroadcastChannel_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_CreateBroadcastChannel_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_CreateBroadcastChannel_Request";
  }
  protected:
  explicit CSteamTV_CreateBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueNameFieldNumber = 1,
  };
  // optional string unique_name = 1 [(.description) = "Unique short broadcast channel name, part of Steam.TV URL"];
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_CreateBroadcastChannel_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_CreateBroadcastChannel_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_CreateBroadcastChannel_Response) */ {
 public:
  inline CSteamTV_CreateBroadcastChannel_Response() : CSteamTV_CreateBroadcastChannel_Response(nullptr) {}
  ~CSteamTV_CreateBroadcastChannel_Response() override;
  explicit constexpr CSteamTV_CreateBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_CreateBroadcastChannel_Response(const CSteamTV_CreateBroadcastChannel_Response& from);
  CSteamTV_CreateBroadcastChannel_Response(CSteamTV_CreateBroadcastChannel_Response&& from) noexcept
    : CSteamTV_CreateBroadcastChannel_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_CreateBroadcastChannel_Response& operator=(const CSteamTV_CreateBroadcastChannel_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_CreateBroadcastChannel_Response& operator=(CSteamTV_CreateBroadcastChannel_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_CreateBroadcastChannel_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_CreateBroadcastChannel_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_CreateBroadcastChannel_Response*>(
               &_CSteamTV_CreateBroadcastChannel_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CSteamTV_CreateBroadcastChannel_Response& a, CSteamTV_CreateBroadcastChannel_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_CreateBroadcastChannel_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_CreateBroadcastChannel_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_CreateBroadcastChannel_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_CreateBroadcastChannel_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_CreateBroadcastChannel_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_CreateBroadcastChannel_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_CreateBroadcastChannel_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_CreateBroadcastChannel_Response";
  }
  protected:
  explicit CSteamTV_CreateBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_CreateBroadcastChannel_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelID_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelID_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelID_Request() : CSteamTV_GetBroadcastChannelID_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelID_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelID_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelID_Request(const CSteamTV_GetBroadcastChannelID_Request& from);
  CSteamTV_GetBroadcastChannelID_Request(CSteamTV_GetBroadcastChannelID_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelID_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelID_Request& operator=(const CSteamTV_GetBroadcastChannelID_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelID_Request& operator=(CSteamTV_GetBroadcastChannelID_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelID_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelID_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelID_Request*>(
               &_CSteamTV_GetBroadcastChannelID_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CSteamTV_GetBroadcastChannelID_Request& a, CSteamTV_GetBroadcastChannelID_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelID_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelID_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelID_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelID_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelID_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelID_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelID_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelID_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelID_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueNameFieldNumber = 1,
  };
  // optional string unique_name = 1 [(.description) = "Channel short name)"];
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelID_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelID_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelID_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelID_Response() : CSteamTV_GetBroadcastChannelID_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelID_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelID_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelID_Response(const CSteamTV_GetBroadcastChannelID_Response& from);
  CSteamTV_GetBroadcastChannelID_Response(CSteamTV_GetBroadcastChannelID_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelID_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelID_Response& operator=(const CSteamTV_GetBroadcastChannelID_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelID_Response& operator=(CSteamTV_GetBroadcastChannelID_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelID_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelID_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelID_Response*>(
               &_CSteamTV_GetBroadcastChannelID_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CSteamTV_GetBroadcastChannelID_Response& a, CSteamTV_GetBroadcastChannelID_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelID_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelID_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelID_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelID_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelID_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelID_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelID_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelID_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelID_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueNameFieldNumber = 2,
    kBroadcastChannelIdFieldNumber = 1,
    kSteamidFieldNumber = 3,
  };
  // optional string unique_name = 2 [(.description) = "Broadcast channel name"];
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional fixed64 steamid = 3 [(.description) = "Broadcast channel owner"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelID_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  uint64_t broadcast_channel_id_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelProfile_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelProfile_Request) */ {
 public:
  inline CSteamTV_SetBroadcastChannelProfile_Request() : CSteamTV_SetBroadcastChannelProfile_Request(nullptr) {}
  ~CSteamTV_SetBroadcastChannelProfile_Request() override;
  explicit constexpr CSteamTV_SetBroadcastChannelProfile_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelProfile_Request(const CSteamTV_SetBroadcastChannelProfile_Request& from);
  CSteamTV_SetBroadcastChannelProfile_Request(CSteamTV_SetBroadcastChannelProfile_Request&& from) noexcept
    : CSteamTV_SetBroadcastChannelProfile_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelProfile_Request& operator=(const CSteamTV_SetBroadcastChannelProfile_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelProfile_Request& operator=(CSteamTV_SetBroadcastChannelProfile_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelProfile_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelProfile_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelProfile_Request*>(
               &_CSteamTV_SetBroadcastChannelProfile_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CSteamTV_SetBroadcastChannelProfile_Request& a, CSteamTV_SetBroadcastChannelProfile_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelProfile_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelProfile_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelProfile_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelProfile_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetBroadcastChannelProfile_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelProfile_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetBroadcastChannelProfile_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelProfile_Request";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelProfile_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kLanguageFieldNumber = 3,
    kHeadlineFieldNumber = 4,
    kSummaryFieldNumber = 5,
    kAvatarHashFieldNumber = 6,
    kScheduleFieldNumber = 7,
    kRulesFieldNumber = 8,
    kPanelsFieldNumber = 9,
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional string name = 2 [(.description) = "long channel name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string language = 3 [(.description) = "primary channel language (Steam shortname)"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string headline = 4 [(.description) = "short channel desciption"];
  bool has_headline() const;
  private:
  bool _internal_has_headline() const;
  public:
  void clear_headline();
  const std::string& headline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headline();
  PROTOBUF_NODISCARD std::string* release_headline();
  void set_allocated_headline(std::string* headline);
  private:
  const std::string& _internal_headline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headline(const std::string& value);
  std::string* _internal_mutable_headline();
  public:

  // optional string summary = 5 [(.description) = "long channel desciption"];
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // optional string avatar_hash = 6 [(.description) = "community avatar hash"];
  bool has_avatar_hash() const;
  private:
  bool _internal_has_avatar_hash() const;
  public:
  void clear_avatar_hash();
  const std::string& avatar_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_hash();
  PROTOBUF_NODISCARD std::string* release_avatar_hash();
  void set_allocated_avatar_hash(std::string* avatar_hash);
  private:
  const std::string& _internal_avatar_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_hash(const std::string& value);
  std::string* _internal_mutable_avatar_hash();
  public:

  // optional string schedule = 7 [(.description) = "broadcast channel schedule"];
  bool has_schedule() const;
  private:
  bool _internal_has_schedule() const;
  public:
  void clear_schedule();
  const std::string& schedule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schedule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schedule();
  PROTOBUF_NODISCARD std::string* release_schedule();
  void set_allocated_schedule(std::string* schedule);
  private:
  const std::string& _internal_schedule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schedule(const std::string& value);
  std::string* _internal_mutable_schedule();
  public:

  // optional string rules = 8 [(.description) = "broadcast channel rules"];
  bool has_rules() const;
  private:
  bool _internal_has_rules() const;
  public:
  void clear_rules();
  const std::string& rules() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rules(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rules();
  PROTOBUF_NODISCARD std::string* release_rules();
  void set_allocated_rules(std::string* rules);
  private:
  const std::string& _internal_rules() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rules(const std::string& value);
  std::string* _internal_mutable_rules();
  public:

  // optional string panels = 9 [(.description) = "JSON data representing the channel panel layout"];
  bool has_panels() const;
  private:
  bool _internal_has_panels() const;
  public:
  void clear_panels();
  const std::string& panels() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_panels(ArgT0&& arg0, ArgT... args);
  std::string* mutable_panels();
  PROTOBUF_NODISCARD std::string* release_panels();
  void set_allocated_panels(std::string* panels);
  private:
  const std::string& _internal_panels() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_panels(const std::string& value);
  std::string* _internal_mutable_panels();
  public:

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelProfile_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_hash_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schedule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr panels_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelProfile_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelProfile_Response) */ {
 public:
  inline CSteamTV_SetBroadcastChannelProfile_Response() : CSteamTV_SetBroadcastChannelProfile_Response(nullptr) {}
  explicit constexpr CSteamTV_SetBroadcastChannelProfile_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelProfile_Response(const CSteamTV_SetBroadcastChannelProfile_Response& from);
  CSteamTV_SetBroadcastChannelProfile_Response(CSteamTV_SetBroadcastChannelProfile_Response&& from) noexcept
    : CSteamTV_SetBroadcastChannelProfile_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelProfile_Response& operator=(const CSteamTV_SetBroadcastChannelProfile_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelProfile_Response& operator=(CSteamTV_SetBroadcastChannelProfile_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelProfile_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelProfile_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelProfile_Response*>(
               &_CSteamTV_SetBroadcastChannelProfile_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CSteamTV_SetBroadcastChannelProfile_Response& a, CSteamTV_SetBroadcastChannelProfile_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelProfile_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelProfile_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelProfile_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelProfile_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_SetBroadcastChannelProfile_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelProfile_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelProfile_Response";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelProfile_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelProfile_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelProfile_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelProfile_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelProfile_Request() : CSteamTV_GetBroadcastChannelProfile_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelProfile_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelProfile_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelProfile_Request(const CSteamTV_GetBroadcastChannelProfile_Request& from);
  CSteamTV_GetBroadcastChannelProfile_Request(CSteamTV_GetBroadcastChannelProfile_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelProfile_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelProfile_Request& operator=(const CSteamTV_GetBroadcastChannelProfile_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelProfile_Request& operator=(CSteamTV_GetBroadcastChannelProfile_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelProfile_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelProfile_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelProfile_Request*>(
               &_CSteamTV_GetBroadcastChannelProfile_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CSteamTV_GetBroadcastChannelProfile_Request& a, CSteamTV_GetBroadcastChannelProfile_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelProfile_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelProfile_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelProfile_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelProfile_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelProfile_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelProfile_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelProfile_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelProfile_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelProfile_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelProfile_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelProfile_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelProfile_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelProfile_Response() : CSteamTV_GetBroadcastChannelProfile_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelProfile_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelProfile_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelProfile_Response(const CSteamTV_GetBroadcastChannelProfile_Response& from);
  CSteamTV_GetBroadcastChannelProfile_Response(CSteamTV_GetBroadcastChannelProfile_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelProfile_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelProfile_Response& operator=(const CSteamTV_GetBroadcastChannelProfile_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelProfile_Response& operator=(CSteamTV_GetBroadcastChannelProfile_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelProfile_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelProfile_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelProfile_Response*>(
               &_CSteamTV_GetBroadcastChannelProfile_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CSteamTV_GetBroadcastChannelProfile_Response& a, CSteamTV_GetBroadcastChannelProfile_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelProfile_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelProfile_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelProfile_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelProfile_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelProfile_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelProfile_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelProfile_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelProfile_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelProfile_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueNameFieldNumber = 1,
    kNameFieldNumber = 3,
    kLanguageFieldNumber = 4,
    kHeadlineFieldNumber = 5,
    kSummaryFieldNumber = 6,
    kScheduleFieldNumber = 7,
    kRulesFieldNumber = 8,
    kPanelsFieldNumber = 9,
    kOwnerSteamidFieldNumber = 2,
    kIsPartneredFieldNumber = 10,
  };
  // optional string unique_name = 1 [(.description) = "Unique short broadcast channel name, part of Steam.TV URL"];
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // optional string name = 3 [(.description) = "long channel name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string language = 4 [(.description) = "primary channel language (Steam shortname)"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string headline = 5 [(.description) = "short channel description"];
  bool has_headline() const;
  private:
  bool _internal_has_headline() const;
  public:
  void clear_headline();
  const std::string& headline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headline();
  PROTOBUF_NODISCARD std::string* release_headline();
  void set_allocated_headline(std::string* headline);
  private:
  const std::string& _internal_headline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headline(const std::string& value);
  std::string* _internal_mutable_headline();
  public:

  // optional string summary = 6 [(.description) = "long channel description"];
  bool has_summary() const;
  private:
  bool _internal_has_summary() const;
  public:
  void clear_summary();
  const std::string& summary() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_summary(ArgT0&& arg0, ArgT... args);
  std::string* mutable_summary();
  PROTOBUF_NODISCARD std::string* release_summary();
  void set_allocated_summary(std::string* summary);
  private:
  const std::string& _internal_summary() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_summary(const std::string& value);
  std::string* _internal_mutable_summary();
  public:

  // optional string schedule = 7 [(.description) = "broadcast channel schedule"];
  bool has_schedule() const;
  private:
  bool _internal_has_schedule() const;
  public:
  void clear_schedule();
  const std::string& schedule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_schedule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_schedule();
  PROTOBUF_NODISCARD std::string* release_schedule();
  void set_allocated_schedule(std::string* schedule);
  private:
  const std::string& _internal_schedule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_schedule(const std::string& value);
  std::string* _internal_mutable_schedule();
  public:

  // optional string rules = 8 [(.description) = "broadcast channel rules"];
  bool has_rules() const;
  private:
  bool _internal_has_rules() const;
  public:
  void clear_rules();
  const std::string& rules() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rules(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rules();
  PROTOBUF_NODISCARD std::string* release_rules();
  void set_allocated_rules(std::string* rules);
  private:
  const std::string& _internal_rules() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rules(const std::string& value);
  std::string* _internal_mutable_rules();
  public:

  // optional string panels = 9 [(.description) = "JSON data representing the channel panel layout"];
  bool has_panels() const;
  private:
  bool _internal_has_panels() const;
  public:
  void clear_panels();
  const std::string& panels() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_panels(ArgT0&& arg0, ArgT... args);
  std::string* mutable_panels();
  PROTOBUF_NODISCARD std::string* release_panels();
  void set_allocated_panels(std::string* panels);
  private:
  const std::string& _internal_panels() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_panels(const std::string& value);
  std::string* _internal_mutable_panels();
  public:

  // optional fixed64 owner_steamid = 2 [(.description) = "Broadcast channel owner"];
  bool has_owner_steamid() const;
  private:
  bool _internal_has_owner_steamid() const;
  public:
  void clear_owner_steamid();
  uint64_t owner_steamid() const;
  void set_owner_steamid(uint64_t value);
  private:
  uint64_t _internal_owner_steamid() const;
  void _internal_set_owner_steamid(uint64_t value);
  public:

  // optional bool is_partnered = 10;
  bool has_is_partnered() const;
  private:
  bool _internal_has_is_partnered() const;
  public:
  void clear_is_partnered();
  bool is_partnered() const;
  void set_is_partnered(bool value);
  private:
  bool _internal_is_partnered() const;
  void _internal_set_is_partnered(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelProfile_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr summary_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr schedule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rules_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr panels_;
  uint64_t owner_steamid_;
  bool is_partnered_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelImage_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelImage_Request) */ {
 public:
  inline CSteamTV_SetBroadcastChannelImage_Request() : CSteamTV_SetBroadcastChannelImage_Request(nullptr) {}
  ~CSteamTV_SetBroadcastChannelImage_Request() override;
  explicit constexpr CSteamTV_SetBroadcastChannelImage_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelImage_Request(const CSteamTV_SetBroadcastChannelImage_Request& from);
  CSteamTV_SetBroadcastChannelImage_Request(CSteamTV_SetBroadcastChannelImage_Request&& from) noexcept
    : CSteamTV_SetBroadcastChannelImage_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelImage_Request& operator=(const CSteamTV_SetBroadcastChannelImage_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelImage_Request& operator=(CSteamTV_SetBroadcastChannelImage_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelImage_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelImage_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelImage_Request*>(
               &_CSteamTV_SetBroadcastChannelImage_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CSteamTV_SetBroadcastChannelImage_Request& a, CSteamTV_SetBroadcastChannelImage_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelImage_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelImage_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelImage_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelImage_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetBroadcastChannelImage_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelImage_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetBroadcastChannelImage_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelImage_Request";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelImage_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileExtensionFieldNumber = 7,
    kFileHashFieldNumber = 8,
    kBroadcastChannelIdFieldNumber = 1,
    kImageTypeFieldNumber = 2,
    kImageIndexFieldNumber = 3,
    kImageWidthFieldNumber = 4,
    kImageHeightFieldNumber = 5,
    kFileSizeFieldNumber = 6,
    kUndoFieldNumber = 9,
  };
  // optional string file_extension = 7 [(.description) = "eg .jpg"];
  bool has_file_extension() const;
  private:
  bool _internal_has_file_extension() const;
  public:
  void clear_file_extension();
  const std::string& file_extension() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_extension(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_extension();
  PROTOBUF_NODISCARD std::string* release_file_extension();
  void set_allocated_file_extension(std::string* file_extension);
  private:
  const std::string& _internal_file_extension() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_extension(const std::string& value);
  std::string* _internal_mutable_file_extension();
  public:

  // optional string file_hash = 8 [(.description) = "image SHA"];
  bool has_file_hash() const;
  private:
  bool _internal_has_file_hash() const;
  public:
  void clear_file_hash();
  const std::string& file_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_hash();
  PROTOBUF_NODISCARD std::string* release_file_hash();
  void set_allocated_file_hash(std::string* file_hash);
  private:
  const std::string& _internal_file_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_hash(const std::string& value);
  std::string* _internal_mutable_file_hash();
  public:

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional .EBroadcastImageType image_type = 2 [default = k_EBroadcastImageType_None, (.description) = "EBroadcastImage"];
  bool has_image_type() const;
  private:
  bool _internal_has_image_type() const;
  public:
  void clear_image_type();
  ::EBroadcastImageType image_type() const;
  void set_image_type(::EBroadcastImageType value);
  private:
  ::EBroadcastImageType _internal_image_type() const;
  void _internal_set_image_type(::EBroadcastImageType value);
  public:

  // optional uint32 image_index = 3 [(.description) = "Index of the image (for supporting multiple uploads of the same type"];
  bool has_image_index() const;
  private:
  bool _internal_has_image_index() const;
  public:
  void clear_image_index();
  uint32_t image_index() const;
  void set_image_index(uint32_t value);
  private:
  uint32_t _internal_image_index() const;
  void _internal_set_image_index(uint32_t value);
  public:

  // optional uint32 image_width = 4 [(.description) = "width in pixels"];
  bool has_image_width() const;
  private:
  bool _internal_has_image_width() const;
  public:
  void clear_image_width();
  uint32_t image_width() const;
  void set_image_width(uint32_t value);
  private:
  uint32_t _internal_image_width() const;
  void _internal_set_image_width(uint32_t value);
  public:

  // optional uint32 image_height = 5 [(.description) = "height in pixels"];
  bool has_image_height() const;
  private:
  bool _internal_has_image_height() const;
  public:
  void clear_image_height();
  uint32_t image_height() const;
  void set_image_height(uint32_t value);
  private:
  uint32_t _internal_image_height() const;
  void _internal_set_image_height(uint32_t value);
  public:

  // optional uint32 file_size = 6 [(.description) = "in bytes"];
  bool has_file_size() const;
  private:
  bool _internal_has_file_size() const;
  public:
  void clear_file_size();
  uint32_t file_size() const;
  void set_file_size(uint32_t value);
  private:
  uint32_t _internal_file_size() const;
  void _internal_set_file_size(uint32_t value);
  public:

  // optional bool undo = 9 [(.description) = "indicates this is a delete request"];
  bool has_undo() const;
  private:
  bool _internal_has_undo() const;
  public:
  void clear_undo();
  bool undo() const;
  void set_undo(bool value);
  private:
  bool _internal_undo() const;
  void _internal_set_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelImage_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_extension_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_hash_;
  uint64_t broadcast_channel_id_;
  int image_type_;
  uint32_t image_index_;
  uint32_t image_width_;
  uint32_t image_height_;
  uint32_t file_size_;
  bool undo_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelImage_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelImage_Response) */ {
 public:
  inline CSteamTV_SetBroadcastChannelImage_Response() : CSteamTV_SetBroadcastChannelImage_Response(nullptr) {}
  ~CSteamTV_SetBroadcastChannelImage_Response() override;
  explicit constexpr CSteamTV_SetBroadcastChannelImage_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelImage_Response(const CSteamTV_SetBroadcastChannelImage_Response& from);
  CSteamTV_SetBroadcastChannelImage_Response(CSteamTV_SetBroadcastChannelImage_Response&& from) noexcept
    : CSteamTV_SetBroadcastChannelImage_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelImage_Response& operator=(const CSteamTV_SetBroadcastChannelImage_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelImage_Response& operator=(CSteamTV_SetBroadcastChannelImage_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelImage_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelImage_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelImage_Response*>(
               &_CSteamTV_SetBroadcastChannelImage_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CSteamTV_SetBroadcastChannelImage_Response& a, CSteamTV_SetBroadcastChannelImage_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelImage_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelImage_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelImage_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelImage_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetBroadcastChannelImage_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelImage_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetBroadcastChannelImage_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelImage_Response";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelImage_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReplaceImageHashFieldNumber = 1,
  };
  // optional string replace_image_hash = 1 [(.description) = "set if caller should remove previous SHA file from cache"];
  bool has_replace_image_hash() const;
  private:
  bool _internal_has_replace_image_hash() const;
  public:
  void clear_replace_image_hash();
  const std::string& replace_image_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_replace_image_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_replace_image_hash();
  PROTOBUF_NODISCARD std::string* release_replace_image_hash();
  void set_allocated_replace_image_hash(std::string* replace_image_hash);
  private:
  const std::string& _internal_replace_image_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_replace_image_hash(const std::string& value);
  std::string* _internal_mutable_replace_image_hash();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelImage_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr replace_image_hash_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelImages_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelImages_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelImages_Request() : CSteamTV_GetBroadcastChannelImages_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelImages_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelImages_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelImages_Request(const CSteamTV_GetBroadcastChannelImages_Request& from);
  CSteamTV_GetBroadcastChannelImages_Request(CSteamTV_GetBroadcastChannelImages_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelImages_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelImages_Request& operator=(const CSteamTV_GetBroadcastChannelImages_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelImages_Request& operator=(CSteamTV_GetBroadcastChannelImages_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelImages_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelImages_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelImages_Request*>(
               &_CSteamTV_GetBroadcastChannelImages_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CSteamTV_GetBroadcastChannelImages_Request& a, CSteamTV_GetBroadcastChannelImages_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelImages_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelImages_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelImages_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelImages_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelImages_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelImages_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelImages_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelImages_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelImages_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageTypesFieldNumber = 2,
    kBroadcastChannelIdFieldNumber = 1,
  };
  // repeated .EBroadcastImageType image_types = 2 [(.description) = "list of EBroadcastImage"];
  int image_types_size() const;
  private:
  int _internal_image_types_size() const;
  public:
  void clear_image_types();
  private:
  ::EBroadcastImageType _internal_image_types(int index) const;
  void _internal_add_image_types(::EBroadcastImageType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_image_types();
  public:
  ::EBroadcastImageType image_types(int index) const;
  void set_image_types(int index, ::EBroadcastImageType value);
  void add_image_types(::EBroadcastImageType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& image_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_image_types();

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelImages_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> image_types_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelImages_Response_Images final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelImages_Response.Images) */ {
 public:
  inline CSteamTV_GetBroadcastChannelImages_Response_Images() : CSteamTV_GetBroadcastChannelImages_Response_Images(nullptr) {}
  ~CSteamTV_GetBroadcastChannelImages_Response_Images() override;
  explicit constexpr CSteamTV_GetBroadcastChannelImages_Response_Images(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelImages_Response_Images(const CSteamTV_GetBroadcastChannelImages_Response_Images& from);
  CSteamTV_GetBroadcastChannelImages_Response_Images(CSteamTV_GetBroadcastChannelImages_Response_Images&& from) noexcept
    : CSteamTV_GetBroadcastChannelImages_Response_Images() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelImages_Response_Images& operator=(const CSteamTV_GetBroadcastChannelImages_Response_Images& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelImages_Response_Images& operator=(CSteamTV_GetBroadcastChannelImages_Response_Images&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelImages_Response_Images& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelImages_Response_Images* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelImages_Response_Images*>(
               &_CSteamTV_GetBroadcastChannelImages_Response_Images_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CSteamTV_GetBroadcastChannelImages_Response_Images& a, CSteamTV_GetBroadcastChannelImages_Response_Images& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelImages_Response_Images* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelImages_Response_Images* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelImages_Response_Images* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelImages_Response_Images>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelImages_Response_Images& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelImages_Response_Images& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelImages_Response_Images* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelImages_Response.Images";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelImages_Response_Images(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImagePathFieldNumber = 2,
    kImageTypeFieldNumber = 1,
    kImageIndexFieldNumber = 3,
  };
  // optional string image_path = 2 [(.description) = "Path to the uploaded image"];
  bool has_image_path() const;
  private:
  bool _internal_has_image_path() const;
  public:
  void clear_image_path();
  const std::string& image_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_path();
  PROTOBUF_NODISCARD std::string* release_image_path();
  void set_allocated_image_path(std::string* image_path);
  private:
  const std::string& _internal_image_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_path(const std::string& value);
  std::string* _internal_mutable_image_path();
  public:

  // optional .EBroadcastImageType image_type = 1 [default = k_EBroadcastImageType_None, (.description) = "Type of the image"];
  bool has_image_type() const;
  private:
  bool _internal_has_image_type() const;
  public:
  void clear_image_type();
  ::EBroadcastImageType image_type() const;
  void set_image_type(::EBroadcastImageType value);
  private:
  ::EBroadcastImageType _internal_image_type() const;
  void _internal_set_image_type(::EBroadcastImageType value);
  public:

  // optional uint32 image_index = 3 [(.description) = "Index of the image"];
  bool has_image_index() const;
  private:
  bool _internal_has_image_index() const;
  public:
  void clear_image_index();
  uint32_t image_index() const;
  void set_image_index(uint32_t value);
  private:
  uint32_t _internal_image_index() const;
  void _internal_set_image_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelImages_Response.Images)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_path_;
  int image_type_;
  uint32_t image_index_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelImages_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelImages_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelImages_Response() : CSteamTV_GetBroadcastChannelImages_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelImages_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelImages_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelImages_Response(const CSteamTV_GetBroadcastChannelImages_Response& from);
  CSteamTV_GetBroadcastChannelImages_Response(CSteamTV_GetBroadcastChannelImages_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelImages_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelImages_Response& operator=(const CSteamTV_GetBroadcastChannelImages_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelImages_Response& operator=(CSteamTV_GetBroadcastChannelImages_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelImages_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelImages_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelImages_Response*>(
               &_CSteamTV_GetBroadcastChannelImages_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CSteamTV_GetBroadcastChannelImages_Response& a, CSteamTV_GetBroadcastChannelImages_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelImages_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelImages_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelImages_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelImages_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelImages_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelImages_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelImages_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelImages_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelImages_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSteamTV_GetBroadcastChannelImages_Response_Images Images;

  // accessors -------------------------------------------------------

  enum : int {
    kImagesFieldNumber = 1,
  };
  // repeated .CSteamTV_GetBroadcastChannelImages_Response.Images images = 1;
  int images_size() const;
  private:
  int _internal_images_size() const;
  public:
  void clear_images();
  ::CSteamTV_GetBroadcastChannelImages_Response_Images* mutable_images(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelImages_Response_Images >*
      mutable_images();
  private:
  const ::CSteamTV_GetBroadcastChannelImages_Response_Images& _internal_images(int index) const;
  ::CSteamTV_GetBroadcastChannelImages_Response_Images* _internal_add_images();
  public:
  const ::CSteamTV_GetBroadcastChannelImages_Response_Images& images(int index) const;
  ::CSteamTV_GetBroadcastChannelImages_Response_Images* add_images();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelImages_Response_Images >&
      images() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelImages_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelImages_Response_Images > images_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelLinkRegions_Request_Links final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links) */ {
 public:
  inline CSteamTV_SetBroadcastChannelLinkRegions_Request_Links() : CSteamTV_SetBroadcastChannelLinkRegions_Request_Links(nullptr) {}
  ~CSteamTV_SetBroadcastChannelLinkRegions_Request_Links() override;
  explicit constexpr CSteamTV_SetBroadcastChannelLinkRegions_Request_Links(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelLinkRegions_Request_Links(const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& from);
  CSteamTV_SetBroadcastChannelLinkRegions_Request_Links(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links&& from) noexcept
    : CSteamTV_SetBroadcastChannelLinkRegions_Request_Links() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& operator=(const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& operator=(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links*>(
               &_CSteamTV_SetBroadcastChannelLinkRegions_Request_Links_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& a, CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelLinkRegions_Request_Links>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelLinkRegions_Request.Links";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelLinkRegions_Request_Links(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kLinkDescriptionFieldNumber = 3,
    kLinkIndexFieldNumber = 1,
    kLeftFieldNumber = 4,
    kTopFieldNumber = 5,
    kWidthFieldNumber = 6,
    kHeightFieldNumber = 7,
  };
  // optional string url = 2 [(.description) = "URL "];
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string link_description = 3 [(.description) = "URL description that will show in the link region"];
  bool has_link_description() const;
  private:
  bool _internal_has_link_description() const;
  public:
  void clear_link_description();
  const std::string& link_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_description();
  PROTOBUF_NODISCARD std::string* release_link_description();
  void set_allocated_link_description(std::string* link_description);
  private:
  const std::string& _internal_link_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_description(const std::string& value);
  std::string* _internal_mutable_link_description();
  public:

  // optional uint32 link_index = 1 [(.description) = "Index of the link (lower number has higher priority)"];
  bool has_link_index() const;
  private:
  bool _internal_has_link_index() const;
  public:
  void clear_link_index();
  uint32_t link_index() const;
  void set_link_index(uint32_t value);
  private:
  uint32_t _internal_link_index() const;
  void _internal_set_link_index(uint32_t value);
  public:

  // optional uint32 left = 4 [(.description) = "Left X position in 100th of a % of the video width"];
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  uint32_t left() const;
  void set_left(uint32_t value);
  private:
  uint32_t _internal_left() const;
  void _internal_set_left(uint32_t value);
  public:

  // optional uint32 top = 5 [(.description) = "Top Y position in 100th of a % of the video height"];
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  uint32_t top() const;
  void set_top(uint32_t value);
  private:
  uint32_t _internal_top() const;
  void _internal_set_top(uint32_t value);
  public:

  // optional uint32 width = 6 [(.description) = "Region Width in 100th of a % of the video width"];
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 7 [(.description) = "Region Height in 100th of a % of the video height"];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_description_;
  uint32_t link_index_;
  uint32_t left_;
  uint32_t top_;
  uint32_t width_;
  uint32_t height_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelLinkRegions_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelLinkRegions_Request) */ {
 public:
  inline CSteamTV_SetBroadcastChannelLinkRegions_Request() : CSteamTV_SetBroadcastChannelLinkRegions_Request(nullptr) {}
  ~CSteamTV_SetBroadcastChannelLinkRegions_Request() override;
  explicit constexpr CSteamTV_SetBroadcastChannelLinkRegions_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelLinkRegions_Request(const CSteamTV_SetBroadcastChannelLinkRegions_Request& from);
  CSteamTV_SetBroadcastChannelLinkRegions_Request(CSteamTV_SetBroadcastChannelLinkRegions_Request&& from) noexcept
    : CSteamTV_SetBroadcastChannelLinkRegions_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelLinkRegions_Request& operator=(const CSteamTV_SetBroadcastChannelLinkRegions_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelLinkRegions_Request& operator=(CSteamTV_SetBroadcastChannelLinkRegions_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelLinkRegions_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelLinkRegions_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelLinkRegions_Request*>(
               &_CSteamTV_SetBroadcastChannelLinkRegions_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CSteamTV_SetBroadcastChannelLinkRegions_Request& a, CSteamTV_SetBroadcastChannelLinkRegions_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelLinkRegions_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelLinkRegions_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelLinkRegions_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelLinkRegions_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetBroadcastChannelLinkRegions_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelLinkRegions_Request";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelLinkRegions_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSteamTV_SetBroadcastChannelLinkRegions_Request_Links Links;

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 2,
    kBroadcastChannelIdFieldNumber = 1,
  };
  // repeated .CSteamTV_SetBroadcastChannelLinkRegions_Request.Links links = 2;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links >*
      mutable_links();
  private:
  const ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& _internal_links(int index) const;
  ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* _internal_add_links();
  public:
  const ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& links(int index) const;
  ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links >&
      links() const;

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelLinkRegions_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links > links_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetBroadcastChannelLinkRegions_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_SetBroadcastChannelLinkRegions_Response) */ {
 public:
  inline CSteamTV_SetBroadcastChannelLinkRegions_Response() : CSteamTV_SetBroadcastChannelLinkRegions_Response(nullptr) {}
  explicit constexpr CSteamTV_SetBroadcastChannelLinkRegions_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetBroadcastChannelLinkRegions_Response(const CSteamTV_SetBroadcastChannelLinkRegions_Response& from);
  CSteamTV_SetBroadcastChannelLinkRegions_Response(CSteamTV_SetBroadcastChannelLinkRegions_Response&& from) noexcept
    : CSteamTV_SetBroadcastChannelLinkRegions_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetBroadcastChannelLinkRegions_Response& operator=(const CSteamTV_SetBroadcastChannelLinkRegions_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetBroadcastChannelLinkRegions_Response& operator=(CSteamTV_SetBroadcastChannelLinkRegions_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetBroadcastChannelLinkRegions_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetBroadcastChannelLinkRegions_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetBroadcastChannelLinkRegions_Response*>(
               &_CSteamTV_SetBroadcastChannelLinkRegions_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CSteamTV_SetBroadcastChannelLinkRegions_Response& a, CSteamTV_SetBroadcastChannelLinkRegions_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetBroadcastChannelLinkRegions_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetBroadcastChannelLinkRegions_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetBroadcastChannelLinkRegions_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetBroadcastChannelLinkRegions_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_SetBroadcastChannelLinkRegions_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetBroadcastChannelLinkRegions_Response";
  }
  protected:
  explicit CSteamTV_SetBroadcastChannelLinkRegions_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_SetBroadcastChannelLinkRegions_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelLinks_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelLinks_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelLinks_Request() : CSteamTV_GetBroadcastChannelLinks_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelLinks_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelLinks_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelLinks_Request(const CSteamTV_GetBroadcastChannelLinks_Request& from);
  CSteamTV_GetBroadcastChannelLinks_Request(CSteamTV_GetBroadcastChannelLinks_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelLinks_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelLinks_Request& operator=(const CSteamTV_GetBroadcastChannelLinks_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelLinks_Request& operator=(CSteamTV_GetBroadcastChannelLinks_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelLinks_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelLinks_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelLinks_Request*>(
               &_CSteamTV_GetBroadcastChannelLinks_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CSteamTV_GetBroadcastChannelLinks_Request& a, CSteamTV_GetBroadcastChannelLinks_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelLinks_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelLinks_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelLinks_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelLinks_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelLinks_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelLinks_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelLinks_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelLinks_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelLinks_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelLinks_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelLinks_Response_Links final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelLinks_Response.Links) */ {
 public:
  inline CSteamTV_GetBroadcastChannelLinks_Response_Links() : CSteamTV_GetBroadcastChannelLinks_Response_Links(nullptr) {}
  ~CSteamTV_GetBroadcastChannelLinks_Response_Links() override;
  explicit constexpr CSteamTV_GetBroadcastChannelLinks_Response_Links(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelLinks_Response_Links(const CSteamTV_GetBroadcastChannelLinks_Response_Links& from);
  CSteamTV_GetBroadcastChannelLinks_Response_Links(CSteamTV_GetBroadcastChannelLinks_Response_Links&& from) noexcept
    : CSteamTV_GetBroadcastChannelLinks_Response_Links() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelLinks_Response_Links& operator=(const CSteamTV_GetBroadcastChannelLinks_Response_Links& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelLinks_Response_Links& operator=(CSteamTV_GetBroadcastChannelLinks_Response_Links&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelLinks_Response_Links& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelLinks_Response_Links* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelLinks_Response_Links*>(
               &_CSteamTV_GetBroadcastChannelLinks_Response_Links_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CSteamTV_GetBroadcastChannelLinks_Response_Links& a, CSteamTV_GetBroadcastChannelLinks_Response_Links& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelLinks_Response_Links* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelLinks_Response_Links* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelLinks_Response_Links* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelLinks_Response_Links>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelLinks_Response_Links& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelLinks_Response_Links& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelLinks_Response_Links* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelLinks_Response.Links";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelLinks_Response_Links(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 2,
    kLinkDescriptionFieldNumber = 3,
    kLinkIndexFieldNumber = 1,
    kLeftFieldNumber = 4,
    kTopFieldNumber = 5,
    kWidthFieldNumber = 6,
    kHeightFieldNumber = 7,
  };
  // optional string url = 2 [(.description) = "URL "];
  bool has_url() const;
  private:
  bool _internal_has_url() const;
  public:
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // optional string link_description = 3 [(.description) = "URL description that will show in the link region"];
  bool has_link_description() const;
  private:
  bool _internal_has_link_description() const;
  public:
  void clear_link_description();
  const std::string& link_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_link_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_link_description();
  PROTOBUF_NODISCARD std::string* release_link_description();
  void set_allocated_link_description(std::string* link_description);
  private:
  const std::string& _internal_link_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_link_description(const std::string& value);
  std::string* _internal_mutable_link_description();
  public:

  // optional uint32 link_index = 1 [(.description) = "Index of the link (lower number has higher priority)"];
  bool has_link_index() const;
  private:
  bool _internal_has_link_index() const;
  public:
  void clear_link_index();
  uint32_t link_index() const;
  void set_link_index(uint32_t value);
  private:
  uint32_t _internal_link_index() const;
  void _internal_set_link_index(uint32_t value);
  public:

  // optional uint32 left = 4 [(.description) = "Left X position in 100th of a % of the video width"];
  bool has_left() const;
  private:
  bool _internal_has_left() const;
  public:
  void clear_left();
  uint32_t left() const;
  void set_left(uint32_t value);
  private:
  uint32_t _internal_left() const;
  void _internal_set_left(uint32_t value);
  public:

  // optional uint32 top = 5 [(.description) = "Top Y position in 100th of a % of the video height"];
  bool has_top() const;
  private:
  bool _internal_has_top() const;
  public:
  void clear_top();
  uint32_t top() const;
  void set_top(uint32_t value);
  private:
  uint32_t _internal_top() const;
  void _internal_set_top(uint32_t value);
  public:

  // optional uint32 width = 6 [(.description) = "Region Width in 100th of a % of the video width"];
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 7 [(.description) = "Region Height in 100th of a % of the video height"];
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelLinks_Response.Links)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr link_description_;
  uint32_t link_index_;
  uint32_t left_;
  uint32_t top_;
  uint32_t width_;
  uint32_t height_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelLinks_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelLinks_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelLinks_Response() : CSteamTV_GetBroadcastChannelLinks_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelLinks_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelLinks_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelLinks_Response(const CSteamTV_GetBroadcastChannelLinks_Response& from);
  CSteamTV_GetBroadcastChannelLinks_Response(CSteamTV_GetBroadcastChannelLinks_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelLinks_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelLinks_Response& operator=(const CSteamTV_GetBroadcastChannelLinks_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelLinks_Response& operator=(CSteamTV_GetBroadcastChannelLinks_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelLinks_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelLinks_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelLinks_Response*>(
               &_CSteamTV_GetBroadcastChannelLinks_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CSteamTV_GetBroadcastChannelLinks_Response& a, CSteamTV_GetBroadcastChannelLinks_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelLinks_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelLinks_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelLinks_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelLinks_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelLinks_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelLinks_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelLinks_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelLinks_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelLinks_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSteamTV_GetBroadcastChannelLinks_Response_Links Links;

  // accessors -------------------------------------------------------

  enum : int {
    kLinksFieldNumber = 1,
  };
  // repeated .CSteamTV_GetBroadcastChannelLinks_Response.Links links = 1;
  int links_size() const;
  private:
  int _internal_links_size() const;
  public:
  void clear_links();
  ::CSteamTV_GetBroadcastChannelLinks_Response_Links* mutable_links(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelLinks_Response_Links >*
      mutable_links();
  private:
  const ::CSteamTV_GetBroadcastChannelLinks_Response_Links& _internal_links(int index) const;
  ::CSteamTV_GetBroadcastChannelLinks_Response_Links* _internal_add_links();
  public:
  const ::CSteamTV_GetBroadcastChannelLinks_Response_Links& links(int index) const;
  ::CSteamTV_GetBroadcastChannelLinks_Response_Links* add_links();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelLinks_Response_Links >&
      links() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelLinks_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelLinks_Response_Links > links_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelBroadcasters_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelBroadcasters_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelBroadcasters_Request() : CSteamTV_GetBroadcastChannelBroadcasters_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelBroadcasters_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelBroadcasters_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelBroadcasters_Request(const CSteamTV_GetBroadcastChannelBroadcasters_Request& from);
  CSteamTV_GetBroadcastChannelBroadcasters_Request(CSteamTV_GetBroadcastChannelBroadcasters_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelBroadcasters_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelBroadcasters_Request& operator=(const CSteamTV_GetBroadcastChannelBroadcasters_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelBroadcasters_Request& operator=(CSteamTV_GetBroadcastChannelBroadcasters_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelBroadcasters_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelBroadcasters_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelBroadcasters_Request*>(
               &_CSteamTV_GetBroadcastChannelBroadcasters_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CSteamTV_GetBroadcastChannelBroadcasters_Request& a, CSteamTV_GetBroadcastChannelBroadcasters_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelBroadcasters_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelBroadcasters_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelBroadcasters_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelBroadcasters_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelBroadcasters_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelBroadcasters_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelBroadcasters_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelBroadcasters_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster) */ {
 public:
  inline CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster() : CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster(nullptr) {}
  ~CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster() override;
  explicit constexpr CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster(const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& from);
  CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster&& from) noexcept
    : CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& operator=(const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& operator=(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster*>(
               &_CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& a, CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kRtmpTokenFieldNumber = 3,
    kSteamidFieldNumber = 1,
  };
  // optional string name = 2 [(.description) = "Broadcaster name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string rtmp_token = 3 [(.description) = "Broadcaster upload token"];
  bool has_rtmp_token() const;
  private:
  bool _internal_has_rtmp_token() const;
  public:
  void clear_rtmp_token();
  const std::string& rtmp_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rtmp_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rtmp_token();
  PROTOBUF_NODISCARD std::string* release_rtmp_token();
  void set_allocated_rtmp_token(std::string* rtmp_token);
  private:
  const std::string& _internal_rtmp_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rtmp_token(const std::string& value);
  std::string* _internal_mutable_rtmp_token();
  public:

  // optional fixed64 steamid = 1 [(.description) = "Broadcaster Steam ID"];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rtmp_token_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelBroadcasters_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelBroadcasters_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelBroadcasters_Response() : CSteamTV_GetBroadcastChannelBroadcasters_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelBroadcasters_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelBroadcasters_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelBroadcasters_Response(const CSteamTV_GetBroadcastChannelBroadcasters_Response& from);
  CSteamTV_GetBroadcastChannelBroadcasters_Response(CSteamTV_GetBroadcastChannelBroadcasters_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelBroadcasters_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelBroadcasters_Response& operator=(const CSteamTV_GetBroadcastChannelBroadcasters_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelBroadcasters_Response& operator=(CSteamTV_GetBroadcastChannelBroadcasters_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelBroadcasters_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelBroadcasters_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelBroadcasters_Response*>(
               &_CSteamTV_GetBroadcastChannelBroadcasters_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CSteamTV_GetBroadcastChannelBroadcasters_Response& a, CSteamTV_GetBroadcastChannelBroadcasters_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelBroadcasters_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelBroadcasters_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelBroadcasters_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelBroadcasters_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelBroadcasters_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelBroadcasters_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelBroadcasters_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelBroadcasters_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster Broadcaster;

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastersFieldNumber = 1,
  };
  // repeated .CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster broadcasters = 1;
  int broadcasters_size() const;
  private:
  int _internal_broadcasters_size() const;
  public:
  void clear_broadcasters();
  ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* mutable_broadcasters(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster >*
      mutable_broadcasters();
  private:
  const ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& _internal_broadcasters(int index) const;
  ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* _internal_add_broadcasters();
  public:
  const ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& broadcasters(int index) const;
  ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* add_broadcasters();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster >&
      broadcasters() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelBroadcasters_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster > broadcasters_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetFollowedChannels_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_GetFollowedChannels_Request) */ {
 public:
  inline CSteamTV_GetFollowedChannels_Request() : CSteamTV_GetFollowedChannels_Request(nullptr) {}
  explicit constexpr CSteamTV_GetFollowedChannels_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetFollowedChannels_Request(const CSteamTV_GetFollowedChannels_Request& from);
  CSteamTV_GetFollowedChannels_Request(CSteamTV_GetFollowedChannels_Request&& from) noexcept
    : CSteamTV_GetFollowedChannels_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetFollowedChannels_Request& operator=(const CSteamTV_GetFollowedChannels_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetFollowedChannels_Request& operator=(CSteamTV_GetFollowedChannels_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetFollowedChannels_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetFollowedChannels_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetFollowedChannels_Request*>(
               &_CSteamTV_GetFollowedChannels_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CSteamTV_GetFollowedChannels_Request& a, CSteamTV_GetFollowedChannels_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetFollowedChannels_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetFollowedChannels_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetFollowedChannels_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetFollowedChannels_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_GetFollowedChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_GetFollowedChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetFollowedChannels_Request";
  }
  protected:
  explicit CSteamTV_GetFollowedChannels_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_GetFollowedChannels_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class GetBroadcastChannelEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GetBroadcastChannelEntry) */ {
 public:
  inline GetBroadcastChannelEntry() : GetBroadcastChannelEntry(nullptr) {}
  ~GetBroadcastChannelEntry() override;
  explicit constexpr GetBroadcastChannelEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBroadcastChannelEntry(const GetBroadcastChannelEntry& from);
  GetBroadcastChannelEntry(GetBroadcastChannelEntry&& from) noexcept
    : GetBroadcastChannelEntry() {
    *this = ::std::move(from);
  }

  inline GetBroadcastChannelEntry& operator=(const GetBroadcastChannelEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBroadcastChannelEntry& operator=(GetBroadcastChannelEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBroadcastChannelEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBroadcastChannelEntry* internal_default_instance() {
    return reinterpret_cast<const GetBroadcastChannelEntry*>(
               &_GetBroadcastChannelEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(GetBroadcastChannelEntry& a, GetBroadcastChannelEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBroadcastChannelEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBroadcastChannelEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GetBroadcastChannelEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GetBroadcastChannelEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBroadcastChannelEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBroadcastChannelEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBroadcastChannelEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GetBroadcastChannelEntry";
  }
  protected:
  explicit GetBroadcastChannelEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUniqueNameFieldNumber = 2,
    kNameFieldNumber = 3,
    kThumbnailUrlFieldNumber = 7,
    kHeadlineFieldNumber = 9,
    kAvatarUrlFieldNumber = 10,
    kBackgroundUrlFieldNumber = 13,
    kLanguageFieldNumber = 17,
    kBroadcastChannelIdFieldNumber = 1,
    kViewersFieldNumber = 5,
    kViewsFieldNumber = 6,
    kFollowersFieldNumber = 8,
    kBroadcasterSteamidFieldNumber = 11,
    kSubscribersFieldNumber = 12,
    kAppidFieldNumber = 4,
    kIsFeaturedFieldNumber = 14,
    kIsDisabledFieldNumber = 15,
    kIsLiveFieldNumber = 16,
    kIsPartneredFieldNumber = 19,
    kReportsFieldNumber = 18,
  };
  // optional string unique_name = 2 [(.description) = "Unique broadcast channel name for URL"];
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // optional string name = 3 [(.description) = "Long broadcast channel name"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string thumbnail_url = 7 [(.description) = "Current thumbnail URL"];
  bool has_thumbnail_url() const;
  private:
  bool _internal_has_thumbnail_url() const;
  public:
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // optional string headline = 9 [(.description) = "short channel description"];
  bool has_headline() const;
  private:
  bool _internal_has_headline() const;
  public:
  void clear_headline();
  const std::string& headline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_headline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_headline();
  PROTOBUF_NODISCARD std::string* release_headline();
  void set_allocated_headline(std::string* headline);
  private:
  const std::string& _internal_headline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_headline(const std::string& value);
  std::string* _internal_mutable_headline();
  public:

  // optional string avatar_url = 10 [(.description) = "community avatar url"];
  bool has_avatar_url() const;
  private:
  bool _internal_has_avatar_url() const;
  public:
  void clear_avatar_url();
  const std::string& avatar_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_url();
  PROTOBUF_NODISCARD std::string* release_avatar_url();
  void set_allocated_avatar_url(std::string* avatar_url);
  private:
  const std::string& _internal_avatar_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_url(const std::string& value);
  std::string* _internal_mutable_avatar_url();
  public:

  // optional string background_url = 13 [(.description) = "Background image url"];
  bool has_background_url() const;
  private:
  bool _internal_has_background_url() const;
  public:
  void clear_background_url();
  const std::string& background_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_background_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_background_url();
  PROTOBUF_NODISCARD std::string* release_background_url();
  void set_allocated_background_url(std::string* background_url);
  private:
  const std::string& _internal_background_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_background_url(const std::string& value);
  std::string* _internal_mutable_background_url();
  public:

  // optional string language = 17 [(.description) = "The language the stream is in"];
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional uint64 viewers = 5 [(.description) = "Number of viewers currently watching"];
  bool has_viewers() const;
  private:
  bool _internal_has_viewers() const;
  public:
  void clear_viewers();
  uint64_t viewers() const;
  void set_viewers(uint64_t value);
  private:
  uint64_t _internal_viewers() const;
  void _internal_set_viewers(uint64_t value);
  public:

  // optional uint64 views = 6 [(.description) = "Number of total views of this channel"];
  bool has_views() const;
  private:
  bool _internal_has_views() const;
  public:
  void clear_views();
  uint64_t views() const;
  void set_views(uint64_t value);
  private:
  uint64_t _internal_views() const;
  void _internal_set_views(uint64_t value);
  public:

  // optional uint64 followers = 8 [(.description) = "Number of followers of this channel"];
  bool has_followers() const;
  private:
  bool _internal_has_followers() const;
  public:
  void clear_followers();
  uint64_t followers() const;
  void set_followers(uint64_t value);
  private:
  uint64_t _internal_followers() const;
  void _internal_set_followers(uint64_t value);
  public:

  // optional fixed64 broadcaster_steamid = 11 [(.description) = "Current broadcaster streaming"];
  bool has_broadcaster_steamid() const;
  private:
  bool _internal_has_broadcaster_steamid() const;
  public:
  void clear_broadcaster_steamid();
  uint64_t broadcaster_steamid() const;
  void set_broadcaster_steamid(uint64_t value);
  private:
  uint64_t _internal_broadcaster_steamid() const;
  void _internal_set_broadcaster_steamid(uint64_t value);
  public:

  // optional uint64 subscribers = 12 [(.description) = "Number of subscribers of this channel"];
  bool has_subscribers() const;
  private:
  bool _internal_has_subscribers() const;
  public:
  void clear_subscribers();
  uint64_t subscribers() const;
  void set_subscribers(uint64_t value);
  private:
  uint64_t _internal_subscribers() const;
  void _internal_set_subscribers(uint64_t value);
  public:

  // optional uint32 appid = 4 [(.description) = "The game ID the requested broadcaster is playing"];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional bool is_featured = 14 [(.description) = "Whether the channel is featured"];
  bool has_is_featured() const;
  private:
  bool _internal_has_is_featured() const;
  public:
  void clear_is_featured();
  bool is_featured() const;
  void set_is_featured(bool value);
  private:
  bool _internal_is_featured() const;
  void _internal_set_is_featured(bool value);
  public:

  // optional bool is_disabled = 15 [(.description) = "Whether the channel is disabled"];
  bool has_is_disabled() const;
  private:
  bool _internal_has_is_disabled() const;
  public:
  void clear_is_disabled();
  bool is_disabled() const;
  void set_is_disabled(bool value);
  private:
  bool _internal_is_disabled() const;
  void _internal_set_is_disabled(bool value);
  public:

  // optional bool is_live = 16 [(.description) = "Whether the channel is streaming"];
  bool has_is_live() const;
  private:
  bool _internal_has_is_live() const;
  public:
  void clear_is_live();
  bool is_live() const;
  void set_is_live(bool value);
  private:
  bool _internal_is_live() const;
  void _internal_set_is_live(bool value);
  public:

  // optional bool is_partnered = 19;
  bool has_is_partnered() const;
  private:
  bool _internal_has_is_partnered() const;
  public:
  void clear_is_partnered();
  bool is_partnered() const;
  void set_is_partnered(bool value);
  private:
  bool _internal_is_partnered() const;
  void _internal_set_is_partnered(bool value);
  public:

  // optional uint32 reports = 18 [(.description) = "The number of reports the channel has"];
  bool has_reports() const;
  private:
  bool _internal_has_reports() const;
  public:
  void clear_reports();
  uint32_t reports() const;
  void set_reports(uint32_t value);
  private:
  uint32_t _internal_reports() const;
  void _internal_set_reports(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GetBroadcastChannelEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr headline_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr background_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  uint64_t broadcast_channel_id_;
  uint64_t viewers_;
  uint64_t views_;
  uint64_t followers_;
  uint64_t broadcaster_steamid_;
  uint64_t subscribers_;
  uint32_t appid_;
  bool is_featured_;
  bool is_disabled_;
  bool is_live_;
  bool is_partnered_;
  uint32_t reports_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetFollowedChannels_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetFollowedChannels_Response) */ {
 public:
  inline CSteamTV_GetFollowedChannels_Response() : CSteamTV_GetFollowedChannels_Response(nullptr) {}
  ~CSteamTV_GetFollowedChannels_Response() override;
  explicit constexpr CSteamTV_GetFollowedChannels_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetFollowedChannels_Response(const CSteamTV_GetFollowedChannels_Response& from);
  CSteamTV_GetFollowedChannels_Response(CSteamTV_GetFollowedChannels_Response&& from) noexcept
    : CSteamTV_GetFollowedChannels_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetFollowedChannels_Response& operator=(const CSteamTV_GetFollowedChannels_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetFollowedChannels_Response& operator=(CSteamTV_GetFollowedChannels_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetFollowedChannels_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetFollowedChannels_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetFollowedChannels_Response*>(
               &_CSteamTV_GetFollowedChannels_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CSteamTV_GetFollowedChannels_Response& a, CSteamTV_GetFollowedChannels_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetFollowedChannels_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetFollowedChannels_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetFollowedChannels_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetFollowedChannels_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetFollowedChannels_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetFollowedChannels_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetFollowedChannels_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetFollowedChannels_Response";
  }
  protected:
  explicit CSteamTV_GetFollowedChannels_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::GetBroadcastChannelEntry* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_results();
  private:
  const ::GetBroadcastChannelEntry& _internal_results(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_results();
  public:
  const ::GetBroadcastChannelEntry& results(int index) const;
  ::GetBroadcastChannelEntry* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetFollowedChannels_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetSubscribedChannels_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_GetSubscribedChannels_Request) */ {
 public:
  inline CSteamTV_GetSubscribedChannels_Request() : CSteamTV_GetSubscribedChannels_Request(nullptr) {}
  explicit constexpr CSteamTV_GetSubscribedChannels_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetSubscribedChannels_Request(const CSteamTV_GetSubscribedChannels_Request& from);
  CSteamTV_GetSubscribedChannels_Request(CSteamTV_GetSubscribedChannels_Request&& from) noexcept
    : CSteamTV_GetSubscribedChannels_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetSubscribedChannels_Request& operator=(const CSteamTV_GetSubscribedChannels_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetSubscribedChannels_Request& operator=(CSteamTV_GetSubscribedChannels_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetSubscribedChannels_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetSubscribedChannels_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetSubscribedChannels_Request*>(
               &_CSteamTV_GetSubscribedChannels_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CSteamTV_GetSubscribedChannels_Request& a, CSteamTV_GetSubscribedChannels_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetSubscribedChannels_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetSubscribedChannels_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetSubscribedChannels_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetSubscribedChannels_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_GetSubscribedChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_GetSubscribedChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetSubscribedChannels_Request";
  }
  protected:
  explicit CSteamTV_GetSubscribedChannels_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_GetSubscribedChannels_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetSubscribedChannels_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetSubscribedChannels_Response) */ {
 public:
  inline CSteamTV_GetSubscribedChannels_Response() : CSteamTV_GetSubscribedChannels_Response(nullptr) {}
  ~CSteamTV_GetSubscribedChannels_Response() override;
  explicit constexpr CSteamTV_GetSubscribedChannels_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetSubscribedChannels_Response(const CSteamTV_GetSubscribedChannels_Response& from);
  CSteamTV_GetSubscribedChannels_Response(CSteamTV_GetSubscribedChannels_Response&& from) noexcept
    : CSteamTV_GetSubscribedChannels_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetSubscribedChannels_Response& operator=(const CSteamTV_GetSubscribedChannels_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetSubscribedChannels_Response& operator=(CSteamTV_GetSubscribedChannels_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetSubscribedChannels_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetSubscribedChannels_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetSubscribedChannels_Response*>(
               &_CSteamTV_GetSubscribedChannels_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CSteamTV_GetSubscribedChannels_Response& a, CSteamTV_GetSubscribedChannels_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetSubscribedChannels_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetSubscribedChannels_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetSubscribedChannels_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetSubscribedChannels_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetSubscribedChannels_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetSubscribedChannels_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetSubscribedChannels_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetSubscribedChannels_Response";
  }
  protected:
  explicit CSteamTV_GetSubscribedChannels_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::GetBroadcastChannelEntry* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_results();
  private:
  const ::GetBroadcastChannelEntry& _internal_results(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_results();
  public:
  const ::GetBroadcastChannelEntry& results(int index) const;
  ::GetBroadcastChannelEntry* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetSubscribedChannels_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelStatus_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelStatus_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelStatus_Request() : CSteamTV_GetBroadcastChannelStatus_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelStatus_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelStatus_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelStatus_Request(const CSteamTV_GetBroadcastChannelStatus_Request& from);
  CSteamTV_GetBroadcastChannelStatus_Request(CSteamTV_GetBroadcastChannelStatus_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelStatus_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelStatus_Request& operator=(const CSteamTV_GetBroadcastChannelStatus_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelStatus_Request& operator=(CSteamTV_GetBroadcastChannelStatus_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelStatus_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelStatus_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelStatus_Request*>(
               &_CSteamTV_GetBroadcastChannelStatus_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CSteamTV_GetBroadcastChannelStatus_Request& a, CSteamTV_GetBroadcastChannelStatus_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelStatus_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelStatus_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelStatus_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelStatus_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelStatus_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelStatus_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelStatus_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelStatus_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelStatus_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelStatus_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelStatus_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelStatus_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelStatus_Response() : CSteamTV_GetBroadcastChannelStatus_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelStatus_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelStatus_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelStatus_Response(const CSteamTV_GetBroadcastChannelStatus_Response& from);
  CSteamTV_GetBroadcastChannelStatus_Response(CSteamTV_GetBroadcastChannelStatus_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelStatus_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelStatus_Response& operator=(const CSteamTV_GetBroadcastChannelStatus_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelStatus_Response& operator=(CSteamTV_GetBroadcastChannelStatus_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelStatus_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelStatus_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelStatus_Response*>(
               &_CSteamTV_GetBroadcastChannelStatus_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CSteamTV_GetBroadcastChannelStatus_Response& a, CSteamTV_GetBroadcastChannelStatus_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelStatus_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelStatus_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelStatus_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelStatus_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelStatus_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelStatus_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelStatus_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelStatus_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelStatus_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kThumbnailUrlFieldNumber = 7,
    kUniqueNameFieldNumber = 10,
    kIsLiveFieldNumber = 1,
    kIsDisabledFieldNumber = 2,
    kAppidFieldNumber = 3,
    kViewersFieldNumber = 4,
    kViewsFieldNumber = 5,
    kBroadcasterSteamidFieldNumber = 6,
    kFollowersFieldNumber = 8,
    kSubscribersFieldNumber = 9,
    kBroadcastSessionIdFieldNumber = 11,
  };
  // optional string thumbnail_url = 7 [(.description) = "Current thumbnail URL"];
  bool has_thumbnail_url() const;
  private:
  bool _internal_has_thumbnail_url() const;
  public:
  void clear_thumbnail_url();
  const std::string& thumbnail_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_url();
  PROTOBUF_NODISCARD std::string* release_thumbnail_url();
  void set_allocated_thumbnail_url(std::string* thumbnail_url);
  private:
  const std::string& _internal_thumbnail_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_url(const std::string& value);
  std::string* _internal_mutable_thumbnail_url();
  public:

  // optional string unique_name = 10;
  bool has_unique_name() const;
  private:
  bool _internal_has_unique_name() const;
  public:
  void clear_unique_name();
  const std::string& unique_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_unique_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_unique_name();
  PROTOBUF_NODISCARD std::string* release_unique_name();
  void set_allocated_unique_name(std::string* unique_name);
  private:
  const std::string& _internal_unique_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_unique_name(const std::string& value);
  std::string* _internal_mutable_unique_name();
  public:

  // optional bool is_live = 1 [(.description) = "Indicates whether the channel is streaming"];
  bool has_is_live() const;
  private:
  bool _internal_has_is_live() const;
  public:
  void clear_is_live();
  bool is_live() const;
  void set_is_live(bool value);
  private:
  bool _internal_is_live() const;
  void _internal_set_is_live(bool value);
  public:

  // optional bool is_disabled = 2 [(.description) = "Indicates whether the channel has been disabled"];
  bool has_is_disabled() const;
  private:
  bool _internal_has_is_disabled() const;
  public:
  void clear_is_disabled();
  bool is_disabled() const;
  void set_is_disabled(bool value);
  private:
  bool _internal_is_disabled() const;
  void _internal_set_is_disabled(bool value);
  public:

  // optional uint32 appid = 3 [(.description) = "The game ID the requested broadcaster is playing"];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint64 viewers = 4 [(.description) = "Number of viewers currently watching"];
  bool has_viewers() const;
  private:
  bool _internal_has_viewers() const;
  public:
  void clear_viewers();
  uint64_t viewers() const;
  void set_viewers(uint64_t value);
  private:
  uint64_t _internal_viewers() const;
  void _internal_set_viewers(uint64_t value);
  public:

  // optional uint64 views = 5 [(.description) = "Number of total views of this channel"];
  bool has_views() const;
  private:
  bool _internal_has_views() const;
  public:
  void clear_views();
  uint64_t views() const;
  void set_views(uint64_t value);
  private:
  uint64_t _internal_views() const;
  void _internal_set_views(uint64_t value);
  public:

  // optional fixed64 broadcaster_steamid = 6 [(.description) = "Current broadcaster streaming"];
  bool has_broadcaster_steamid() const;
  private:
  bool _internal_has_broadcaster_steamid() const;
  public:
  void clear_broadcaster_steamid();
  uint64_t broadcaster_steamid() const;
  void set_broadcaster_steamid(uint64_t value);
  private:
  uint64_t _internal_broadcaster_steamid() const;
  void _internal_set_broadcaster_steamid(uint64_t value);
  public:

  // optional uint64 followers = 8 [(.description) = "Number of followers of this channel"];
  bool has_followers() const;
  private:
  bool _internal_has_followers() const;
  public:
  void clear_followers();
  uint64_t followers() const;
  void set_followers(uint64_t value);
  private:
  uint64_t _internal_followers() const;
  void _internal_set_followers(uint64_t value);
  public:

  // optional uint64 subscribers = 9 [(.description) = "Number of subscribers of this channel"];
  bool has_subscribers() const;
  private:
  bool _internal_has_subscribers() const;
  public:
  void clear_subscribers();
  uint64_t subscribers() const;
  void set_subscribers(uint64_t value);
  private:
  uint64_t _internal_subscribers() const;
  void _internal_set_subscribers(uint64_t value);
  public:

  // optional uint64 broadcast_session_id = 11;
  bool has_broadcast_session_id() const;
  private:
  bool _internal_has_broadcast_session_id() const;
  public:
  void clear_broadcast_session_id();
  uint64_t broadcast_session_id() const;
  void set_broadcast_session_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_session_id() const;
  void _internal_set_broadcast_session_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelStatus_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr unique_name_;
  bool is_live_;
  bool is_disabled_;
  uint32_t appid_;
  uint64_t viewers_;
  uint64_t views_;
  uint64_t broadcaster_steamid_;
  uint64_t followers_;
  uint64_t subscribers_;
  uint64_t broadcast_session_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_FollowBroadcastChannel_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_FollowBroadcastChannel_Request) */ {
 public:
  inline CSteamTV_FollowBroadcastChannel_Request() : CSteamTV_FollowBroadcastChannel_Request(nullptr) {}
  ~CSteamTV_FollowBroadcastChannel_Request() override;
  explicit constexpr CSteamTV_FollowBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_FollowBroadcastChannel_Request(const CSteamTV_FollowBroadcastChannel_Request& from);
  CSteamTV_FollowBroadcastChannel_Request(CSteamTV_FollowBroadcastChannel_Request&& from) noexcept
    : CSteamTV_FollowBroadcastChannel_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_FollowBroadcastChannel_Request& operator=(const CSteamTV_FollowBroadcastChannel_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_FollowBroadcastChannel_Request& operator=(CSteamTV_FollowBroadcastChannel_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_FollowBroadcastChannel_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_FollowBroadcastChannel_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_FollowBroadcastChannel_Request*>(
               &_CSteamTV_FollowBroadcastChannel_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CSteamTV_FollowBroadcastChannel_Request& a, CSteamTV_FollowBroadcastChannel_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_FollowBroadcastChannel_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_FollowBroadcastChannel_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_FollowBroadcastChannel_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_FollowBroadcastChannel_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_FollowBroadcastChannel_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_FollowBroadcastChannel_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_FollowBroadcastChannel_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_FollowBroadcastChannel_Request";
  }
  protected:
  explicit CSteamTV_FollowBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
    kUndoFieldNumber = 2,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional bool undo = 2 [(.description) = "Indicates this is an unfollow request"];
  bool has_undo() const;
  private:
  bool _internal_has_undo() const;
  public:
  void clear_undo();
  bool undo() const;
  void set_undo(bool value);
  private:
  bool _internal_undo() const;
  void _internal_set_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_FollowBroadcastChannel_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  bool undo_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_FollowBroadcastChannel_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_FollowBroadcastChannel_Response) */ {
 public:
  inline CSteamTV_FollowBroadcastChannel_Response() : CSteamTV_FollowBroadcastChannel_Response(nullptr) {}
  ~CSteamTV_FollowBroadcastChannel_Response() override;
  explicit constexpr CSteamTV_FollowBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_FollowBroadcastChannel_Response(const CSteamTV_FollowBroadcastChannel_Response& from);
  CSteamTV_FollowBroadcastChannel_Response(CSteamTV_FollowBroadcastChannel_Response&& from) noexcept
    : CSteamTV_FollowBroadcastChannel_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_FollowBroadcastChannel_Response& operator=(const CSteamTV_FollowBroadcastChannel_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_FollowBroadcastChannel_Response& operator=(CSteamTV_FollowBroadcastChannel_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_FollowBroadcastChannel_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_FollowBroadcastChannel_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_FollowBroadcastChannel_Response*>(
               &_CSteamTV_FollowBroadcastChannel_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CSteamTV_FollowBroadcastChannel_Response& a, CSteamTV_FollowBroadcastChannel_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_FollowBroadcastChannel_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_FollowBroadcastChannel_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_FollowBroadcastChannel_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_FollowBroadcastChannel_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_FollowBroadcastChannel_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_FollowBroadcastChannel_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_FollowBroadcastChannel_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_FollowBroadcastChannel_Response";
  }
  protected:
  explicit CSteamTV_FollowBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFollowedFieldNumber = 1,
  };
  // optional bool is_followed = 1 [(.description) = "Whether the user is now following"];
  bool has_is_followed() const;
  private:
  bool _internal_has_is_followed() const;
  public:
  void clear_is_followed();
  bool is_followed() const;
  void set_is_followed(bool value);
  private:
  bool _internal_is_followed() const;
  void _internal_set_is_followed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_FollowBroadcastChannel_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_followed_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SubscribeBroadcastChannel_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SubscribeBroadcastChannel_Request) */ {
 public:
  inline CSteamTV_SubscribeBroadcastChannel_Request() : CSteamTV_SubscribeBroadcastChannel_Request(nullptr) {}
  ~CSteamTV_SubscribeBroadcastChannel_Request() override;
  explicit constexpr CSteamTV_SubscribeBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SubscribeBroadcastChannel_Request(const CSteamTV_SubscribeBroadcastChannel_Request& from);
  CSteamTV_SubscribeBroadcastChannel_Request(CSteamTV_SubscribeBroadcastChannel_Request&& from) noexcept
    : CSteamTV_SubscribeBroadcastChannel_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SubscribeBroadcastChannel_Request& operator=(const CSteamTV_SubscribeBroadcastChannel_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SubscribeBroadcastChannel_Request& operator=(CSteamTV_SubscribeBroadcastChannel_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SubscribeBroadcastChannel_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SubscribeBroadcastChannel_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SubscribeBroadcastChannel_Request*>(
               &_CSteamTV_SubscribeBroadcastChannel_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CSteamTV_SubscribeBroadcastChannel_Request& a, CSteamTV_SubscribeBroadcastChannel_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SubscribeBroadcastChannel_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SubscribeBroadcastChannel_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SubscribeBroadcastChannel_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SubscribeBroadcastChannel_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SubscribeBroadcastChannel_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SubscribeBroadcastChannel_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SubscribeBroadcastChannel_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SubscribeBroadcastChannel_Request";
  }
  protected:
  explicit CSteamTV_SubscribeBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SubscribeBroadcastChannel_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SubscribeBroadcastChannel_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SubscribeBroadcastChannel_Response) */ {
 public:
  inline CSteamTV_SubscribeBroadcastChannel_Response() : CSteamTV_SubscribeBroadcastChannel_Response(nullptr) {}
  ~CSteamTV_SubscribeBroadcastChannel_Response() override;
  explicit constexpr CSteamTV_SubscribeBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SubscribeBroadcastChannel_Response(const CSteamTV_SubscribeBroadcastChannel_Response& from);
  CSteamTV_SubscribeBroadcastChannel_Response(CSteamTV_SubscribeBroadcastChannel_Response&& from) noexcept
    : CSteamTV_SubscribeBroadcastChannel_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SubscribeBroadcastChannel_Response& operator=(const CSteamTV_SubscribeBroadcastChannel_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SubscribeBroadcastChannel_Response& operator=(CSteamTV_SubscribeBroadcastChannel_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SubscribeBroadcastChannel_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SubscribeBroadcastChannel_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SubscribeBroadcastChannel_Response*>(
               &_CSteamTV_SubscribeBroadcastChannel_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CSteamTV_SubscribeBroadcastChannel_Response& a, CSteamTV_SubscribeBroadcastChannel_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SubscribeBroadcastChannel_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SubscribeBroadcastChannel_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SubscribeBroadcastChannel_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SubscribeBroadcastChannel_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SubscribeBroadcastChannel_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SubscribeBroadcastChannel_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SubscribeBroadcastChannel_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SubscribeBroadcastChannel_Response";
  }
  protected:
  explicit CSteamTV_SubscribeBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSubscribedFieldNumber = 1,
  };
  // optional bool is_subscribed = 1 [(.description) = "Whether the user is now subscribed"];
  bool has_is_subscribed() const;
  private:
  bool _internal_has_is_subscribed() const;
  public:
  void clear_is_subscribed();
  bool is_subscribed() const;
  void set_is_subscribed(bool value);
  private:
  bool _internal_is_subscribed() const;
  void _internal_set_is_subscribed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SubscribeBroadcastChannel_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_subscribed_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelClips_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelClips_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelClips_Request() : CSteamTV_GetBroadcastChannelClips_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelClips_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelClips_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelClips_Request(const CSteamTV_GetBroadcastChannelClips_Request& from);
  CSteamTV_GetBroadcastChannelClips_Request(CSteamTV_GetBroadcastChannelClips_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelClips_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelClips_Request& operator=(const CSteamTV_GetBroadcastChannelClips_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelClips_Request& operator=(CSteamTV_GetBroadcastChannelClips_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelClips_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelClips_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelClips_Request*>(
               &_CSteamTV_GetBroadcastChannelClips_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CSteamTV_GetBroadcastChannelClips_Request& a, CSteamTV_GetBroadcastChannelClips_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelClips_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelClips_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelClips_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelClips_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelClips_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelClips_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelClips_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelClips_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelClips_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelClips_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_BroadcastClipInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_BroadcastClipInfo) */ {
 public:
  inline CSteamTV_BroadcastClipInfo() : CSteamTV_BroadcastClipInfo(nullptr) {}
  ~CSteamTV_BroadcastClipInfo() override;
  explicit constexpr CSteamTV_BroadcastClipInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_BroadcastClipInfo(const CSteamTV_BroadcastClipInfo& from);
  CSteamTV_BroadcastClipInfo(CSteamTV_BroadcastClipInfo&& from) noexcept
    : CSteamTV_BroadcastClipInfo() {
    *this = ::std::move(from);
  }

  inline CSteamTV_BroadcastClipInfo& operator=(const CSteamTV_BroadcastClipInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_BroadcastClipInfo& operator=(CSteamTV_BroadcastClipInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_BroadcastClipInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_BroadcastClipInfo* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_BroadcastClipInfo*>(
               &_CSteamTV_BroadcastClipInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CSteamTV_BroadcastClipInfo& a, CSteamTV_BroadcastClipInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_BroadcastClipInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_BroadcastClipInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_BroadcastClipInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_BroadcastClipInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_BroadcastClipInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_BroadcastClipInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_BroadcastClipInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_BroadcastClipInfo";
  }
  protected:
  explicit CSteamTV_BroadcastClipInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVideoDescriptionFieldNumber = 6,
    kThumbnailPathFieldNumber = 9,
    kBroadcastClipIdFieldNumber = 1,
    kChannelIdFieldNumber = 2,
    kBroadcasterSteamidFieldNumber = 4,
    kCreatorSteamidFieldNumber = 5,
    kAppIdFieldNumber = 3,
    kLiveTimeFieldNumber = 7,
    kLengthMsFieldNumber = 8,
  };
  // optional string video_description = 6 [(.description) = "Short name or description of this clip"];
  bool has_video_description() const;
  private:
  bool _internal_has_video_description() const;
  public:
  void clear_video_description();
  const std::string& video_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_video_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_video_description();
  PROTOBUF_NODISCARD std::string* release_video_description();
  void set_allocated_video_description(std::string* video_description);
  private:
  const std::string& _internal_video_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_video_description(const std::string& value);
  std::string* _internal_mutable_video_description();
  public:

  // optional string thumbnail_path = 9 [(.description) = "relative path for thumbnail URL on host"];
  bool has_thumbnail_path() const;
  private:
  bool _internal_has_thumbnail_path() const;
  public:
  void clear_thumbnail_path();
  const std::string& thumbnail_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_path();
  PROTOBUF_NODISCARD std::string* release_thumbnail_path();
  void set_allocated_thumbnail_path(std::string* thumbnail_path);
  private:
  const std::string& _internal_thumbnail_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_path(const std::string& value);
  std::string* _internal_mutable_thumbnail_path();
  public:

  // optional uint64 broadcast_clip_id = 1 [(.description) = "broadcast clip ID"];
  bool has_broadcast_clip_id() const;
  private:
  bool _internal_has_broadcast_clip_id() const;
  public:
  void clear_broadcast_clip_id();
  uint64_t broadcast_clip_id() const;
  void set_broadcast_clip_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_clip_id() const;
  void _internal_set_broadcast_clip_id(uint64_t value);
  public:

  // optional uint64 channel_id = 2 [(.description) = "Broadcast Channel ID"];
  bool has_channel_id() const;
  private:
  bool _internal_has_channel_id() const;
  public:
  void clear_channel_id();
  uint64_t channel_id() const;
  void set_channel_id(uint64_t value);
  private:
  uint64_t _internal_channel_id() const;
  void _internal_set_channel_id(uint64_t value);
  public:

  // optional fixed64 broadcaster_steamid = 4 [(.description) = "Broadcaster SteamID"];
  bool has_broadcaster_steamid() const;
  private:
  bool _internal_has_broadcaster_steamid() const;
  public:
  void clear_broadcaster_steamid();
  uint64_t broadcaster_steamid() const;
  void set_broadcaster_steamid(uint64_t value);
  private:
  uint64_t _internal_broadcaster_steamid() const;
  void _internal_set_broadcaster_steamid(uint64_t value);
  public:

  // optional fixed64 creator_steamid = 5 [(.description) = "Clip-maker SteamID"];
  bool has_creator_steamid() const;
  private:
  bool _internal_has_creator_steamid() const;
  public:
  void clear_creator_steamid();
  uint64_t creator_steamid() const;
  void set_creator_steamid(uint64_t value);
  private:
  uint64_t _internal_creator_steamid() const;
  void _internal_set_creator_steamid(uint64_t value);
  public:

  // optional uint32 app_id = 3 [(.description) = "App ID stream is tagged with"];
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 live_time = 7 [(.description) = "GMT time clip was broadcasted live"];
  bool has_live_time() const;
  private:
  bool _internal_has_live_time() const;
  public:
  void clear_live_time();
  uint32_t live_time() const;
  void set_live_time(uint32_t value);
  private:
  uint32_t _internal_live_time() const;
  void _internal_set_live_time(uint32_t value);
  public:

  // optional uint32 length_ms = 8 [(.description) = "length of video in MS"];
  bool has_length_ms() const;
  private:
  bool _internal_has_length_ms() const;
  public:
  void clear_length_ms();
  uint32_t length_ms() const;
  void set_length_ms(uint32_t value);
  private:
  uint32_t _internal_length_ms() const;
  void _internal_set_length_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_BroadcastClipInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr video_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_path_;
  uint64_t broadcast_clip_id_;
  uint64_t channel_id_;
  uint64_t broadcaster_steamid_;
  uint64_t creator_steamid_;
  uint32_t app_id_;
  uint32_t live_time_;
  uint32_t length_ms_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelClips_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelClips_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelClips_Response() : CSteamTV_GetBroadcastChannelClips_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelClips_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelClips_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelClips_Response(const CSteamTV_GetBroadcastChannelClips_Response& from);
  CSteamTV_GetBroadcastChannelClips_Response(CSteamTV_GetBroadcastChannelClips_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelClips_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelClips_Response& operator=(const CSteamTV_GetBroadcastChannelClips_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelClips_Response& operator=(CSteamTV_GetBroadcastChannelClips_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelClips_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelClips_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelClips_Response*>(
               &_CSteamTV_GetBroadcastChannelClips_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CSteamTV_GetBroadcastChannelClips_Response& a, CSteamTV_GetBroadcastChannelClips_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelClips_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelClips_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelClips_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelClips_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelClips_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelClips_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelClips_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelClips_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelClips_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClipsFieldNumber = 1,
    kThumbnailHostFieldNumber = 2,
  };
  // repeated .CSteamTV_BroadcastClipInfo clips = 1;
  int clips_size() const;
  private:
  int _internal_clips_size() const;
  public:
  void clear_clips();
  ::CSteamTV_BroadcastClipInfo* mutable_clips(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_BroadcastClipInfo >*
      mutable_clips();
  private:
  const ::CSteamTV_BroadcastClipInfo& _internal_clips(int index) const;
  ::CSteamTV_BroadcastClipInfo* _internal_add_clips();
  public:
  const ::CSteamTV_BroadcastClipInfo& clips(int index) const;
  ::CSteamTV_BroadcastClipInfo* add_clips();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_BroadcastClipInfo >&
      clips() const;

  // optional string thumbnail_host = 2;
  bool has_thumbnail_host() const;
  private:
  bool _internal_has_thumbnail_host() const;
  public:
  void clear_thumbnail_host();
  const std::string& thumbnail_host() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_thumbnail_host(ArgT0&& arg0, ArgT... args);
  std::string* mutable_thumbnail_host();
  PROTOBUF_NODISCARD std::string* release_thumbnail_host();
  void set_allocated_thumbnail_host(std::string* thumbnail_host);
  private:
  const std::string& _internal_thumbnail_host() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_thumbnail_host(const std::string& value);
  std::string* _internal_mutable_thumbnail_host();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelClips_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_BroadcastClipInfo > clips_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr thumbnail_host_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_ReportBroadcastChannel_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_ReportBroadcastChannel_Request) */ {
 public:
  inline CSteamTV_ReportBroadcastChannel_Request() : CSteamTV_ReportBroadcastChannel_Request(nullptr) {}
  ~CSteamTV_ReportBroadcastChannel_Request() override;
  explicit constexpr CSteamTV_ReportBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_ReportBroadcastChannel_Request(const CSteamTV_ReportBroadcastChannel_Request& from);
  CSteamTV_ReportBroadcastChannel_Request(CSteamTV_ReportBroadcastChannel_Request&& from) noexcept
    : CSteamTV_ReportBroadcastChannel_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_ReportBroadcastChannel_Request& operator=(const CSteamTV_ReportBroadcastChannel_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_ReportBroadcastChannel_Request& operator=(CSteamTV_ReportBroadcastChannel_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_ReportBroadcastChannel_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_ReportBroadcastChannel_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_ReportBroadcastChannel_Request*>(
               &_CSteamTV_ReportBroadcastChannel_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CSteamTV_ReportBroadcastChannel_Request& a, CSteamTV_ReportBroadcastChannel_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_ReportBroadcastChannel_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_ReportBroadcastChannel_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_ReportBroadcastChannel_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_ReportBroadcastChannel_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_ReportBroadcastChannel_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_ReportBroadcastChannel_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_ReportBroadcastChannel_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_ReportBroadcastChannel_Request";
  }
  protected:
  explicit CSteamTV_ReportBroadcastChannel_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReasonFieldNumber = 2,
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional string reason = 2 [(.description) = "The reason for the report"];
  bool has_reason() const;
  private:
  bool _internal_has_reason() const;
  public:
  void clear_reason();
  const std::string& reason() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reason(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reason();
  PROTOBUF_NODISCARD std::string* release_reason();
  void set_allocated_reason(std::string* reason);
  private:
  const std::string& _internal_reason() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reason(const std::string& value);
  std::string* _internal_mutable_reason();
  public:

  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_ReportBroadcastChannel_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reason_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_ReportBroadcastChannel_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_ReportBroadcastChannel_Response) */ {
 public:
  inline CSteamTV_ReportBroadcastChannel_Response() : CSteamTV_ReportBroadcastChannel_Response(nullptr) {}
  explicit constexpr CSteamTV_ReportBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_ReportBroadcastChannel_Response(const CSteamTV_ReportBroadcastChannel_Response& from);
  CSteamTV_ReportBroadcastChannel_Response(CSteamTV_ReportBroadcastChannel_Response&& from) noexcept
    : CSteamTV_ReportBroadcastChannel_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_ReportBroadcastChannel_Response& operator=(const CSteamTV_ReportBroadcastChannel_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_ReportBroadcastChannel_Response& operator=(CSteamTV_ReportBroadcastChannel_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_ReportBroadcastChannel_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_ReportBroadcastChannel_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_ReportBroadcastChannel_Response*>(
               &_CSteamTV_ReportBroadcastChannel_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CSteamTV_ReportBroadcastChannel_Response& a, CSteamTV_ReportBroadcastChannel_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_ReportBroadcastChannel_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_ReportBroadcastChannel_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_ReportBroadcastChannel_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_ReportBroadcastChannel_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_ReportBroadcastChannel_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_ReportBroadcastChannel_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_ReportBroadcastChannel_Response";
  }
  protected:
  explicit CSteamTV_ReportBroadcastChannel_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_ReportBroadcastChannel_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelInteraction_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelInteraction_Request) */ {
 public:
  inline CSteamTV_GetBroadcastChannelInteraction_Request() : CSteamTV_GetBroadcastChannelInteraction_Request(nullptr) {}
  ~CSteamTV_GetBroadcastChannelInteraction_Request() override;
  explicit constexpr CSteamTV_GetBroadcastChannelInteraction_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelInteraction_Request(const CSteamTV_GetBroadcastChannelInteraction_Request& from);
  CSteamTV_GetBroadcastChannelInteraction_Request(CSteamTV_GetBroadcastChannelInteraction_Request&& from) noexcept
    : CSteamTV_GetBroadcastChannelInteraction_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelInteraction_Request& operator=(const CSteamTV_GetBroadcastChannelInteraction_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelInteraction_Request& operator=(CSteamTV_GetBroadcastChannelInteraction_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelInteraction_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelInteraction_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelInteraction_Request*>(
               &_CSteamTV_GetBroadcastChannelInteraction_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CSteamTV_GetBroadcastChannelInteraction_Request& a, CSteamTV_GetBroadcastChannelInteraction_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelInteraction_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelInteraction_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelInteraction_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelInteraction_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelInteraction_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelInteraction_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelInteraction_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelInteraction_Request";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelInteraction_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelInteraction_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetBroadcastChannelInteraction_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetBroadcastChannelInteraction_Response) */ {
 public:
  inline CSteamTV_GetBroadcastChannelInteraction_Response() : CSteamTV_GetBroadcastChannelInteraction_Response(nullptr) {}
  ~CSteamTV_GetBroadcastChannelInteraction_Response() override;
  explicit constexpr CSteamTV_GetBroadcastChannelInteraction_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetBroadcastChannelInteraction_Response(const CSteamTV_GetBroadcastChannelInteraction_Response& from);
  CSteamTV_GetBroadcastChannelInteraction_Response(CSteamTV_GetBroadcastChannelInteraction_Response&& from) noexcept
    : CSteamTV_GetBroadcastChannelInteraction_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetBroadcastChannelInteraction_Response& operator=(const CSteamTV_GetBroadcastChannelInteraction_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetBroadcastChannelInteraction_Response& operator=(CSteamTV_GetBroadcastChannelInteraction_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetBroadcastChannelInteraction_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetBroadcastChannelInteraction_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetBroadcastChannelInteraction_Response*>(
               &_CSteamTV_GetBroadcastChannelInteraction_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CSteamTV_GetBroadcastChannelInteraction_Response& a, CSteamTV_GetBroadcastChannelInteraction_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetBroadcastChannelInteraction_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetBroadcastChannelInteraction_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetBroadcastChannelInteraction_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetBroadcastChannelInteraction_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetBroadcastChannelInteraction_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetBroadcastChannelInteraction_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetBroadcastChannelInteraction_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetBroadcastChannelInteraction_Response";
  }
  protected:
  explicit CSteamTV_GetBroadcastChannelInteraction_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsFollowedFieldNumber = 1,
    kIsSubscribedFieldNumber = 2,
  };
  // optional bool is_followed = 1 [(.description) = "Whether the user has followed this channel"];
  bool has_is_followed() const;
  private:
  bool _internal_has_is_followed() const;
  public:
  void clear_is_followed();
  bool is_followed() const;
  void set_is_followed(bool value);
  private:
  bool _internal_is_followed() const;
  void _internal_set_is_followed(bool value);
  public:

  // optional bool is_subscribed = 2 [(.description) = "Whether the user has subscribed to this channel"];
  bool has_is_subscribed() const;
  private:
  bool _internal_has_is_subscribed() const;
  public:
  void clear_is_subscribed();
  bool is_subscribed() const;
  void set_is_subscribed(bool value);
  private:
  bool _internal_is_subscribed() const;
  void _internal_set_is_subscribed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetBroadcastChannelInteraction_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_followed_;
  bool is_subscribed_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetGames_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetGames_Request) */ {
 public:
  inline CSteamTV_GetGames_Request() : CSteamTV_GetGames_Request(nullptr) {}
  ~CSteamTV_GetGames_Request() override;
  explicit constexpr CSteamTV_GetGames_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetGames_Request(const CSteamTV_GetGames_Request& from);
  CSteamTV_GetGames_Request(CSteamTV_GetGames_Request&& from) noexcept
    : CSteamTV_GetGames_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetGames_Request& operator=(const CSteamTV_GetGames_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetGames_Request& operator=(CSteamTV_GetGames_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetGames_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetGames_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetGames_Request*>(
               &_CSteamTV_GetGames_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CSteamTV_GetGames_Request& a, CSteamTV_GetGames_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetGames_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetGames_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetGames_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetGames_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetGames_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetGames_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetGames_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetGames_Request";
  }
  protected:
  explicit CSteamTV_GetGames_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kCountFieldNumber = 3,
    kAlgorithmFieldNumber = 2,
  };
  // optional uint32 appid = 1 [(.description) = "The ID for the game"];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 count = 3 [(.description) = "The maximum number of results to return"];
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional .EGetGamesAlgorithm algorithm = 2 [default = k_EGetGamesAlgorithm_Default, (.description) = "The algorithm to use when picking games to return"];
  bool has_algorithm() const;
  private:
  bool _internal_has_algorithm() const;
  public:
  void clear_algorithm();
  ::EGetGamesAlgorithm algorithm() const;
  void set_algorithm(::EGetGamesAlgorithm value);
  private:
  ::EGetGamesAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::EGetGamesAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetGames_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t count_;
  int algorithm_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_Game final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_Game) */ {
 public:
  inline CSteamTV_Game() : CSteamTV_Game(nullptr) {}
  ~CSteamTV_Game() override;
  explicit constexpr CSteamTV_Game(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_Game(const CSteamTV_Game& from);
  CSteamTV_Game(CSteamTV_Game&& from) noexcept
    : CSteamTV_Game() {
    *this = ::std::move(from);
  }

  inline CSteamTV_Game& operator=(const CSteamTV_Game& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_Game& operator=(CSteamTV_Game&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_Game& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_Game* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_Game*>(
               &_CSteamTV_Game_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CSteamTV_Game& a, CSteamTV_Game& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_Game* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_Game* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_Game* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_Game>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_Game& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_Game& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_Game* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_Game";
  }
  protected:
  explicit CSteamTV_Game(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelsFieldNumber = 5,
    kNameFieldNumber = 2,
    kImageFieldNumber = 3,
    kReleaseDateFieldNumber = 6,
    kDeveloperFieldNumber = 7,
    kPublisherFieldNumber = 8,
    kViewersFieldNumber = 4,
    kAppidFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry channels = 5 [(.description) = "Live channels streaming this game"];
  int channels_size() const;
  private:
  int _internal_channels_size() const;
  public:
  void clear_channels();
  ::GetBroadcastChannelEntry* mutable_channels(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_channels();
  private:
  const ::GetBroadcastChannelEntry& _internal_channels(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_channels();
  public:
  const ::GetBroadcastChannelEntry& channels(int index) const;
  ::GetBroadcastChannelEntry* add_channels();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      channels() const;

  // optional string name = 2 [(.description) = "The name for the game"];
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string image = 3 [(.description) = "The image for the game"];
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // optional string release_date = 6;
  bool has_release_date() const;
  private:
  bool _internal_has_release_date() const;
  public:
  void clear_release_date();
  const std::string& release_date() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_release_date(ArgT0&& arg0, ArgT... args);
  std::string* mutable_release_date();
  PROTOBUF_NODISCARD std::string* release_release_date();
  void set_allocated_release_date(std::string* release_date);
  private:
  const std::string& _internal_release_date() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_release_date(const std::string& value);
  std::string* _internal_mutable_release_date();
  public:

  // optional string developer = 7;
  bool has_developer() const;
  private:
  bool _internal_has_developer() const;
  public:
  void clear_developer();
  const std::string& developer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_developer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_developer();
  PROTOBUF_NODISCARD std::string* release_developer();
  void set_allocated_developer(std::string* developer);
  private:
  const std::string& _internal_developer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_developer(const std::string& value);
  std::string* _internal_mutable_developer();
  public:

  // optional string publisher = 8;
  bool has_publisher() const;
  private:
  bool _internal_has_publisher() const;
  public:
  void clear_publisher();
  const std::string& publisher() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_publisher(ArgT0&& arg0, ArgT... args);
  std::string* mutable_publisher();
  PROTOBUF_NODISCARD std::string* release_publisher();
  void set_allocated_publisher(std::string* publisher);
  private:
  const std::string& _internal_publisher() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_publisher(const std::string& value);
  std::string* _internal_mutable_publisher();
  public:

  // optional uint64 viewers = 4 [(.description) = "Number of people watching this game"];
  bool has_viewers() const;
  private:
  bool _internal_has_viewers() const;
  public:
  void clear_viewers();
  uint64_t viewers() const;
  void set_viewers(uint64_t value);
  private:
  uint64_t _internal_viewers() const;
  void _internal_set_viewers(uint64_t value);
  public:

  // optional uint32 appid = 1 [(.description) = "The ID for the game"];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_Game)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > channels_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr release_date_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr developer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr publisher_;
  uint64_t viewers_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetGames_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetGames_Response) */ {
 public:
  inline CSteamTV_GetGames_Response() : CSteamTV_GetGames_Response(nullptr) {}
  ~CSteamTV_GetGames_Response() override;
  explicit constexpr CSteamTV_GetGames_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetGames_Response(const CSteamTV_GetGames_Response& from);
  CSteamTV_GetGames_Response(CSteamTV_GetGames_Response&& from) noexcept
    : CSteamTV_GetGames_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetGames_Response& operator=(const CSteamTV_GetGames_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetGames_Response& operator=(CSteamTV_GetGames_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetGames_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetGames_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetGames_Response*>(
               &_CSteamTV_GetGames_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CSteamTV_GetGames_Response& a, CSteamTV_GetGames_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetGames_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetGames_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetGames_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetGames_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetGames_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetGames_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetGames_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetGames_Response";
  }
  protected:
  explicit CSteamTV_GetGames_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .CSteamTV_Game results = 1 [(.description) = "The list of games"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CSteamTV_Game* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_Game >*
      mutable_results();
  private:
  const ::CSteamTV_Game& _internal_results(int index) const;
  ::CSteamTV_Game* _internal_add_results();
  public:
  const ::CSteamTV_Game& results(int index) const;
  ::CSteamTV_Game* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_Game >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetGames_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_Game > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChannels_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChannels_Request) */ {
 public:
  inline CSteamTV_GetChannels_Request() : CSteamTV_GetChannels_Request(nullptr) {}
  ~CSteamTV_GetChannels_Request() override;
  explicit constexpr CSteamTV_GetChannels_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChannels_Request(const CSteamTV_GetChannels_Request& from);
  CSteamTV_GetChannels_Request(CSteamTV_GetChannels_Request&& from) noexcept
    : CSteamTV_GetChannels_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChannels_Request& operator=(const CSteamTV_GetChannels_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChannels_Request& operator=(CSteamTV_GetChannels_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChannels_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChannels_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChannels_Request*>(
               &_CSteamTV_GetChannels_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CSteamTV_GetChannels_Request& a, CSteamTV_GetChannels_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChannels_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChannels_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChannels_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChannels_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChannels_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChannels_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChannels_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChannels_Request";
  }
  protected:
  explicit CSteamTV_GetChannels_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCountFieldNumber = 2,
    kAppidFieldNumber = 3,
    kAlgorithmFieldNumber = 1,
  };
  // optional uint32 count = 2 [(.description) = "The maximum number of results to return"];
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional uint32 appid = 3 [(.description) = "Filter results to only this appid"];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional .EGetChannelsAlgorithm algorithm = 1 [default = k_EGetChannelsAlgorithm_Default, (.description) = "The algorithm to use when picking channels to return"];
  bool has_algorithm() const;
  private:
  bool _internal_has_algorithm() const;
  public:
  void clear_algorithm();
  ::EGetChannelsAlgorithm algorithm() const;
  void set_algorithm(::EGetChannelsAlgorithm value);
  private:
  ::EGetChannelsAlgorithm _internal_algorithm() const;
  void _internal_set_algorithm(::EGetChannelsAlgorithm value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChannels_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t count_;
  uint32_t appid_;
  int algorithm_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChannels_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChannels_Response) */ {
 public:
  inline CSteamTV_GetChannels_Response() : CSteamTV_GetChannels_Response(nullptr) {}
  ~CSteamTV_GetChannels_Response() override;
  explicit constexpr CSteamTV_GetChannels_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChannels_Response(const CSteamTV_GetChannels_Response& from);
  CSteamTV_GetChannels_Response(CSteamTV_GetChannels_Response&& from) noexcept
    : CSteamTV_GetChannels_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChannels_Response& operator=(const CSteamTV_GetChannels_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChannels_Response& operator=(CSteamTV_GetChannels_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChannels_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChannels_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChannels_Response*>(
               &_CSteamTV_GetChannels_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CSteamTV_GetChannels_Response& a, CSteamTV_GetChannels_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChannels_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChannels_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChannels_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChannels_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChannels_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChannels_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChannels_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChannels_Response";
  }
  protected:
  explicit CSteamTV_GetChannels_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of featured broadcasters"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::GetBroadcastChannelEntry* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_results();
  private:
  const ::GetBroadcastChannelEntry& _internal_results(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_results();
  public:
  const ::GetBroadcastChannelEntry& results(int index) const;
  ::GetBroadcastChannelEntry* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChannels_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddChatBan_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AddChatBan_Request) */ {
 public:
  inline CSteamTV_AddChatBan_Request() : CSteamTV_AddChatBan_Request(nullptr) {}
  ~CSteamTV_AddChatBan_Request() override;
  explicit constexpr CSteamTV_AddChatBan_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddChatBan_Request(const CSteamTV_AddChatBan_Request& from);
  CSteamTV_AddChatBan_Request(CSteamTV_AddChatBan_Request&& from) noexcept
    : CSteamTV_AddChatBan_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddChatBan_Request& operator=(const CSteamTV_AddChatBan_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddChatBan_Request& operator=(CSteamTV_AddChatBan_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddChatBan_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddChatBan_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddChatBan_Request*>(
               &_CSteamTV_AddChatBan_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CSteamTV_AddChatBan_Request& a, CSteamTV_AddChatBan_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddChatBan_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddChatBan_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddChatBan_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddChatBan_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AddChatBan_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AddChatBan_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AddChatBan_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddChatBan_Request";
  }
  protected:
  explicit CSteamTV_AddChatBan_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
    kChatterSteamidFieldNumber = 2,
    kDurationFieldNumber = 3,
    kPermanentFieldNumber = 4,
    kUndoFieldNumber = 5,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional fixed64 chatter_steamid = 2;
  bool has_chatter_steamid() const;
  private:
  bool _internal_has_chatter_steamid() const;
  public:
  void clear_chatter_steamid();
  uint64_t chatter_steamid() const;
  void set_chatter_steamid(uint64_t value);
  private:
  uint64_t _internal_chatter_steamid() const;
  void _internal_set_chatter_steamid(uint64_t value);
  public:

  // optional uint32 duration = 3;
  bool has_duration() const;
  private:
  bool _internal_has_duration() const;
  public:
  void clear_duration();
  uint32_t duration() const;
  void set_duration(uint32_t value);
  private:
  uint32_t _internal_duration() const;
  void _internal_set_duration(uint32_t value);
  public:

  // optional bool permanent = 4;
  bool has_permanent() const;
  private:
  bool _internal_has_permanent() const;
  public:
  void clear_permanent();
  bool permanent() const;
  void set_permanent(bool value);
  private:
  bool _internal_permanent() const;
  void _internal_set_permanent(bool value);
  public:

  // optional bool undo = 5;
  bool has_undo() const;
  private:
  bool _internal_has_undo() const;
  public:
  void clear_undo();
  bool undo() const;
  void set_undo(bool value);
  private:
  bool _internal_undo() const;
  void _internal_set_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AddChatBan_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  uint64_t chatter_steamid_;
  uint32_t duration_;
  bool permanent_;
  bool undo_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddChatBan_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_AddChatBan_Response) */ {
 public:
  inline CSteamTV_AddChatBan_Response() : CSteamTV_AddChatBan_Response(nullptr) {}
  explicit constexpr CSteamTV_AddChatBan_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddChatBan_Response(const CSteamTV_AddChatBan_Response& from);
  CSteamTV_AddChatBan_Response(CSteamTV_AddChatBan_Response&& from) noexcept
    : CSteamTV_AddChatBan_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddChatBan_Response& operator=(const CSteamTV_AddChatBan_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddChatBan_Response& operator=(CSteamTV_AddChatBan_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddChatBan_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddChatBan_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddChatBan_Response*>(
               &_CSteamTV_AddChatBan_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CSteamTV_AddChatBan_Response& a, CSteamTV_AddChatBan_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddChatBan_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddChatBan_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddChatBan_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddChatBan_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_AddChatBan_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_AddChatBan_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddChatBan_Response";
  }
  protected:
  explicit CSteamTV_AddChatBan_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_AddChatBan_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChatBans_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChatBans_Request) */ {
 public:
  inline CSteamTV_GetChatBans_Request() : CSteamTV_GetChatBans_Request(nullptr) {}
  ~CSteamTV_GetChatBans_Request() override;
  explicit constexpr CSteamTV_GetChatBans_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChatBans_Request(const CSteamTV_GetChatBans_Request& from);
  CSteamTV_GetChatBans_Request(CSteamTV_GetChatBans_Request&& from) noexcept
    : CSteamTV_GetChatBans_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChatBans_Request& operator=(const CSteamTV_GetChatBans_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChatBans_Request& operator=(CSteamTV_GetChatBans_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChatBans_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChatBans_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChatBans_Request*>(
               &_CSteamTV_GetChatBans_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CSteamTV_GetChatBans_Request& a, CSteamTV_GetChatBans_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChatBans_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChatBans_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChatBans_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChatBans_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChatBans_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChatBans_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChatBans_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChatBans_Request";
  }
  protected:
  explicit CSteamTV_GetChatBans_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChatBans_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_ChatBan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_ChatBan) */ {
 public:
  inline CSteamTV_ChatBan() : CSteamTV_ChatBan(nullptr) {}
  ~CSteamTV_ChatBan() override;
  explicit constexpr CSteamTV_ChatBan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_ChatBan(const CSteamTV_ChatBan& from);
  CSteamTV_ChatBan(CSteamTV_ChatBan&& from) noexcept
    : CSteamTV_ChatBan() {
    *this = ::std::move(from);
  }

  inline CSteamTV_ChatBan& operator=(const CSteamTV_ChatBan& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_ChatBan& operator=(CSteamTV_ChatBan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_ChatBan& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_ChatBan* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_ChatBan*>(
               &_CSteamTV_ChatBan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CSteamTV_ChatBan& a, CSteamTV_ChatBan& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_ChatBan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_ChatBan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_ChatBan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_ChatBan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_ChatBan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_ChatBan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_ChatBan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_ChatBan";
  }
  protected:
  explicit CSteamTV_ChatBan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeExpiresFieldNumber = 3,
    kNameFieldNumber = 5,
    kIssuerSteamidFieldNumber = 1,
    kChatterSteamidFieldNumber = 2,
    kPermanentFieldNumber = 4,
  };
  // optional string time_expires = 3;
  bool has_time_expires() const;
  private:
  bool _internal_has_time_expires() const;
  public:
  void clear_time_expires();
  const std::string& time_expires() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time_expires(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time_expires();
  PROTOBUF_NODISCARD std::string* release_time_expires();
  void set_allocated_time_expires(std::string* time_expires);
  private:
  const std::string& _internal_time_expires() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time_expires(const std::string& value);
  std::string* _internal_mutable_time_expires();
  public:

  // optional string name = 5;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional fixed64 issuer_steamid = 1;
  bool has_issuer_steamid() const;
  private:
  bool _internal_has_issuer_steamid() const;
  public:
  void clear_issuer_steamid();
  uint64_t issuer_steamid() const;
  void set_issuer_steamid(uint64_t value);
  private:
  uint64_t _internal_issuer_steamid() const;
  void _internal_set_issuer_steamid(uint64_t value);
  public:

  // optional fixed64 chatter_steamid = 2;
  bool has_chatter_steamid() const;
  private:
  bool _internal_has_chatter_steamid() const;
  public:
  void clear_chatter_steamid();
  uint64_t chatter_steamid() const;
  void set_chatter_steamid(uint64_t value);
  private:
  uint64_t _internal_chatter_steamid() const;
  void _internal_set_chatter_steamid(uint64_t value);
  public:

  // optional bool permanent = 4;
  bool has_permanent() const;
  private:
  bool _internal_has_permanent() const;
  public:
  void clear_permanent();
  bool permanent() const;
  void set_permanent(bool value);
  private:
  bool _internal_permanent() const;
  void _internal_set_permanent(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_ChatBan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_expires_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t issuer_steamid_;
  uint64_t chatter_steamid_;
  bool permanent_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChatBans_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChatBans_Response) */ {
 public:
  inline CSteamTV_GetChatBans_Response() : CSteamTV_GetChatBans_Response(nullptr) {}
  ~CSteamTV_GetChatBans_Response() override;
  explicit constexpr CSteamTV_GetChatBans_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChatBans_Response(const CSteamTV_GetChatBans_Response& from);
  CSteamTV_GetChatBans_Response(CSteamTV_GetChatBans_Response&& from) noexcept
    : CSteamTV_GetChatBans_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChatBans_Response& operator=(const CSteamTV_GetChatBans_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChatBans_Response& operator=(CSteamTV_GetChatBans_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChatBans_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChatBans_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChatBans_Response*>(
               &_CSteamTV_GetChatBans_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CSteamTV_GetChatBans_Response& a, CSteamTV_GetChatBans_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChatBans_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChatBans_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChatBans_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChatBans_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChatBans_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChatBans_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChatBans_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChatBans_Response";
  }
  protected:
  explicit CSteamTV_GetChatBans_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .CSteamTV_ChatBan results = 1 [(.description) = "The list of bans"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CSteamTV_ChatBan* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatBan >*
      mutable_results();
  private:
  const ::CSteamTV_ChatBan& _internal_results(int index) const;
  ::CSteamTV_ChatBan* _internal_add_results();
  public:
  const ::CSteamTV_ChatBan& results(int index) const;
  ::CSteamTV_ChatBan* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatBan >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChatBans_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatBan > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddChatModerator_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AddChatModerator_Request) */ {
 public:
  inline CSteamTV_AddChatModerator_Request() : CSteamTV_AddChatModerator_Request(nullptr) {}
  ~CSteamTV_AddChatModerator_Request() override;
  explicit constexpr CSteamTV_AddChatModerator_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddChatModerator_Request(const CSteamTV_AddChatModerator_Request& from);
  CSteamTV_AddChatModerator_Request(CSteamTV_AddChatModerator_Request&& from) noexcept
    : CSteamTV_AddChatModerator_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddChatModerator_Request& operator=(const CSteamTV_AddChatModerator_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddChatModerator_Request& operator=(CSteamTV_AddChatModerator_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddChatModerator_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddChatModerator_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddChatModerator_Request*>(
               &_CSteamTV_AddChatModerator_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CSteamTV_AddChatModerator_Request& a, CSteamTV_AddChatModerator_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddChatModerator_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddChatModerator_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddChatModerator_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddChatModerator_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AddChatModerator_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AddChatModerator_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AddChatModerator_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddChatModerator_Request";
  }
  protected:
  explicit CSteamTV_AddChatModerator_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
    kModeratorSteamidFieldNumber = 2,
    kUndoFieldNumber = 3,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional fixed64 moderator_steamid = 2;
  bool has_moderator_steamid() const;
  private:
  bool _internal_has_moderator_steamid() const;
  public:
  void clear_moderator_steamid();
  uint64_t moderator_steamid() const;
  void set_moderator_steamid(uint64_t value);
  private:
  uint64_t _internal_moderator_steamid() const;
  void _internal_set_moderator_steamid(uint64_t value);
  public:

  // optional bool undo = 3;
  bool has_undo() const;
  private:
  bool _internal_has_undo() const;
  public:
  void clear_undo();
  bool undo() const;
  void set_undo(bool value);
  private:
  bool _internal_undo() const;
  void _internal_set_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AddChatModerator_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  uint64_t moderator_steamid_;
  bool undo_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddChatModerator_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_AddChatModerator_Response) */ {
 public:
  inline CSteamTV_AddChatModerator_Response() : CSteamTV_AddChatModerator_Response(nullptr) {}
  explicit constexpr CSteamTV_AddChatModerator_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddChatModerator_Response(const CSteamTV_AddChatModerator_Response& from);
  CSteamTV_AddChatModerator_Response(CSteamTV_AddChatModerator_Response&& from) noexcept
    : CSteamTV_AddChatModerator_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddChatModerator_Response& operator=(const CSteamTV_AddChatModerator_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddChatModerator_Response& operator=(CSteamTV_AddChatModerator_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddChatModerator_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddChatModerator_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddChatModerator_Response*>(
               &_CSteamTV_AddChatModerator_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CSteamTV_AddChatModerator_Response& a, CSteamTV_AddChatModerator_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddChatModerator_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddChatModerator_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddChatModerator_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddChatModerator_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_AddChatModerator_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_AddChatModerator_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddChatModerator_Response";
  }
  protected:
  explicit CSteamTV_AddChatModerator_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_AddChatModerator_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChatModerators_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChatModerators_Request) */ {
 public:
  inline CSteamTV_GetChatModerators_Request() : CSteamTV_GetChatModerators_Request(nullptr) {}
  ~CSteamTV_GetChatModerators_Request() override;
  explicit constexpr CSteamTV_GetChatModerators_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChatModerators_Request(const CSteamTV_GetChatModerators_Request& from);
  CSteamTV_GetChatModerators_Request(CSteamTV_GetChatModerators_Request&& from) noexcept
    : CSteamTV_GetChatModerators_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChatModerators_Request& operator=(const CSteamTV_GetChatModerators_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChatModerators_Request& operator=(CSteamTV_GetChatModerators_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChatModerators_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChatModerators_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChatModerators_Request*>(
               &_CSteamTV_GetChatModerators_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CSteamTV_GetChatModerators_Request& a, CSteamTV_GetChatModerators_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChatModerators_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChatModerators_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChatModerators_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChatModerators_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChatModerators_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChatModerators_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChatModerators_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChatModerators_Request";
  }
  protected:
  explicit CSteamTV_GetChatModerators_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChatModerators_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_ChatModerator final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_ChatModerator) */ {
 public:
  inline CSteamTV_ChatModerator() : CSteamTV_ChatModerator(nullptr) {}
  ~CSteamTV_ChatModerator() override;
  explicit constexpr CSteamTV_ChatModerator(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_ChatModerator(const CSteamTV_ChatModerator& from);
  CSteamTV_ChatModerator(CSteamTV_ChatModerator&& from) noexcept
    : CSteamTV_ChatModerator() {
    *this = ::std::move(from);
  }

  inline CSteamTV_ChatModerator& operator=(const CSteamTV_ChatModerator& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_ChatModerator& operator=(CSteamTV_ChatModerator&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_ChatModerator& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_ChatModerator* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_ChatModerator*>(
               &_CSteamTV_ChatModerator_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CSteamTV_ChatModerator& a, CSteamTV_ChatModerator& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_ChatModerator* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_ChatModerator* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_ChatModerator* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_ChatModerator>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_ChatModerator& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_ChatModerator& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_ChatModerator* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_ChatModerator";
  }
  protected:
  explicit CSteamTV_ChatModerator(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kSteamidFieldNumber = 1,
  };
  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_ChatModerator)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetChatModerators_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetChatModerators_Response) */ {
 public:
  inline CSteamTV_GetChatModerators_Response() : CSteamTV_GetChatModerators_Response(nullptr) {}
  ~CSteamTV_GetChatModerators_Response() override;
  explicit constexpr CSteamTV_GetChatModerators_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetChatModerators_Response(const CSteamTV_GetChatModerators_Response& from);
  CSteamTV_GetChatModerators_Response(CSteamTV_GetChatModerators_Response&& from) noexcept
    : CSteamTV_GetChatModerators_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetChatModerators_Response& operator=(const CSteamTV_GetChatModerators_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetChatModerators_Response& operator=(CSteamTV_GetChatModerators_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetChatModerators_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetChatModerators_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetChatModerators_Response*>(
               &_CSteamTV_GetChatModerators_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CSteamTV_GetChatModerators_Response& a, CSteamTV_GetChatModerators_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetChatModerators_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetChatModerators_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetChatModerators_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetChatModerators_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetChatModerators_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetChatModerators_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetChatModerators_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetChatModerators_Response";
  }
  protected:
  explicit CSteamTV_GetChatModerators_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .CSteamTV_ChatModerator results = 1 [(.description) = "The list of moderators"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::CSteamTV_ChatModerator* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatModerator >*
      mutable_results();
  private:
  const ::CSteamTV_ChatModerator& _internal_results(int index) const;
  ::CSteamTV_ChatModerator* _internal_add_results();
  public:
  const ::CSteamTV_ChatModerator& results(int index) const;
  ::CSteamTV_ChatModerator* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatModerator >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetChatModerators_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatModerator > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddWordBan_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AddWordBan_Request) */ {
 public:
  inline CSteamTV_AddWordBan_Request() : CSteamTV_AddWordBan_Request(nullptr) {}
  ~CSteamTV_AddWordBan_Request() override;
  explicit constexpr CSteamTV_AddWordBan_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddWordBan_Request(const CSteamTV_AddWordBan_Request& from);
  CSteamTV_AddWordBan_Request(CSteamTV_AddWordBan_Request&& from) noexcept
    : CSteamTV_AddWordBan_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddWordBan_Request& operator=(const CSteamTV_AddWordBan_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddWordBan_Request& operator=(CSteamTV_AddWordBan_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddWordBan_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddWordBan_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddWordBan_Request*>(
               &_CSteamTV_AddWordBan_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CSteamTV_AddWordBan_Request& a, CSteamTV_AddWordBan_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddWordBan_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddWordBan_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddWordBan_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddWordBan_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AddWordBan_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AddWordBan_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AddWordBan_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddWordBan_Request";
  }
  protected:
  explicit CSteamTV_AddWordBan_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWordFieldNumber = 2,
    kBroadcastChannelIdFieldNumber = 1,
    kUndoFieldNumber = 3,
  };
  // optional string word = 2;
  bool has_word() const;
  private:
  bool _internal_has_word() const;
  public:
  void clear_word();
  const std::string& word() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_word(ArgT0&& arg0, ArgT... args);
  std::string* mutable_word();
  PROTOBUF_NODISCARD std::string* release_word();
  void set_allocated_word(std::string* word);
  private:
  const std::string& _internal_word() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_word(const std::string& value);
  std::string* _internal_mutable_word();
  public:

  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // optional bool undo = 3;
  bool has_undo() const;
  private:
  bool _internal_has_undo() const;
  public:
  void clear_undo();
  bool undo() const;
  void set_undo(bool value);
  private:
  bool _internal_undo() const;
  void _internal_set_undo(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AddWordBan_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr word_;
  uint64_t broadcast_channel_id_;
  bool undo_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AddWordBan_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_AddWordBan_Response) */ {
 public:
  inline CSteamTV_AddWordBan_Response() : CSteamTV_AddWordBan_Response(nullptr) {}
  explicit constexpr CSteamTV_AddWordBan_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AddWordBan_Response(const CSteamTV_AddWordBan_Response& from);
  CSteamTV_AddWordBan_Response(CSteamTV_AddWordBan_Response&& from) noexcept
    : CSteamTV_AddWordBan_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AddWordBan_Response& operator=(const CSteamTV_AddWordBan_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AddWordBan_Response& operator=(CSteamTV_AddWordBan_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AddWordBan_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AddWordBan_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AddWordBan_Response*>(
               &_CSteamTV_AddWordBan_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CSteamTV_AddWordBan_Response& a, CSteamTV_AddWordBan_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AddWordBan_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AddWordBan_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AddWordBan_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AddWordBan_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_AddWordBan_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_AddWordBan_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AddWordBan_Response";
  }
  protected:
  explicit CSteamTV_AddWordBan_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_AddWordBan_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetWordBans_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetWordBans_Request) */ {
 public:
  inline CSteamTV_GetWordBans_Request() : CSteamTV_GetWordBans_Request(nullptr) {}
  ~CSteamTV_GetWordBans_Request() override;
  explicit constexpr CSteamTV_GetWordBans_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetWordBans_Request(const CSteamTV_GetWordBans_Request& from);
  CSteamTV_GetWordBans_Request(CSteamTV_GetWordBans_Request&& from) noexcept
    : CSteamTV_GetWordBans_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetWordBans_Request& operator=(const CSteamTV_GetWordBans_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetWordBans_Request& operator=(CSteamTV_GetWordBans_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetWordBans_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetWordBans_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetWordBans_Request*>(
               &_CSteamTV_GetWordBans_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CSteamTV_GetWordBans_Request& a, CSteamTV_GetWordBans_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetWordBans_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetWordBans_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetWordBans_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetWordBans_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetWordBans_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetWordBans_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetWordBans_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetWordBans_Request";
  }
  protected:
  explicit CSteamTV_GetWordBans_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetWordBans_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetWordBans_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetWordBans_Response) */ {
 public:
  inline CSteamTV_GetWordBans_Response() : CSteamTV_GetWordBans_Response(nullptr) {}
  ~CSteamTV_GetWordBans_Response() override;
  explicit constexpr CSteamTV_GetWordBans_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetWordBans_Response(const CSteamTV_GetWordBans_Response& from);
  CSteamTV_GetWordBans_Response(CSteamTV_GetWordBans_Response&& from) noexcept
    : CSteamTV_GetWordBans_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetWordBans_Response& operator=(const CSteamTV_GetWordBans_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetWordBans_Response& operator=(CSteamTV_GetWordBans_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetWordBans_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetWordBans_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetWordBans_Response*>(
               &_CSteamTV_GetWordBans_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CSteamTV_GetWordBans_Response& a, CSteamTV_GetWordBans_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetWordBans_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetWordBans_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetWordBans_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetWordBans_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetWordBans_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetWordBans_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetWordBans_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetWordBans_Response";
  }
  protected:
  explicit CSteamTV_GetWordBans_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated string results = 1 [(.description) = "The list of banned words"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  const std::string& results(int index) const;
  std::string* mutable_results(int index);
  void set_results(int index, const std::string& value);
  void set_results(int index, std::string&& value);
  void set_results(int index, const char* value);
  void set_results(int index, const char* value, size_t size);
  std::string* add_results();
  void add_results(const std::string& value);
  void add_results(std::string&& value);
  void add_results(const char* value);
  void add_results(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& results() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_results();
  private:
  const std::string& _internal_results(int index) const;
  std::string* _internal_add_results();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetWordBans_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_JoinChat_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_JoinChat_Request) */ {
 public:
  inline CSteamTV_JoinChat_Request() : CSteamTV_JoinChat_Request(nullptr) {}
  ~CSteamTV_JoinChat_Request() override;
  explicit constexpr CSteamTV_JoinChat_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_JoinChat_Request(const CSteamTV_JoinChat_Request& from);
  CSteamTV_JoinChat_Request(CSteamTV_JoinChat_Request&& from) noexcept
    : CSteamTV_JoinChat_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_JoinChat_Request& operator=(const CSteamTV_JoinChat_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_JoinChat_Request& operator=(CSteamTV_JoinChat_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_JoinChat_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_JoinChat_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_JoinChat_Request*>(
               &_CSteamTV_JoinChat_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CSteamTV_JoinChat_Request& a, CSteamTV_JoinChat_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_JoinChat_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_JoinChat_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_JoinChat_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_JoinChat_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_JoinChat_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_JoinChat_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_JoinChat_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_JoinChat_Request";
  }
  protected:
  explicit CSteamTV_JoinChat_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastChannelIdFieldNumber = 1,
  };
  // optional fixed64 broadcast_channel_id = 1;
  bool has_broadcast_channel_id() const;
  private:
  bool _internal_has_broadcast_channel_id() const;
  public:
  void clear_broadcast_channel_id();
  uint64_t broadcast_channel_id() const;
  void set_broadcast_channel_id(uint64_t value);
  private:
  uint64_t _internal_broadcast_channel_id() const;
  void _internal_set_broadcast_channel_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_JoinChat_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t broadcast_channel_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_JoinChat_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_JoinChat_Response) */ {
 public:
  inline CSteamTV_JoinChat_Response() : CSteamTV_JoinChat_Response(nullptr) {}
  ~CSteamTV_JoinChat_Response() override;
  explicit constexpr CSteamTV_JoinChat_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_JoinChat_Response(const CSteamTV_JoinChat_Response& from);
  CSteamTV_JoinChat_Response(CSteamTV_JoinChat_Response&& from) noexcept
    : CSteamTV_JoinChat_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_JoinChat_Response& operator=(const CSteamTV_JoinChat_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_JoinChat_Response& operator=(CSteamTV_JoinChat_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_JoinChat_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_JoinChat_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_JoinChat_Response*>(
               &_CSteamTV_JoinChat_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CSteamTV_JoinChat_Response& a, CSteamTV_JoinChat_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_JoinChat_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_JoinChat_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_JoinChat_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_JoinChat_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_JoinChat_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_JoinChat_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_JoinChat_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_JoinChat_Response";
  }
  protected:
  explicit CSteamTV_JoinChat_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlairGroupIdsFieldNumber = 3,
    kViewUrlTemplateFieldNumber = 2,
    kChatIdFieldNumber = 1,
  };
  // repeated uint64 flair_group_ids = 3;
  int flair_group_ids_size() const;
  private:
  int _internal_flair_group_ids_size() const;
  public:
  void clear_flair_group_ids();
  private:
  uint64_t _internal_flair_group_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_flair_group_ids() const;
  void _internal_add_flair_group_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_flair_group_ids();
  public:
  uint64_t flair_group_ids(int index) const;
  void set_flair_group_ids(int index, uint64_t value);
  void add_flair_group_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      flair_group_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_flair_group_ids();

  // optional string view_url_template = 2;
  bool has_view_url_template() const;
  private:
  bool _internal_has_view_url_template() const;
  public:
  void clear_view_url_template();
  const std::string& view_url_template() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_view_url_template(ArgT0&& arg0, ArgT... args);
  std::string* mutable_view_url_template();
  PROTOBUF_NODISCARD std::string* release_view_url_template();
  void set_allocated_view_url_template(std::string* view_url_template);
  private:
  const std::string& _internal_view_url_template() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_view_url_template(const std::string& value);
  std::string* _internal_mutable_view_url_template();
  public:

  // optional fixed64 chat_id = 1;
  bool has_chat_id() const;
  private:
  bool _internal_has_chat_id() const;
  public:
  void clear_chat_id();
  uint64_t chat_id() const;
  void set_chat_id(uint64_t value);
  private:
  uint64_t _internal_chat_id() const;
  void _internal_set_chat_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_JoinChat_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > flair_group_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr view_url_template_;
  uint64_t chat_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_Search_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_Search_Request) */ {
 public:
  inline CSteamTV_Search_Request() : CSteamTV_Search_Request(nullptr) {}
  ~CSteamTV_Search_Request() override;
  explicit constexpr CSteamTV_Search_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_Search_Request(const CSteamTV_Search_Request& from);
  CSteamTV_Search_Request(CSteamTV_Search_Request&& from) noexcept
    : CSteamTV_Search_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_Search_Request& operator=(const CSteamTV_Search_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_Search_Request& operator=(CSteamTV_Search_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_Search_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_Search_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_Search_Request*>(
               &_CSteamTV_Search_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CSteamTV_Search_Request& a, CSteamTV_Search_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_Search_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_Search_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_Search_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_Search_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_Search_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_Search_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_Search_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_Search_Request";
  }
  protected:
  explicit CSteamTV_Search_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTermFieldNumber = 1,
  };
  // optional string term = 1;
  bool has_term() const;
  private:
  bool _internal_has_term() const;
  public:
  void clear_term();
  const std::string& term() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_term(ArgT0&& arg0, ArgT... args);
  std::string* mutable_term();
  PROTOBUF_NODISCARD std::string* release_term();
  void set_allocated_term(std::string* term);
  private:
  const std::string& _internal_term() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_term(const std::string& value);
  std::string* _internal_mutable_term();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_Search_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr term_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_Search_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_Search_Response) */ {
 public:
  inline CSteamTV_Search_Response() : CSteamTV_Search_Response(nullptr) {}
  ~CSteamTV_Search_Response() override;
  explicit constexpr CSteamTV_Search_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_Search_Response(const CSteamTV_Search_Response& from);
  CSteamTV_Search_Response(CSteamTV_Search_Response&& from) noexcept
    : CSteamTV_Search_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_Search_Response& operator=(const CSteamTV_Search_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_Search_Response& operator=(CSteamTV_Search_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_Search_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_Search_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_Search_Response*>(
               &_CSteamTV_Search_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CSteamTV_Search_Response& a, CSteamTV_Search_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_Search_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_Search_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_Search_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_Search_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_Search_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_Search_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_Search_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_Search_Response";
  }
  protected:
  explicit CSteamTV_Search_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::GetBroadcastChannelEntry* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_results();
  private:
  const ::GetBroadcastChannelEntry& _internal_results(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_results();
  public:
  const ::GetBroadcastChannelEntry& results(int index) const;
  ::GetBroadcastChannelEntry* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_Search_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetSteamTVUserSettings_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_GetSteamTVUserSettings_Request) */ {
 public:
  inline CSteamTV_GetSteamTVUserSettings_Request() : CSteamTV_GetSteamTVUserSettings_Request(nullptr) {}
  explicit constexpr CSteamTV_GetSteamTVUserSettings_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetSteamTVUserSettings_Request(const CSteamTV_GetSteamTVUserSettings_Request& from);
  CSteamTV_GetSteamTVUserSettings_Request(CSteamTV_GetSteamTVUserSettings_Request&& from) noexcept
    : CSteamTV_GetSteamTVUserSettings_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetSteamTVUserSettings_Request& operator=(const CSteamTV_GetSteamTVUserSettings_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetSteamTVUserSettings_Request& operator=(CSteamTV_GetSteamTVUserSettings_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetSteamTVUserSettings_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetSteamTVUserSettings_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetSteamTVUserSettings_Request*>(
               &_CSteamTV_GetSteamTVUserSettings_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CSteamTV_GetSteamTVUserSettings_Request& a, CSteamTV_GetSteamTVUserSettings_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetSteamTVUserSettings_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetSteamTVUserSettings_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetSteamTVUserSettings_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetSteamTVUserSettings_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_GetSteamTVUserSettings_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_GetSteamTVUserSettings_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetSteamTVUserSettings_Request";
  }
  protected:
  explicit CSteamTV_GetSteamTVUserSettings_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_GetSteamTVUserSettings_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetSteamTVUserSettings_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetSteamTVUserSettings_Response) */ {
 public:
  inline CSteamTV_GetSteamTVUserSettings_Response() : CSteamTV_GetSteamTVUserSettings_Response(nullptr) {}
  ~CSteamTV_GetSteamTVUserSettings_Response() override;
  explicit constexpr CSteamTV_GetSteamTVUserSettings_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetSteamTVUserSettings_Response(const CSteamTV_GetSteamTVUserSettings_Response& from);
  CSteamTV_GetSteamTVUserSettings_Response(CSteamTV_GetSteamTVUserSettings_Response&& from) noexcept
    : CSteamTV_GetSteamTVUserSettings_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetSteamTVUserSettings_Response& operator=(const CSteamTV_GetSteamTVUserSettings_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetSteamTVUserSettings_Response& operator=(CSteamTV_GetSteamTVUserSettings_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetSteamTVUserSettings_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetSteamTVUserSettings_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetSteamTVUserSettings_Response*>(
               &_CSteamTV_GetSteamTVUserSettings_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CSteamTV_GetSteamTVUserSettings_Response& a, CSteamTV_GetSteamTVUserSettings_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetSteamTVUserSettings_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetSteamTVUserSettings_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetSteamTVUserSettings_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetSteamTVUserSettings_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetSteamTVUserSettings_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetSteamTVUserSettings_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetSteamTVUserSettings_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetSteamTVUserSettings_Response";
  }
  protected:
  explicit CSteamTV_GetSteamTVUserSettings_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamLiveEmailFieldNumber = 1,
    kStreamLiveNotificationFieldNumber = 2,
  };
  // optional bool stream_live_email = 1 [(.description) = "Send email when followed stream starts"];
  bool has_stream_live_email() const;
  private:
  bool _internal_has_stream_live_email() const;
  public:
  void clear_stream_live_email();
  bool stream_live_email() const;
  void set_stream_live_email(bool value);
  private:
  bool _internal_stream_live_email() const;
  void _internal_set_stream_live_email(bool value);
  public:

  // optional bool stream_live_notification = 2 [(.description) = "Send Steam notification when followed stream starts"];
  bool has_stream_live_notification() const;
  private:
  bool _internal_has_stream_live_notification() const;
  public:
  void clear_stream_live_notification();
  bool stream_live_notification() const;
  void set_stream_live_notification(bool value);
  private:
  bool _internal_stream_live_notification() const;
  void _internal_set_stream_live_notification(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_GetSteamTVUserSettings_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool stream_live_email_;
  bool stream_live_notification_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetSteamTVUserSettings_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_SetSteamTVUserSettings_Request) */ {
 public:
  inline CSteamTV_SetSteamTVUserSettings_Request() : CSteamTV_SetSteamTVUserSettings_Request(nullptr) {}
  ~CSteamTV_SetSteamTVUserSettings_Request() override;
  explicit constexpr CSteamTV_SetSteamTVUserSettings_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetSteamTVUserSettings_Request(const CSteamTV_SetSteamTVUserSettings_Request& from);
  CSteamTV_SetSteamTVUserSettings_Request(CSteamTV_SetSteamTVUserSettings_Request&& from) noexcept
    : CSteamTV_SetSteamTVUserSettings_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetSteamTVUserSettings_Request& operator=(const CSteamTV_SetSteamTVUserSettings_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetSteamTVUserSettings_Request& operator=(CSteamTV_SetSteamTVUserSettings_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetSteamTVUserSettings_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetSteamTVUserSettings_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetSteamTVUserSettings_Request*>(
               &_CSteamTV_SetSteamTVUserSettings_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CSteamTV_SetSteamTVUserSettings_Request& a, CSteamTV_SetSteamTVUserSettings_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetSteamTVUserSettings_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetSteamTVUserSettings_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetSteamTVUserSettings_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetSteamTVUserSettings_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_SetSteamTVUserSettings_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_SetSteamTVUserSettings_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_SetSteamTVUserSettings_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetSteamTVUserSettings_Request";
  }
  protected:
  explicit CSteamTV_SetSteamTVUserSettings_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamLiveEmailFieldNumber = 1,
    kStreamLiveNotificationFieldNumber = 2,
  };
  // optional bool stream_live_email = 1 [(.description) = "Send email when followed stream starts"];
  bool has_stream_live_email() const;
  private:
  bool _internal_has_stream_live_email() const;
  public:
  void clear_stream_live_email();
  bool stream_live_email() const;
  void set_stream_live_email(bool value);
  private:
  bool _internal_stream_live_email() const;
  void _internal_set_stream_live_email(bool value);
  public:

  // optional bool stream_live_notification = 2 [(.description) = "Send Steam notification when followed stream starts"];
  bool has_stream_live_notification() const;
  private:
  bool _internal_has_stream_live_notification() const;
  public:
  void clear_stream_live_notification();
  bool stream_live_notification() const;
  void set_stream_live_notification(bool value);
  private:
  bool _internal_stream_live_notification() const;
  void _internal_set_stream_live_notification(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_SetSteamTVUserSettings_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool stream_live_email_;
  bool stream_live_notification_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_SetSteamTVUserSettings_Response final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_SetSteamTVUserSettings_Response) */ {
 public:
  inline CSteamTV_SetSteamTVUserSettings_Response() : CSteamTV_SetSteamTVUserSettings_Response(nullptr) {}
  explicit constexpr CSteamTV_SetSteamTVUserSettings_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_SetSteamTVUserSettings_Response(const CSteamTV_SetSteamTVUserSettings_Response& from);
  CSteamTV_SetSteamTVUserSettings_Response(CSteamTV_SetSteamTVUserSettings_Response&& from) noexcept
    : CSteamTV_SetSteamTVUserSettings_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_SetSteamTVUserSettings_Response& operator=(const CSteamTV_SetSteamTVUserSettings_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_SetSteamTVUserSettings_Response& operator=(CSteamTV_SetSteamTVUserSettings_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_SetSteamTVUserSettings_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_SetSteamTVUserSettings_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_SetSteamTVUserSettings_Response*>(
               &_CSteamTV_SetSteamTVUserSettings_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CSteamTV_SetSteamTVUserSettings_Response& a, CSteamTV_SetSteamTVUserSettings_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_SetSteamTVUserSettings_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_SetSteamTVUserSettings_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_SetSteamTVUserSettings_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_SetSteamTVUserSettings_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_SetSteamTVUserSettings_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_SetSteamTVUserSettings_Response& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_SetSteamTVUserSettings_Response";
  }
  protected:
  explicit CSteamTV_SetSteamTVUserSettings_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_SetSteamTVUserSettings_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetMyBroadcastChannels_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_GetMyBroadcastChannels_Request) */ {
 public:
  inline CSteamTV_GetMyBroadcastChannels_Request() : CSteamTV_GetMyBroadcastChannels_Request(nullptr) {}
  explicit constexpr CSteamTV_GetMyBroadcastChannels_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetMyBroadcastChannels_Request(const CSteamTV_GetMyBroadcastChannels_Request& from);
  CSteamTV_GetMyBroadcastChannels_Request(CSteamTV_GetMyBroadcastChannels_Request&& from) noexcept
    : CSteamTV_GetMyBroadcastChannels_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetMyBroadcastChannels_Request& operator=(const CSteamTV_GetMyBroadcastChannels_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetMyBroadcastChannels_Request& operator=(CSteamTV_GetMyBroadcastChannels_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetMyBroadcastChannels_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetMyBroadcastChannels_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetMyBroadcastChannels_Request*>(
               &_CSteamTV_GetMyBroadcastChannels_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CSteamTV_GetMyBroadcastChannels_Request& a, CSteamTV_GetMyBroadcastChannels_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetMyBroadcastChannels_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetMyBroadcastChannels_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetMyBroadcastChannels_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetMyBroadcastChannels_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_GetMyBroadcastChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_GetMyBroadcastChannels_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetMyBroadcastChannels_Request";
  }
  protected:
  explicit CSteamTV_GetMyBroadcastChannels_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_GetMyBroadcastChannels_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetMyBroadcastChannels_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetMyBroadcastChannels_Response) */ {
 public:
  inline CSteamTV_GetMyBroadcastChannels_Response() : CSteamTV_GetMyBroadcastChannels_Response(nullptr) {}
  ~CSteamTV_GetMyBroadcastChannels_Response() override;
  explicit constexpr CSteamTV_GetMyBroadcastChannels_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetMyBroadcastChannels_Response(const CSteamTV_GetMyBroadcastChannels_Response& from);
  CSteamTV_GetMyBroadcastChannels_Response(CSteamTV_GetMyBroadcastChannels_Response&& from) noexcept
    : CSteamTV_GetMyBroadcastChannels_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetMyBroadcastChannels_Response& operator=(const CSteamTV_GetMyBroadcastChannels_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetMyBroadcastChannels_Response& operator=(CSteamTV_GetMyBroadcastChannels_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetMyBroadcastChannels_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetMyBroadcastChannels_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetMyBroadcastChannels_Response*>(
               &_CSteamTV_GetMyBroadcastChannels_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(CSteamTV_GetMyBroadcastChannels_Response& a, CSteamTV_GetMyBroadcastChannels_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetMyBroadcastChannels_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetMyBroadcastChannels_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetMyBroadcastChannels_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetMyBroadcastChannels_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetMyBroadcastChannels_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetMyBroadcastChannels_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetMyBroadcastChannels_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetMyBroadcastChannels_Response";
  }
  protected:
  explicit CSteamTV_GetMyBroadcastChannels_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::GetBroadcastChannelEntry* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_results();
  private:
  const ::GetBroadcastChannelEntry& _internal_results(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_results();
  public:
  const ::GetBroadcastChannelEntry& results(int index) const;
  ::GetBroadcastChannelEntry* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      results() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetMyBroadcastChannels_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetHomePageContents_Request final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSteamTV_GetHomePageContents_Request) */ {
 public:
  inline CSteamTV_GetHomePageContents_Request() : CSteamTV_GetHomePageContents_Request(nullptr) {}
  explicit constexpr CSteamTV_GetHomePageContents_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetHomePageContents_Request(const CSteamTV_GetHomePageContents_Request& from);
  CSteamTV_GetHomePageContents_Request(CSteamTV_GetHomePageContents_Request&& from) noexcept
    : CSteamTV_GetHomePageContents_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetHomePageContents_Request& operator=(const CSteamTV_GetHomePageContents_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetHomePageContents_Request& operator=(CSteamTV_GetHomePageContents_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetHomePageContents_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetHomePageContents_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetHomePageContents_Request*>(
               &_CSteamTV_GetHomePageContents_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CSteamTV_GetHomePageContents_Request& a, CSteamTV_GetHomePageContents_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetHomePageContents_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetHomePageContents_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetHomePageContents_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetHomePageContents_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSteamTV_GetHomePageContents_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSteamTV_GetHomePageContents_Request& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetHomePageContents_Request";
  }
  protected:
  explicit CSteamTV_GetHomePageContents_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSteamTV_GetHomePageContents_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_Takeover final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_Takeover) */ {
 public:
  inline CSteamTV_HomePageTemplate_Takeover() : CSteamTV_HomePageTemplate_Takeover(nullptr) {}
  ~CSteamTV_HomePageTemplate_Takeover() override;
  explicit constexpr CSteamTV_HomePageTemplate_Takeover(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_Takeover(const CSteamTV_HomePageTemplate_Takeover& from);
  CSteamTV_HomePageTemplate_Takeover(CSteamTV_HomePageTemplate_Takeover&& from) noexcept
    : CSteamTV_HomePageTemplate_Takeover() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_Takeover& operator=(const CSteamTV_HomePageTemplate_Takeover& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_Takeover& operator=(CSteamTV_HomePageTemplate_Takeover&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_Takeover& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_Takeover* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_Takeover*>(
               &_CSteamTV_HomePageTemplate_Takeover_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CSteamTV_HomePageTemplate_Takeover& a, CSteamTV_HomePageTemplate_Takeover& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_Takeover* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_Takeover* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_Takeover* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_Takeover>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_Takeover& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_Takeover& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_Takeover* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_Takeover";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_Takeover(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastsFieldNumber = 1,
  };
  // repeated .GetBroadcastChannelEntry broadcasts = 1;
  int broadcasts_size() const;
  private:
  int _internal_broadcasts_size() const;
  public:
  void clear_broadcasts();
  ::GetBroadcastChannelEntry* mutable_broadcasts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_broadcasts();
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcasts(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_broadcasts();
  public:
  const ::GetBroadcastChannelEntry& broadcasts(int index) const;
  ::GetBroadcastChannelEntry* add_broadcasts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      broadcasts() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_Takeover)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > broadcasts_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_SingleGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_SingleGame) */ {
 public:
  inline CSteamTV_HomePageTemplate_SingleGame() : CSteamTV_HomePageTemplate_SingleGame(nullptr) {}
  ~CSteamTV_HomePageTemplate_SingleGame() override;
  explicit constexpr CSteamTV_HomePageTemplate_SingleGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_SingleGame(const CSteamTV_HomePageTemplate_SingleGame& from);
  CSteamTV_HomePageTemplate_SingleGame(CSteamTV_HomePageTemplate_SingleGame&& from) noexcept
    : CSteamTV_HomePageTemplate_SingleGame() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_SingleGame& operator=(const CSteamTV_HomePageTemplate_SingleGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_SingleGame& operator=(CSteamTV_HomePageTemplate_SingleGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_SingleGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_SingleGame* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_SingleGame*>(
               &_CSteamTV_HomePageTemplate_SingleGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(CSteamTV_HomePageTemplate_SingleGame& a, CSteamTV_HomePageTemplate_SingleGame& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_SingleGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_SingleGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_SingleGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_SingleGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_SingleGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_SingleGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_SingleGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_SingleGame";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_SingleGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastsFieldNumber = 1,
    kTitleFieldNumber = 3,
    kAppidFieldNumber = 2,
  };
  // repeated .GetBroadcastChannelEntry broadcasts = 1;
  int broadcasts_size() const;
  private:
  int _internal_broadcasts_size() const;
  public:
  void clear_broadcasts();
  ::GetBroadcastChannelEntry* mutable_broadcasts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_broadcasts();
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcasts(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_broadcasts();
  public:
  const ::GetBroadcastChannelEntry& broadcasts(int index) const;
  ::GetBroadcastChannelEntry* add_broadcasts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      broadcasts() const;

  // optional string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_SingleGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > broadcasts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class GameListEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:GameListEntry) */ {
 public:
  inline GameListEntry() : GameListEntry(nullptr) {}
  ~GameListEntry() override;
  explicit constexpr GameListEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GameListEntry(const GameListEntry& from);
  GameListEntry(GameListEntry&& from) noexcept
    : GameListEntry() {
    *this = ::std::move(from);
  }

  inline GameListEntry& operator=(const GameListEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline GameListEntry& operator=(GameListEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GameListEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const GameListEntry* internal_default_instance() {
    return reinterpret_cast<const GameListEntry*>(
               &_GameListEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(GameListEntry& a, GameListEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(GameListEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GameListEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GameListEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GameListEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GameListEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GameListEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GameListEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "GameListEntry";
  }
  protected:
  explicit GameListEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 2,
    kBroadcastFieldNumber = 3,
    kAppidFieldNumber = 1,
  };
  // optional string game_name = 2;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional .GetBroadcastChannelEntry broadcast = 3;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::GetBroadcastChannelEntry& broadcast() const;
  PROTOBUF_NODISCARD ::GetBroadcastChannelEntry* release_broadcast();
  ::GetBroadcastChannelEntry* mutable_broadcast();
  void set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast);
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcast() const;
  ::GetBroadcastChannelEntry* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::GetBroadcastChannelEntry* broadcast);
  ::GetBroadcastChannelEntry* unsafe_arena_release_broadcast();

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:GameListEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  ::GetBroadcastChannelEntry* broadcast_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_GameList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_GameList) */ {
 public:
  inline CSteamTV_HomePageTemplate_GameList() : CSteamTV_HomePageTemplate_GameList(nullptr) {}
  ~CSteamTV_HomePageTemplate_GameList() override;
  explicit constexpr CSteamTV_HomePageTemplate_GameList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_GameList(const CSteamTV_HomePageTemplate_GameList& from);
  CSteamTV_HomePageTemplate_GameList(CSteamTV_HomePageTemplate_GameList&& from) noexcept
    : CSteamTV_HomePageTemplate_GameList() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_GameList& operator=(const CSteamTV_HomePageTemplate_GameList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_GameList& operator=(CSteamTV_HomePageTemplate_GameList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_GameList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_GameList* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_GameList*>(
               &_CSteamTV_HomePageTemplate_GameList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(CSteamTV_HomePageTemplate_GameList& a, CSteamTV_HomePageTemplate_GameList& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_GameList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_GameList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_GameList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_GameList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_GameList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_GameList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_GameList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_GameList";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_GameList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
    kTitleFieldNumber = 2,
  };
  // repeated .GameListEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::GameListEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameListEntry >*
      mutable_entries();
  private:
  const ::GameListEntry& _internal_entries(int index) const;
  ::GameListEntry* _internal_add_entries();
  public:
  const ::GameListEntry& entries(int index) const;
  ::GameListEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameListEntry >&
      entries() const;

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_GameList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameListEntry > entries_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_QuickExplore final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_QuickExplore) */ {
 public:
  inline CSteamTV_HomePageTemplate_QuickExplore() : CSteamTV_HomePageTemplate_QuickExplore(nullptr) {}
  ~CSteamTV_HomePageTemplate_QuickExplore() override;
  explicit constexpr CSteamTV_HomePageTemplate_QuickExplore(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_QuickExplore(const CSteamTV_HomePageTemplate_QuickExplore& from);
  CSteamTV_HomePageTemplate_QuickExplore(CSteamTV_HomePageTemplate_QuickExplore&& from) noexcept
    : CSteamTV_HomePageTemplate_QuickExplore() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_QuickExplore& operator=(const CSteamTV_HomePageTemplate_QuickExplore& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_QuickExplore& operator=(CSteamTV_HomePageTemplate_QuickExplore&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_QuickExplore& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_QuickExplore* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_QuickExplore*>(
               &_CSteamTV_HomePageTemplate_QuickExplore_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(CSteamTV_HomePageTemplate_QuickExplore& a, CSteamTV_HomePageTemplate_QuickExplore& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_QuickExplore* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_QuickExplore* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_QuickExplore* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_QuickExplore>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_QuickExplore& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_QuickExplore& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_QuickExplore* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_QuickExplore";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_QuickExplore(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastsFieldNumber = 1,
    kTitleFieldNumber = 2,
  };
  // repeated .GetBroadcastChannelEntry broadcasts = 1;
  int broadcasts_size() const;
  private:
  int _internal_broadcasts_size() const;
  public:
  void clear_broadcasts();
  ::GetBroadcastChannelEntry* mutable_broadcasts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_broadcasts();
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcasts(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_broadcasts();
  public:
  const ::GetBroadcastChannelEntry& broadcasts(int index) const;
  ::GetBroadcastChannelEntry* add_broadcasts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      broadcasts() const;

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_QuickExplore)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > broadcasts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_ConveyorBelt final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_ConveyorBelt) */ {
 public:
  inline CSteamTV_HomePageTemplate_ConveyorBelt() : CSteamTV_HomePageTemplate_ConveyorBelt(nullptr) {}
  ~CSteamTV_HomePageTemplate_ConveyorBelt() override;
  explicit constexpr CSteamTV_HomePageTemplate_ConveyorBelt(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_ConveyorBelt(const CSteamTV_HomePageTemplate_ConveyorBelt& from);
  CSteamTV_HomePageTemplate_ConveyorBelt(CSteamTV_HomePageTemplate_ConveyorBelt&& from) noexcept
    : CSteamTV_HomePageTemplate_ConveyorBelt() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_ConveyorBelt& operator=(const CSteamTV_HomePageTemplate_ConveyorBelt& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_ConveyorBelt& operator=(CSteamTV_HomePageTemplate_ConveyorBelt&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_ConveyorBelt& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_ConveyorBelt* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_ConveyorBelt*>(
               &_CSteamTV_HomePageTemplate_ConveyorBelt_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(CSteamTV_HomePageTemplate_ConveyorBelt& a, CSteamTV_HomePageTemplate_ConveyorBelt& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_ConveyorBelt* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_ConveyorBelt* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_ConveyorBelt* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_ConveyorBelt>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_ConveyorBelt& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_ConveyorBelt& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_ConveyorBelt* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_ConveyorBelt";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_ConveyorBelt(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastsFieldNumber = 1,
    kTitleFieldNumber = 2,
  };
  // repeated .GetBroadcastChannelEntry broadcasts = 1;
  int broadcasts_size() const;
  private:
  int _internal_broadcasts_size() const;
  public:
  void clear_broadcasts();
  ::GetBroadcastChannelEntry* mutable_broadcasts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
      mutable_broadcasts();
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcasts(int index) const;
  ::GetBroadcastChannelEntry* _internal_add_broadcasts();
  public:
  const ::GetBroadcastChannelEntry& broadcasts(int index) const;
  ::GetBroadcastChannelEntry* add_broadcasts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
      broadcasts() const;

  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_ConveyorBelt)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry > broadcasts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_WatchParty final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_WatchParty) */ {
 public:
  inline CSteamTV_HomePageTemplate_WatchParty() : CSteamTV_HomePageTemplate_WatchParty(nullptr) {}
  ~CSteamTV_HomePageTemplate_WatchParty() override;
  explicit constexpr CSteamTV_HomePageTemplate_WatchParty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_WatchParty(const CSteamTV_HomePageTemplate_WatchParty& from);
  CSteamTV_HomePageTemplate_WatchParty(CSteamTV_HomePageTemplate_WatchParty&& from) noexcept
    : CSteamTV_HomePageTemplate_WatchParty() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_WatchParty& operator=(const CSteamTV_HomePageTemplate_WatchParty& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_WatchParty& operator=(CSteamTV_HomePageTemplate_WatchParty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_WatchParty& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_WatchParty* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_WatchParty*>(
               &_CSteamTV_HomePageTemplate_WatchParty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(CSteamTV_HomePageTemplate_WatchParty& a, CSteamTV_HomePageTemplate_WatchParty& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_WatchParty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_WatchParty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_WatchParty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_WatchParty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_WatchParty& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_WatchParty& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_WatchParty* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_WatchParty";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_WatchParty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kBroadcastFieldNumber = 1,
    kChatGroupIdFieldNumber = 3,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .GetBroadcastChannelEntry broadcast = 1;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::GetBroadcastChannelEntry& broadcast() const;
  PROTOBUF_NODISCARD ::GetBroadcastChannelEntry* release_broadcast();
  ::GetBroadcastChannelEntry* mutable_broadcast();
  void set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast);
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcast() const;
  ::GetBroadcastChannelEntry* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::GetBroadcastChannelEntry* broadcast);
  ::GetBroadcastChannelEntry* unsafe_arena_release_broadcast();

  // optional uint64 chat_group_id = 3;
  bool has_chat_group_id() const;
  private:
  bool _internal_has_chat_group_id() const;
  public:
  void clear_chat_group_id();
  uint64_t chat_group_id() const;
  void set_chat_group_id(uint64_t value);
  private:
  uint64_t _internal_chat_group_id() const;
  void _internal_set_chat_group_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_WatchParty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::GetBroadcastChannelEntry* broadcast_;
  uint64_t chat_group_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_Developer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_Developer) */ {
 public:
  inline CSteamTV_HomePageTemplate_Developer() : CSteamTV_HomePageTemplate_Developer(nullptr) {}
  ~CSteamTV_HomePageTemplate_Developer() override;
  explicit constexpr CSteamTV_HomePageTemplate_Developer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_Developer(const CSteamTV_HomePageTemplate_Developer& from);
  CSteamTV_HomePageTemplate_Developer(CSteamTV_HomePageTemplate_Developer&& from) noexcept
    : CSteamTV_HomePageTemplate_Developer() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_Developer& operator=(const CSteamTV_HomePageTemplate_Developer& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_Developer& operator=(CSteamTV_HomePageTemplate_Developer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_Developer& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_Developer* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_Developer*>(
               &_CSteamTV_HomePageTemplate_Developer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(CSteamTV_HomePageTemplate_Developer& a, CSteamTV_HomePageTemplate_Developer& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_Developer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_Developer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_Developer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_Developer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_Developer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_Developer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_Developer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_Developer";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_Developer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 2,
    kBroadcastFieldNumber = 1,
  };
  // optional string title = 2;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional .GetBroadcastChannelEntry broadcast = 1;
  bool has_broadcast() const;
  private:
  bool _internal_has_broadcast() const;
  public:
  void clear_broadcast();
  const ::GetBroadcastChannelEntry& broadcast() const;
  PROTOBUF_NODISCARD ::GetBroadcastChannelEntry* release_broadcast();
  ::GetBroadcastChannelEntry* mutable_broadcast();
  void set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast);
  private:
  const ::GetBroadcastChannelEntry& _internal_broadcast() const;
  ::GetBroadcastChannelEntry* _internal_mutable_broadcast();
  public:
  void unsafe_arena_set_allocated_broadcast(
      ::GetBroadcastChannelEntry* broadcast);
  ::GetBroadcastChannelEntry* unsafe_arena_release_broadcast();

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_Developer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::GetBroadcastChannelEntry* broadcast_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageTemplate_Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageTemplate_Event) */ {
 public:
  inline CSteamTV_HomePageTemplate_Event() : CSteamTV_HomePageTemplate_Event(nullptr) {}
  ~CSteamTV_HomePageTemplate_Event() override;
  explicit constexpr CSteamTV_HomePageTemplate_Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageTemplate_Event(const CSteamTV_HomePageTemplate_Event& from);
  CSteamTV_HomePageTemplate_Event(CSteamTV_HomePageTemplate_Event&& from) noexcept
    : CSteamTV_HomePageTemplate_Event() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageTemplate_Event& operator=(const CSteamTV_HomePageTemplate_Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageTemplate_Event& operator=(CSteamTV_HomePageTemplate_Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageTemplate_Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageTemplate_Event* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageTemplate_Event*>(
               &_CSteamTV_HomePageTemplate_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(CSteamTV_HomePageTemplate_Event& a, CSteamTV_HomePageTemplate_Event& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageTemplate_Event* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageTemplate_Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageTemplate_Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageTemplate_Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageTemplate_Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageTemplate_Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageTemplate_Event* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageTemplate_Event";
  }
  protected:
  explicit CSteamTV_HomePageTemplate_Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTitleFieldNumber = 1,
  };
  // optional string title = 1;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageTemplate_Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_HomePageContentRow final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_HomePageContentRow) */ {
 public:
  inline CSteamTV_HomePageContentRow() : CSteamTV_HomePageContentRow(nullptr) {}
  ~CSteamTV_HomePageContentRow() override;
  explicit constexpr CSteamTV_HomePageContentRow(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_HomePageContentRow(const CSteamTV_HomePageContentRow& from);
  CSteamTV_HomePageContentRow(CSteamTV_HomePageContentRow&& from) noexcept
    : CSteamTV_HomePageContentRow() {
    *this = ::std::move(from);
  }

  inline CSteamTV_HomePageContentRow& operator=(const CSteamTV_HomePageContentRow& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_HomePageContentRow& operator=(CSteamTV_HomePageContentRow&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_HomePageContentRow& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_HomePageContentRow* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_HomePageContentRow*>(
               &_CSteamTV_HomePageContentRow_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(CSteamTV_HomePageContentRow& a, CSteamTV_HomePageContentRow& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_HomePageContentRow* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_HomePageContentRow* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_HomePageContentRow* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_HomePageContentRow>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_HomePageContentRow& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_HomePageContentRow& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_HomePageContentRow* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_HomePageContentRow";
  }
  protected:
  explicit CSteamTV_HomePageContentRow(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTakeoverFieldNumber = 2,
    kSingleGameFieldNumber = 3,
    kGameListFieldNumber = 4,
    kQuickExploreFieldNumber = 5,
    kConveyorBeltFieldNumber = 6,
    kWatchPartyFieldNumber = 7,
    kDeveloperFieldNumber = 8,
    kEventFieldNumber = 9,
    kTemplateTypeFieldNumber = 1,
  };
  // optional .CSteamTV_HomePageTemplate_Takeover takeover = 2;
  bool has_takeover() const;
  private:
  bool _internal_has_takeover() const;
  public:
  void clear_takeover();
  const ::CSteamTV_HomePageTemplate_Takeover& takeover() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_Takeover* release_takeover();
  ::CSteamTV_HomePageTemplate_Takeover* mutable_takeover();
  void set_allocated_takeover(::CSteamTV_HomePageTemplate_Takeover* takeover);
  private:
  const ::CSteamTV_HomePageTemplate_Takeover& _internal_takeover() const;
  ::CSteamTV_HomePageTemplate_Takeover* _internal_mutable_takeover();
  public:
  void unsafe_arena_set_allocated_takeover(
      ::CSteamTV_HomePageTemplate_Takeover* takeover);
  ::CSteamTV_HomePageTemplate_Takeover* unsafe_arena_release_takeover();

  // optional .CSteamTV_HomePageTemplate_SingleGame single_game = 3;
  bool has_single_game() const;
  private:
  bool _internal_has_single_game() const;
  public:
  void clear_single_game();
  const ::CSteamTV_HomePageTemplate_SingleGame& single_game() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_SingleGame* release_single_game();
  ::CSteamTV_HomePageTemplate_SingleGame* mutable_single_game();
  void set_allocated_single_game(::CSteamTV_HomePageTemplate_SingleGame* single_game);
  private:
  const ::CSteamTV_HomePageTemplate_SingleGame& _internal_single_game() const;
  ::CSteamTV_HomePageTemplate_SingleGame* _internal_mutable_single_game();
  public:
  void unsafe_arena_set_allocated_single_game(
      ::CSteamTV_HomePageTemplate_SingleGame* single_game);
  ::CSteamTV_HomePageTemplate_SingleGame* unsafe_arena_release_single_game();

  // optional .CSteamTV_HomePageTemplate_GameList game_list = 4;
  bool has_game_list() const;
  private:
  bool _internal_has_game_list() const;
  public:
  void clear_game_list();
  const ::CSteamTV_HomePageTemplate_GameList& game_list() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_GameList* release_game_list();
  ::CSteamTV_HomePageTemplate_GameList* mutable_game_list();
  void set_allocated_game_list(::CSteamTV_HomePageTemplate_GameList* game_list);
  private:
  const ::CSteamTV_HomePageTemplate_GameList& _internal_game_list() const;
  ::CSteamTV_HomePageTemplate_GameList* _internal_mutable_game_list();
  public:
  void unsafe_arena_set_allocated_game_list(
      ::CSteamTV_HomePageTemplate_GameList* game_list);
  ::CSteamTV_HomePageTemplate_GameList* unsafe_arena_release_game_list();

  // optional .CSteamTV_HomePageTemplate_QuickExplore quick_explore = 5;
  bool has_quick_explore() const;
  private:
  bool _internal_has_quick_explore() const;
  public:
  void clear_quick_explore();
  const ::CSteamTV_HomePageTemplate_QuickExplore& quick_explore() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_QuickExplore* release_quick_explore();
  ::CSteamTV_HomePageTemplate_QuickExplore* mutable_quick_explore();
  void set_allocated_quick_explore(::CSteamTV_HomePageTemplate_QuickExplore* quick_explore);
  private:
  const ::CSteamTV_HomePageTemplate_QuickExplore& _internal_quick_explore() const;
  ::CSteamTV_HomePageTemplate_QuickExplore* _internal_mutable_quick_explore();
  public:
  void unsafe_arena_set_allocated_quick_explore(
      ::CSteamTV_HomePageTemplate_QuickExplore* quick_explore);
  ::CSteamTV_HomePageTemplate_QuickExplore* unsafe_arena_release_quick_explore();

  // optional .CSteamTV_HomePageTemplate_ConveyorBelt conveyor_belt = 6;
  bool has_conveyor_belt() const;
  private:
  bool _internal_has_conveyor_belt() const;
  public:
  void clear_conveyor_belt();
  const ::CSteamTV_HomePageTemplate_ConveyorBelt& conveyor_belt() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_ConveyorBelt* release_conveyor_belt();
  ::CSteamTV_HomePageTemplate_ConveyorBelt* mutable_conveyor_belt();
  void set_allocated_conveyor_belt(::CSteamTV_HomePageTemplate_ConveyorBelt* conveyor_belt);
  private:
  const ::CSteamTV_HomePageTemplate_ConveyorBelt& _internal_conveyor_belt() const;
  ::CSteamTV_HomePageTemplate_ConveyorBelt* _internal_mutable_conveyor_belt();
  public:
  void unsafe_arena_set_allocated_conveyor_belt(
      ::CSteamTV_HomePageTemplate_ConveyorBelt* conveyor_belt);
  ::CSteamTV_HomePageTemplate_ConveyorBelt* unsafe_arena_release_conveyor_belt();

  // optional .CSteamTV_HomePageTemplate_WatchParty watch_party = 7;
  bool has_watch_party() const;
  private:
  bool _internal_has_watch_party() const;
  public:
  void clear_watch_party();
  const ::CSteamTV_HomePageTemplate_WatchParty& watch_party() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_WatchParty* release_watch_party();
  ::CSteamTV_HomePageTemplate_WatchParty* mutable_watch_party();
  void set_allocated_watch_party(::CSteamTV_HomePageTemplate_WatchParty* watch_party);
  private:
  const ::CSteamTV_HomePageTemplate_WatchParty& _internal_watch_party() const;
  ::CSteamTV_HomePageTemplate_WatchParty* _internal_mutable_watch_party();
  public:
  void unsafe_arena_set_allocated_watch_party(
      ::CSteamTV_HomePageTemplate_WatchParty* watch_party);
  ::CSteamTV_HomePageTemplate_WatchParty* unsafe_arena_release_watch_party();

  // optional .CSteamTV_HomePageTemplate_Developer developer = 8;
  bool has_developer() const;
  private:
  bool _internal_has_developer() const;
  public:
  void clear_developer();
  const ::CSteamTV_HomePageTemplate_Developer& developer() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_Developer* release_developer();
  ::CSteamTV_HomePageTemplate_Developer* mutable_developer();
  void set_allocated_developer(::CSteamTV_HomePageTemplate_Developer* developer);
  private:
  const ::CSteamTV_HomePageTemplate_Developer& _internal_developer() const;
  ::CSteamTV_HomePageTemplate_Developer* _internal_mutable_developer();
  public:
  void unsafe_arena_set_allocated_developer(
      ::CSteamTV_HomePageTemplate_Developer* developer);
  ::CSteamTV_HomePageTemplate_Developer* unsafe_arena_release_developer();

  // optional .CSteamTV_HomePageTemplate_Event event = 9;
  bool has_event() const;
  private:
  bool _internal_has_event() const;
  public:
  void clear_event();
  const ::CSteamTV_HomePageTemplate_Event& event() const;
  PROTOBUF_NODISCARD ::CSteamTV_HomePageTemplate_Event* release_event();
  ::CSteamTV_HomePageTemplate_Event* mutable_event();
  void set_allocated_event(::CSteamTV_HomePageTemplate_Event* event);
  private:
  const ::CSteamTV_HomePageTemplate_Event& _internal_event() const;
  ::CSteamTV_HomePageTemplate_Event* _internal_mutable_event();
  public:
  void unsafe_arena_set_allocated_event(
      ::CSteamTV_HomePageTemplate_Event* event);
  ::CSteamTV_HomePageTemplate_Event* unsafe_arena_release_event();

  // optional .ESteamTVContentTemplate template_type = 1 [default = k_ESteamTVContentTemplate_Invalid];
  bool has_template_type() const;
  private:
  bool _internal_has_template_type() const;
  public:
  void clear_template_type();
  ::ESteamTVContentTemplate template_type() const;
  void set_template_type(::ESteamTVContentTemplate value);
  private:
  ::ESteamTVContentTemplate _internal_template_type() const;
  void _internal_set_template_type(::ESteamTVContentTemplate value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_HomePageContentRow)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CSteamTV_HomePageTemplate_Takeover* takeover_;
  ::CSteamTV_HomePageTemplate_SingleGame* single_game_;
  ::CSteamTV_HomePageTemplate_GameList* game_list_;
  ::CSteamTV_HomePageTemplate_QuickExplore* quick_explore_;
  ::CSteamTV_HomePageTemplate_ConveyorBelt* conveyor_belt_;
  ::CSteamTV_HomePageTemplate_WatchParty* watch_party_;
  ::CSteamTV_HomePageTemplate_Developer* developer_;
  ::CSteamTV_HomePageTemplate_Event* event_;
  int template_type_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_GetHomePageContents_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_GetHomePageContents_Response) */ {
 public:
  inline CSteamTV_GetHomePageContents_Response() : CSteamTV_GetHomePageContents_Response(nullptr) {}
  ~CSteamTV_GetHomePageContents_Response() override;
  explicit constexpr CSteamTV_GetHomePageContents_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_GetHomePageContents_Response(const CSteamTV_GetHomePageContents_Response& from);
  CSteamTV_GetHomePageContents_Response(CSteamTV_GetHomePageContents_Response&& from) noexcept
    : CSteamTV_GetHomePageContents_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_GetHomePageContents_Response& operator=(const CSteamTV_GetHomePageContents_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_GetHomePageContents_Response& operator=(CSteamTV_GetHomePageContents_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_GetHomePageContents_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_GetHomePageContents_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_GetHomePageContents_Response*>(
               &_CSteamTV_GetHomePageContents_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(CSteamTV_GetHomePageContents_Response& a, CSteamTV_GetHomePageContents_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_GetHomePageContents_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_GetHomePageContents_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_GetHomePageContents_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_GetHomePageContents_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_GetHomePageContents_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_GetHomePageContents_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_GetHomePageContents_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_GetHomePageContents_Response";
  }
  protected:
  explicit CSteamTV_GetHomePageContents_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRowsFieldNumber = 1,
  };
  // repeated .CSteamTV_HomePageContentRow rows = 1;
  int rows_size() const;
  private:
  int _internal_rows_size() const;
  public:
  void clear_rows();
  ::CSteamTV_HomePageContentRow* mutable_rows(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_HomePageContentRow >*
      mutable_rows();
  private:
  const ::CSteamTV_HomePageContentRow& _internal_rows(int index) const;
  ::CSteamTV_HomePageContentRow* _internal_add_rows();
  public:
  const ::CSteamTV_HomePageContentRow& rows(int index) const;
  ::CSteamTV_HomePageContentRow* add_rows();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_HomePageContentRow >&
      rows() const;

  // @@protoc_insertion_point(class_scope:CSteamTV_GetHomePageContents_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_HomePageContentRow > rows_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AppCheer_SingleCheerType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AppCheer_SingleCheerType) */ {
 public:
  inline CSteamTV_AppCheer_SingleCheerType() : CSteamTV_AppCheer_SingleCheerType(nullptr) {}
  ~CSteamTV_AppCheer_SingleCheerType() override;
  explicit constexpr CSteamTV_AppCheer_SingleCheerType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AppCheer_SingleCheerType(const CSteamTV_AppCheer_SingleCheerType& from);
  CSteamTV_AppCheer_SingleCheerType(CSteamTV_AppCheer_SingleCheerType&& from) noexcept
    : CSteamTV_AppCheer_SingleCheerType() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AppCheer_SingleCheerType& operator=(const CSteamTV_AppCheer_SingleCheerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AppCheer_SingleCheerType& operator=(CSteamTV_AppCheer_SingleCheerType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AppCheer_SingleCheerType& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AppCheer_SingleCheerType* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AppCheer_SingleCheerType*>(
               &_CSteamTV_AppCheer_SingleCheerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(CSteamTV_AppCheer_SingleCheerType& a, CSteamTV_AppCheer_SingleCheerType& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AppCheer_SingleCheerType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AppCheer_SingleCheerType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AppCheer_SingleCheerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AppCheer_SingleCheerType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AppCheer_SingleCheerType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AppCheer_SingleCheerType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AppCheer_SingleCheerType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AppCheer_SingleCheerType";
  }
  protected:
  explicit CSteamTV_AppCheer_SingleCheerType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheerTypeFieldNumber = 1,
    kCheerAmountFieldNumber = 2,
  };
  // optional uint32 cheer_type = 1 [(.description) = "The type of cheer. App dependent (different teams, heroes, players, etc)"];
  bool has_cheer_type() const;
  private:
  bool _internal_has_cheer_type() const;
  public:
  void clear_cheer_type();
  uint32_t cheer_type() const;
  void set_cheer_type(uint32_t value);
  private:
  uint32_t _internal_cheer_type() const;
  void _internal_set_cheer_type(uint32_t value);
  public:

  // optional uint32 cheer_amount = 2 [(.description) = "The amount of cheers."];
  bool has_cheer_amount() const;
  private:
  bool _internal_has_cheer_amount() const;
  public:
  void clear_cheer_amount();
  uint32_t cheer_amount() const;
  void set_cheer_amount(uint32_t value);
  private:
  uint32_t _internal_cheer_amount() const;
  void _internal_set_cheer_amount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AppCheer_SingleCheerType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t cheer_type_;
  uint32_t cheer_amount_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AppCheer_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AppCheer_Request) */ {
 public:
  inline CSteamTV_AppCheer_Request() : CSteamTV_AppCheer_Request(nullptr) {}
  ~CSteamTV_AppCheer_Request() override;
  explicit constexpr CSteamTV_AppCheer_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AppCheer_Request(const CSteamTV_AppCheer_Request& from);
  CSteamTV_AppCheer_Request(CSteamTV_AppCheer_Request&& from) noexcept
    : CSteamTV_AppCheer_Request() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AppCheer_Request& operator=(const CSteamTV_AppCheer_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AppCheer_Request& operator=(CSteamTV_AppCheer_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AppCheer_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AppCheer_Request* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AppCheer_Request*>(
               &_CSteamTV_AppCheer_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(CSteamTV_AppCheer_Request& a, CSteamTV_AppCheer_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AppCheer_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AppCheer_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AppCheer_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AppCheer_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AppCheer_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AppCheer_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AppCheer_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AppCheer_Request";
  }
  protected:
  explicit CSteamTV_AppCheer_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCheersFieldNumber = 3,
    kCheerTargetIdFieldNumber = 2,
    kAppIdFieldNumber = 1,
  };
  // repeated .CSteamTV_AppCheer_SingleCheerType cheers = 3 [(.description) = "The set of cheers this request represents (could be multiple of different types)."];
  int cheers_size() const;
  private:
  int _internal_cheers_size() const;
  public:
  void clear_cheers();
  ::CSteamTV_AppCheer_SingleCheerType* mutable_cheers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_AppCheer_SingleCheerType >*
      mutable_cheers();
  private:
  const ::CSteamTV_AppCheer_SingleCheerType& _internal_cheers(int index) const;
  ::CSteamTV_AppCheer_SingleCheerType* _internal_add_cheers();
  public:
  const ::CSteamTV_AppCheer_SingleCheerType& cheers(int index) const;
  ::CSteamTV_AppCheer_SingleCheerType* add_cheers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_AppCheer_SingleCheerType >&
      cheers() const;

  // optional fixed64 cheer_target_id = 2 [(.description) = "The thing being cheered on. ID is app dependent (could be steam id, match id, lobby id, server id, etc)."];
  bool has_cheer_target_id() const;
  private:
  bool _internal_has_cheer_target_id() const;
  public:
  void clear_cheer_target_id();
  uint64_t cheer_target_id() const;
  void set_cheer_target_id(uint64_t value);
  private:
  uint64_t _internal_cheer_target_id() const;
  void _internal_set_cheer_target_id(uint64_t value);
  public:

  // optional uint32 app_id = 1 [(.description) = "App ID this cheer is for."];
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AppCheer_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_AppCheer_SingleCheerType > cheers_;
  uint64_t cheer_target_id_;
  uint32_t app_id_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CSteamTV_AppCheer_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSteamTV_AppCheer_Response) */ {
 public:
  inline CSteamTV_AppCheer_Response() : CSteamTV_AppCheer_Response(nullptr) {}
  ~CSteamTV_AppCheer_Response() override;
  explicit constexpr CSteamTV_AppCheer_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSteamTV_AppCheer_Response(const CSteamTV_AppCheer_Response& from);
  CSteamTV_AppCheer_Response(CSteamTV_AppCheer_Response&& from) noexcept
    : CSteamTV_AppCheer_Response() {
    *this = ::std::move(from);
  }

  inline CSteamTV_AppCheer_Response& operator=(const CSteamTV_AppCheer_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSteamTV_AppCheer_Response& operator=(CSteamTV_AppCheer_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSteamTV_AppCheer_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSteamTV_AppCheer_Response* internal_default_instance() {
    return reinterpret_cast<const CSteamTV_AppCheer_Response*>(
               &_CSteamTV_AppCheer_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(CSteamTV_AppCheer_Response& a, CSteamTV_AppCheer_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CSteamTV_AppCheer_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSteamTV_AppCheer_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSteamTV_AppCheer_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSteamTV_AppCheer_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSteamTV_AppCheer_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSteamTV_AppCheer_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSteamTV_AppCheer_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSteamTV_AppCheer_Response";
  }
  protected:
  explicit CSteamTV_AppCheer_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAggregationDelayMsFieldNumber = 1,
  };
  // optional uint32 aggregation_delay_ms = 1 [(.description) = "The amount of time in milliseconds that the client should aggregate cheers before sending them. The server can control this dynamically to ask clients to slow down sending."];
  bool has_aggregation_delay_ms() const;
  private:
  bool _internal_has_aggregation_delay_ms() const;
  public:
  void clear_aggregation_delay_ms();
  uint32_t aggregation_delay_ms() const;
  void set_aggregation_delay_ms(uint32_t value);
  private:
  uint32_t _internal_aggregation_delay_ms() const;
  void _internal_set_aggregation_delay_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSteamTV_AppCheer_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t aggregation_delay_ms_;
  friend struct ::TableStruct_steammessages_5fsteamtv_2esteamclient_2eproto;
};
// ===================================================================

class SteamTV_Stub;

class SteamTV : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline SteamTV() {};
 public:
  virtual ~SteamTV();

  typedef SteamTV_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void CreateBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_CreateBroadcastChannel_Request* request,
                       ::CSteamTV_CreateBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelID_Request* request,
                       ::CSteamTV_GetBroadcastChannelID_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SetBroadcastChannelProfile(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelProfile_Request* request,
                       ::CSteamTV_SetBroadcastChannelProfile_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelProfile(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelProfile_Request* request,
                       ::CSteamTV_GetBroadcastChannelProfile_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SetBroadcastChannelImage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelImage_Request* request,
                       ::CSteamTV_SetBroadcastChannelImage_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelImages(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelImages_Request* request,
                       ::CSteamTV_GetBroadcastChannelImages_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SetBroadcastChannelLinkRegions(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelLinkRegions_Request* request,
                       ::CSteamTV_SetBroadcastChannelLinkRegions_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelLinks(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelLinks_Request* request,
                       ::CSteamTV_GetBroadcastChannelLinks_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelBroadcasters(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelBroadcasters_Request* request,
                       ::CSteamTV_GetBroadcastChannelBroadcasters_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetFollowedChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetFollowedChannels_Request* request,
                       ::CSteamTV_GetFollowedChannels_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetSubscribedChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetSubscribedChannels_Request* request,
                       ::CSteamTV_GetSubscribedChannels_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelStatus_Request* request,
                       ::CSteamTV_GetBroadcastChannelStatus_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void FollowBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_FollowBroadcastChannel_Request* request,
                       ::CSteamTV_FollowBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SubscribeBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SubscribeBroadcastChannel_Request* request,
                       ::CSteamTV_SubscribeBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelClips(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelClips_Request* request,
                       ::CSteamTV_GetBroadcastChannelClips_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void ReportBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_ReportBroadcastChannel_Request* request,
                       ::CSteamTV_ReportBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetBroadcastChannelInteraction(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelInteraction_Request* request,
                       ::CSteamTV_GetBroadcastChannelInteraction_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetGames(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetGames_Request* request,
                       ::CSteamTV_GetGames_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChannels_Request* request,
                       ::CSteamTV_GetChannels_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void AddChatBan(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddChatBan_Request* request,
                       ::CSteamTV_AddChatBan_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetChatBans(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChatBans_Request* request,
                       ::CSteamTV_GetChatBans_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void AddChatModerator(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddChatModerator_Request* request,
                       ::CSteamTV_AddChatModerator_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetChatModerators(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChatModerators_Request* request,
                       ::CSteamTV_GetChatModerators_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void AddWordBan(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddWordBan_Request* request,
                       ::CSteamTV_AddWordBan_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetWordBans(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetWordBans_Request* request,
                       ::CSteamTV_GetWordBans_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void JoinChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_JoinChat_Request* request,
                       ::CSteamTV_JoinChat_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void Search(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_Search_Request* request,
                       ::CSteamTV_Search_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetSteamTVUserSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetSteamTVUserSettings_Request* request,
                       ::CSteamTV_GetSteamTVUserSettings_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void SetSteamTVUserSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetSteamTVUserSettings_Request* request,
                       ::CSteamTV_SetSteamTVUserSettings_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetMyBroadcastChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetMyBroadcastChannels_Request* request,
                       ::CSteamTV_GetMyBroadcastChannels_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetHomePageContents(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetHomePageContents_Request* request,
                       ::CSteamTV_GetHomePageContents_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void AppCheer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AppCheer_Request* request,
                       ::CSteamTV_AppCheer_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SteamTV);
};

class SteamTV_Stub : public SteamTV {
 public:
  SteamTV_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  SteamTV_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~SteamTV_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements SteamTV ------------------------------------------

  void CreateBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_CreateBroadcastChannel_Request* request,
                       ::CSteamTV_CreateBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelID_Request* request,
                       ::CSteamTV_GetBroadcastChannelID_Response* response,
                       ::google::protobuf::Closure* done);
  void SetBroadcastChannelProfile(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelProfile_Request* request,
                       ::CSteamTV_SetBroadcastChannelProfile_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelProfile(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelProfile_Request* request,
                       ::CSteamTV_GetBroadcastChannelProfile_Response* response,
                       ::google::protobuf::Closure* done);
  void SetBroadcastChannelImage(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelImage_Request* request,
                       ::CSteamTV_SetBroadcastChannelImage_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelImages(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelImages_Request* request,
                       ::CSteamTV_GetBroadcastChannelImages_Response* response,
                       ::google::protobuf::Closure* done);
  void SetBroadcastChannelLinkRegions(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetBroadcastChannelLinkRegions_Request* request,
                       ::CSteamTV_SetBroadcastChannelLinkRegions_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelLinks(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelLinks_Request* request,
                       ::CSteamTV_GetBroadcastChannelLinks_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelBroadcasters(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelBroadcasters_Request* request,
                       ::CSteamTV_GetBroadcastChannelBroadcasters_Response* response,
                       ::google::protobuf::Closure* done);
  void GetFollowedChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetFollowedChannels_Request* request,
                       ::CSteamTV_GetFollowedChannels_Response* response,
                       ::google::protobuf::Closure* done);
  void GetSubscribedChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetSubscribedChannels_Request* request,
                       ::CSteamTV_GetSubscribedChannels_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelStatus_Request* request,
                       ::CSteamTV_GetBroadcastChannelStatus_Response* response,
                       ::google::protobuf::Closure* done);
  void FollowBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_FollowBroadcastChannel_Request* request,
                       ::CSteamTV_FollowBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  void SubscribeBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SubscribeBroadcastChannel_Request* request,
                       ::CSteamTV_SubscribeBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelClips(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelClips_Request* request,
                       ::CSteamTV_GetBroadcastChannelClips_Response* response,
                       ::google::protobuf::Closure* done);
  void ReportBroadcastChannel(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_ReportBroadcastChannel_Request* request,
                       ::CSteamTV_ReportBroadcastChannel_Response* response,
                       ::google::protobuf::Closure* done);
  void GetBroadcastChannelInteraction(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetBroadcastChannelInteraction_Request* request,
                       ::CSteamTV_GetBroadcastChannelInteraction_Response* response,
                       ::google::protobuf::Closure* done);
  void GetGames(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetGames_Request* request,
                       ::CSteamTV_GetGames_Response* response,
                       ::google::protobuf::Closure* done);
  void GetChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChannels_Request* request,
                       ::CSteamTV_GetChannels_Response* response,
                       ::google::protobuf::Closure* done);
  void AddChatBan(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddChatBan_Request* request,
                       ::CSteamTV_AddChatBan_Response* response,
                       ::google::protobuf::Closure* done);
  void GetChatBans(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChatBans_Request* request,
                       ::CSteamTV_GetChatBans_Response* response,
                       ::google::protobuf::Closure* done);
  void AddChatModerator(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddChatModerator_Request* request,
                       ::CSteamTV_AddChatModerator_Response* response,
                       ::google::protobuf::Closure* done);
  void GetChatModerators(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetChatModerators_Request* request,
                       ::CSteamTV_GetChatModerators_Response* response,
                       ::google::protobuf::Closure* done);
  void AddWordBan(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AddWordBan_Request* request,
                       ::CSteamTV_AddWordBan_Response* response,
                       ::google::protobuf::Closure* done);
  void GetWordBans(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetWordBans_Request* request,
                       ::CSteamTV_GetWordBans_Response* response,
                       ::google::protobuf::Closure* done);
  void JoinChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_JoinChat_Request* request,
                       ::CSteamTV_JoinChat_Response* response,
                       ::google::protobuf::Closure* done);
  void Search(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_Search_Request* request,
                       ::CSteamTV_Search_Response* response,
                       ::google::protobuf::Closure* done);
  void GetSteamTVUserSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetSteamTVUserSettings_Request* request,
                       ::CSteamTV_GetSteamTVUserSettings_Response* response,
                       ::google::protobuf::Closure* done);
  void SetSteamTVUserSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_SetSteamTVUserSettings_Request* request,
                       ::CSteamTV_SetSteamTVUserSettings_Response* response,
                       ::google::protobuf::Closure* done);
  void GetMyBroadcastChannels(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetMyBroadcastChannels_Request* request,
                       ::CSteamTV_GetMyBroadcastChannels_Response* response,
                       ::google::protobuf::Closure* done);
  void GetHomePageContents(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_GetHomePageContents_Request* request,
                       ::CSteamTV_GetHomePageContents_Response* response,
                       ::google::protobuf::Closure* done);
  void AppCheer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CSteamTV_AppCheer_Request* request,
                       ::CSteamTV_AppCheer_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(SteamTV_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CSteamTV_CreateBroadcastChannel_Request

// optional string unique_name = 1 [(.description) = "Unique short broadcast channel name, part of Steam.TV URL"];
inline bool CSteamTV_CreateBroadcastChannel_Request::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_CreateBroadcastChannel_Request::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void CSteamTV_CreateBroadcastChannel_Request::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_CreateBroadcastChannel_Request::unique_name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_CreateBroadcastChannel_Request.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_CreateBroadcastChannel_Request::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_CreateBroadcastChannel_Request.unique_name)
}
inline std::string* CSteamTV_CreateBroadcastChannel_Request::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_CreateBroadcastChannel_Request.unique_name)
  return _s;
}
inline const std::string& CSteamTV_CreateBroadcastChannel_Request::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void CSteamTV_CreateBroadcastChannel_Request::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_CreateBroadcastChannel_Request::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000001u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_CreateBroadcastChannel_Request::release_unique_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_CreateBroadcastChannel_Request.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_CreateBroadcastChannel_Request::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_CreateBroadcastChannel_Request.unique_name)
}

// -------------------------------------------------------------------

// CSteamTV_CreateBroadcastChannel_Response

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
inline bool CSteamTV_CreateBroadcastChannel_Response::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_CreateBroadcastChannel_Response::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_CreateBroadcastChannel_Response::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_CreateBroadcastChannel_Response::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_CreateBroadcastChannel_Response::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_CreateBroadcastChannel_Response.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_CreateBroadcastChannel_Response::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_CreateBroadcastChannel_Response::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_CreateBroadcastChannel_Response.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelID_Request

// optional string unique_name = 1 [(.description) = "Channel short name)"];
inline bool CSteamTV_GetBroadcastChannelID_Request::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelID_Request::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void CSteamTV_GetBroadcastChannelID_Request::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelID_Request::unique_name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelID_Request.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelID_Request::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelID_Request.unique_name)
}
inline std::string* CSteamTV_GetBroadcastChannelID_Request::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelID_Request.unique_name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelID_Request::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void CSteamTV_GetBroadcastChannelID_Request::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelID_Request::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000001u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelID_Request::release_unique_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelID_Request.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelID_Request::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelID_Request.unique_name)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelID_Response

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
inline bool CSteamTV_GetBroadcastChannelID_Response::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelID_Response::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelID_Response::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_GetBroadcastChannelID_Response::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelID_Response::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelID_Response.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelID_Response::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelID_Response::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelID_Response.broadcast_channel_id)
}

// optional string unique_name = 2 [(.description) = "Broadcast channel name"];
inline bool CSteamTV_GetBroadcastChannelID_Response::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelID_Response::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void CSteamTV_GetBroadcastChannelID_Response::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelID_Response::unique_name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelID_Response.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelID_Response::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelID_Response.unique_name)
}
inline std::string* CSteamTV_GetBroadcastChannelID_Response::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelID_Response.unique_name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelID_Response::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void CSteamTV_GetBroadcastChannelID_Response::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelID_Response::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000001u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelID_Response::release_unique_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelID_Response.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelID_Response::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelID_Response.unique_name)
}

// optional fixed64 steamid = 3 [(.description) = "Broadcast channel owner"];
inline bool CSteamTV_GetBroadcastChannelID_Response::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelID_Response::has_steamid() const {
  return _internal_has_steamid();
}
inline void CSteamTV_GetBroadcastChannelID_Response::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_GetBroadcastChannelID_Response::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CSteamTV_GetBroadcastChannelID_Response::steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelID_Response.steamid)
  return _internal_steamid();
}
inline void CSteamTV_GetBroadcastChannelID_Response::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CSteamTV_GetBroadcastChannelID_Response::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelID_Response.steamid)
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelProfile_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t CSteamTV_SetBroadcastChannelProfile_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_SetBroadcastChannelProfile_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.broadcast_channel_id)
}

// optional string name = 2 [(.description) = "long channel name"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.name)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.name)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.name)
}

// optional string language = 3 [(.description) = "primary channel language (Steam shortname)"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_language() const {
  return _internal_has_language();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::language() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.language)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.language)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_language() const {
  return language_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000002u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_language() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.language)
}

// optional string headline = 4 [(.description) = "short channel desciption"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_headline() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_headline() const {
  return _internal_has_headline();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_headline() {
  headline_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::headline() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.headline)
  return _internal_headline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_headline(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.headline)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_headline() {
  std::string* _s = _internal_mutable_headline();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.headline)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_headline() const {
  return headline_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_headline(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_headline() {
  _has_bits_[0] |= 0x00000004u;
  return headline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_headline() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.headline)
  if (!_internal_has_headline()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = headline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_headline(std::string* headline) {
  if (headline != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  headline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.headline)
}

// optional string summary = 5 [(.description) = "long channel desciption"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_summary() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_summary() const {
  return _internal_has_summary();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_summary() {
  summary_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::summary() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_summary(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 summary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.summary)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.summary)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_summary() const {
  return summary_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_summary(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  summary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_summary() {
  _has_bits_[0] |= 0x00000008u;
  return summary_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_summary() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.summary)
  if (!_internal_has_summary()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = summary_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (summary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    summary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  summary_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), summary,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (summary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    summary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.summary)
}

// optional string avatar_hash = 6 [(.description) = "community avatar hash"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_avatar_hash() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_avatar_hash() const {
  return _internal_has_avatar_hash();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_avatar_hash() {
  avatar_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::avatar_hash() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
  return _internal_avatar_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_avatar_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 avatar_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_avatar_hash() {
  std::string* _s = _internal_mutable_avatar_hash();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_avatar_hash() const {
  return avatar_hash_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_avatar_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  avatar_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_avatar_hash() {
  _has_bits_[0] |= 0x00000010u;
  return avatar_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_avatar_hash() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
  if (!_internal_has_avatar_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = avatar_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_avatar_hash(std::string* avatar_hash) {
  if (avatar_hash != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  avatar_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.avatar_hash)
}

// optional string schedule = 7 [(.description) = "broadcast channel schedule"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_schedule() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_schedule() const {
  return _internal_has_schedule();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_schedule() {
  schedule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::schedule() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
  return _internal_schedule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_schedule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 schedule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_schedule() {
  std::string* _s = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_schedule() const {
  return schedule_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_schedule(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  schedule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_schedule() {
  _has_bits_[0] |= 0x00000020u;
  return schedule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_schedule() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
  if (!_internal_has_schedule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = schedule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schedule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schedule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_schedule(std::string* schedule) {
  if (schedule != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  schedule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schedule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schedule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schedule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.schedule)
}

// optional string rules = 8 [(.description) = "broadcast channel rules"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_rules() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_rules() const {
  return _internal_has_rules();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_rules() {
  rules_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::rules() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.rules)
  return _internal_rules();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_rules(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 rules_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.rules)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_rules() {
  std::string* _s = _internal_mutable_rules();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.rules)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_rules() const {
  return rules_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_rules(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  rules_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_rules() {
  _has_bits_[0] |= 0x00000040u;
  return rules_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_rules() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.rules)
  if (!_internal_has_rules()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = rules_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rules_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rules_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_rules(std::string* rules) {
  if (rules != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  rules_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rules,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rules_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rules_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.rules)
}

// optional string panels = 9 [(.description) = "JSON data representing the channel panel layout"];
inline bool CSteamTV_SetBroadcastChannelProfile_Request::_internal_has_panels() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelProfile_Request::has_panels() const {
  return _internal_has_panels();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::clear_panels() {
  panels_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::panels() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelProfile_Request.panels)
  return _internal_panels();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelProfile_Request::set_panels(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 panels_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelProfile_Request.panels)
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::mutable_panels() {
  std::string* _s = _internal_mutable_panels();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelProfile_Request.panels)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelProfile_Request::_internal_panels() const {
  return panels_.Get();
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::_internal_set_panels(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  panels_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::_internal_mutable_panels() {
  _has_bits_[0] |= 0x00000080u;
  return panels_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelProfile_Request::release_panels() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelProfile_Request.panels)
  if (!_internal_has_panels()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = panels_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (panels_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    panels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelProfile_Request::set_allocated_panels(std::string* panels) {
  if (panels != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  panels_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), panels,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (panels_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    panels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelProfile_Request.panels)
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelProfile_Response

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelProfile_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelProfile_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelProfile_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelProfile_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelProfile_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelProfile_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelProfile_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelProfile_Response

// optional string unique_name = 1 [(.description) = "Unique short broadcast channel name, part of Steam.TV URL"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::unique_name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000001u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_unique_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.unique_name)
}

// optional fixed64 owner_steamid = 2 [(.description) = "Broadcast channel owner"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_owner_steamid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_owner_steamid() const {
  return _internal_has_owner_steamid();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_owner_steamid() {
  owner_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t CSteamTV_GetBroadcastChannelProfile_Response::_internal_owner_steamid() const {
  return owner_steamid_;
}
inline uint64_t CSteamTV_GetBroadcastChannelProfile_Response::owner_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.owner_steamid)
  return _internal_owner_steamid();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_owner_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  owner_steamid_ = value;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_owner_steamid(uint64_t value) {
  _internal_set_owner_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.owner_steamid)
}

// optional string name = 3 [(.description) = "long channel name"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.name)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.name)
}

// optional string language = 4 [(.description) = "primary channel language (Steam shortname)"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_language() const {
  return _internal_has_language();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::language() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.language)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.language)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_language() const {
  return language_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000004u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_language() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.language)
}

// optional string headline = 5 [(.description) = "short channel description"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_headline() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_headline() const {
  return _internal_has_headline();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_headline() {
  headline_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::headline() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.headline)
  return _internal_headline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_headline(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.headline)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_headline() {
  std::string* _s = _internal_mutable_headline();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.headline)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_headline() const {
  return headline_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_headline(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_headline() {
  _has_bits_[0] |= 0x00000008u;
  return headline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_headline() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.headline)
  if (!_internal_has_headline()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = headline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_headline(std::string* headline) {
  if (headline != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  headline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.headline)
}

// optional string summary = 6 [(.description) = "long channel description"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_summary() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_summary() const {
  return _internal_has_summary();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_summary() {
  summary_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::summary() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.summary)
  return _internal_summary();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_summary(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 summary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.summary)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_summary() {
  std::string* _s = _internal_mutable_summary();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.summary)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_summary() const {
  return summary_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_summary(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  summary_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_summary() {
  _has_bits_[0] |= 0x00000010u;
  return summary_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_summary() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.summary)
  if (!_internal_has_summary()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = summary_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (summary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    summary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_summary(std::string* summary) {
  if (summary != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  summary_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), summary,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (summary_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    summary_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.summary)
}

// optional string schedule = 7 [(.description) = "broadcast channel schedule"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_schedule() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_schedule() const {
  return _internal_has_schedule();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_schedule() {
  schedule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::schedule() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
  return _internal_schedule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_schedule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 schedule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_schedule() {
  std::string* _s = _internal_mutable_schedule();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_schedule() const {
  return schedule_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_schedule(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  schedule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_schedule() {
  _has_bits_[0] |= 0x00000020u;
  return schedule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_schedule() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
  if (!_internal_has_schedule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = schedule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schedule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schedule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_schedule(std::string* schedule) {
  if (schedule != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  schedule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), schedule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (schedule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    schedule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.schedule)
}

// optional string rules = 8 [(.description) = "broadcast channel rules"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_rules() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_rules() const {
  return _internal_has_rules();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_rules() {
  rules_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::rules() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.rules)
  return _internal_rules();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_rules(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 rules_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.rules)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_rules() {
  std::string* _s = _internal_mutable_rules();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.rules)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_rules() const {
  return rules_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_rules(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  rules_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_rules() {
  _has_bits_[0] |= 0x00000040u;
  return rules_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_rules() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.rules)
  if (!_internal_has_rules()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = rules_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rules_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rules_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_rules(std::string* rules) {
  if (rules != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  rules_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rules,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rules_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rules_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.rules)
}

// optional string panels = 9 [(.description) = "JSON data representing the channel panel layout"];
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_panels() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_panels() const {
  return _internal_has_panels();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_panels() {
  panels_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::panels() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.panels)
  return _internal_panels();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelProfile_Response::set_panels(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 panels_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.panels)
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::mutable_panels() {
  std::string* _s = _internal_mutable_panels();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelProfile_Response.panels)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelProfile_Response::_internal_panels() const {
  return panels_.Get();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_panels(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  panels_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::_internal_mutable_panels() {
  _has_bits_[0] |= 0x00000080u;
  return panels_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelProfile_Response::release_panels() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelProfile_Response.panels)
  if (!_internal_has_panels()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = panels_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (panels_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    panels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_allocated_panels(std::string* panels) {
  if (panels != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  panels_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), panels,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (panels_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    panels_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelProfile_Response.panels)
}

// optional bool is_partnered = 10;
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_has_is_partnered() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::has_is_partnered() const {
  return _internal_has_is_partnered();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::clear_is_partnered() {
  is_partnered_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::_internal_is_partnered() const {
  return is_partnered_;
}
inline bool CSteamTV_GetBroadcastChannelProfile_Response::is_partnered() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelProfile_Response.is_partnered)
  return _internal_is_partnered();
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::_internal_set_is_partnered(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is_partnered_ = value;
}
inline void CSteamTV_GetBroadcastChannelProfile_Response::set_is_partnered(bool value) {
  _internal_set_is_partnered(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelProfile_Response.is_partnered)
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelImage_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_SetBroadcastChannelImage_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_SetBroadcastChannelImage_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.broadcast_channel_id)
}

// optional .EBroadcastImageType image_type = 2 [default = k_EBroadcastImageType_None, (.description) = "EBroadcastImage"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_image_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_image_type() const {
  return _internal_has_image_type();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_image_type() {
  image_type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EBroadcastImageType CSteamTV_SetBroadcastChannelImage_Request::_internal_image_type() const {
  return static_cast< ::EBroadcastImageType >(image_type_);
}
inline ::EBroadcastImageType CSteamTV_SetBroadcastChannelImage_Request::image_type() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.image_type)
  return _internal_image_type();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_image_type(::EBroadcastImageType value) {
  assert(::EBroadcastImageType_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  image_type_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_image_type(::EBroadcastImageType value) {
  _internal_set_image_type(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.image_type)
}

// optional uint32 image_index = 3 [(.description) = "Index of the image (for supporting multiple uploads of the same type"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_image_index() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_image_index() const {
  return _internal_has_image_index();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_image_index() {
  image_index_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::_internal_image_index() const {
  return image_index_;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::image_index() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.image_index)
  return _internal_image_index();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_image_index(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  image_index_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_image_index(uint32_t value) {
  _internal_set_image_index(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.image_index)
}

// optional uint32 image_width = 4 [(.description) = "width in pixels"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_image_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_image_width() const {
  return _internal_has_image_width();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_image_width() {
  image_width_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::_internal_image_width() const {
  return image_width_;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::image_width() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.image_width)
  return _internal_image_width();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_image_width(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  image_width_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_image_width(uint32_t value) {
  _internal_set_image_width(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.image_width)
}

// optional uint32 image_height = 5 [(.description) = "height in pixels"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_image_height() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_image_height() const {
  return _internal_has_image_height();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_image_height() {
  image_height_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::_internal_image_height() const {
  return image_height_;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::image_height() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.image_height)
  return _internal_image_height();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_image_height(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  image_height_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_image_height(uint32_t value) {
  _internal_set_image_height(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.image_height)
}

// optional uint32 file_size = 6 [(.description) = "in bytes"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_file_size() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_file_size() const {
  return _internal_has_file_size();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_file_size() {
  file_size_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::_internal_file_size() const {
  return file_size_;
}
inline uint32_t CSteamTV_SetBroadcastChannelImage_Request::file_size() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.file_size)
  return _internal_file_size();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_file_size(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  file_size_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_file_size(uint32_t value) {
  _internal_set_file_size(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.file_size)
}

// optional string file_extension = 7 [(.description) = "eg .jpg"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_file_extension() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_file_extension() const {
  return _internal_has_file_extension();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_file_extension() {
  file_extension_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Request::file_extension() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
  return _internal_file_extension();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelImage_Request::set_file_extension(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 file_extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::mutable_file_extension() {
  std::string* _s = _internal_mutable_file_extension();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Request::_internal_file_extension() const {
  return file_extension_.Get();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_file_extension(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  file_extension_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::_internal_mutable_file_extension() {
  _has_bits_[0] |= 0x00000001u;
  return file_extension_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::release_file_extension() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
  if (!_internal_has_file_extension()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = file_extension_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_extension_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_extension_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_allocated_file_extension(std::string* file_extension) {
  if (file_extension != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  file_extension_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_extension,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_extension_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_extension_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelImage_Request.file_extension)
}

// optional string file_hash = 8 [(.description) = "image SHA"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_file_hash() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_file_hash() const {
  return _internal_has_file_hash();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_file_hash() {
  file_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Request::file_hash() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
  return _internal_file_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelImage_Request::set_file_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 file_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::mutable_file_hash() {
  std::string* _s = _internal_mutable_file_hash();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Request::_internal_file_hash() const {
  return file_hash_.Get();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_file_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  file_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::_internal_mutable_file_hash() {
  _has_bits_[0] |= 0x00000002u;
  return file_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Request::release_file_hash() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
  if (!_internal_has_file_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = file_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_allocated_file_hash(std::string* file_hash) {
  if (file_hash != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  file_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), file_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (file_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    file_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelImage_Request.file_hash)
}

// optional bool undo = 9 [(.description) = "indicates this is a delete request"];
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_has_undo() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::has_undo() const {
  return _internal_has_undo();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::clear_undo() {
  undo_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::_internal_undo() const {
  return undo_;
}
inline bool CSteamTV_SetBroadcastChannelImage_Request::undo() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Request.undo)
  return _internal_undo();
}
inline void CSteamTV_SetBroadcastChannelImage_Request::_internal_set_undo(bool value) {
  _has_bits_[0] |= 0x00000100u;
  undo_ = value;
}
inline void CSteamTV_SetBroadcastChannelImage_Request::set_undo(bool value) {
  _internal_set_undo(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Request.undo)
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelImage_Response

// optional string replace_image_hash = 1 [(.description) = "set if caller should remove previous SHA file from cache"];
inline bool CSteamTV_SetBroadcastChannelImage_Response::_internal_has_replace_image_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelImage_Response::has_replace_image_hash() const {
  return _internal_has_replace_image_hash();
}
inline void CSteamTV_SetBroadcastChannelImage_Response::clear_replace_image_hash() {
  replace_image_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Response::replace_image_hash() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
  return _internal_replace_image_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelImage_Response::set_replace_image_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 replace_image_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Response::mutable_replace_image_hash() {
  std::string* _s = _internal_mutable_replace_image_hash();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelImage_Response::_internal_replace_image_hash() const {
  return replace_image_hash_.Get();
}
inline void CSteamTV_SetBroadcastChannelImage_Response::_internal_set_replace_image_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  replace_image_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Response::_internal_mutable_replace_image_hash() {
  _has_bits_[0] |= 0x00000001u;
  return replace_image_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelImage_Response::release_replace_image_hash() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
  if (!_internal_has_replace_image_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = replace_image_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (replace_image_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    replace_image_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelImage_Response::set_allocated_replace_image_hash(std::string* replace_image_hash) {
  if (replace_image_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  replace_image_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), replace_image_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (replace_image_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    replace_image_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelImage_Response.replace_image_hash)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelImages_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelImages_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelImages_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelImages_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelImages_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelImages_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelImages_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelImages_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelImages_Request.broadcast_channel_id)
}

// repeated .EBroadcastImageType image_types = 2 [(.description) = "list of EBroadcastImage"];
inline int CSteamTV_GetBroadcastChannelImages_Request::_internal_image_types_size() const {
  return image_types_.size();
}
inline int CSteamTV_GetBroadcastChannelImages_Request::image_types_size() const {
  return _internal_image_types_size();
}
inline void CSteamTV_GetBroadcastChannelImages_Request::clear_image_types() {
  image_types_.Clear();
}
inline ::EBroadcastImageType CSteamTV_GetBroadcastChannelImages_Request::_internal_image_types(int index) const {
  return static_cast< ::EBroadcastImageType >(image_types_.Get(index));
}
inline ::EBroadcastImageType CSteamTV_GetBroadcastChannelImages_Request::image_types(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Request.image_types)
  return _internal_image_types(index);
}
inline void CSteamTV_GetBroadcastChannelImages_Request::set_image_types(int index, ::EBroadcastImageType value) {
  assert(::EBroadcastImageType_IsValid(value));
  image_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelImages_Request.image_types)
}
inline void CSteamTV_GetBroadcastChannelImages_Request::_internal_add_image_types(::EBroadcastImageType value) {
  assert(::EBroadcastImageType_IsValid(value));
  image_types_.Add(value);
}
inline void CSteamTV_GetBroadcastChannelImages_Request::add_image_types(::EBroadcastImageType value) {
  _internal_add_image_types(value);
  // @@protoc_insertion_point(field_add:CSteamTV_GetBroadcastChannelImages_Request.image_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CSteamTV_GetBroadcastChannelImages_Request::image_types() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetBroadcastChannelImages_Request.image_types)
  return image_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CSteamTV_GetBroadcastChannelImages_Request::_internal_mutable_image_types() {
  return &image_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CSteamTV_GetBroadcastChannelImages_Request::mutable_image_types() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetBroadcastChannelImages_Request.image_types)
  return _internal_mutable_image_types();
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelImages_Response_Images

// optional .EBroadcastImageType image_type = 1 [default = k_EBroadcastImageType_None, (.description) = "Type of the image"];
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_has_image_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::has_image_type() const {
  return _internal_has_image_type();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::clear_image_type() {
  image_type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EBroadcastImageType CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_image_type() const {
  return static_cast< ::EBroadcastImageType >(image_type_);
}
inline ::EBroadcastImageType CSteamTV_GetBroadcastChannelImages_Response_Images::image_type() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Response.Images.image_type)
  return _internal_image_type();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_set_image_type(::EBroadcastImageType value) {
  assert(::EBroadcastImageType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  image_type_ = value;
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::set_image_type(::EBroadcastImageType value) {
  _internal_set_image_type(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelImages_Response.Images.image_type)
}

// optional string image_path = 2 [(.description) = "Path to the uploaded image"];
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_has_image_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::has_image_path() const {
  return _internal_has_image_path();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::clear_image_path() {
  image_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelImages_Response_Images::image_path() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
  return _internal_image_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelImages_Response_Images::set_image_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 image_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
}
inline std::string* CSteamTV_GetBroadcastChannelImages_Response_Images::mutable_image_path() {
  std::string* _s = _internal_mutable_image_path();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_image_path() const {
  return image_path_.Get();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_set_image_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_mutable_image_path() {
  _has_bits_[0] |= 0x00000001u;
  return image_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelImages_Response_Images::release_image_path() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
  if (!_internal_has_image_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = image_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::set_allocated_image_path(std::string* image_path) {
  if (image_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelImages_Response.Images.image_path)
}

// optional uint32 image_index = 3 [(.description) = "Index of the image"];
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_has_image_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelImages_Response_Images::has_image_index() const {
  return _internal_has_image_index();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::clear_image_index() {
  image_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_image_index() const {
  return image_index_;
}
inline uint32_t CSteamTV_GetBroadcastChannelImages_Response_Images::image_index() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Response.Images.image_index)
  return _internal_image_index();
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::_internal_set_image_index(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  image_index_ = value;
}
inline void CSteamTV_GetBroadcastChannelImages_Response_Images::set_image_index(uint32_t value) {
  _internal_set_image_index(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelImages_Response.Images.image_index)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelImages_Response

// repeated .CSteamTV_GetBroadcastChannelImages_Response.Images images = 1;
inline int CSteamTV_GetBroadcastChannelImages_Response::_internal_images_size() const {
  return images_.size();
}
inline int CSteamTV_GetBroadcastChannelImages_Response::images_size() const {
  return _internal_images_size();
}
inline void CSteamTV_GetBroadcastChannelImages_Response::clear_images() {
  images_.Clear();
}
inline ::CSteamTV_GetBroadcastChannelImages_Response_Images* CSteamTV_GetBroadcastChannelImages_Response::mutable_images(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelImages_Response.images)
  return images_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelImages_Response_Images >*
CSteamTV_GetBroadcastChannelImages_Response::mutable_images() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetBroadcastChannelImages_Response.images)
  return &images_;
}
inline const ::CSteamTV_GetBroadcastChannelImages_Response_Images& CSteamTV_GetBroadcastChannelImages_Response::_internal_images(int index) const {
  return images_.Get(index);
}
inline const ::CSteamTV_GetBroadcastChannelImages_Response_Images& CSteamTV_GetBroadcastChannelImages_Response::images(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelImages_Response.images)
  return _internal_images(index);
}
inline ::CSteamTV_GetBroadcastChannelImages_Response_Images* CSteamTV_GetBroadcastChannelImages_Response::_internal_add_images() {
  return images_.Add();
}
inline ::CSteamTV_GetBroadcastChannelImages_Response_Images* CSteamTV_GetBroadcastChannelImages_Response::add_images() {
  ::CSteamTV_GetBroadcastChannelImages_Response_Images* _add = _internal_add_images();
  // @@protoc_insertion_point(field_add:CSteamTV_GetBroadcastChannelImages_Response.images)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelImages_Response_Images >&
CSteamTV_GetBroadcastChannelImages_Response::images() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetBroadcastChannelImages_Response.images)
  return images_;
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelLinkRegions_Request_Links

// optional uint32 link_index = 1 [(.description) = "Index of the link (lower number has higher priority)"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_link_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_link_index() const {
  return _internal_has_link_index();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_link_index() {
  link_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_link_index() const {
  return link_index_;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::link_index() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_index)
  return _internal_link_index();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_link_index(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  link_index_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_link_index(uint32_t value) {
  _internal_set_link_index(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_index)
}

// optional string url = 2 [(.description) = "URL "];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_url() const {
  return _internal_has_url();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::url() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_url() const {
  return url_.Get();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::release_url() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.url)
}

// optional string link_description = 3 [(.description) = "URL description that will show in the link region"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_link_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_link_description() const {
  return _internal_has_link_description();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_link_description() {
  link_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::link_description() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
  return _internal_link_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_link_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 link_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::mutable_link_description() {
  std::string* _s = _internal_mutable_link_description();
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
  return _s;
}
inline const std::string& CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_link_description() const {
  return link_description_.Get();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_link_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_mutable_link_description() {
  _has_bits_[0] |= 0x00000002u;
  return link_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::release_link_description() {
  // @@protoc_insertion_point(field_release:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
  if (!_internal_has_link_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = link_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    link_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_allocated_link_description(std::string* link_description) {
  if (link_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    link_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.link_description)
}

// optional uint32 left = 4 [(.description) = "Left X position in 100th of a % of the video width"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_left() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_left() const {
  return _internal_has_left();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_left() {
  left_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_left() const {
  return left_;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::left() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.left)
  return _internal_left();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_left(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  left_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_left(uint32_t value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.left)
}

// optional uint32 top = 5 [(.description) = "Top Y position in 100th of a % of the video height"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_top() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_top() const {
  return _internal_has_top();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_top() {
  top_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_top() const {
  return top_;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::top() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.top)
  return _internal_top();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_top(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  top_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_top(uint32_t value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.top)
}

// optional uint32 width = 6 [(.description) = "Region Width in 100th of a % of the video width"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_width() const {
  return _internal_has_width();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_width() const {
  return width_;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::width() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.width)
  return _internal_width();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  width_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.width)
}

// optional uint32 height = 7 [(.description) = "Region Height in 100th of a % of the video height"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::has_height() const {
  return _internal_has_height();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_height() const {
  return height_;
}
inline uint32_t CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::height() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.height)
  return _internal_height();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  height_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request_Links::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.Links.height)
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelLinkRegions_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetBroadcastChannelLinkRegions_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_SetBroadcastChannelLinkRegions_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetBroadcastChannelLinkRegions_Request.broadcast_channel_id)
}

// repeated .CSteamTV_SetBroadcastChannelLinkRegions_Request.Links links = 2;
inline int CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_links_size() const {
  return links_.size();
}
inline int CSteamTV_SetBroadcastChannelLinkRegions_Request::links_size() const {
  return _internal_links_size();
}
inline void CSteamTV_SetBroadcastChannelLinkRegions_Request::clear_links() {
  links_.Clear();
}
inline ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* CSteamTV_SetBroadcastChannelLinkRegions_Request::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
  return links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links >*
CSteamTV_SetBroadcastChannelLinkRegions_Request::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
  return &links_;
}
inline const ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_links(int index) const {
  return links_.Get(index);
}
inline const ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links& CSteamTV_SetBroadcastChannelLinkRegions_Request::links(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
  return _internal_links(index);
}
inline ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* CSteamTV_SetBroadcastChannelLinkRegions_Request::_internal_add_links() {
  return links_.Add();
}
inline ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* CSteamTV_SetBroadcastChannelLinkRegions_Request::add_links() {
  ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_SetBroadcastChannelLinkRegions_Request_Links >&
CSteamTV_SetBroadcastChannelLinkRegions_Request::links() const {
  // @@protoc_insertion_point(field_list:CSteamTV_SetBroadcastChannelLinkRegions_Request.links)
  return links_;
}

// -------------------------------------------------------------------

// CSteamTV_SetBroadcastChannelLinkRegions_Response

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelLinks_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelLinks_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelLinks_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelLinks_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelLinks_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelLinks_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelLinks_Response_Links

// optional uint32 link_index = 1 [(.description) = "Index of the link (lower number has higher priority)"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_link_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_link_index() const {
  return _internal_has_link_index();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_link_index() {
  link_index_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_link_index() const {
  return link_index_;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::link_index() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_index)
  return _internal_link_index();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_link_index(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  link_index_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_link_index(uint32_t value) {
  _internal_set_link_index(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_index)
}

// optional string url = 2 [(.description) = "URL "];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_url() const {
  return _internal_has_url();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_url() {
  url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelLinks_Response_Links::url() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_url() const {
  return url_.Get();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_mutable_url() {
  _has_bits_[0] |= 0x00000001u;
  return url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::release_url() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
  if (!_internal_has_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelLinks_Response.Links.url)
}

// optional string link_description = 3 [(.description) = "URL description that will show in the link region"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_link_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_link_description() const {
  return _internal_has_link_description();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_link_description() {
  link_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_GetBroadcastChannelLinks_Response_Links::link_description() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
  return _internal_link_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_link_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 link_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::mutable_link_description() {
  std::string* _s = _internal_mutable_link_description();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_link_description() const {
  return link_description_.Get();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_link_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  link_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_mutable_link_description() {
  _has_bits_[0] |= 0x00000002u;
  return link_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelLinks_Response_Links::release_link_description() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
  if (!_internal_has_link_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = link_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    link_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_allocated_link_description(std::string* link_description) {
  if (link_description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  link_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), link_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (link_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    link_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelLinks_Response.Links.link_description)
}

// optional uint32 left = 4 [(.description) = "Left X position in 100th of a % of the video width"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_left() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_left() const {
  return _internal_has_left();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_left() {
  left_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_left() const {
  return left_;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::left() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.left)
  return _internal_left();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_left(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  left_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_left(uint32_t value) {
  _internal_set_left(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.left)
}

// optional uint32 top = 5 [(.description) = "Top Y position in 100th of a % of the video height"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_top() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_top() const {
  return _internal_has_top();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_top() {
  top_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_top() const {
  return top_;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::top() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.top)
  return _internal_top();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_top(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  top_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_top(uint32_t value) {
  _internal_set_top(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.top)
}

// optional uint32 width = 6 [(.description) = "Region Width in 100th of a % of the video width"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_width() const {
  return _internal_has_width();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_width() const {
  return width_;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::width() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.width)
  return _internal_width();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  width_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.width)
}

// optional uint32 height = 7 [(.description) = "Region Height in 100th of a % of the video height"];
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelLinks_Response_Links::has_height() const {
  return _internal_has_height();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_height() const {
  return height_;
}
inline uint32_t CSteamTV_GetBroadcastChannelLinks_Response_Links::height() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.Links.height)
  return _internal_height();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  height_ = value;
}
inline void CSteamTV_GetBroadcastChannelLinks_Response_Links::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelLinks_Response.Links.height)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelLinks_Response

// repeated .CSteamTV_GetBroadcastChannelLinks_Response.Links links = 1;
inline int CSteamTV_GetBroadcastChannelLinks_Response::_internal_links_size() const {
  return links_.size();
}
inline int CSteamTV_GetBroadcastChannelLinks_Response::links_size() const {
  return _internal_links_size();
}
inline void CSteamTV_GetBroadcastChannelLinks_Response::clear_links() {
  links_.Clear();
}
inline ::CSteamTV_GetBroadcastChannelLinks_Response_Links* CSteamTV_GetBroadcastChannelLinks_Response::mutable_links(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelLinks_Response.links)
  return links_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelLinks_Response_Links >*
CSteamTV_GetBroadcastChannelLinks_Response::mutable_links() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetBroadcastChannelLinks_Response.links)
  return &links_;
}
inline const ::CSteamTV_GetBroadcastChannelLinks_Response_Links& CSteamTV_GetBroadcastChannelLinks_Response::_internal_links(int index) const {
  return links_.Get(index);
}
inline const ::CSteamTV_GetBroadcastChannelLinks_Response_Links& CSteamTV_GetBroadcastChannelLinks_Response::links(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelLinks_Response.links)
  return _internal_links(index);
}
inline ::CSteamTV_GetBroadcastChannelLinks_Response_Links* CSteamTV_GetBroadcastChannelLinks_Response::_internal_add_links() {
  return links_.Add();
}
inline ::CSteamTV_GetBroadcastChannelLinks_Response_Links* CSteamTV_GetBroadcastChannelLinks_Response::add_links() {
  ::CSteamTV_GetBroadcastChannelLinks_Response_Links* _add = _internal_add_links();
  // @@protoc_insertion_point(field_add:CSteamTV_GetBroadcastChannelLinks_Response.links)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelLinks_Response_Links >&
CSteamTV_GetBroadcastChannelLinks_Response::links() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetBroadcastChannelLinks_Response.links)
  return links_;
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelBroadcasters_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelBroadcasters_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelBroadcasters_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelBroadcasters_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelBroadcasters_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster

// optional fixed64 steamid = 1 [(.description) = "Broadcaster Steam ID"];
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::has_steamid() const {
  return _internal_has_steamid();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.steamid)
  return _internal_steamid();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.steamid)
}

// optional string name = 2 [(.description) = "Broadcaster name"];
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.name)
}

// optional string rtmp_token = 3 [(.description) = "Broadcaster upload token"];
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_has_rtmp_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::has_rtmp_token() const {
  return _internal_has_rtmp_token();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::clear_rtmp_token() {
  rtmp_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::rtmp_token() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
  return _internal_rtmp_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::set_rtmp_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 rtmp_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::mutable_rtmp_token() {
  std::string* _s = _internal_mutable_rtmp_token();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_rtmp_token() const {
  return rtmp_token_.Get();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_set_rtmp_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  rtmp_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::_internal_mutable_rtmp_token() {
  _has_bits_[0] |= 0x00000002u;
  return rtmp_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::release_rtmp_token() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
  if (!_internal_has_rtmp_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = rtmp_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rtmp_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rtmp_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster::set_allocated_rtmp_token(std::string* rtmp_token) {
  if (rtmp_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rtmp_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rtmp_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rtmp_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rtmp_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster.rtmp_token)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelBroadcasters_Response

// repeated .CSteamTV_GetBroadcastChannelBroadcasters_Response.Broadcaster broadcasters = 1;
inline int CSteamTV_GetBroadcastChannelBroadcasters_Response::_internal_broadcasters_size() const {
  return broadcasters_.size();
}
inline int CSteamTV_GetBroadcastChannelBroadcasters_Response::broadcasters_size() const {
  return _internal_broadcasters_size();
}
inline void CSteamTV_GetBroadcastChannelBroadcasters_Response::clear_broadcasters() {
  broadcasters_.Clear();
}
inline ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* CSteamTV_GetBroadcastChannelBroadcasters_Response::mutable_broadcasters(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
  return broadcasters_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster >*
CSteamTV_GetBroadcastChannelBroadcasters_Response::mutable_broadcasters() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
  return &broadcasters_;
}
inline const ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& CSteamTV_GetBroadcastChannelBroadcasters_Response::_internal_broadcasters(int index) const {
  return broadcasters_.Get(index);
}
inline const ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster& CSteamTV_GetBroadcastChannelBroadcasters_Response::broadcasters(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
  return _internal_broadcasters(index);
}
inline ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* CSteamTV_GetBroadcastChannelBroadcasters_Response::_internal_add_broadcasters() {
  return broadcasters_.Add();
}
inline ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* CSteamTV_GetBroadcastChannelBroadcasters_Response::add_broadcasters() {
  ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster* _add = _internal_add_broadcasters();
  // @@protoc_insertion_point(field_add:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_GetBroadcastChannelBroadcasters_Response_Broadcaster >&
CSteamTV_GetBroadcastChannelBroadcasters_Response::broadcasters() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetBroadcastChannelBroadcasters_Response.broadcasters)
  return broadcasters_;
}

// -------------------------------------------------------------------

// CSteamTV_GetFollowedChannels_Request

// -------------------------------------------------------------------

// GetBroadcastChannelEntry

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID or 0"];
inline bool GetBroadcastChannelEntry::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void GetBroadcastChannelEntry::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t GetBroadcastChannelEntry::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void GetBroadcastChannelEntry::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  broadcast_channel_id_ = value;
}
inline void GetBroadcastChannelEntry::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.broadcast_channel_id)
}

// optional string unique_name = 2 [(.description) = "Unique broadcast channel name for URL"];
inline bool GetBroadcastChannelEntry::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void GetBroadcastChannelEntry::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GetBroadcastChannelEntry::unique_name() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.unique_name)
}
inline std::string* GetBroadcastChannelEntry::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.unique_name)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000001u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_unique_name() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.unique_name)
}

// optional string name = 3 [(.description) = "Long broadcast channel name"];
inline bool GetBroadcastChannelEntry::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_name() const {
  return _internal_has_name();
}
inline void GetBroadcastChannelEntry::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& GetBroadcastChannelEntry::name() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.name)
}
inline std::string* GetBroadcastChannelEntry::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.name)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_name() const {
  return name_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_name() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.name)
}

// optional uint32 appid = 4 [(.description) = "The game ID the requested broadcaster is playing"];
inline bool GetBroadcastChannelEntry::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_appid() const {
  return _internal_has_appid();
}
inline void GetBroadcastChannelEntry::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t GetBroadcastChannelEntry::_internal_appid() const {
  return appid_;
}
inline uint32_t GetBroadcastChannelEntry::appid() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.appid)
  return _internal_appid();
}
inline void GetBroadcastChannelEntry::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  appid_ = value;
}
inline void GetBroadcastChannelEntry::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.appid)
}

// optional uint64 viewers = 5 [(.description) = "Number of viewers currently watching"];
inline bool GetBroadcastChannelEntry::_internal_has_viewers() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_viewers() const {
  return _internal_has_viewers();
}
inline void GetBroadcastChannelEntry::clear_viewers() {
  viewers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_viewers() const {
  return viewers_;
}
inline uint64_t GetBroadcastChannelEntry::viewers() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.viewers)
  return _internal_viewers();
}
inline void GetBroadcastChannelEntry::_internal_set_viewers(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  viewers_ = value;
}
inline void GetBroadcastChannelEntry::set_viewers(uint64_t value) {
  _internal_set_viewers(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.viewers)
}

// optional uint64 views = 6 [(.description) = "Number of total views of this channel"];
inline bool GetBroadcastChannelEntry::_internal_has_views() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_views() const {
  return _internal_has_views();
}
inline void GetBroadcastChannelEntry::clear_views() {
  views_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_views() const {
  return views_;
}
inline uint64_t GetBroadcastChannelEntry::views() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.views)
  return _internal_views();
}
inline void GetBroadcastChannelEntry::_internal_set_views(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  views_ = value;
}
inline void GetBroadcastChannelEntry::set_views(uint64_t value) {
  _internal_set_views(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.views)
}

// optional string thumbnail_url = 7 [(.description) = "Current thumbnail URL"];
inline bool GetBroadcastChannelEntry::_internal_has_thumbnail_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_thumbnail_url() const {
  return _internal_has_thumbnail_url();
}
inline void GetBroadcastChannelEntry::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& GetBroadcastChannelEntry::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 thumbnail_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.thumbnail_url)
}
inline std::string* GetBroadcastChannelEntry::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.thumbnail_url)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_thumbnail_url() const {
  return thumbnail_url_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_thumbnail_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  thumbnail_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_thumbnail_url() {
  _has_bits_[0] |= 0x00000004u;
  return thumbnail_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.thumbnail_url)
  if (!_internal_has_thumbnail_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = thumbnail_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  thumbnail_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.thumbnail_url)
}

// optional uint64 followers = 8 [(.description) = "Number of followers of this channel"];
inline bool GetBroadcastChannelEntry::_internal_has_followers() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_followers() const {
  return _internal_has_followers();
}
inline void GetBroadcastChannelEntry::clear_followers() {
  followers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_followers() const {
  return followers_;
}
inline uint64_t GetBroadcastChannelEntry::followers() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.followers)
  return _internal_followers();
}
inline void GetBroadcastChannelEntry::_internal_set_followers(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  followers_ = value;
}
inline void GetBroadcastChannelEntry::set_followers(uint64_t value) {
  _internal_set_followers(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.followers)
}

// optional string headline = 9 [(.description) = "short channel description"];
inline bool GetBroadcastChannelEntry::_internal_has_headline() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_headline() const {
  return _internal_has_headline();
}
inline void GetBroadcastChannelEntry::clear_headline() {
  headline_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& GetBroadcastChannelEntry::headline() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.headline)
  return _internal_headline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_headline(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.headline)
}
inline std::string* GetBroadcastChannelEntry::mutable_headline() {
  std::string* _s = _internal_mutable_headline();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.headline)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_headline() const {
  return headline_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_headline(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_headline() {
  _has_bits_[0] |= 0x00000008u;
  return headline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_headline() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.headline)
  if (!_internal_has_headline()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = headline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_headline(std::string* headline) {
  if (headline != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  headline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), headline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.headline)
}

// optional string avatar_url = 10 [(.description) = "community avatar url"];
inline bool GetBroadcastChannelEntry::_internal_has_avatar_url() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_avatar_url() const {
  return _internal_has_avatar_url();
}
inline void GetBroadcastChannelEntry::clear_avatar_url() {
  avatar_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& GetBroadcastChannelEntry::avatar_url() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.avatar_url)
  return _internal_avatar_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_avatar_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.avatar_url)
}
inline std::string* GetBroadcastChannelEntry::mutable_avatar_url() {
  std::string* _s = _internal_mutable_avatar_url();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.avatar_url)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_avatar_url() const {
  return avatar_url_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_avatar_url(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  avatar_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_avatar_url() {
  _has_bits_[0] |= 0x00000010u;
  return avatar_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_avatar_url() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.avatar_url)
  if (!_internal_has_avatar_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = avatar_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_avatar_url(std::string* avatar_url) {
  if (avatar_url != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  avatar_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.avatar_url)
}

// optional fixed64 broadcaster_steamid = 11 [(.description) = "Current broadcaster streaming"];
inline bool GetBroadcastChannelEntry::_internal_has_broadcaster_steamid() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_broadcaster_steamid() const {
  return _internal_has_broadcaster_steamid();
}
inline void GetBroadcastChannelEntry::clear_broadcaster_steamid() {
  broadcaster_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000800u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_broadcaster_steamid() const {
  return broadcaster_steamid_;
}
inline uint64_t GetBroadcastChannelEntry::broadcaster_steamid() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.broadcaster_steamid)
  return _internal_broadcaster_steamid();
}
inline void GetBroadcastChannelEntry::_internal_set_broadcaster_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000800u;
  broadcaster_steamid_ = value;
}
inline void GetBroadcastChannelEntry::set_broadcaster_steamid(uint64_t value) {
  _internal_set_broadcaster_steamid(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.broadcaster_steamid)
}

// optional uint64 subscribers = 12 [(.description) = "Number of subscribers of this channel"];
inline bool GetBroadcastChannelEntry::_internal_has_subscribers() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_subscribers() const {
  return _internal_has_subscribers();
}
inline void GetBroadcastChannelEntry::clear_subscribers() {
  subscribers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t GetBroadcastChannelEntry::_internal_subscribers() const {
  return subscribers_;
}
inline uint64_t GetBroadcastChannelEntry::subscribers() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.subscribers)
  return _internal_subscribers();
}
inline void GetBroadcastChannelEntry::_internal_set_subscribers(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  subscribers_ = value;
}
inline void GetBroadcastChannelEntry::set_subscribers(uint64_t value) {
  _internal_set_subscribers(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.subscribers)
}

// optional string background_url = 13 [(.description) = "Background image url"];
inline bool GetBroadcastChannelEntry::_internal_has_background_url() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_background_url() const {
  return _internal_has_background_url();
}
inline void GetBroadcastChannelEntry::clear_background_url() {
  background_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& GetBroadcastChannelEntry::background_url() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.background_url)
  return _internal_background_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_background_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 background_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.background_url)
}
inline std::string* GetBroadcastChannelEntry::mutable_background_url() {
  std::string* _s = _internal_mutable_background_url();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.background_url)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_background_url() const {
  return background_url_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_background_url(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  background_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_background_url() {
  _has_bits_[0] |= 0x00000020u;
  return background_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_background_url() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.background_url)
  if (!_internal_has_background_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = background_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (background_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    background_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_background_url(std::string* background_url) {
  if (background_url != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  background_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), background_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (background_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    background_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.background_url)
}

// optional bool is_featured = 14 [(.description) = "Whether the channel is featured"];
inline bool GetBroadcastChannelEntry::_internal_has_is_featured() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_is_featured() const {
  return _internal_has_is_featured();
}
inline void GetBroadcastChannelEntry::clear_is_featured() {
  is_featured_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool GetBroadcastChannelEntry::_internal_is_featured() const {
  return is_featured_;
}
inline bool GetBroadcastChannelEntry::is_featured() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.is_featured)
  return _internal_is_featured();
}
inline void GetBroadcastChannelEntry::_internal_set_is_featured(bool value) {
  _has_bits_[0] |= 0x00004000u;
  is_featured_ = value;
}
inline void GetBroadcastChannelEntry::set_is_featured(bool value) {
  _internal_set_is_featured(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.is_featured)
}

// optional bool is_disabled = 15 [(.description) = "Whether the channel is disabled"];
inline bool GetBroadcastChannelEntry::_internal_has_is_disabled() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_is_disabled() const {
  return _internal_has_is_disabled();
}
inline void GetBroadcastChannelEntry::clear_is_disabled() {
  is_disabled_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool GetBroadcastChannelEntry::_internal_is_disabled() const {
  return is_disabled_;
}
inline bool GetBroadcastChannelEntry::is_disabled() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.is_disabled)
  return _internal_is_disabled();
}
inline void GetBroadcastChannelEntry::_internal_set_is_disabled(bool value) {
  _has_bits_[0] |= 0x00008000u;
  is_disabled_ = value;
}
inline void GetBroadcastChannelEntry::set_is_disabled(bool value) {
  _internal_set_is_disabled(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.is_disabled)
}

// optional bool is_live = 16 [(.description) = "Whether the channel is streaming"];
inline bool GetBroadcastChannelEntry::_internal_has_is_live() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_is_live() const {
  return _internal_has_is_live();
}
inline void GetBroadcastChannelEntry::clear_is_live() {
  is_live_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool GetBroadcastChannelEntry::_internal_is_live() const {
  return is_live_;
}
inline bool GetBroadcastChannelEntry::is_live() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.is_live)
  return _internal_is_live();
}
inline void GetBroadcastChannelEntry::_internal_set_is_live(bool value) {
  _has_bits_[0] |= 0x00010000u;
  is_live_ = value;
}
inline void GetBroadcastChannelEntry::set_is_live(bool value) {
  _internal_set_is_live(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.is_live)
}

// optional string language = 17 [(.description) = "The language the stream is in"];
inline bool GetBroadcastChannelEntry::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_language() const {
  return _internal_has_language();
}
inline void GetBroadcastChannelEntry::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& GetBroadcastChannelEntry::language() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBroadcastChannelEntry::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.language)
}
inline std::string* GetBroadcastChannelEntry::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:GetBroadcastChannelEntry.language)
  return _s;
}
inline const std::string& GetBroadcastChannelEntry::_internal_language() const {
  return language_.Get();
}
inline void GetBroadcastChannelEntry::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000040u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBroadcastChannelEntry::release_language() {
  // @@protoc_insertion_point(field_release:GetBroadcastChannelEntry.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GetBroadcastChannelEntry::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GetBroadcastChannelEntry.language)
}

// optional uint32 reports = 18 [(.description) = "The number of reports the channel has"];
inline bool GetBroadcastChannelEntry::_internal_has_reports() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_reports() const {
  return _internal_has_reports();
}
inline void GetBroadcastChannelEntry::clear_reports() {
  reports_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t GetBroadcastChannelEntry::_internal_reports() const {
  return reports_;
}
inline uint32_t GetBroadcastChannelEntry::reports() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.reports)
  return _internal_reports();
}
inline void GetBroadcastChannelEntry::_internal_set_reports(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  reports_ = value;
}
inline void GetBroadcastChannelEntry::set_reports(uint32_t value) {
  _internal_set_reports(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.reports)
}

// optional bool is_partnered = 19;
inline bool GetBroadcastChannelEntry::_internal_has_is_partnered() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool GetBroadcastChannelEntry::has_is_partnered() const {
  return _internal_has_is_partnered();
}
inline void GetBroadcastChannelEntry::clear_is_partnered() {
  is_partnered_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool GetBroadcastChannelEntry::_internal_is_partnered() const {
  return is_partnered_;
}
inline bool GetBroadcastChannelEntry::is_partnered() const {
  // @@protoc_insertion_point(field_get:GetBroadcastChannelEntry.is_partnered)
  return _internal_is_partnered();
}
inline void GetBroadcastChannelEntry::_internal_set_is_partnered(bool value) {
  _has_bits_[0] |= 0x00020000u;
  is_partnered_ = value;
}
inline void GetBroadcastChannelEntry::set_is_partnered(bool value) {
  _internal_set_is_partnered(value);
  // @@protoc_insertion_point(field_set:GetBroadcastChannelEntry.is_partnered)
}

// -------------------------------------------------------------------

// CSteamTV_GetFollowedChannels_Response

// repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
inline int CSteamTV_GetFollowedChannels_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetFollowedChannels_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetFollowedChannels_Response::clear_results() {
  results_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetFollowedChannels_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetFollowedChannels_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_GetFollowedChannels_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetFollowedChannels_Response.results)
  return &results_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetFollowedChannels_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetFollowedChannels_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetFollowedChannels_Response.results)
  return _internal_results(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetFollowedChannels_Response::_internal_add_results() {
  return results_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetFollowedChannels_Response::add_results() {
  ::GetBroadcastChannelEntry* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetFollowedChannels_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_GetFollowedChannels_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetFollowedChannels_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_GetSubscribedChannels_Request

// -------------------------------------------------------------------

// CSteamTV_GetSubscribedChannels_Response

// repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
inline int CSteamTV_GetSubscribedChannels_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetSubscribedChannels_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetSubscribedChannels_Response::clear_results() {
  results_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetSubscribedChannels_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetSubscribedChannels_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_GetSubscribedChannels_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetSubscribedChannels_Response.results)
  return &results_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetSubscribedChannels_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetSubscribedChannels_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetSubscribedChannels_Response.results)
  return _internal_results(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetSubscribedChannels_Response::_internal_add_results() {
  return results_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetSubscribedChannels_Response::add_results() {
  ::GetBroadcastChannelEntry* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetSubscribedChannels_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_GetSubscribedChannels_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetSubscribedChannels_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelStatus_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelStatus_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelStatus_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelStatus_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelStatus_Response

// optional bool is_live = 1 [(.description) = "Indicates whether the channel is streaming"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_is_live() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_is_live() const {
  return _internal_has_is_live();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_is_live() {
  is_live_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_is_live() const {
  return is_live_;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::is_live() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.is_live)
  return _internal_is_live();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_is_live(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_live_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_is_live(bool value) {
  _internal_set_is_live(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.is_live)
}

// optional bool is_disabled = 2 [(.description) = "Indicates whether the channel has been disabled"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_is_disabled() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_is_disabled() const {
  return _internal_has_is_disabled();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_is_disabled() {
  is_disabled_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_is_disabled() const {
  return is_disabled_;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::is_disabled() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.is_disabled)
  return _internal_is_disabled();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_is_disabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  is_disabled_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_is_disabled(bool value) {
  _internal_set_is_disabled(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.is_disabled)
}

// optional uint32 appid = 3 [(.description) = "The game ID the requested broadcaster is playing"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_appid() const {
  return _internal_has_appid();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_appid() const {
  return appid_;
}
inline uint32_t CSteamTV_GetBroadcastChannelStatus_Response::appid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.appid)
  return _internal_appid();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  appid_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.appid)
}

// optional uint64 viewers = 4 [(.description) = "Number of viewers currently watching"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_viewers() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_viewers() const {
  return _internal_has_viewers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_viewers() {
  viewers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_viewers() const {
  return viewers_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::viewers() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.viewers)
  return _internal_viewers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_viewers(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  viewers_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_viewers(uint64_t value) {
  _internal_set_viewers(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.viewers)
}

// optional uint64 views = 5 [(.description) = "Number of total views of this channel"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_views() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_views() const {
  return _internal_has_views();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_views() {
  views_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000040u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_views() const {
  return views_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::views() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.views)
  return _internal_views();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_views(uint64_t value) {
  _has_bits_[0] |= 0x00000040u;
  views_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_views(uint64_t value) {
  _internal_set_views(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.views)
}

// optional fixed64 broadcaster_steamid = 6 [(.description) = "Current broadcaster streaming"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_broadcaster_steamid() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_broadcaster_steamid() const {
  return _internal_has_broadcaster_steamid();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_broadcaster_steamid() {
  broadcaster_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000080u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_broadcaster_steamid() const {
  return broadcaster_steamid_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::broadcaster_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.broadcaster_steamid)
  return _internal_broadcaster_steamid();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_broadcaster_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000080u;
  broadcaster_steamid_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_broadcaster_steamid(uint64_t value) {
  _internal_set_broadcaster_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.broadcaster_steamid)
}

// optional string thumbnail_url = 7 [(.description) = "Current thumbnail URL"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_thumbnail_url() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_thumbnail_url() const {
  return _internal_has_thumbnail_url();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_thumbnail_url() {
  thumbnail_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelStatus_Response::thumbnail_url() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
  return _internal_thumbnail_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelStatus_Response::set_thumbnail_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 thumbnail_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::mutable_thumbnail_url() {
  std::string* _s = _internal_mutable_thumbnail_url();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelStatus_Response::_internal_thumbnail_url() const {
  return thumbnail_url_.Get();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_thumbnail_url(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  thumbnail_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::_internal_mutable_thumbnail_url() {
  _has_bits_[0] |= 0x00000001u;
  return thumbnail_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::release_thumbnail_url() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
  if (!_internal_has_thumbnail_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = thumbnail_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_allocated_thumbnail_url(std::string* thumbnail_url) {
  if (thumbnail_url != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  thumbnail_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelStatus_Response.thumbnail_url)
}

// optional uint64 followers = 8 [(.description) = "Number of followers of this channel"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_followers() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_followers() const {
  return _internal_has_followers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_followers() {
  followers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000100u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_followers() const {
  return followers_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::followers() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.followers)
  return _internal_followers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_followers(uint64_t value) {
  _has_bits_[0] |= 0x00000100u;
  followers_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_followers(uint64_t value) {
  _internal_set_followers(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.followers)
}

// optional uint64 subscribers = 9 [(.description) = "Number of subscribers of this channel"];
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_subscribers() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_subscribers() const {
  return _internal_has_subscribers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_subscribers() {
  subscribers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_subscribers() const {
  return subscribers_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::subscribers() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.subscribers)
  return _internal_subscribers();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_subscribers(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  subscribers_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_subscribers(uint64_t value) {
  _internal_set_subscribers(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.subscribers)
}

// optional string unique_name = 10;
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_unique_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_unique_name() const {
  return _internal_has_unique_name();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_unique_name() {
  unique_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_GetBroadcastChannelStatus_Response::unique_name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
  return _internal_unique_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelStatus_Response::set_unique_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::mutable_unique_name() {
  std::string* _s = _internal_mutable_unique_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelStatus_Response::_internal_unique_name() const {
  return unique_name_.Get();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_unique_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  unique_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::_internal_mutable_unique_name() {
  _has_bits_[0] |= 0x00000002u;
  return unique_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelStatus_Response::release_unique_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
  if (!_internal_has_unique_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = unique_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_allocated_unique_name(std::string* unique_name) {
  if (unique_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  unique_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), unique_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (unique_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    unique_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelStatus_Response.unique_name)
}

// optional uint64 broadcast_session_id = 11;
inline bool CSteamTV_GetBroadcastChannelStatus_Response::_internal_has_broadcast_session_id() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelStatus_Response::has_broadcast_session_id() const {
  return _internal_has_broadcast_session_id();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::clear_broadcast_session_id() {
  broadcast_session_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000400u;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::_internal_broadcast_session_id() const {
  return broadcast_session_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelStatus_Response::broadcast_session_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelStatus_Response.broadcast_session_id)
  return _internal_broadcast_session_id();
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::_internal_set_broadcast_session_id(uint64_t value) {
  _has_bits_[0] |= 0x00000400u;
  broadcast_session_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelStatus_Response::set_broadcast_session_id(uint64_t value) {
  _internal_set_broadcast_session_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelStatus_Response.broadcast_session_id)
}

// -------------------------------------------------------------------

// CSteamTV_FollowBroadcastChannel_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_FollowBroadcastChannel_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_FollowBroadcastChannel_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_FollowBroadcastChannel_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_FollowBroadcastChannel_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_FollowBroadcastChannel_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_FollowBroadcastChannel_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_FollowBroadcastChannel_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_FollowBroadcastChannel_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_FollowBroadcastChannel_Request.broadcast_channel_id)
}

// optional bool undo = 2 [(.description) = "Indicates this is an unfollow request"];
inline bool CSteamTV_FollowBroadcastChannel_Request::_internal_has_undo() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_FollowBroadcastChannel_Request::has_undo() const {
  return _internal_has_undo();
}
inline void CSteamTV_FollowBroadcastChannel_Request::clear_undo() {
  undo_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CSteamTV_FollowBroadcastChannel_Request::_internal_undo() const {
  return undo_;
}
inline bool CSteamTV_FollowBroadcastChannel_Request::undo() const {
  // @@protoc_insertion_point(field_get:CSteamTV_FollowBroadcastChannel_Request.undo)
  return _internal_undo();
}
inline void CSteamTV_FollowBroadcastChannel_Request::_internal_set_undo(bool value) {
  _has_bits_[0] |= 0x00000002u;
  undo_ = value;
}
inline void CSteamTV_FollowBroadcastChannel_Request::set_undo(bool value) {
  _internal_set_undo(value);
  // @@protoc_insertion_point(field_set:CSteamTV_FollowBroadcastChannel_Request.undo)
}

// -------------------------------------------------------------------

// CSteamTV_FollowBroadcastChannel_Response

// optional bool is_followed = 1 [(.description) = "Whether the user is now following"];
inline bool CSteamTV_FollowBroadcastChannel_Response::_internal_has_is_followed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_FollowBroadcastChannel_Response::has_is_followed() const {
  return _internal_has_is_followed();
}
inline void CSteamTV_FollowBroadcastChannel_Response::clear_is_followed() {
  is_followed_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSteamTV_FollowBroadcastChannel_Response::_internal_is_followed() const {
  return is_followed_;
}
inline bool CSteamTV_FollowBroadcastChannel_Response::is_followed() const {
  // @@protoc_insertion_point(field_get:CSteamTV_FollowBroadcastChannel_Response.is_followed)
  return _internal_is_followed();
}
inline void CSteamTV_FollowBroadcastChannel_Response::_internal_set_is_followed(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_followed_ = value;
}
inline void CSteamTV_FollowBroadcastChannel_Response::set_is_followed(bool value) {
  _internal_set_is_followed(value);
  // @@protoc_insertion_point(field_set:CSteamTV_FollowBroadcastChannel_Response.is_followed)
}

// -------------------------------------------------------------------

// CSteamTV_SubscribeBroadcastChannel_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_SubscribeBroadcastChannel_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SubscribeBroadcastChannel_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_SubscribeBroadcastChannel_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_SubscribeBroadcastChannel_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_SubscribeBroadcastChannel_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SubscribeBroadcastChannel_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_SubscribeBroadcastChannel_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_SubscribeBroadcastChannel_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SubscribeBroadcastChannel_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_SubscribeBroadcastChannel_Response

// optional bool is_subscribed = 1 [(.description) = "Whether the user is now subscribed"];
inline bool CSteamTV_SubscribeBroadcastChannel_Response::_internal_has_is_subscribed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SubscribeBroadcastChannel_Response::has_is_subscribed() const {
  return _internal_has_is_subscribed();
}
inline void CSteamTV_SubscribeBroadcastChannel_Response::clear_is_subscribed() {
  is_subscribed_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSteamTV_SubscribeBroadcastChannel_Response::_internal_is_subscribed() const {
  return is_subscribed_;
}
inline bool CSteamTV_SubscribeBroadcastChannel_Response::is_subscribed() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SubscribeBroadcastChannel_Response.is_subscribed)
  return _internal_is_subscribed();
}
inline void CSteamTV_SubscribeBroadcastChannel_Response::_internal_set_is_subscribed(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_subscribed_ = value;
}
inline void CSteamTV_SubscribeBroadcastChannel_Response::set_is_subscribed(bool value) {
  _internal_set_is_subscribed(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SubscribeBroadcastChannel_Response.is_subscribed)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelClips_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_GetBroadcastChannelClips_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelClips_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelClips_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelClips_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelClips_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelClips_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelClips_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelClips_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelClips_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_BroadcastClipInfo

// optional uint64 broadcast_clip_id = 1 [(.description) = "broadcast clip ID"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_broadcast_clip_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_broadcast_clip_id() const {
  return _internal_has_broadcast_clip_id();
}
inline void CSteamTV_BroadcastClipInfo::clear_broadcast_clip_id() {
  broadcast_clip_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_BroadcastClipInfo::_internal_broadcast_clip_id() const {
  return broadcast_clip_id_;
}
inline uint64_t CSteamTV_BroadcastClipInfo::broadcast_clip_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.broadcast_clip_id)
  return _internal_broadcast_clip_id();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_broadcast_clip_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  broadcast_clip_id_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_broadcast_clip_id(uint64_t value) {
  _internal_set_broadcast_clip_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.broadcast_clip_id)
}

// optional uint64 channel_id = 2 [(.description) = "Broadcast Channel ID"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_channel_id() const {
  return _internal_has_channel_id();
}
inline void CSteamTV_BroadcastClipInfo::clear_channel_id() {
  channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CSteamTV_BroadcastClipInfo::_internal_channel_id() const {
  return channel_id_;
}
inline uint64_t CSteamTV_BroadcastClipInfo::channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.channel_id)
  return _internal_channel_id();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  channel_id_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_channel_id(uint64_t value) {
  _internal_set_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.channel_id)
}

// optional uint32 app_id = 3 [(.description) = "App ID stream is tagged with"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_app_id() const {
  return _internal_has_app_id();
}
inline void CSteamTV_BroadcastClipInfo::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CSteamTV_BroadcastClipInfo::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CSteamTV_BroadcastClipInfo::app_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.app_id)
  return _internal_app_id();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  app_id_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.app_id)
}

// optional fixed64 broadcaster_steamid = 4 [(.description) = "Broadcaster SteamID"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_broadcaster_steamid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_broadcaster_steamid() const {
  return _internal_has_broadcaster_steamid();
}
inline void CSteamTV_BroadcastClipInfo::clear_broadcaster_steamid() {
  broadcaster_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CSteamTV_BroadcastClipInfo::_internal_broadcaster_steamid() const {
  return broadcaster_steamid_;
}
inline uint64_t CSteamTV_BroadcastClipInfo::broadcaster_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.broadcaster_steamid)
  return _internal_broadcaster_steamid();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_broadcaster_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  broadcaster_steamid_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_broadcaster_steamid(uint64_t value) {
  _internal_set_broadcaster_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.broadcaster_steamid)
}

// optional fixed64 creator_steamid = 5 [(.description) = "Clip-maker SteamID"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_creator_steamid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_creator_steamid() const {
  return _internal_has_creator_steamid();
}
inline void CSteamTV_BroadcastClipInfo::clear_creator_steamid() {
  creator_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CSteamTV_BroadcastClipInfo::_internal_creator_steamid() const {
  return creator_steamid_;
}
inline uint64_t CSteamTV_BroadcastClipInfo::creator_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.creator_steamid)
  return _internal_creator_steamid();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_creator_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  creator_steamid_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_creator_steamid(uint64_t value) {
  _internal_set_creator_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.creator_steamid)
}

// optional string video_description = 6 [(.description) = "Short name or description of this clip"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_video_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_video_description() const {
  return _internal_has_video_description();
}
inline void CSteamTV_BroadcastClipInfo::clear_video_description() {
  video_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_BroadcastClipInfo::video_description() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.video_description)
  return _internal_video_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_BroadcastClipInfo::set_video_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 video_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.video_description)
}
inline std::string* CSteamTV_BroadcastClipInfo::mutable_video_description() {
  std::string* _s = _internal_mutable_video_description();
  // @@protoc_insertion_point(field_mutable:CSteamTV_BroadcastClipInfo.video_description)
  return _s;
}
inline const std::string& CSteamTV_BroadcastClipInfo::_internal_video_description() const {
  return video_description_.Get();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_video_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  video_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_BroadcastClipInfo::_internal_mutable_video_description() {
  _has_bits_[0] |= 0x00000001u;
  return video_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_BroadcastClipInfo::release_video_description() {
  // @@protoc_insertion_point(field_release:CSteamTV_BroadcastClipInfo.video_description)
  if (!_internal_has_video_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = video_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (video_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    video_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_BroadcastClipInfo::set_allocated_video_description(std::string* video_description) {
  if (video_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  video_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), video_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (video_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    video_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_BroadcastClipInfo.video_description)
}

// optional uint32 live_time = 7 [(.description) = "GMT time clip was broadcasted live"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_live_time() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_live_time() const {
  return _internal_has_live_time();
}
inline void CSteamTV_BroadcastClipInfo::clear_live_time() {
  live_time_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CSteamTV_BroadcastClipInfo::_internal_live_time() const {
  return live_time_;
}
inline uint32_t CSteamTV_BroadcastClipInfo::live_time() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.live_time)
  return _internal_live_time();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_live_time(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  live_time_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_live_time(uint32_t value) {
  _internal_set_live_time(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.live_time)
}

// optional uint32 length_ms = 8 [(.description) = "length of video in MS"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_length_ms() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_length_ms() const {
  return _internal_has_length_ms();
}
inline void CSteamTV_BroadcastClipInfo::clear_length_ms() {
  length_ms_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CSteamTV_BroadcastClipInfo::_internal_length_ms() const {
  return length_ms_;
}
inline uint32_t CSteamTV_BroadcastClipInfo::length_ms() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.length_ms)
  return _internal_length_ms();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_length_ms(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  length_ms_ = value;
}
inline void CSteamTV_BroadcastClipInfo::set_length_ms(uint32_t value) {
  _internal_set_length_ms(value);
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.length_ms)
}

// optional string thumbnail_path = 9 [(.description) = "relative path for thumbnail URL on host"];
inline bool CSteamTV_BroadcastClipInfo::_internal_has_thumbnail_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_BroadcastClipInfo::has_thumbnail_path() const {
  return _internal_has_thumbnail_path();
}
inline void CSteamTV_BroadcastClipInfo::clear_thumbnail_path() {
  thumbnail_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_BroadcastClipInfo::thumbnail_path() const {
  // @@protoc_insertion_point(field_get:CSteamTV_BroadcastClipInfo.thumbnail_path)
  return _internal_thumbnail_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_BroadcastClipInfo::set_thumbnail_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 thumbnail_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_BroadcastClipInfo.thumbnail_path)
}
inline std::string* CSteamTV_BroadcastClipInfo::mutable_thumbnail_path() {
  std::string* _s = _internal_mutable_thumbnail_path();
  // @@protoc_insertion_point(field_mutable:CSteamTV_BroadcastClipInfo.thumbnail_path)
  return _s;
}
inline const std::string& CSteamTV_BroadcastClipInfo::_internal_thumbnail_path() const {
  return thumbnail_path_.Get();
}
inline void CSteamTV_BroadcastClipInfo::_internal_set_thumbnail_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  thumbnail_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_BroadcastClipInfo::_internal_mutable_thumbnail_path() {
  _has_bits_[0] |= 0x00000002u;
  return thumbnail_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_BroadcastClipInfo::release_thumbnail_path() {
  // @@protoc_insertion_point(field_release:CSteamTV_BroadcastClipInfo.thumbnail_path)
  if (!_internal_has_thumbnail_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = thumbnail_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_BroadcastClipInfo::set_allocated_thumbnail_path(std::string* thumbnail_path) {
  if (thumbnail_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  thumbnail_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_BroadcastClipInfo.thumbnail_path)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelClips_Response

// repeated .CSteamTV_BroadcastClipInfo clips = 1;
inline int CSteamTV_GetBroadcastChannelClips_Response::_internal_clips_size() const {
  return clips_.size();
}
inline int CSteamTV_GetBroadcastChannelClips_Response::clips_size() const {
  return _internal_clips_size();
}
inline void CSteamTV_GetBroadcastChannelClips_Response::clear_clips() {
  clips_.Clear();
}
inline ::CSteamTV_BroadcastClipInfo* CSteamTV_GetBroadcastChannelClips_Response::mutable_clips(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelClips_Response.clips)
  return clips_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_BroadcastClipInfo >*
CSteamTV_GetBroadcastChannelClips_Response::mutable_clips() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetBroadcastChannelClips_Response.clips)
  return &clips_;
}
inline const ::CSteamTV_BroadcastClipInfo& CSteamTV_GetBroadcastChannelClips_Response::_internal_clips(int index) const {
  return clips_.Get(index);
}
inline const ::CSteamTV_BroadcastClipInfo& CSteamTV_GetBroadcastChannelClips_Response::clips(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelClips_Response.clips)
  return _internal_clips(index);
}
inline ::CSteamTV_BroadcastClipInfo* CSteamTV_GetBroadcastChannelClips_Response::_internal_add_clips() {
  return clips_.Add();
}
inline ::CSteamTV_BroadcastClipInfo* CSteamTV_GetBroadcastChannelClips_Response::add_clips() {
  ::CSteamTV_BroadcastClipInfo* _add = _internal_add_clips();
  // @@protoc_insertion_point(field_add:CSteamTV_GetBroadcastChannelClips_Response.clips)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_BroadcastClipInfo >&
CSteamTV_GetBroadcastChannelClips_Response::clips() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetBroadcastChannelClips_Response.clips)
  return clips_;
}

// optional string thumbnail_host = 2;
inline bool CSteamTV_GetBroadcastChannelClips_Response::_internal_has_thumbnail_host() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelClips_Response::has_thumbnail_host() const {
  return _internal_has_thumbnail_host();
}
inline void CSteamTV_GetBroadcastChannelClips_Response::clear_thumbnail_host() {
  thumbnail_host_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_GetBroadcastChannelClips_Response::thumbnail_host() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
  return _internal_thumbnail_host();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_GetBroadcastChannelClips_Response::set_thumbnail_host(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 thumbnail_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
}
inline std::string* CSteamTV_GetBroadcastChannelClips_Response::mutable_thumbnail_host() {
  std::string* _s = _internal_mutable_thumbnail_host();
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
  return _s;
}
inline const std::string& CSteamTV_GetBroadcastChannelClips_Response::_internal_thumbnail_host() const {
  return thumbnail_host_.Get();
}
inline void CSteamTV_GetBroadcastChannelClips_Response::_internal_set_thumbnail_host(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  thumbnail_host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelClips_Response::_internal_mutable_thumbnail_host() {
  _has_bits_[0] |= 0x00000001u;
  return thumbnail_host_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_GetBroadcastChannelClips_Response::release_thumbnail_host() {
  // @@protoc_insertion_point(field_release:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
  if (!_internal_has_thumbnail_host()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = thumbnail_host_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_GetBroadcastChannelClips_Response::set_allocated_thumbnail_host(std::string* thumbnail_host) {
  if (thumbnail_host != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  thumbnail_host_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), thumbnail_host,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (thumbnail_host_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    thumbnail_host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_GetBroadcastChannelClips_Response.thumbnail_host)
}

// -------------------------------------------------------------------

// CSteamTV_ReportBroadcastChannel_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_ReportBroadcastChannel_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_ReportBroadcastChannel_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_ReportBroadcastChannel_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_ReportBroadcastChannel_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_ReportBroadcastChannel_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ReportBroadcastChannel_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_ReportBroadcastChannel_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_ReportBroadcastChannel_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_ReportBroadcastChannel_Request.broadcast_channel_id)
}

// optional string reason = 2 [(.description) = "The reason for the report"];
inline bool CSteamTV_ReportBroadcastChannel_Request::_internal_has_reason() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_ReportBroadcastChannel_Request::has_reason() const {
  return _internal_has_reason();
}
inline void CSteamTV_ReportBroadcastChannel_Request::clear_reason() {
  reason_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_ReportBroadcastChannel_Request::reason() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ReportBroadcastChannel_Request.reason)
  return _internal_reason();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_ReportBroadcastChannel_Request::set_reason(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_ReportBroadcastChannel_Request.reason)
}
inline std::string* CSteamTV_ReportBroadcastChannel_Request::mutable_reason() {
  std::string* _s = _internal_mutable_reason();
  // @@protoc_insertion_point(field_mutable:CSteamTV_ReportBroadcastChannel_Request.reason)
  return _s;
}
inline const std::string& CSteamTV_ReportBroadcastChannel_Request::_internal_reason() const {
  return reason_.Get();
}
inline void CSteamTV_ReportBroadcastChannel_Request::_internal_set_reason(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  reason_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_ReportBroadcastChannel_Request::_internal_mutable_reason() {
  _has_bits_[0] |= 0x00000001u;
  return reason_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_ReportBroadcastChannel_Request::release_reason() {
  // @@protoc_insertion_point(field_release:CSteamTV_ReportBroadcastChannel_Request.reason)
  if (!_internal_has_reason()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = reason_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_ReportBroadcastChannel_Request::set_allocated_reason(std::string* reason) {
  if (reason != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  reason_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reason,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (reason_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    reason_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_ReportBroadcastChannel_Request.reason)
}

// -------------------------------------------------------------------

// CSteamTV_ReportBroadcastChannel_Response

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelInteraction_Request

// optional fixed64 broadcast_channel_id = 1 [(.description) = "Broadcast channel ID"];
inline bool CSteamTV_GetBroadcastChannelInteraction_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetBroadcastChannelInteraction_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetBroadcastChannelInteraction_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelInteraction_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetBroadcastChannelInteraction_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelInteraction_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetBroadcastChannelInteraction_Response

// optional bool is_followed = 1 [(.description) = "Whether the user has followed this channel"];
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::_internal_has_is_followed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::has_is_followed() const {
  return _internal_has_is_followed();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::clear_is_followed() {
  is_followed_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::_internal_is_followed() const {
  return is_followed_;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::is_followed() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelInteraction_Response.is_followed)
  return _internal_is_followed();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::_internal_set_is_followed(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_followed_ = value;
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::set_is_followed(bool value) {
  _internal_set_is_followed(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelInteraction_Response.is_followed)
}

// optional bool is_subscribed = 2 [(.description) = "Whether the user has subscribed to this channel"];
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::_internal_has_is_subscribed() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::has_is_subscribed() const {
  return _internal_has_is_subscribed();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::clear_is_subscribed() {
  is_subscribed_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::_internal_is_subscribed() const {
  return is_subscribed_;
}
inline bool CSteamTV_GetBroadcastChannelInteraction_Response::is_subscribed() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetBroadcastChannelInteraction_Response.is_subscribed)
  return _internal_is_subscribed();
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::_internal_set_is_subscribed(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_subscribed_ = value;
}
inline void CSteamTV_GetBroadcastChannelInteraction_Response::set_is_subscribed(bool value) {
  _internal_set_is_subscribed(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetBroadcastChannelInteraction_Response.is_subscribed)
}

// -------------------------------------------------------------------

// CSteamTV_GetGames_Request

// optional uint32 appid = 1 [(.description) = "The ID for the game"];
inline bool CSteamTV_GetGames_Request::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetGames_Request::has_appid() const {
  return _internal_has_appid();
}
inline void CSteamTV_GetGames_Request::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSteamTV_GetGames_Request::_internal_appid() const {
  return appid_;
}
inline uint32_t CSteamTV_GetGames_Request::appid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetGames_Request.appid)
  return _internal_appid();
}
inline void CSteamTV_GetGames_Request::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CSteamTV_GetGames_Request::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetGames_Request.appid)
}

// optional .EGetGamesAlgorithm algorithm = 2 [default = k_EGetGamesAlgorithm_Default, (.description) = "The algorithm to use when picking games to return"];
inline bool CSteamTV_GetGames_Request::_internal_has_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetGames_Request::has_algorithm() const {
  return _internal_has_algorithm();
}
inline void CSteamTV_GetGames_Request::clear_algorithm() {
  algorithm_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EGetGamesAlgorithm CSteamTV_GetGames_Request::_internal_algorithm() const {
  return static_cast< ::EGetGamesAlgorithm >(algorithm_);
}
inline ::EGetGamesAlgorithm CSteamTV_GetGames_Request::algorithm() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetGames_Request.algorithm)
  return _internal_algorithm();
}
inline void CSteamTV_GetGames_Request::_internal_set_algorithm(::EGetGamesAlgorithm value) {
  assert(::EGetGamesAlgorithm_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  algorithm_ = value;
}
inline void CSteamTV_GetGames_Request::set_algorithm(::EGetGamesAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetGames_Request.algorithm)
}

// optional uint32 count = 3 [(.description) = "The maximum number of results to return"];
inline bool CSteamTV_GetGames_Request::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetGames_Request::has_count() const {
  return _internal_has_count();
}
inline void CSteamTV_GetGames_Request::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSteamTV_GetGames_Request::_internal_count() const {
  return count_;
}
inline uint32_t CSteamTV_GetGames_Request::count() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetGames_Request.count)
  return _internal_count();
}
inline void CSteamTV_GetGames_Request::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void CSteamTV_GetGames_Request::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetGames_Request.count)
}

// -------------------------------------------------------------------

// CSteamTV_Game

// optional uint32 appid = 1 [(.description) = "The ID for the game"];
inline bool CSteamTV_Game::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_appid() const {
  return _internal_has_appid();
}
inline void CSteamTV_Game::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CSteamTV_Game::_internal_appid() const {
  return appid_;
}
inline uint32_t CSteamTV_Game::appid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.appid)
  return _internal_appid();
}
inline void CSteamTV_Game::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  appid_ = value;
}
inline void CSteamTV_Game::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_Game.appid)
}

// optional string name = 2 [(.description) = "The name for the game"];
inline bool CSteamTV_Game::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_Game::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_Game::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Game::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Game.name)
}
inline std::string* CSteamTV_Game::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.name)
  return _s;
}
inline const std::string& CSteamTV_Game::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_Game::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_Game.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Game::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Game.name)
}

// optional string image = 3 [(.description) = "The image for the game"];
inline bool CSteamTV_Game::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_image() const {
  return _internal_has_image();
}
inline void CSteamTV_Game::clear_image() {
  image_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_Game::image() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Game::set_image(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Game.image)
}
inline std::string* CSteamTV_Game::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.image)
  return _s;
}
inline const std::string& CSteamTV_Game::_internal_image() const {
  return image_.Get();
}
inline void CSteamTV_Game::_internal_set_image(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000002u;
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::release_image() {
  // @@protoc_insertion_point(field_release:CSteamTV_Game.image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Game::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Game.image)
}

// optional uint64 viewers = 4 [(.description) = "Number of people watching this game"];
inline bool CSteamTV_Game::_internal_has_viewers() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_viewers() const {
  return _internal_has_viewers();
}
inline void CSteamTV_Game::clear_viewers() {
  viewers_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CSteamTV_Game::_internal_viewers() const {
  return viewers_;
}
inline uint64_t CSteamTV_Game::viewers() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.viewers)
  return _internal_viewers();
}
inline void CSteamTV_Game::_internal_set_viewers(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  viewers_ = value;
}
inline void CSteamTV_Game::set_viewers(uint64_t value) {
  _internal_set_viewers(value);
  // @@protoc_insertion_point(field_set:CSteamTV_Game.viewers)
}

// repeated .GetBroadcastChannelEntry channels = 5 [(.description) = "Live channels streaming this game"];
inline int CSteamTV_Game::_internal_channels_size() const {
  return channels_.size();
}
inline int CSteamTV_Game::channels_size() const {
  return _internal_channels_size();
}
inline void CSteamTV_Game::clear_channels() {
  channels_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_Game::mutable_channels(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.channels)
  return channels_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_Game::mutable_channels() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_Game.channels)
  return &channels_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_Game::_internal_channels(int index) const {
  return channels_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_Game::channels(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.channels)
  return _internal_channels(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_Game::_internal_add_channels() {
  return channels_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_Game::add_channels() {
  ::GetBroadcastChannelEntry* _add = _internal_add_channels();
  // @@protoc_insertion_point(field_add:CSteamTV_Game.channels)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_Game::channels() const {
  // @@protoc_insertion_point(field_list:CSteamTV_Game.channels)
  return channels_;
}

// optional string release_date = 6;
inline bool CSteamTV_Game::_internal_has_release_date() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_release_date() const {
  return _internal_has_release_date();
}
inline void CSteamTV_Game::clear_release_date() {
  release_date_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CSteamTV_Game::release_date() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.release_date)
  return _internal_release_date();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Game::set_release_date(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 release_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Game.release_date)
}
inline std::string* CSteamTV_Game::mutable_release_date() {
  std::string* _s = _internal_mutable_release_date();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.release_date)
  return _s;
}
inline const std::string& CSteamTV_Game::_internal_release_date() const {
  return release_date_.Get();
}
inline void CSteamTV_Game::_internal_set_release_date(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  release_date_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::_internal_mutable_release_date() {
  _has_bits_[0] |= 0x00000004u;
  return release_date_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::release_release_date() {
  // @@protoc_insertion_point(field_release:CSteamTV_Game.release_date)
  if (!_internal_has_release_date()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = release_date_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (release_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    release_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Game::set_allocated_release_date(std::string* release_date) {
  if (release_date != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  release_date_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), release_date,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (release_date_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    release_date_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Game.release_date)
}

// optional string developer = 7;
inline bool CSteamTV_Game::_internal_has_developer() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_developer() const {
  return _internal_has_developer();
}
inline void CSteamTV_Game::clear_developer() {
  developer_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CSteamTV_Game::developer() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.developer)
  return _internal_developer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Game::set_developer(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 developer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Game.developer)
}
inline std::string* CSteamTV_Game::mutable_developer() {
  std::string* _s = _internal_mutable_developer();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.developer)
  return _s;
}
inline const std::string& CSteamTV_Game::_internal_developer() const {
  return developer_.Get();
}
inline void CSteamTV_Game::_internal_set_developer(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  developer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::_internal_mutable_developer() {
  _has_bits_[0] |= 0x00000008u;
  return developer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::release_developer() {
  // @@protoc_insertion_point(field_release:CSteamTV_Game.developer)
  if (!_internal_has_developer()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = developer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (developer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    developer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Game::set_allocated_developer(std::string* developer) {
  if (developer != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  developer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), developer,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (developer_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    developer_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Game.developer)
}

// optional string publisher = 8;
inline bool CSteamTV_Game::_internal_has_publisher() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_Game::has_publisher() const {
  return _internal_has_publisher();
}
inline void CSteamTV_Game::clear_publisher() {
  publisher_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CSteamTV_Game::publisher() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Game.publisher)
  return _internal_publisher();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Game::set_publisher(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 publisher_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Game.publisher)
}
inline std::string* CSteamTV_Game::mutable_publisher() {
  std::string* _s = _internal_mutable_publisher();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Game.publisher)
  return _s;
}
inline const std::string& CSteamTV_Game::_internal_publisher() const {
  return publisher_.Get();
}
inline void CSteamTV_Game::_internal_set_publisher(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  publisher_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::_internal_mutable_publisher() {
  _has_bits_[0] |= 0x00000010u;
  return publisher_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Game::release_publisher() {
  // @@protoc_insertion_point(field_release:CSteamTV_Game.publisher)
  if (!_internal_has_publisher()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = publisher_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publisher_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publisher_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Game::set_allocated_publisher(std::string* publisher) {
  if (publisher != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  publisher_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), publisher,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (publisher_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    publisher_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Game.publisher)
}

// -------------------------------------------------------------------

// CSteamTV_GetGames_Response

// repeated .CSteamTV_Game results = 1 [(.description) = "The list of games"];
inline int CSteamTV_GetGames_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetGames_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetGames_Response::clear_results() {
  results_.Clear();
}
inline ::CSteamTV_Game* CSteamTV_GetGames_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetGames_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_Game >*
CSteamTV_GetGames_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetGames_Response.results)
  return &results_;
}
inline const ::CSteamTV_Game& CSteamTV_GetGames_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::CSteamTV_Game& CSteamTV_GetGames_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetGames_Response.results)
  return _internal_results(index);
}
inline ::CSteamTV_Game* CSteamTV_GetGames_Response::_internal_add_results() {
  return results_.Add();
}
inline ::CSteamTV_Game* CSteamTV_GetGames_Response::add_results() {
  ::CSteamTV_Game* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetGames_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_Game >&
CSteamTV_GetGames_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetGames_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_GetChannels_Request

// optional .EGetChannelsAlgorithm algorithm = 1 [default = k_EGetChannelsAlgorithm_Default, (.description) = "The algorithm to use when picking channels to return"];
inline bool CSteamTV_GetChannels_Request::_internal_has_algorithm() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_GetChannels_Request::has_algorithm() const {
  return _internal_has_algorithm();
}
inline void CSteamTV_GetChannels_Request::clear_algorithm() {
  algorithm_ = 1;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EGetChannelsAlgorithm CSteamTV_GetChannels_Request::_internal_algorithm() const {
  return static_cast< ::EGetChannelsAlgorithm >(algorithm_);
}
inline ::EGetChannelsAlgorithm CSteamTV_GetChannels_Request::algorithm() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChannels_Request.algorithm)
  return _internal_algorithm();
}
inline void CSteamTV_GetChannels_Request::_internal_set_algorithm(::EGetChannelsAlgorithm value) {
  assert(::EGetChannelsAlgorithm_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  algorithm_ = value;
}
inline void CSteamTV_GetChannels_Request::set_algorithm(::EGetChannelsAlgorithm value) {
  _internal_set_algorithm(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetChannels_Request.algorithm)
}

// optional uint32 count = 2 [(.description) = "The maximum number of results to return"];
inline bool CSteamTV_GetChannels_Request::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetChannels_Request::has_count() const {
  return _internal_has_count();
}
inline void CSteamTV_GetChannels_Request::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSteamTV_GetChannels_Request::_internal_count() const {
  return count_;
}
inline uint32_t CSteamTV_GetChannels_Request::count() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChannels_Request.count)
  return _internal_count();
}
inline void CSteamTV_GetChannels_Request::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  count_ = value;
}
inline void CSteamTV_GetChannels_Request::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetChannels_Request.count)
}

// optional uint32 appid = 3 [(.description) = "Filter results to only this appid"];
inline bool CSteamTV_GetChannels_Request::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetChannels_Request::has_appid() const {
  return _internal_has_appid();
}
inline void CSteamTV_GetChannels_Request::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSteamTV_GetChannels_Request::_internal_appid() const {
  return appid_;
}
inline uint32_t CSteamTV_GetChannels_Request::appid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChannels_Request.appid)
  return _internal_appid();
}
inline void CSteamTV_GetChannels_Request::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CSteamTV_GetChannels_Request::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetChannels_Request.appid)
}

// -------------------------------------------------------------------

// CSteamTV_GetChannels_Response

// repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of featured broadcasters"];
inline int CSteamTV_GetChannels_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetChannels_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetChannels_Response::clear_results() {
  results_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetChannels_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetChannels_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_GetChannels_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetChannels_Response.results)
  return &results_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetChannels_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetChannels_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChannels_Response.results)
  return _internal_results(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetChannels_Response::_internal_add_results() {
  return results_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetChannels_Response::add_results() {
  ::GetBroadcastChannelEntry* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetChannels_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_GetChannels_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetChannels_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_AddChatBan_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_AddChatBan_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AddChatBan_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_AddChatBan_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_AddChatBan_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_AddChatBan_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatBan_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_AddChatBan_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_AddChatBan_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatBan_Request.broadcast_channel_id)
}

// optional fixed64 chatter_steamid = 2;
inline bool CSteamTV_AddChatBan_Request::_internal_has_chatter_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_AddChatBan_Request::has_chatter_steamid() const {
  return _internal_has_chatter_steamid();
}
inline void CSteamTV_AddChatBan_Request::clear_chatter_steamid() {
  chatter_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_AddChatBan_Request::_internal_chatter_steamid() const {
  return chatter_steamid_;
}
inline uint64_t CSteamTV_AddChatBan_Request::chatter_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatBan_Request.chatter_steamid)
  return _internal_chatter_steamid();
}
inline void CSteamTV_AddChatBan_Request::_internal_set_chatter_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  chatter_steamid_ = value;
}
inline void CSteamTV_AddChatBan_Request::set_chatter_steamid(uint64_t value) {
  _internal_set_chatter_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatBan_Request.chatter_steamid)
}

// optional uint32 duration = 3;
inline bool CSteamTV_AddChatBan_Request::_internal_has_duration() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_AddChatBan_Request::has_duration() const {
  return _internal_has_duration();
}
inline void CSteamTV_AddChatBan_Request::clear_duration() {
  duration_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSteamTV_AddChatBan_Request::_internal_duration() const {
  return duration_;
}
inline uint32_t CSteamTV_AddChatBan_Request::duration() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatBan_Request.duration)
  return _internal_duration();
}
inline void CSteamTV_AddChatBan_Request::_internal_set_duration(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  duration_ = value;
}
inline void CSteamTV_AddChatBan_Request::set_duration(uint32_t value) {
  _internal_set_duration(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatBan_Request.duration)
}

// optional bool permanent = 4;
inline bool CSteamTV_AddChatBan_Request::_internal_has_permanent() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_AddChatBan_Request::has_permanent() const {
  return _internal_has_permanent();
}
inline void CSteamTV_AddChatBan_Request::clear_permanent() {
  permanent_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CSteamTV_AddChatBan_Request::_internal_permanent() const {
  return permanent_;
}
inline bool CSteamTV_AddChatBan_Request::permanent() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatBan_Request.permanent)
  return _internal_permanent();
}
inline void CSteamTV_AddChatBan_Request::_internal_set_permanent(bool value) {
  _has_bits_[0] |= 0x00000008u;
  permanent_ = value;
}
inline void CSteamTV_AddChatBan_Request::set_permanent(bool value) {
  _internal_set_permanent(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatBan_Request.permanent)
}

// optional bool undo = 5;
inline bool CSteamTV_AddChatBan_Request::_internal_has_undo() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_AddChatBan_Request::has_undo() const {
  return _internal_has_undo();
}
inline void CSteamTV_AddChatBan_Request::clear_undo() {
  undo_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CSteamTV_AddChatBan_Request::_internal_undo() const {
  return undo_;
}
inline bool CSteamTV_AddChatBan_Request::undo() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatBan_Request.undo)
  return _internal_undo();
}
inline void CSteamTV_AddChatBan_Request::_internal_set_undo(bool value) {
  _has_bits_[0] |= 0x00000010u;
  undo_ = value;
}
inline void CSteamTV_AddChatBan_Request::set_undo(bool value) {
  _internal_set_undo(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatBan_Request.undo)
}

// -------------------------------------------------------------------

// CSteamTV_AddChatBan_Response

// -------------------------------------------------------------------

// CSteamTV_GetChatBans_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_GetChatBans_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetChatBans_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetChatBans_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetChatBans_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetChatBans_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChatBans_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetChatBans_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetChatBans_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetChatBans_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_ChatBan

// optional fixed64 issuer_steamid = 1;
inline bool CSteamTV_ChatBan::_internal_has_issuer_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_ChatBan::has_issuer_steamid() const {
  return _internal_has_issuer_steamid();
}
inline void CSteamTV_ChatBan::clear_issuer_steamid() {
  issuer_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_ChatBan::_internal_issuer_steamid() const {
  return issuer_steamid_;
}
inline uint64_t CSteamTV_ChatBan::issuer_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatBan.issuer_steamid)
  return _internal_issuer_steamid();
}
inline void CSteamTV_ChatBan::_internal_set_issuer_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  issuer_steamid_ = value;
}
inline void CSteamTV_ChatBan::set_issuer_steamid(uint64_t value) {
  _internal_set_issuer_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_ChatBan.issuer_steamid)
}

// optional fixed64 chatter_steamid = 2;
inline bool CSteamTV_ChatBan::_internal_has_chatter_steamid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSteamTV_ChatBan::has_chatter_steamid() const {
  return _internal_has_chatter_steamid();
}
inline void CSteamTV_ChatBan::clear_chatter_steamid() {
  chatter_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CSteamTV_ChatBan::_internal_chatter_steamid() const {
  return chatter_steamid_;
}
inline uint64_t CSteamTV_ChatBan::chatter_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatBan.chatter_steamid)
  return _internal_chatter_steamid();
}
inline void CSteamTV_ChatBan::_internal_set_chatter_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  chatter_steamid_ = value;
}
inline void CSteamTV_ChatBan::set_chatter_steamid(uint64_t value) {
  _internal_set_chatter_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_ChatBan.chatter_steamid)
}

// optional string time_expires = 3;
inline bool CSteamTV_ChatBan::_internal_has_time_expires() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_ChatBan::has_time_expires() const {
  return _internal_has_time_expires();
}
inline void CSteamTV_ChatBan::clear_time_expires() {
  time_expires_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_ChatBan::time_expires() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatBan.time_expires)
  return _internal_time_expires();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_ChatBan::set_time_expires(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 time_expires_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_ChatBan.time_expires)
}
inline std::string* CSteamTV_ChatBan::mutable_time_expires() {
  std::string* _s = _internal_mutable_time_expires();
  // @@protoc_insertion_point(field_mutable:CSteamTV_ChatBan.time_expires)
  return _s;
}
inline const std::string& CSteamTV_ChatBan::_internal_time_expires() const {
  return time_expires_.Get();
}
inline void CSteamTV_ChatBan::_internal_set_time_expires(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  time_expires_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatBan::_internal_mutable_time_expires() {
  _has_bits_[0] |= 0x00000001u;
  return time_expires_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatBan::release_time_expires() {
  // @@protoc_insertion_point(field_release:CSteamTV_ChatBan.time_expires)
  if (!_internal_has_time_expires()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = time_expires_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (time_expires_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    time_expires_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_ChatBan::set_allocated_time_expires(std::string* time_expires) {
  if (time_expires != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  time_expires_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), time_expires,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (time_expires_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    time_expires_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_ChatBan.time_expires)
}

// optional bool permanent = 4;
inline bool CSteamTV_ChatBan::_internal_has_permanent() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSteamTV_ChatBan::has_permanent() const {
  return _internal_has_permanent();
}
inline void CSteamTV_ChatBan::clear_permanent() {
  permanent_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CSteamTV_ChatBan::_internal_permanent() const {
  return permanent_;
}
inline bool CSteamTV_ChatBan::permanent() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatBan.permanent)
  return _internal_permanent();
}
inline void CSteamTV_ChatBan::_internal_set_permanent(bool value) {
  _has_bits_[0] |= 0x00000010u;
  permanent_ = value;
}
inline void CSteamTV_ChatBan::set_permanent(bool value) {
  _internal_set_permanent(value);
  // @@protoc_insertion_point(field_set:CSteamTV_ChatBan.permanent)
}

// optional string name = 5;
inline bool CSteamTV_ChatBan::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_ChatBan::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_ChatBan::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSteamTV_ChatBan::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatBan.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_ChatBan::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_ChatBan.name)
}
inline std::string* CSteamTV_ChatBan::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_ChatBan.name)
  return _s;
}
inline const std::string& CSteamTV_ChatBan::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_ChatBan::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatBan::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatBan::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_ChatBan.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_ChatBan::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_ChatBan.name)
}

// -------------------------------------------------------------------

// CSteamTV_GetChatBans_Response

// repeated .CSteamTV_ChatBan results = 1 [(.description) = "The list of bans"];
inline int CSteamTV_GetChatBans_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetChatBans_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetChatBans_Response::clear_results() {
  results_.Clear();
}
inline ::CSteamTV_ChatBan* CSteamTV_GetChatBans_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetChatBans_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatBan >*
CSteamTV_GetChatBans_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetChatBans_Response.results)
  return &results_;
}
inline const ::CSteamTV_ChatBan& CSteamTV_GetChatBans_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::CSteamTV_ChatBan& CSteamTV_GetChatBans_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChatBans_Response.results)
  return _internal_results(index);
}
inline ::CSteamTV_ChatBan* CSteamTV_GetChatBans_Response::_internal_add_results() {
  return results_.Add();
}
inline ::CSteamTV_ChatBan* CSteamTV_GetChatBans_Response::add_results() {
  ::CSteamTV_ChatBan* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetChatBans_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatBan >&
CSteamTV_GetChatBans_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetChatBans_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_AddChatModerator_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_AddChatModerator_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AddChatModerator_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_AddChatModerator_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_AddChatModerator_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_AddChatModerator_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatModerator_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_AddChatModerator_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_AddChatModerator_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatModerator_Request.broadcast_channel_id)
}

// optional fixed64 moderator_steamid = 2;
inline bool CSteamTV_AddChatModerator_Request::_internal_has_moderator_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_AddChatModerator_Request::has_moderator_steamid() const {
  return _internal_has_moderator_steamid();
}
inline void CSteamTV_AddChatModerator_Request::clear_moderator_steamid() {
  moderator_steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_AddChatModerator_Request::_internal_moderator_steamid() const {
  return moderator_steamid_;
}
inline uint64_t CSteamTV_AddChatModerator_Request::moderator_steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatModerator_Request.moderator_steamid)
  return _internal_moderator_steamid();
}
inline void CSteamTV_AddChatModerator_Request::_internal_set_moderator_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  moderator_steamid_ = value;
}
inline void CSteamTV_AddChatModerator_Request::set_moderator_steamid(uint64_t value) {
  _internal_set_moderator_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatModerator_Request.moderator_steamid)
}

// optional bool undo = 3;
inline bool CSteamTV_AddChatModerator_Request::_internal_has_undo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_AddChatModerator_Request::has_undo() const {
  return _internal_has_undo();
}
inline void CSteamTV_AddChatModerator_Request::clear_undo() {
  undo_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CSteamTV_AddChatModerator_Request::_internal_undo() const {
  return undo_;
}
inline bool CSteamTV_AddChatModerator_Request::undo() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddChatModerator_Request.undo)
  return _internal_undo();
}
inline void CSteamTV_AddChatModerator_Request::_internal_set_undo(bool value) {
  _has_bits_[0] |= 0x00000004u;
  undo_ = value;
}
inline void CSteamTV_AddChatModerator_Request::set_undo(bool value) {
  _internal_set_undo(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddChatModerator_Request.undo)
}

// -------------------------------------------------------------------

// CSteamTV_AddChatModerator_Response

// -------------------------------------------------------------------

// CSteamTV_GetChatModerators_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_GetChatModerators_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetChatModerators_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetChatModerators_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetChatModerators_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetChatModerators_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChatModerators_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetChatModerators_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetChatModerators_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetChatModerators_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_ChatModerator

// optional fixed64 steamid = 1;
inline bool CSteamTV_ChatModerator::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_ChatModerator::has_steamid() const {
  return _internal_has_steamid();
}
inline void CSteamTV_ChatModerator::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_ChatModerator::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CSteamTV_ChatModerator::steamid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatModerator.steamid)
  return _internal_steamid();
}
inline void CSteamTV_ChatModerator::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CSteamTV_ChatModerator::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_ChatModerator.steamid)
}

// optional string name = 2;
inline bool CSteamTV_ChatModerator::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_ChatModerator::has_name() const {
  return _internal_has_name();
}
inline void CSteamTV_ChatModerator::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_ChatModerator::name() const {
  // @@protoc_insertion_point(field_get:CSteamTV_ChatModerator.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_ChatModerator::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_ChatModerator.name)
}
inline std::string* CSteamTV_ChatModerator::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CSteamTV_ChatModerator.name)
  return _s;
}
inline const std::string& CSteamTV_ChatModerator::_internal_name() const {
  return name_.Get();
}
inline void CSteamTV_ChatModerator::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatModerator::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_ChatModerator::release_name() {
  // @@protoc_insertion_point(field_release:CSteamTV_ChatModerator.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_ChatModerator::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_ChatModerator.name)
}

// -------------------------------------------------------------------

// CSteamTV_GetChatModerators_Response

// repeated .CSteamTV_ChatModerator results = 1 [(.description) = "The list of moderators"];
inline int CSteamTV_GetChatModerators_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetChatModerators_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetChatModerators_Response::clear_results() {
  results_.Clear();
}
inline ::CSteamTV_ChatModerator* CSteamTV_GetChatModerators_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetChatModerators_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatModerator >*
CSteamTV_GetChatModerators_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetChatModerators_Response.results)
  return &results_;
}
inline const ::CSteamTV_ChatModerator& CSteamTV_GetChatModerators_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::CSteamTV_ChatModerator& CSteamTV_GetChatModerators_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetChatModerators_Response.results)
  return _internal_results(index);
}
inline ::CSteamTV_ChatModerator* CSteamTV_GetChatModerators_Response::_internal_add_results() {
  return results_.Add();
}
inline ::CSteamTV_ChatModerator* CSteamTV_GetChatModerators_Response::add_results() {
  ::CSteamTV_ChatModerator* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetChatModerators_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_ChatModerator >&
CSteamTV_GetChatModerators_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetChatModerators_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_AddWordBan_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_AddWordBan_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_AddWordBan_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_AddWordBan_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_AddWordBan_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_AddWordBan_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddWordBan_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_AddWordBan_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_AddWordBan_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddWordBan_Request.broadcast_channel_id)
}

// optional string word = 2;
inline bool CSteamTV_AddWordBan_Request::_internal_has_word() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AddWordBan_Request::has_word() const {
  return _internal_has_word();
}
inline void CSteamTV_AddWordBan_Request::clear_word() {
  word_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_AddWordBan_Request::word() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddWordBan_Request.word)
  return _internal_word();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_AddWordBan_Request::set_word(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 word_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_AddWordBan_Request.word)
}
inline std::string* CSteamTV_AddWordBan_Request::mutable_word() {
  std::string* _s = _internal_mutable_word();
  // @@protoc_insertion_point(field_mutable:CSteamTV_AddWordBan_Request.word)
  return _s;
}
inline const std::string& CSteamTV_AddWordBan_Request::_internal_word() const {
  return word_.Get();
}
inline void CSteamTV_AddWordBan_Request::_internal_set_word(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  word_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_AddWordBan_Request::_internal_mutable_word() {
  _has_bits_[0] |= 0x00000001u;
  return word_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_AddWordBan_Request::release_word() {
  // @@protoc_insertion_point(field_release:CSteamTV_AddWordBan_Request.word)
  if (!_internal_has_word()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = word_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (word_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    word_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_AddWordBan_Request::set_allocated_word(std::string* word) {
  if (word != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  word_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), word,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (word_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    word_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_AddWordBan_Request.word)
}

// optional bool undo = 3;
inline bool CSteamTV_AddWordBan_Request::_internal_has_undo() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_AddWordBan_Request::has_undo() const {
  return _internal_has_undo();
}
inline void CSteamTV_AddWordBan_Request::clear_undo() {
  undo_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CSteamTV_AddWordBan_Request::_internal_undo() const {
  return undo_;
}
inline bool CSteamTV_AddWordBan_Request::undo() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AddWordBan_Request.undo)
  return _internal_undo();
}
inline void CSteamTV_AddWordBan_Request::_internal_set_undo(bool value) {
  _has_bits_[0] |= 0x00000004u;
  undo_ = value;
}
inline void CSteamTV_AddWordBan_Request::set_undo(bool value) {
  _internal_set_undo(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AddWordBan_Request.undo)
}

// -------------------------------------------------------------------

// CSteamTV_AddWordBan_Response

// -------------------------------------------------------------------

// CSteamTV_GetWordBans_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_GetWordBans_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetWordBans_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_GetWordBans_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_GetWordBans_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_GetWordBans_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetWordBans_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_GetWordBans_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_GetWordBans_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetWordBans_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_GetWordBans_Response

// repeated string results = 1 [(.description) = "The list of banned words"];
inline int CSteamTV_GetWordBans_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetWordBans_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetWordBans_Response::clear_results() {
  results_.Clear();
}
inline std::string* CSteamTV_GetWordBans_Response::add_results() {
  std::string* _s = _internal_add_results();
  // @@protoc_insertion_point(field_add_mutable:CSteamTV_GetWordBans_Response.results)
  return _s;
}
inline const std::string& CSteamTV_GetWordBans_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const std::string& CSteamTV_GetWordBans_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetWordBans_Response.results)
  return _internal_results(index);
}
inline std::string* CSteamTV_GetWordBans_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetWordBans_Response.results)
  return results_.Mutable(index);
}
inline void CSteamTV_GetWordBans_Response::set_results(int index, const std::string& value) {
  results_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::set_results(int index, std::string&& value) {
  results_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::set_results(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  results_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::set_results(int index, const char* value, size_t size) {
  results_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CSteamTV_GetWordBans_Response.results)
}
inline std::string* CSteamTV_GetWordBans_Response::_internal_add_results() {
  return results_.Add();
}
inline void CSteamTV_GetWordBans_Response::add_results(const std::string& value) {
  results_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::add_results(std::string&& value) {
  results_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::add_results(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  results_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CSteamTV_GetWordBans_Response.results)
}
inline void CSteamTV_GetWordBans_Response::add_results(const char* value, size_t size) {
  results_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CSteamTV_GetWordBans_Response.results)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CSteamTV_GetWordBans_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetWordBans_Response.results)
  return results_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CSteamTV_GetWordBans_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetWordBans_Response.results)
  return &results_;
}

// -------------------------------------------------------------------

// CSteamTV_JoinChat_Request

// optional fixed64 broadcast_channel_id = 1;
inline bool CSteamTV_JoinChat_Request::_internal_has_broadcast_channel_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_JoinChat_Request::has_broadcast_channel_id() const {
  return _internal_has_broadcast_channel_id();
}
inline void CSteamTV_JoinChat_Request::clear_broadcast_channel_id() {
  broadcast_channel_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_JoinChat_Request::_internal_broadcast_channel_id() const {
  return broadcast_channel_id_;
}
inline uint64_t CSteamTV_JoinChat_Request::broadcast_channel_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_JoinChat_Request.broadcast_channel_id)
  return _internal_broadcast_channel_id();
}
inline void CSteamTV_JoinChat_Request::_internal_set_broadcast_channel_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_channel_id_ = value;
}
inline void CSteamTV_JoinChat_Request::set_broadcast_channel_id(uint64_t value) {
  _internal_set_broadcast_channel_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_JoinChat_Request.broadcast_channel_id)
}

// -------------------------------------------------------------------

// CSteamTV_JoinChat_Response

// optional fixed64 chat_id = 1;
inline bool CSteamTV_JoinChat_Response::_internal_has_chat_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_JoinChat_Response::has_chat_id() const {
  return _internal_has_chat_id();
}
inline void CSteamTV_JoinChat_Response::clear_chat_id() {
  chat_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSteamTV_JoinChat_Response::_internal_chat_id() const {
  return chat_id_;
}
inline uint64_t CSteamTV_JoinChat_Response::chat_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_JoinChat_Response.chat_id)
  return _internal_chat_id();
}
inline void CSteamTV_JoinChat_Response::_internal_set_chat_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  chat_id_ = value;
}
inline void CSteamTV_JoinChat_Response::set_chat_id(uint64_t value) {
  _internal_set_chat_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_JoinChat_Response.chat_id)
}

// optional string view_url_template = 2;
inline bool CSteamTV_JoinChat_Response::_internal_has_view_url_template() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_JoinChat_Response::has_view_url_template() const {
  return _internal_has_view_url_template();
}
inline void CSteamTV_JoinChat_Response::clear_view_url_template() {
  view_url_template_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_JoinChat_Response::view_url_template() const {
  // @@protoc_insertion_point(field_get:CSteamTV_JoinChat_Response.view_url_template)
  return _internal_view_url_template();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_JoinChat_Response::set_view_url_template(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 view_url_template_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_JoinChat_Response.view_url_template)
}
inline std::string* CSteamTV_JoinChat_Response::mutable_view_url_template() {
  std::string* _s = _internal_mutable_view_url_template();
  // @@protoc_insertion_point(field_mutable:CSteamTV_JoinChat_Response.view_url_template)
  return _s;
}
inline const std::string& CSteamTV_JoinChat_Response::_internal_view_url_template() const {
  return view_url_template_.Get();
}
inline void CSteamTV_JoinChat_Response::_internal_set_view_url_template(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  view_url_template_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_JoinChat_Response::_internal_mutable_view_url_template() {
  _has_bits_[0] |= 0x00000001u;
  return view_url_template_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_JoinChat_Response::release_view_url_template() {
  // @@protoc_insertion_point(field_release:CSteamTV_JoinChat_Response.view_url_template)
  if (!_internal_has_view_url_template()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = view_url_template_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_url_template_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    view_url_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_JoinChat_Response::set_allocated_view_url_template(std::string* view_url_template) {
  if (view_url_template != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  view_url_template_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), view_url_template,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (view_url_template_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    view_url_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_JoinChat_Response.view_url_template)
}

// repeated uint64 flair_group_ids = 3;
inline int CSteamTV_JoinChat_Response::_internal_flair_group_ids_size() const {
  return flair_group_ids_.size();
}
inline int CSteamTV_JoinChat_Response::flair_group_ids_size() const {
  return _internal_flair_group_ids_size();
}
inline void CSteamTV_JoinChat_Response::clear_flair_group_ids() {
  flair_group_ids_.Clear();
}
inline uint64_t CSteamTV_JoinChat_Response::_internal_flair_group_ids(int index) const {
  return flair_group_ids_.Get(index);
}
inline uint64_t CSteamTV_JoinChat_Response::flair_group_ids(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_JoinChat_Response.flair_group_ids)
  return _internal_flair_group_ids(index);
}
inline void CSteamTV_JoinChat_Response::set_flair_group_ids(int index, uint64_t value) {
  flair_group_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CSteamTV_JoinChat_Response.flair_group_ids)
}
inline void CSteamTV_JoinChat_Response::_internal_add_flair_group_ids(uint64_t value) {
  flair_group_ids_.Add(value);
}
inline void CSteamTV_JoinChat_Response::add_flair_group_ids(uint64_t value) {
  _internal_add_flair_group_ids(value);
  // @@protoc_insertion_point(field_add:CSteamTV_JoinChat_Response.flair_group_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CSteamTV_JoinChat_Response::_internal_flair_group_ids() const {
  return flair_group_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CSteamTV_JoinChat_Response::flair_group_ids() const {
  // @@protoc_insertion_point(field_list:CSteamTV_JoinChat_Response.flair_group_ids)
  return _internal_flair_group_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CSteamTV_JoinChat_Response::_internal_mutable_flair_group_ids() {
  return &flair_group_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CSteamTV_JoinChat_Response::mutable_flair_group_ids() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_JoinChat_Response.flair_group_ids)
  return _internal_mutable_flair_group_ids();
}

// -------------------------------------------------------------------

// CSteamTV_Search_Request

// optional string term = 1;
inline bool CSteamTV_Search_Request::_internal_has_term() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_Search_Request::has_term() const {
  return _internal_has_term();
}
inline void CSteamTV_Search_Request::clear_term() {
  term_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_Search_Request::term() const {
  // @@protoc_insertion_point(field_get:CSteamTV_Search_Request.term)
  return _internal_term();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_Search_Request::set_term(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 term_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_Search_Request.term)
}
inline std::string* CSteamTV_Search_Request::mutable_term() {
  std::string* _s = _internal_mutable_term();
  // @@protoc_insertion_point(field_mutable:CSteamTV_Search_Request.term)
  return _s;
}
inline const std::string& CSteamTV_Search_Request::_internal_term() const {
  return term_.Get();
}
inline void CSteamTV_Search_Request::_internal_set_term(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  term_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_Search_Request::_internal_mutable_term() {
  _has_bits_[0] |= 0x00000001u;
  return term_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_Search_Request::release_term() {
  // @@protoc_insertion_point(field_release:CSteamTV_Search_Request.term)
  if (!_internal_has_term()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = term_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (term_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    term_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_Search_Request::set_allocated_term(std::string* term) {
  if (term != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  term_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), term,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (term_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    term_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_Search_Request.term)
}

// -------------------------------------------------------------------

// CSteamTV_Search_Response

// repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
inline int CSteamTV_Search_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_Search_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_Search_Response::clear_results() {
  results_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_Search_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_Search_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_Search_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_Search_Response.results)
  return &results_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_Search_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_Search_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_Search_Response.results)
  return _internal_results(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_Search_Response::_internal_add_results() {
  return results_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_Search_Response::add_results() {
  ::GetBroadcastChannelEntry* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_Search_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_Search_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_Search_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_GetSteamTVUserSettings_Request

// -------------------------------------------------------------------

// CSteamTV_GetSteamTVUserSettings_Response

// optional bool stream_live_email = 1 [(.description) = "Send email when followed stream starts"];
inline bool CSteamTV_GetSteamTVUserSettings_Response::_internal_has_stream_live_email() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::has_stream_live_email() const {
  return _internal_has_stream_live_email();
}
inline void CSteamTV_GetSteamTVUserSettings_Response::clear_stream_live_email() {
  stream_live_email_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::_internal_stream_live_email() const {
  return stream_live_email_;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::stream_live_email() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetSteamTVUserSettings_Response.stream_live_email)
  return _internal_stream_live_email();
}
inline void CSteamTV_GetSteamTVUserSettings_Response::_internal_set_stream_live_email(bool value) {
  _has_bits_[0] |= 0x00000001u;
  stream_live_email_ = value;
}
inline void CSteamTV_GetSteamTVUserSettings_Response::set_stream_live_email(bool value) {
  _internal_set_stream_live_email(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetSteamTVUserSettings_Response.stream_live_email)
}

// optional bool stream_live_notification = 2 [(.description) = "Send Steam notification when followed stream starts"];
inline bool CSteamTV_GetSteamTVUserSettings_Response::_internal_has_stream_live_notification() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::has_stream_live_notification() const {
  return _internal_has_stream_live_notification();
}
inline void CSteamTV_GetSteamTVUserSettings_Response::clear_stream_live_notification() {
  stream_live_notification_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::_internal_stream_live_notification() const {
  return stream_live_notification_;
}
inline bool CSteamTV_GetSteamTVUserSettings_Response::stream_live_notification() const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetSteamTVUserSettings_Response.stream_live_notification)
  return _internal_stream_live_notification();
}
inline void CSteamTV_GetSteamTVUserSettings_Response::_internal_set_stream_live_notification(bool value) {
  _has_bits_[0] |= 0x00000002u;
  stream_live_notification_ = value;
}
inline void CSteamTV_GetSteamTVUserSettings_Response::set_stream_live_notification(bool value) {
  _internal_set_stream_live_notification(value);
  // @@protoc_insertion_point(field_set:CSteamTV_GetSteamTVUserSettings_Response.stream_live_notification)
}

// -------------------------------------------------------------------

// CSteamTV_SetSteamTVUserSettings_Request

// optional bool stream_live_email = 1 [(.description) = "Send email when followed stream starts"];
inline bool CSteamTV_SetSteamTVUserSettings_Request::_internal_has_stream_live_email() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::has_stream_live_email() const {
  return _internal_has_stream_live_email();
}
inline void CSteamTV_SetSteamTVUserSettings_Request::clear_stream_live_email() {
  stream_live_email_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::_internal_stream_live_email() const {
  return stream_live_email_;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::stream_live_email() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetSteamTVUserSettings_Request.stream_live_email)
  return _internal_stream_live_email();
}
inline void CSteamTV_SetSteamTVUserSettings_Request::_internal_set_stream_live_email(bool value) {
  _has_bits_[0] |= 0x00000001u;
  stream_live_email_ = value;
}
inline void CSteamTV_SetSteamTVUserSettings_Request::set_stream_live_email(bool value) {
  _internal_set_stream_live_email(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetSteamTVUserSettings_Request.stream_live_email)
}

// optional bool stream_live_notification = 2 [(.description) = "Send Steam notification when followed stream starts"];
inline bool CSteamTV_SetSteamTVUserSettings_Request::_internal_has_stream_live_notification() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::has_stream_live_notification() const {
  return _internal_has_stream_live_notification();
}
inline void CSteamTV_SetSteamTVUserSettings_Request::clear_stream_live_notification() {
  stream_live_notification_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::_internal_stream_live_notification() const {
  return stream_live_notification_;
}
inline bool CSteamTV_SetSteamTVUserSettings_Request::stream_live_notification() const {
  // @@protoc_insertion_point(field_get:CSteamTV_SetSteamTVUserSettings_Request.stream_live_notification)
  return _internal_stream_live_notification();
}
inline void CSteamTV_SetSteamTVUserSettings_Request::_internal_set_stream_live_notification(bool value) {
  _has_bits_[0] |= 0x00000002u;
  stream_live_notification_ = value;
}
inline void CSteamTV_SetSteamTVUserSettings_Request::set_stream_live_notification(bool value) {
  _internal_set_stream_live_notification(value);
  // @@protoc_insertion_point(field_set:CSteamTV_SetSteamTVUserSettings_Request.stream_live_notification)
}

// -------------------------------------------------------------------

// CSteamTV_SetSteamTVUserSettings_Response

// -------------------------------------------------------------------

// CSteamTV_GetMyBroadcastChannels_Request

// -------------------------------------------------------------------

// CSteamTV_GetMyBroadcastChannels_Response

// repeated .GetBroadcastChannelEntry results = 1 [(.description) = "The list of broadcasters"];
inline int CSteamTV_GetMyBroadcastChannels_Response::_internal_results_size() const {
  return results_.size();
}
inline int CSteamTV_GetMyBroadcastChannels_Response::results_size() const {
  return _internal_results_size();
}
inline void CSteamTV_GetMyBroadcastChannels_Response::clear_results() {
  results_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetMyBroadcastChannels_Response::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetMyBroadcastChannels_Response.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_GetMyBroadcastChannels_Response::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetMyBroadcastChannels_Response.results)
  return &results_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetMyBroadcastChannels_Response::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_GetMyBroadcastChannels_Response::results(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetMyBroadcastChannels_Response.results)
  return _internal_results(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetMyBroadcastChannels_Response::_internal_add_results() {
  return results_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_GetMyBroadcastChannels_Response::add_results() {
  ::GetBroadcastChannelEntry* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:CSteamTV_GetMyBroadcastChannels_Response.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_GetMyBroadcastChannels_Response::results() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetMyBroadcastChannels_Response.results)
  return results_;
}

// -------------------------------------------------------------------

// CSteamTV_GetHomePageContents_Request

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_Takeover

// repeated .GetBroadcastChannelEntry broadcasts = 1;
inline int CSteamTV_HomePageTemplate_Takeover::_internal_broadcasts_size() const {
  return broadcasts_.size();
}
inline int CSteamTV_HomePageTemplate_Takeover::broadcasts_size() const {
  return _internal_broadcasts_size();
}
inline void CSteamTV_HomePageTemplate_Takeover::clear_broadcasts() {
  broadcasts_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Takeover::mutable_broadcasts(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_Takeover.broadcasts)
  return broadcasts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_HomePageTemplate_Takeover::mutable_broadcasts() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_HomePageTemplate_Takeover.broadcasts)
  return &broadcasts_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_Takeover::_internal_broadcasts(int index) const {
  return broadcasts_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_Takeover::broadcasts(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_Takeover.broadcasts)
  return _internal_broadcasts(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Takeover::_internal_add_broadcasts() {
  return broadcasts_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Takeover::add_broadcasts() {
  ::GetBroadcastChannelEntry* _add = _internal_add_broadcasts();
  // @@protoc_insertion_point(field_add:CSteamTV_HomePageTemplate_Takeover.broadcasts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_HomePageTemplate_Takeover::broadcasts() const {
  // @@protoc_insertion_point(field_list:CSteamTV_HomePageTemplate_Takeover.broadcasts)
  return broadcasts_;
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_SingleGame

// repeated .GetBroadcastChannelEntry broadcasts = 1;
inline int CSteamTV_HomePageTemplate_SingleGame::_internal_broadcasts_size() const {
  return broadcasts_.size();
}
inline int CSteamTV_HomePageTemplate_SingleGame::broadcasts_size() const {
  return _internal_broadcasts_size();
}
inline void CSteamTV_HomePageTemplate_SingleGame::clear_broadcasts() {
  broadcasts_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_SingleGame::mutable_broadcasts(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
  return broadcasts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_HomePageTemplate_SingleGame::mutable_broadcasts() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
  return &broadcasts_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_SingleGame::_internal_broadcasts(int index) const {
  return broadcasts_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_SingleGame::broadcasts(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
  return _internal_broadcasts(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_SingleGame::_internal_add_broadcasts() {
  return broadcasts_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_SingleGame::add_broadcasts() {
  ::GetBroadcastChannelEntry* _add = _internal_add_broadcasts();
  // @@protoc_insertion_point(field_add:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_HomePageTemplate_SingleGame::broadcasts() const {
  // @@protoc_insertion_point(field_list:CSteamTV_HomePageTemplate_SingleGame.broadcasts)
  return broadcasts_;
}

// optional uint32 appid = 2;
inline bool CSteamTV_HomePageTemplate_SingleGame::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_SingleGame::has_appid() const {
  return _internal_has_appid();
}
inline void CSteamTV_HomePageTemplate_SingleGame::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSteamTV_HomePageTemplate_SingleGame::_internal_appid() const {
  return appid_;
}
inline uint32_t CSteamTV_HomePageTemplate_SingleGame::appid() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_SingleGame.appid)
  return _internal_appid();
}
inline void CSteamTV_HomePageTemplate_SingleGame::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CSteamTV_HomePageTemplate_SingleGame::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_SingleGame.appid)
}

// optional string title = 3;
inline bool CSteamTV_HomePageTemplate_SingleGame::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_SingleGame::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_SingleGame::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_SingleGame::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_SingleGame.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_SingleGame::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_SingleGame.title)
}
inline std::string* CSteamTV_HomePageTemplate_SingleGame::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_SingleGame.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_SingleGame::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_SingleGame::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_SingleGame::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_SingleGame::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_SingleGame.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_SingleGame::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_SingleGame.title)
}

// -------------------------------------------------------------------

// GameListEntry

// optional uint32 appid = 1;
inline bool GameListEntry::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool GameListEntry::has_appid() const {
  return _internal_has_appid();
}
inline void GameListEntry::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t GameListEntry::_internal_appid() const {
  return appid_;
}
inline uint32_t GameListEntry::appid() const {
  // @@protoc_insertion_point(field_get:GameListEntry.appid)
  return _internal_appid();
}
inline void GameListEntry::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void GameListEntry::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:GameListEntry.appid)
}

// optional string game_name = 2;
inline bool GameListEntry::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool GameListEntry::has_game_name() const {
  return _internal_has_game_name();
}
inline void GameListEntry::clear_game_name() {
  game_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& GameListEntry::game_name() const {
  // @@protoc_insertion_point(field_get:GameListEntry.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GameListEntry::set_game_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:GameListEntry.game_name)
}
inline std::string* GameListEntry::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:GameListEntry.game_name)
  return _s;
}
inline const std::string& GameListEntry::_internal_game_name() const {
  return game_name_.Get();
}
inline void GameListEntry::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GameListEntry::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  return game_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GameListEntry::release_game_name() {
  // @@protoc_insertion_point(field_release:GameListEntry.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void GameListEntry::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:GameListEntry.game_name)
}

// optional .GetBroadcastChannelEntry broadcast = 3;
inline bool GameListEntry::_internal_has_broadcast() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || broadcast_ != nullptr);
  return value;
}
inline bool GameListEntry::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void GameListEntry::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::GetBroadcastChannelEntry& GameListEntry::_internal_broadcast() const {
  const ::GetBroadcastChannelEntry* p = broadcast_;
  return p != nullptr ? *p : reinterpret_cast<const ::GetBroadcastChannelEntry&>(
      ::_GetBroadcastChannelEntry_default_instance_);
}
inline const ::GetBroadcastChannelEntry& GameListEntry::broadcast() const {
  // @@protoc_insertion_point(field_get:GameListEntry.broadcast)
  return _internal_broadcast();
}
inline void GameListEntry::unsafe_arena_set_allocated_broadcast(
    ::GetBroadcastChannelEntry* broadcast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:GameListEntry.broadcast)
}
inline ::GetBroadcastChannelEntry* GameListEntry::release_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GetBroadcastChannelEntry* GameListEntry::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:GameListEntry.broadcast)
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::GetBroadcastChannelEntry* GameListEntry::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000002u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::GetBroadcastChannelEntry>(GetArenaForAllocation());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::GetBroadcastChannelEntry* GameListEntry::mutable_broadcast() {
  ::GetBroadcastChannelEntry* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:GameListEntry.broadcast)
  return _msg;
}
inline void GameListEntry::set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GetBroadcastChannelEntry>::GetOwningArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:GameListEntry.broadcast)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_GameList

// repeated .GameListEntry entries = 1;
inline int CSteamTV_HomePageTemplate_GameList::_internal_entries_size() const {
  return entries_.size();
}
inline int CSteamTV_HomePageTemplate_GameList::entries_size() const {
  return _internal_entries_size();
}
inline void CSteamTV_HomePageTemplate_GameList::clear_entries() {
  entries_.Clear();
}
inline ::GameListEntry* CSteamTV_HomePageTemplate_GameList::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_GameList.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameListEntry >*
CSteamTV_HomePageTemplate_GameList::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_HomePageTemplate_GameList.entries)
  return &entries_;
}
inline const ::GameListEntry& CSteamTV_HomePageTemplate_GameList::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::GameListEntry& CSteamTV_HomePageTemplate_GameList::entries(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_GameList.entries)
  return _internal_entries(index);
}
inline ::GameListEntry* CSteamTV_HomePageTemplate_GameList::_internal_add_entries() {
  return entries_.Add();
}
inline ::GameListEntry* CSteamTV_HomePageTemplate_GameList::add_entries() {
  ::GameListEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:CSteamTV_HomePageTemplate_GameList.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GameListEntry >&
CSteamTV_HomePageTemplate_GameList::entries() const {
  // @@protoc_insertion_point(field_list:CSteamTV_HomePageTemplate_GameList.entries)
  return entries_;
}

// optional string title = 2;
inline bool CSteamTV_HomePageTemplate_GameList::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_GameList::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_GameList::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_GameList::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_GameList.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_GameList::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_GameList.title)
}
inline std::string* CSteamTV_HomePageTemplate_GameList::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_GameList.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_GameList::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_GameList::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_GameList::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_GameList::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_GameList.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_GameList::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_GameList.title)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_QuickExplore

// repeated .GetBroadcastChannelEntry broadcasts = 1;
inline int CSteamTV_HomePageTemplate_QuickExplore::_internal_broadcasts_size() const {
  return broadcasts_.size();
}
inline int CSteamTV_HomePageTemplate_QuickExplore::broadcasts_size() const {
  return _internal_broadcasts_size();
}
inline void CSteamTV_HomePageTemplate_QuickExplore::clear_broadcasts() {
  broadcasts_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_QuickExplore::mutable_broadcasts(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
  return broadcasts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_HomePageTemplate_QuickExplore::mutable_broadcasts() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
  return &broadcasts_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_QuickExplore::_internal_broadcasts(int index) const {
  return broadcasts_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_QuickExplore::broadcasts(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
  return _internal_broadcasts(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_QuickExplore::_internal_add_broadcasts() {
  return broadcasts_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_QuickExplore::add_broadcasts() {
  ::GetBroadcastChannelEntry* _add = _internal_add_broadcasts();
  // @@protoc_insertion_point(field_add:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_HomePageTemplate_QuickExplore::broadcasts() const {
  // @@protoc_insertion_point(field_list:CSteamTV_HomePageTemplate_QuickExplore.broadcasts)
  return broadcasts_;
}

// optional string title = 2;
inline bool CSteamTV_HomePageTemplate_QuickExplore::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_QuickExplore::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_QuickExplore::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_QuickExplore::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_QuickExplore.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_QuickExplore::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_QuickExplore.title)
}
inline std::string* CSteamTV_HomePageTemplate_QuickExplore::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_QuickExplore.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_QuickExplore::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_QuickExplore::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_QuickExplore::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_QuickExplore::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_QuickExplore.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_QuickExplore::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_QuickExplore.title)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_ConveyorBelt

// repeated .GetBroadcastChannelEntry broadcasts = 1;
inline int CSteamTV_HomePageTemplate_ConveyorBelt::_internal_broadcasts_size() const {
  return broadcasts_.size();
}
inline int CSteamTV_HomePageTemplate_ConveyorBelt::broadcasts_size() const {
  return _internal_broadcasts_size();
}
inline void CSteamTV_HomePageTemplate_ConveyorBelt::clear_broadcasts() {
  broadcasts_.Clear();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_ConveyorBelt::mutable_broadcasts(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
  return broadcasts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >*
CSteamTV_HomePageTemplate_ConveyorBelt::mutable_broadcasts() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
  return &broadcasts_;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_ConveyorBelt::_internal_broadcasts(int index) const {
  return broadcasts_.Get(index);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_ConveyorBelt::broadcasts(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
  return _internal_broadcasts(index);
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_ConveyorBelt::_internal_add_broadcasts() {
  return broadcasts_.Add();
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_ConveyorBelt::add_broadcasts() {
  ::GetBroadcastChannelEntry* _add = _internal_add_broadcasts();
  // @@protoc_insertion_point(field_add:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::GetBroadcastChannelEntry >&
CSteamTV_HomePageTemplate_ConveyorBelt::broadcasts() const {
  // @@protoc_insertion_point(field_list:CSteamTV_HomePageTemplate_ConveyorBelt.broadcasts)
  return broadcasts_;
}

// optional string title = 2;
inline bool CSteamTV_HomePageTemplate_ConveyorBelt::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_ConveyorBelt::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_ConveyorBelt::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_ConveyorBelt::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_ConveyorBelt.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_ConveyorBelt::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_ConveyorBelt.title)
}
inline std::string* CSteamTV_HomePageTemplate_ConveyorBelt::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_ConveyorBelt.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_ConveyorBelt::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_ConveyorBelt::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_ConveyorBelt::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_ConveyorBelt::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_ConveyorBelt.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_ConveyorBelt::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_ConveyorBelt.title)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_WatchParty

// optional .GetBroadcastChannelEntry broadcast = 1;
inline bool CSteamTV_HomePageTemplate_WatchParty::_internal_has_broadcast() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || broadcast_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageTemplate_WatchParty::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void CSteamTV_HomePageTemplate_WatchParty::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_WatchParty::_internal_broadcast() const {
  const ::GetBroadcastChannelEntry* p = broadcast_;
  return p != nullptr ? *p : reinterpret_cast<const ::GetBroadcastChannelEntry&>(
      ::_GetBroadcastChannelEntry_default_instance_);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_WatchParty::broadcast() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_WatchParty.broadcast)
  return _internal_broadcast();
}
inline void CSteamTV_HomePageTemplate_WatchParty::unsafe_arena_set_allocated_broadcast(
    ::GetBroadcastChannelEntry* broadcast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageTemplate_WatchParty.broadcast)
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_WatchParty::release_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_WatchParty::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_WatchParty.broadcast)
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_WatchParty::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000002u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::GetBroadcastChannelEntry>(GetArenaForAllocation());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_WatchParty::mutable_broadcast() {
  ::GetBroadcastChannelEntry* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_WatchParty.broadcast)
  return _msg;
}
inline void CSteamTV_HomePageTemplate_WatchParty::set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GetBroadcastChannelEntry>::GetOwningArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_WatchParty.broadcast)
}

// optional string title = 2;
inline bool CSteamTV_HomePageTemplate_WatchParty::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_WatchParty::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_WatchParty::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_WatchParty::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_WatchParty.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_WatchParty::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_WatchParty.title)
}
inline std::string* CSteamTV_HomePageTemplate_WatchParty::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_WatchParty.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_WatchParty::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_WatchParty::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_WatchParty::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_WatchParty::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_WatchParty.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_WatchParty::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_WatchParty.title)
}

// optional uint64 chat_group_id = 3;
inline bool CSteamTV_HomePageTemplate_WatchParty::_internal_has_chat_group_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_WatchParty::has_chat_group_id() const {
  return _internal_has_chat_group_id();
}
inline void CSteamTV_HomePageTemplate_WatchParty::clear_chat_group_id() {
  chat_group_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CSteamTV_HomePageTemplate_WatchParty::_internal_chat_group_id() const {
  return chat_group_id_;
}
inline uint64_t CSteamTV_HomePageTemplate_WatchParty::chat_group_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_WatchParty.chat_group_id)
  return _internal_chat_group_id();
}
inline void CSteamTV_HomePageTemplate_WatchParty::_internal_set_chat_group_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  chat_group_id_ = value;
}
inline void CSteamTV_HomePageTemplate_WatchParty::set_chat_group_id(uint64_t value) {
  _internal_set_chat_group_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_WatchParty.chat_group_id)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_Developer

// optional .GetBroadcastChannelEntry broadcast = 1;
inline bool CSteamTV_HomePageTemplate_Developer::_internal_has_broadcast() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || broadcast_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageTemplate_Developer::has_broadcast() const {
  return _internal_has_broadcast();
}
inline void CSteamTV_HomePageTemplate_Developer::clear_broadcast() {
  if (broadcast_ != nullptr) broadcast_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_Developer::_internal_broadcast() const {
  const ::GetBroadcastChannelEntry* p = broadcast_;
  return p != nullptr ? *p : reinterpret_cast<const ::GetBroadcastChannelEntry&>(
      ::_GetBroadcastChannelEntry_default_instance_);
}
inline const ::GetBroadcastChannelEntry& CSteamTV_HomePageTemplate_Developer::broadcast() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_Developer.broadcast)
  return _internal_broadcast();
}
inline void CSteamTV_HomePageTemplate_Developer::unsafe_arena_set_allocated_broadcast(
    ::GetBroadcastChannelEntry* broadcast) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(broadcast_);
  }
  broadcast_ = broadcast;
  if (broadcast) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageTemplate_Developer.broadcast)
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Developer::release_broadcast() {
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Developer::unsafe_arena_release_broadcast() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_Developer.broadcast)
  _has_bits_[0] &= ~0x00000002u;
  ::GetBroadcastChannelEntry* temp = broadcast_;
  broadcast_ = nullptr;
  return temp;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Developer::_internal_mutable_broadcast() {
  _has_bits_[0] |= 0x00000002u;
  if (broadcast_ == nullptr) {
    auto* p = CreateMaybeMessage<::GetBroadcastChannelEntry>(GetArenaForAllocation());
    broadcast_ = p;
  }
  return broadcast_;
}
inline ::GetBroadcastChannelEntry* CSteamTV_HomePageTemplate_Developer::mutable_broadcast() {
  ::GetBroadcastChannelEntry* _msg = _internal_mutable_broadcast();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_Developer.broadcast)
  return _msg;
}
inline void CSteamTV_HomePageTemplate_Developer::set_allocated_broadcast(::GetBroadcastChannelEntry* broadcast) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete broadcast_;
  }
  if (broadcast) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::GetBroadcastChannelEntry>::GetOwningArena(broadcast);
    if (message_arena != submessage_arena) {
      broadcast = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, broadcast, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  broadcast_ = broadcast;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_Developer.broadcast)
}

// optional string title = 2;
inline bool CSteamTV_HomePageTemplate_Developer::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_Developer::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_Developer::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_Developer::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_Developer.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_Developer::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_Developer.title)
}
inline std::string* CSteamTV_HomePageTemplate_Developer::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_Developer.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_Developer::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_Developer::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_Developer::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_Developer::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_Developer.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_Developer::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_Developer.title)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageTemplate_Event

// optional string title = 1;
inline bool CSteamTV_HomePageTemplate_Event::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_HomePageTemplate_Event::has_title() const {
  return _internal_has_title();
}
inline void CSteamTV_HomePageTemplate_Event::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSteamTV_HomePageTemplate_Event::title() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageTemplate_Event.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSteamTV_HomePageTemplate_Event::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageTemplate_Event.title)
}
inline std::string* CSteamTV_HomePageTemplate_Event::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageTemplate_Event.title)
  return _s;
}
inline const std::string& CSteamTV_HomePageTemplate_Event::_internal_title() const {
  return title_.Get();
}
inline void CSteamTV_HomePageTemplate_Event::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_Event::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000001u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSteamTV_HomePageTemplate_Event::release_title() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageTemplate_Event.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSteamTV_HomePageTemplate_Event::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageTemplate_Event.title)
}

// -------------------------------------------------------------------

// CSteamTV_HomePageContentRow

// optional .ESteamTVContentTemplate template_type = 1 [default = k_ESteamTVContentTemplate_Invalid];
inline bool CSteamTV_HomePageContentRow::_internal_has_template_type() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_template_type() const {
  return _internal_has_template_type();
}
inline void CSteamTV_HomePageContentRow::clear_template_type() {
  template_type_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::ESteamTVContentTemplate CSteamTV_HomePageContentRow::_internal_template_type() const {
  return static_cast< ::ESteamTVContentTemplate >(template_type_);
}
inline ::ESteamTVContentTemplate CSteamTV_HomePageContentRow::template_type() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.template_type)
  return _internal_template_type();
}
inline void CSteamTV_HomePageContentRow::_internal_set_template_type(::ESteamTVContentTemplate value) {
  assert(::ESteamTVContentTemplate_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  template_type_ = value;
}
inline void CSteamTV_HomePageContentRow::set_template_type(::ESteamTVContentTemplate value) {
  _internal_set_template_type(value);
  // @@protoc_insertion_point(field_set:CSteamTV_HomePageContentRow.template_type)
}

// optional .CSteamTV_HomePageTemplate_Takeover takeover = 2;
inline bool CSteamTV_HomePageContentRow::_internal_has_takeover() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || takeover_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_takeover() const {
  return _internal_has_takeover();
}
inline void CSteamTV_HomePageContentRow::clear_takeover() {
  if (takeover_ != nullptr) takeover_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CSteamTV_HomePageTemplate_Takeover& CSteamTV_HomePageContentRow::_internal_takeover() const {
  const ::CSteamTV_HomePageTemplate_Takeover* p = takeover_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_Takeover&>(
      ::_CSteamTV_HomePageTemplate_Takeover_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_Takeover& CSteamTV_HomePageContentRow::takeover() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.takeover)
  return _internal_takeover();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_takeover(
    ::CSteamTV_HomePageTemplate_Takeover* takeover) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(takeover_);
  }
  takeover_ = takeover;
  if (takeover) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.takeover)
}
inline ::CSteamTV_HomePageTemplate_Takeover* CSteamTV_HomePageContentRow::release_takeover() {
  _has_bits_[0] &= ~0x00000001u;
  ::CSteamTV_HomePageTemplate_Takeover* temp = takeover_;
  takeover_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Takeover* CSteamTV_HomePageContentRow::unsafe_arena_release_takeover() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.takeover)
  _has_bits_[0] &= ~0x00000001u;
  ::CSteamTV_HomePageTemplate_Takeover* temp = takeover_;
  takeover_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Takeover* CSteamTV_HomePageContentRow::_internal_mutable_takeover() {
  _has_bits_[0] |= 0x00000001u;
  if (takeover_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_Takeover>(GetArenaForAllocation());
    takeover_ = p;
  }
  return takeover_;
}
inline ::CSteamTV_HomePageTemplate_Takeover* CSteamTV_HomePageContentRow::mutable_takeover() {
  ::CSteamTV_HomePageTemplate_Takeover* _msg = _internal_mutable_takeover();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.takeover)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_takeover(::CSteamTV_HomePageTemplate_Takeover* takeover) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete takeover_;
  }
  if (takeover) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_Takeover>::GetOwningArena(takeover);
    if (message_arena != submessage_arena) {
      takeover = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, takeover, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  takeover_ = takeover;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.takeover)
}

// optional .CSteamTV_HomePageTemplate_SingleGame single_game = 3;
inline bool CSteamTV_HomePageContentRow::_internal_has_single_game() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || single_game_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_single_game() const {
  return _internal_has_single_game();
}
inline void CSteamTV_HomePageContentRow::clear_single_game() {
  if (single_game_ != nullptr) single_game_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CSteamTV_HomePageTemplate_SingleGame& CSteamTV_HomePageContentRow::_internal_single_game() const {
  const ::CSteamTV_HomePageTemplate_SingleGame* p = single_game_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_SingleGame&>(
      ::_CSteamTV_HomePageTemplate_SingleGame_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_SingleGame& CSteamTV_HomePageContentRow::single_game() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.single_game)
  return _internal_single_game();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_single_game(
    ::CSteamTV_HomePageTemplate_SingleGame* single_game) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(single_game_);
  }
  single_game_ = single_game;
  if (single_game) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.single_game)
}
inline ::CSteamTV_HomePageTemplate_SingleGame* CSteamTV_HomePageContentRow::release_single_game() {
  _has_bits_[0] &= ~0x00000002u;
  ::CSteamTV_HomePageTemplate_SingleGame* temp = single_game_;
  single_game_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_SingleGame* CSteamTV_HomePageContentRow::unsafe_arena_release_single_game() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.single_game)
  _has_bits_[0] &= ~0x00000002u;
  ::CSteamTV_HomePageTemplate_SingleGame* temp = single_game_;
  single_game_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_SingleGame* CSteamTV_HomePageContentRow::_internal_mutable_single_game() {
  _has_bits_[0] |= 0x00000002u;
  if (single_game_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_SingleGame>(GetArenaForAllocation());
    single_game_ = p;
  }
  return single_game_;
}
inline ::CSteamTV_HomePageTemplate_SingleGame* CSteamTV_HomePageContentRow::mutable_single_game() {
  ::CSteamTV_HomePageTemplate_SingleGame* _msg = _internal_mutable_single_game();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.single_game)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_single_game(::CSteamTV_HomePageTemplate_SingleGame* single_game) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete single_game_;
  }
  if (single_game) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_SingleGame>::GetOwningArena(single_game);
    if (message_arena != submessage_arena) {
      single_game = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, single_game, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  single_game_ = single_game;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.single_game)
}

// optional .CSteamTV_HomePageTemplate_GameList game_list = 4;
inline bool CSteamTV_HomePageContentRow::_internal_has_game_list() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || game_list_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_game_list() const {
  return _internal_has_game_list();
}
inline void CSteamTV_HomePageContentRow::clear_game_list() {
  if (game_list_ != nullptr) game_list_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CSteamTV_HomePageTemplate_GameList& CSteamTV_HomePageContentRow::_internal_game_list() const {
  const ::CSteamTV_HomePageTemplate_GameList* p = game_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_GameList&>(
      ::_CSteamTV_HomePageTemplate_GameList_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_GameList& CSteamTV_HomePageContentRow::game_list() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.game_list)
  return _internal_game_list();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_game_list(
    ::CSteamTV_HomePageTemplate_GameList* game_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_list_);
  }
  game_list_ = game_list;
  if (game_list) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.game_list)
}
inline ::CSteamTV_HomePageTemplate_GameList* CSteamTV_HomePageContentRow::release_game_list() {
  _has_bits_[0] &= ~0x00000004u;
  ::CSteamTV_HomePageTemplate_GameList* temp = game_list_;
  game_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_GameList* CSteamTV_HomePageContentRow::unsafe_arena_release_game_list() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.game_list)
  _has_bits_[0] &= ~0x00000004u;
  ::CSteamTV_HomePageTemplate_GameList* temp = game_list_;
  game_list_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_GameList* CSteamTV_HomePageContentRow::_internal_mutable_game_list() {
  _has_bits_[0] |= 0x00000004u;
  if (game_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_GameList>(GetArenaForAllocation());
    game_list_ = p;
  }
  return game_list_;
}
inline ::CSteamTV_HomePageTemplate_GameList* CSteamTV_HomePageContentRow::mutable_game_list() {
  ::CSteamTV_HomePageTemplate_GameList* _msg = _internal_mutable_game_list();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.game_list)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_game_list(::CSteamTV_HomePageTemplate_GameList* game_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete game_list_;
  }
  if (game_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_GameList>::GetOwningArena(game_list);
    if (message_arena != submessage_arena) {
      game_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_list, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  game_list_ = game_list;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.game_list)
}

// optional .CSteamTV_HomePageTemplate_QuickExplore quick_explore = 5;
inline bool CSteamTV_HomePageContentRow::_internal_has_quick_explore() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || quick_explore_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_quick_explore() const {
  return _internal_has_quick_explore();
}
inline void CSteamTV_HomePageContentRow::clear_quick_explore() {
  if (quick_explore_ != nullptr) quick_explore_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::CSteamTV_HomePageTemplate_QuickExplore& CSteamTV_HomePageContentRow::_internal_quick_explore() const {
  const ::CSteamTV_HomePageTemplate_QuickExplore* p = quick_explore_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_QuickExplore&>(
      ::_CSteamTV_HomePageTemplate_QuickExplore_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_QuickExplore& CSteamTV_HomePageContentRow::quick_explore() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.quick_explore)
  return _internal_quick_explore();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_quick_explore(
    ::CSteamTV_HomePageTemplate_QuickExplore* quick_explore) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quick_explore_);
  }
  quick_explore_ = quick_explore;
  if (quick_explore) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.quick_explore)
}
inline ::CSteamTV_HomePageTemplate_QuickExplore* CSteamTV_HomePageContentRow::release_quick_explore() {
  _has_bits_[0] &= ~0x00000008u;
  ::CSteamTV_HomePageTemplate_QuickExplore* temp = quick_explore_;
  quick_explore_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_QuickExplore* CSteamTV_HomePageContentRow::unsafe_arena_release_quick_explore() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.quick_explore)
  _has_bits_[0] &= ~0x00000008u;
  ::CSteamTV_HomePageTemplate_QuickExplore* temp = quick_explore_;
  quick_explore_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_QuickExplore* CSteamTV_HomePageContentRow::_internal_mutable_quick_explore() {
  _has_bits_[0] |= 0x00000008u;
  if (quick_explore_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_QuickExplore>(GetArenaForAllocation());
    quick_explore_ = p;
  }
  return quick_explore_;
}
inline ::CSteamTV_HomePageTemplate_QuickExplore* CSteamTV_HomePageContentRow::mutable_quick_explore() {
  ::CSteamTV_HomePageTemplate_QuickExplore* _msg = _internal_mutable_quick_explore();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.quick_explore)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_quick_explore(::CSteamTV_HomePageTemplate_QuickExplore* quick_explore) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete quick_explore_;
  }
  if (quick_explore) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_QuickExplore>::GetOwningArena(quick_explore);
    if (message_arena != submessage_arena) {
      quick_explore = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quick_explore, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  quick_explore_ = quick_explore;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.quick_explore)
}

// optional .CSteamTV_HomePageTemplate_ConveyorBelt conveyor_belt = 6;
inline bool CSteamTV_HomePageContentRow::_internal_has_conveyor_belt() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || conveyor_belt_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_conveyor_belt() const {
  return _internal_has_conveyor_belt();
}
inline void CSteamTV_HomePageContentRow::clear_conveyor_belt() {
  if (conveyor_belt_ != nullptr) conveyor_belt_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::CSteamTV_HomePageTemplate_ConveyorBelt& CSteamTV_HomePageContentRow::_internal_conveyor_belt() const {
  const ::CSteamTV_HomePageTemplate_ConveyorBelt* p = conveyor_belt_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_ConveyorBelt&>(
      ::_CSteamTV_HomePageTemplate_ConveyorBelt_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_ConveyorBelt& CSteamTV_HomePageContentRow::conveyor_belt() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.conveyor_belt)
  return _internal_conveyor_belt();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_conveyor_belt(
    ::CSteamTV_HomePageTemplate_ConveyorBelt* conveyor_belt) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(conveyor_belt_);
  }
  conveyor_belt_ = conveyor_belt;
  if (conveyor_belt) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.conveyor_belt)
}
inline ::CSteamTV_HomePageTemplate_ConveyorBelt* CSteamTV_HomePageContentRow::release_conveyor_belt() {
  _has_bits_[0] &= ~0x00000010u;
  ::CSteamTV_HomePageTemplate_ConveyorBelt* temp = conveyor_belt_;
  conveyor_belt_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_ConveyorBelt* CSteamTV_HomePageContentRow::unsafe_arena_release_conveyor_belt() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.conveyor_belt)
  _has_bits_[0] &= ~0x00000010u;
  ::CSteamTV_HomePageTemplate_ConveyorBelt* temp = conveyor_belt_;
  conveyor_belt_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_ConveyorBelt* CSteamTV_HomePageContentRow::_internal_mutable_conveyor_belt() {
  _has_bits_[0] |= 0x00000010u;
  if (conveyor_belt_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_ConveyorBelt>(GetArenaForAllocation());
    conveyor_belt_ = p;
  }
  return conveyor_belt_;
}
inline ::CSteamTV_HomePageTemplate_ConveyorBelt* CSteamTV_HomePageContentRow::mutable_conveyor_belt() {
  ::CSteamTV_HomePageTemplate_ConveyorBelt* _msg = _internal_mutable_conveyor_belt();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.conveyor_belt)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_conveyor_belt(::CSteamTV_HomePageTemplate_ConveyorBelt* conveyor_belt) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete conveyor_belt_;
  }
  if (conveyor_belt) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_ConveyorBelt>::GetOwningArena(conveyor_belt);
    if (message_arena != submessage_arena) {
      conveyor_belt = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, conveyor_belt, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  conveyor_belt_ = conveyor_belt;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.conveyor_belt)
}

// optional .CSteamTV_HomePageTemplate_WatchParty watch_party = 7;
inline bool CSteamTV_HomePageContentRow::_internal_has_watch_party() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || watch_party_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_watch_party() const {
  return _internal_has_watch_party();
}
inline void CSteamTV_HomePageContentRow::clear_watch_party() {
  if (watch_party_ != nullptr) watch_party_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::CSteamTV_HomePageTemplate_WatchParty& CSteamTV_HomePageContentRow::_internal_watch_party() const {
  const ::CSteamTV_HomePageTemplate_WatchParty* p = watch_party_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_WatchParty&>(
      ::_CSteamTV_HomePageTemplate_WatchParty_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_WatchParty& CSteamTV_HomePageContentRow::watch_party() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.watch_party)
  return _internal_watch_party();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_watch_party(
    ::CSteamTV_HomePageTemplate_WatchParty* watch_party) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(watch_party_);
  }
  watch_party_ = watch_party;
  if (watch_party) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.watch_party)
}
inline ::CSteamTV_HomePageTemplate_WatchParty* CSteamTV_HomePageContentRow::release_watch_party() {
  _has_bits_[0] &= ~0x00000020u;
  ::CSteamTV_HomePageTemplate_WatchParty* temp = watch_party_;
  watch_party_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_WatchParty* CSteamTV_HomePageContentRow::unsafe_arena_release_watch_party() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.watch_party)
  _has_bits_[0] &= ~0x00000020u;
  ::CSteamTV_HomePageTemplate_WatchParty* temp = watch_party_;
  watch_party_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_WatchParty* CSteamTV_HomePageContentRow::_internal_mutable_watch_party() {
  _has_bits_[0] |= 0x00000020u;
  if (watch_party_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_WatchParty>(GetArenaForAllocation());
    watch_party_ = p;
  }
  return watch_party_;
}
inline ::CSteamTV_HomePageTemplate_WatchParty* CSteamTV_HomePageContentRow::mutable_watch_party() {
  ::CSteamTV_HomePageTemplate_WatchParty* _msg = _internal_mutable_watch_party();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.watch_party)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_watch_party(::CSteamTV_HomePageTemplate_WatchParty* watch_party) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete watch_party_;
  }
  if (watch_party) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_WatchParty>::GetOwningArena(watch_party);
    if (message_arena != submessage_arena) {
      watch_party = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, watch_party, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  watch_party_ = watch_party;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.watch_party)
}

// optional .CSteamTV_HomePageTemplate_Developer developer = 8;
inline bool CSteamTV_HomePageContentRow::_internal_has_developer() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || developer_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_developer() const {
  return _internal_has_developer();
}
inline void CSteamTV_HomePageContentRow::clear_developer() {
  if (developer_ != nullptr) developer_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::CSteamTV_HomePageTemplate_Developer& CSteamTV_HomePageContentRow::_internal_developer() const {
  const ::CSteamTV_HomePageTemplate_Developer* p = developer_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_Developer&>(
      ::_CSteamTV_HomePageTemplate_Developer_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_Developer& CSteamTV_HomePageContentRow::developer() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.developer)
  return _internal_developer();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_developer(
    ::CSteamTV_HomePageTemplate_Developer* developer) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(developer_);
  }
  developer_ = developer;
  if (developer) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.developer)
}
inline ::CSteamTV_HomePageTemplate_Developer* CSteamTV_HomePageContentRow::release_developer() {
  _has_bits_[0] &= ~0x00000040u;
  ::CSteamTV_HomePageTemplate_Developer* temp = developer_;
  developer_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Developer* CSteamTV_HomePageContentRow::unsafe_arena_release_developer() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.developer)
  _has_bits_[0] &= ~0x00000040u;
  ::CSteamTV_HomePageTemplate_Developer* temp = developer_;
  developer_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Developer* CSteamTV_HomePageContentRow::_internal_mutable_developer() {
  _has_bits_[0] |= 0x00000040u;
  if (developer_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_Developer>(GetArenaForAllocation());
    developer_ = p;
  }
  return developer_;
}
inline ::CSteamTV_HomePageTemplate_Developer* CSteamTV_HomePageContentRow::mutable_developer() {
  ::CSteamTV_HomePageTemplate_Developer* _msg = _internal_mutable_developer();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.developer)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_developer(::CSteamTV_HomePageTemplate_Developer* developer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete developer_;
  }
  if (developer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_Developer>::GetOwningArena(developer);
    if (message_arena != submessage_arena) {
      developer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, developer, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  developer_ = developer;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.developer)
}

// optional .CSteamTV_HomePageTemplate_Event event = 9;
inline bool CSteamTV_HomePageContentRow::_internal_has_event() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || event_ != nullptr);
  return value;
}
inline bool CSteamTV_HomePageContentRow::has_event() const {
  return _internal_has_event();
}
inline void CSteamTV_HomePageContentRow::clear_event() {
  if (event_ != nullptr) event_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::CSteamTV_HomePageTemplate_Event& CSteamTV_HomePageContentRow::_internal_event() const {
  const ::CSteamTV_HomePageTemplate_Event* p = event_;
  return p != nullptr ? *p : reinterpret_cast<const ::CSteamTV_HomePageTemplate_Event&>(
      ::_CSteamTV_HomePageTemplate_Event_default_instance_);
}
inline const ::CSteamTV_HomePageTemplate_Event& CSteamTV_HomePageContentRow::event() const {
  // @@protoc_insertion_point(field_get:CSteamTV_HomePageContentRow.event)
  return _internal_event();
}
inline void CSteamTV_HomePageContentRow::unsafe_arena_set_allocated_event(
    ::CSteamTV_HomePageTemplate_Event* event) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(event_);
  }
  event_ = event;
  if (event) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSteamTV_HomePageContentRow.event)
}
inline ::CSteamTV_HomePageTemplate_Event* CSteamTV_HomePageContentRow::release_event() {
  _has_bits_[0] &= ~0x00000080u;
  ::CSteamTV_HomePageTemplate_Event* temp = event_;
  event_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Event* CSteamTV_HomePageContentRow::unsafe_arena_release_event() {
  // @@protoc_insertion_point(field_release:CSteamTV_HomePageContentRow.event)
  _has_bits_[0] &= ~0x00000080u;
  ::CSteamTV_HomePageTemplate_Event* temp = event_;
  event_ = nullptr;
  return temp;
}
inline ::CSteamTV_HomePageTemplate_Event* CSteamTV_HomePageContentRow::_internal_mutable_event() {
  _has_bits_[0] |= 0x00000080u;
  if (event_ == nullptr) {
    auto* p = CreateMaybeMessage<::CSteamTV_HomePageTemplate_Event>(GetArenaForAllocation());
    event_ = p;
  }
  return event_;
}
inline ::CSteamTV_HomePageTemplate_Event* CSteamTV_HomePageContentRow::mutable_event() {
  ::CSteamTV_HomePageTemplate_Event* _msg = _internal_mutable_event();
  // @@protoc_insertion_point(field_mutable:CSteamTV_HomePageContentRow.event)
  return _msg;
}
inline void CSteamTV_HomePageContentRow::set_allocated_event(::CSteamTV_HomePageTemplate_Event* event) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete event_;
  }
  if (event) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CSteamTV_HomePageTemplate_Event>::GetOwningArena(event);
    if (message_arena != submessage_arena) {
      event = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, event, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  event_ = event;
  // @@protoc_insertion_point(field_set_allocated:CSteamTV_HomePageContentRow.event)
}

// -------------------------------------------------------------------

// CSteamTV_GetHomePageContents_Response

// repeated .CSteamTV_HomePageContentRow rows = 1;
inline int CSteamTV_GetHomePageContents_Response::_internal_rows_size() const {
  return rows_.size();
}
inline int CSteamTV_GetHomePageContents_Response::rows_size() const {
  return _internal_rows_size();
}
inline void CSteamTV_GetHomePageContents_Response::clear_rows() {
  rows_.Clear();
}
inline ::CSteamTV_HomePageContentRow* CSteamTV_GetHomePageContents_Response::mutable_rows(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_GetHomePageContents_Response.rows)
  return rows_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_HomePageContentRow >*
CSteamTV_GetHomePageContents_Response::mutable_rows() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_GetHomePageContents_Response.rows)
  return &rows_;
}
inline const ::CSteamTV_HomePageContentRow& CSteamTV_GetHomePageContents_Response::_internal_rows(int index) const {
  return rows_.Get(index);
}
inline const ::CSteamTV_HomePageContentRow& CSteamTV_GetHomePageContents_Response::rows(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_GetHomePageContents_Response.rows)
  return _internal_rows(index);
}
inline ::CSteamTV_HomePageContentRow* CSteamTV_GetHomePageContents_Response::_internal_add_rows() {
  return rows_.Add();
}
inline ::CSteamTV_HomePageContentRow* CSteamTV_GetHomePageContents_Response::add_rows() {
  ::CSteamTV_HomePageContentRow* _add = _internal_add_rows();
  // @@protoc_insertion_point(field_add:CSteamTV_GetHomePageContents_Response.rows)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_HomePageContentRow >&
CSteamTV_GetHomePageContents_Response::rows() const {
  // @@protoc_insertion_point(field_list:CSteamTV_GetHomePageContents_Response.rows)
  return rows_;
}

// -------------------------------------------------------------------

// CSteamTV_AppCheer_SingleCheerType

// optional uint32 cheer_type = 1 [(.description) = "The type of cheer. App dependent (different teams, heroes, players, etc)"];
inline bool CSteamTV_AppCheer_SingleCheerType::_internal_has_cheer_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AppCheer_SingleCheerType::has_cheer_type() const {
  return _internal_has_cheer_type();
}
inline void CSteamTV_AppCheer_SingleCheerType::clear_cheer_type() {
  cheer_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSteamTV_AppCheer_SingleCheerType::_internal_cheer_type() const {
  return cheer_type_;
}
inline uint32_t CSteamTV_AppCheer_SingleCheerType::cheer_type() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_SingleCheerType.cheer_type)
  return _internal_cheer_type();
}
inline void CSteamTV_AppCheer_SingleCheerType::_internal_set_cheer_type(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  cheer_type_ = value;
}
inline void CSteamTV_AppCheer_SingleCheerType::set_cheer_type(uint32_t value) {
  _internal_set_cheer_type(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AppCheer_SingleCheerType.cheer_type)
}

// optional uint32 cheer_amount = 2 [(.description) = "The amount of cheers."];
inline bool CSteamTV_AppCheer_SingleCheerType::_internal_has_cheer_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_AppCheer_SingleCheerType::has_cheer_amount() const {
  return _internal_has_cheer_amount();
}
inline void CSteamTV_AppCheer_SingleCheerType::clear_cheer_amount() {
  cheer_amount_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSteamTV_AppCheer_SingleCheerType::_internal_cheer_amount() const {
  return cheer_amount_;
}
inline uint32_t CSteamTV_AppCheer_SingleCheerType::cheer_amount() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_SingleCheerType.cheer_amount)
  return _internal_cheer_amount();
}
inline void CSteamTV_AppCheer_SingleCheerType::_internal_set_cheer_amount(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  cheer_amount_ = value;
}
inline void CSteamTV_AppCheer_SingleCheerType::set_cheer_amount(uint32_t value) {
  _internal_set_cheer_amount(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AppCheer_SingleCheerType.cheer_amount)
}

// -------------------------------------------------------------------

// CSteamTV_AppCheer_Request

// optional uint32 app_id = 1 [(.description) = "App ID this cheer is for."];
inline bool CSteamTV_AppCheer_Request::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSteamTV_AppCheer_Request::has_app_id() const {
  return _internal_has_app_id();
}
inline void CSteamTV_AppCheer_Request::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSteamTV_AppCheer_Request::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CSteamTV_AppCheer_Request::app_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_Request.app_id)
  return _internal_app_id();
}
inline void CSteamTV_AppCheer_Request::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  app_id_ = value;
}
inline void CSteamTV_AppCheer_Request::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AppCheer_Request.app_id)
}

// optional fixed64 cheer_target_id = 2 [(.description) = "The thing being cheered on. ID is app dependent (could be steam id, match id, lobby id, server id, etc)."];
inline bool CSteamTV_AppCheer_Request::_internal_has_cheer_target_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AppCheer_Request::has_cheer_target_id() const {
  return _internal_has_cheer_target_id();
}
inline void CSteamTV_AppCheer_Request::clear_cheer_target_id() {
  cheer_target_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSteamTV_AppCheer_Request::_internal_cheer_target_id() const {
  return cheer_target_id_;
}
inline uint64_t CSteamTV_AppCheer_Request::cheer_target_id() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_Request.cheer_target_id)
  return _internal_cheer_target_id();
}
inline void CSteamTV_AppCheer_Request::_internal_set_cheer_target_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  cheer_target_id_ = value;
}
inline void CSteamTV_AppCheer_Request::set_cheer_target_id(uint64_t value) {
  _internal_set_cheer_target_id(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AppCheer_Request.cheer_target_id)
}

// repeated .CSteamTV_AppCheer_SingleCheerType cheers = 3 [(.description) = "The set of cheers this request represents (could be multiple of different types)."];
inline int CSteamTV_AppCheer_Request::_internal_cheers_size() const {
  return cheers_.size();
}
inline int CSteamTV_AppCheer_Request::cheers_size() const {
  return _internal_cheers_size();
}
inline void CSteamTV_AppCheer_Request::clear_cheers() {
  cheers_.Clear();
}
inline ::CSteamTV_AppCheer_SingleCheerType* CSteamTV_AppCheer_Request::mutable_cheers(int index) {
  // @@protoc_insertion_point(field_mutable:CSteamTV_AppCheer_Request.cheers)
  return cheers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_AppCheer_SingleCheerType >*
CSteamTV_AppCheer_Request::mutable_cheers() {
  // @@protoc_insertion_point(field_mutable_list:CSteamTV_AppCheer_Request.cheers)
  return &cheers_;
}
inline const ::CSteamTV_AppCheer_SingleCheerType& CSteamTV_AppCheer_Request::_internal_cheers(int index) const {
  return cheers_.Get(index);
}
inline const ::CSteamTV_AppCheer_SingleCheerType& CSteamTV_AppCheer_Request::cheers(int index) const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_Request.cheers)
  return _internal_cheers(index);
}
inline ::CSteamTV_AppCheer_SingleCheerType* CSteamTV_AppCheer_Request::_internal_add_cheers() {
  return cheers_.Add();
}
inline ::CSteamTV_AppCheer_SingleCheerType* CSteamTV_AppCheer_Request::add_cheers() {
  ::CSteamTV_AppCheer_SingleCheerType* _add = _internal_add_cheers();
  // @@protoc_insertion_point(field_add:CSteamTV_AppCheer_Request.cheers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CSteamTV_AppCheer_SingleCheerType >&
CSteamTV_AppCheer_Request::cheers() const {
  // @@protoc_insertion_point(field_list:CSteamTV_AppCheer_Request.cheers)
  return cheers_;
}

// -------------------------------------------------------------------

// CSteamTV_AppCheer_Response

// optional uint32 aggregation_delay_ms = 1 [(.description) = "The amount of time in milliseconds that the client should aggregate cheers before sending them. The server can control this dynamically to ask clients to slow down sending."];
inline bool CSteamTV_AppCheer_Response::_internal_has_aggregation_delay_ms() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSteamTV_AppCheer_Response::has_aggregation_delay_ms() const {
  return _internal_has_aggregation_delay_ms();
}
inline void CSteamTV_AppCheer_Response::clear_aggregation_delay_ms() {
  aggregation_delay_ms_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSteamTV_AppCheer_Response::_internal_aggregation_delay_ms() const {
  return aggregation_delay_ms_;
}
inline uint32_t CSteamTV_AppCheer_Response::aggregation_delay_ms() const {
  // @@protoc_insertion_point(field_get:CSteamTV_AppCheer_Response.aggregation_delay_ms)
  return _internal_aggregation_delay_ms();
}
inline void CSteamTV_AppCheer_Response::_internal_set_aggregation_delay_ms(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  aggregation_delay_ms_ = value;
}
inline void CSteamTV_AppCheer_Response::set_aggregation_delay_ms(uint32_t value) {
  _internal_set_aggregation_delay_ms(value);
  // @@protoc_insertion_point(field_set:CSteamTV_AppCheer_Response.aggregation_delay_ms)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EBroadcastImageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EBroadcastImageType>() {
  return ::EBroadcastImageType_descriptor();
}
template <> struct is_proto_enum< ::EGetGamesAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGetGamesAlgorithm>() {
  return ::EGetGamesAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::EGetChannelsAlgorithm> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EGetChannelsAlgorithm>() {
  return ::EGetChannelsAlgorithm_descriptor();
}
template <> struct is_proto_enum< ::ESteamTVContentTemplate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESteamTVContentTemplate>() {
  return ::ESteamTVContentTemplate_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fsteamtv_2esteamclient_2eproto
