// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_storebrowse.steamclient.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fstorebrowse_2esteamclient_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fstorebrowse_2esteamclient_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
#include "steammessages_unified_base.steamclient.pb.h"
#include "enums_productinfo.pb.h"
#include "enums.pb.h"
#include "contenthubs.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fstorebrowse_2esteamclient_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[37]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fstorebrowse_2esteamclient_2eproto;
class CStoreBrowse_GetDLCForAppsSolr_Request;
struct CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal;
extern CStoreBrowse_GetDLCForAppsSolr_RequestDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Request_default_instance_;
class CStoreBrowse_GetDLCForAppsSolr_Response;
struct CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal;
extern CStoreBrowse_GetDLCForAppsSolr_ResponseDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Response_default_instance_;
class CStoreBrowse_GetDLCForAppsSolr_Response_DLCList;
struct CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal;
extern CStoreBrowse_GetDLCForAppsSolr_Response_DLCListDefaultTypeInternal _CStoreBrowse_GetDLCForAppsSolr_Response_DLCList_default_instance_;
class CStoreBrowse_GetDLCForApps_Request;
struct CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal;
extern CStoreBrowse_GetDLCForApps_RequestDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Request_default_instance_;
class CStoreBrowse_GetDLCForApps_Response;
struct CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal;
extern CStoreBrowse_GetDLCForApps_ResponseDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_default_instance_;
class CStoreBrowse_GetDLCForApps_Response_DLCData;
struct CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal;
extern CStoreBrowse_GetDLCForApps_Response_DLCDataDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_DLCData_default_instance_;
class CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp;
struct CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal;
extern CStoreBrowse_GetDLCForApps_Response_PlaytimeForAppDefaultTypeInternal _CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp_default_instance_;
class CStoreBrowse_GetItems_Request;
struct CStoreBrowse_GetItems_RequestDefaultTypeInternal;
extern CStoreBrowse_GetItems_RequestDefaultTypeInternal _CStoreBrowse_GetItems_Request_default_instance_;
class CStoreBrowse_GetItems_Response;
struct CStoreBrowse_GetItems_ResponseDefaultTypeInternal;
extern CStoreBrowse_GetItems_ResponseDefaultTypeInternal _CStoreBrowse_GetItems_Response_default_instance_;
class CStoreBrowse_GetStoreCategories_Request;
struct CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal;
extern CStoreBrowse_GetStoreCategories_RequestDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Request_default_instance_;
class CStoreBrowse_GetStoreCategories_Response;
struct CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal;
extern CStoreBrowse_GetStoreCategories_ResponseDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Response_default_instance_;
class CStoreBrowse_GetStoreCategories_Response_Category;
struct CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal;
extern CStoreBrowse_GetStoreCategories_Response_CategoryDefaultTypeInternal _CStoreBrowse_GetStoreCategories_Response_Category_default_instance_;
class StoreBrowseContext;
struct StoreBrowseContextDefaultTypeInternal;
extern StoreBrowseContextDefaultTypeInternal _StoreBrowseContext_default_instance_;
class StoreBrowseItemDataRequest;
struct StoreBrowseItemDataRequestDefaultTypeInternal;
extern StoreBrowseItemDataRequestDefaultTypeInternal _StoreBrowseItemDataRequest_default_instance_;
class StoreGameRating;
struct StoreGameRatingDefaultTypeInternal;
extern StoreGameRatingDefaultTypeInternal _StoreGameRating_default_instance_;
class StoreItem;
struct StoreItemDefaultTypeInternal;
extern StoreItemDefaultTypeInternal _StoreItem_default_instance_;
class StoreItemID;
struct StoreItemIDDefaultTypeInternal;
extern StoreItemIDDefaultTypeInternal _StoreItemID_default_instance_;
class StoreItem_Assets;
struct StoreItem_AssetsDefaultTypeInternal;
extern StoreItem_AssetsDefaultTypeInternal _StoreItem_Assets_default_instance_;
class StoreItem_BasicInfo;
struct StoreItem_BasicInfoDefaultTypeInternal;
extern StoreItem_BasicInfoDefaultTypeInternal _StoreItem_BasicInfo_default_instance_;
class StoreItem_BasicInfo_CreatorHomeLink;
struct StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal;
extern StoreItem_BasicInfo_CreatorHomeLinkDefaultTypeInternal _StoreItem_BasicInfo_CreatorHomeLink_default_instance_;
class StoreItem_Categories;
struct StoreItem_CategoriesDefaultTypeInternal;
extern StoreItem_CategoriesDefaultTypeInternal _StoreItem_Categories_default_instance_;
class StoreItem_FreeWeekend;
struct StoreItem_FreeWeekendDefaultTypeInternal;
extern StoreItem_FreeWeekendDefaultTypeInternal _StoreItem_FreeWeekend_default_instance_;
class StoreItem_Platforms;
struct StoreItem_PlatformsDefaultTypeInternal;
extern StoreItem_PlatformsDefaultTypeInternal _StoreItem_Platforms_default_instance_;
class StoreItem_Platforms_VRSupport;
struct StoreItem_Platforms_VRSupportDefaultTypeInternal;
extern StoreItem_Platforms_VRSupportDefaultTypeInternal _StoreItem_Platforms_VRSupport_default_instance_;
class StoreItem_PurchaseOption;
struct StoreItem_PurchaseOptionDefaultTypeInternal;
extern StoreItem_PurchaseOptionDefaultTypeInternal _StoreItem_PurchaseOption_default_instance_;
class StoreItem_PurchaseOption_Discount;
struct StoreItem_PurchaseOption_DiscountDefaultTypeInternal;
extern StoreItem_PurchaseOption_DiscountDefaultTypeInternal _StoreItem_PurchaseOption_Discount_default_instance_;
class StoreItem_RelatedItems;
struct StoreItem_RelatedItemsDefaultTypeInternal;
extern StoreItem_RelatedItemsDefaultTypeInternal _StoreItem_RelatedItems_default_instance_;
class StoreItem_ReleaseInfo;
struct StoreItem_ReleaseInfoDefaultTypeInternal;
extern StoreItem_ReleaseInfoDefaultTypeInternal _StoreItem_ReleaseInfo_default_instance_;
class StoreItem_Reviews;
struct StoreItem_ReviewsDefaultTypeInternal;
extern StoreItem_ReviewsDefaultTypeInternal _StoreItem_Reviews_default_instance_;
class StoreItem_Reviews_StoreReviewSummary;
struct StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal;
extern StoreItem_Reviews_StoreReviewSummaryDefaultTypeInternal _StoreItem_Reviews_StoreReviewSummary_default_instance_;
class StoreItem_Screenshots;
struct StoreItem_ScreenshotsDefaultTypeInternal;
extern StoreItem_ScreenshotsDefaultTypeInternal _StoreItem_Screenshots_default_instance_;
class StoreItem_Screenshots_Screenshot;
struct StoreItem_Screenshots_ScreenshotDefaultTypeInternal;
extern StoreItem_Screenshots_ScreenshotDefaultTypeInternal _StoreItem_Screenshots_Screenshot_default_instance_;
class StoreItem_SupportedLanguage;
struct StoreItem_SupportedLanguageDefaultTypeInternal;
extern StoreItem_SupportedLanguageDefaultTypeInternal _StoreItem_SupportedLanguage_default_instance_;
class StoreItem_Tag;
struct StoreItem_TagDefaultTypeInternal;
extern StoreItem_TagDefaultTypeInternal _StoreItem_Tag_default_instance_;
class StoreItem_Trailers;
struct StoreItem_TrailersDefaultTypeInternal;
extern StoreItem_TrailersDefaultTypeInternal _StoreItem_Trailers_default_instance_;
class StoreItem_Trailers_Trailer;
struct StoreItem_Trailers_TrailerDefaultTypeInternal;
extern StoreItem_Trailers_TrailerDefaultTypeInternal _StoreItem_Trailers_Trailer_default_instance_;
class StoreItem_Trailers_VideoSource;
struct StoreItem_Trailers_VideoSourceDefaultTypeInternal;
extern StoreItem_Trailers_VideoSourceDefaultTypeInternal _StoreItem_Trailers_VideoSource_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CStoreBrowse_GetDLCForAppsSolr_Request* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForAppsSolr_Request>(Arena*);
template<> ::CStoreBrowse_GetDLCForAppsSolr_Response* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForAppsSolr_Response>(Arena*);
template<> ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList>(Arena*);
template<> ::CStoreBrowse_GetDLCForApps_Request* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForApps_Request>(Arena*);
template<> ::CStoreBrowse_GetDLCForApps_Response* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForApps_Response>(Arena*);
template<> ::CStoreBrowse_GetDLCForApps_Response_DLCData* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForApps_Response_DLCData>(Arena*);
template<> ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* Arena::CreateMaybeMessage<::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp>(Arena*);
template<> ::CStoreBrowse_GetItems_Request* Arena::CreateMaybeMessage<::CStoreBrowse_GetItems_Request>(Arena*);
template<> ::CStoreBrowse_GetItems_Response* Arena::CreateMaybeMessage<::CStoreBrowse_GetItems_Response>(Arena*);
template<> ::CStoreBrowse_GetStoreCategories_Request* Arena::CreateMaybeMessage<::CStoreBrowse_GetStoreCategories_Request>(Arena*);
template<> ::CStoreBrowse_GetStoreCategories_Response* Arena::CreateMaybeMessage<::CStoreBrowse_GetStoreCategories_Response>(Arena*);
template<> ::CStoreBrowse_GetStoreCategories_Response_Category* Arena::CreateMaybeMessage<::CStoreBrowse_GetStoreCategories_Response_Category>(Arena*);
template<> ::StoreBrowseContext* Arena::CreateMaybeMessage<::StoreBrowseContext>(Arena*);
template<> ::StoreBrowseItemDataRequest* Arena::CreateMaybeMessage<::StoreBrowseItemDataRequest>(Arena*);
template<> ::StoreGameRating* Arena::CreateMaybeMessage<::StoreGameRating>(Arena*);
template<> ::StoreItem* Arena::CreateMaybeMessage<::StoreItem>(Arena*);
template<> ::StoreItemID* Arena::CreateMaybeMessage<::StoreItemID>(Arena*);
template<> ::StoreItem_Assets* Arena::CreateMaybeMessage<::StoreItem_Assets>(Arena*);
template<> ::StoreItem_BasicInfo* Arena::CreateMaybeMessage<::StoreItem_BasicInfo>(Arena*);
template<> ::StoreItem_BasicInfo_CreatorHomeLink* Arena::CreateMaybeMessage<::StoreItem_BasicInfo_CreatorHomeLink>(Arena*);
template<> ::StoreItem_Categories* Arena::CreateMaybeMessage<::StoreItem_Categories>(Arena*);
template<> ::StoreItem_FreeWeekend* Arena::CreateMaybeMessage<::StoreItem_FreeWeekend>(Arena*);
template<> ::StoreItem_Platforms* Arena::CreateMaybeMessage<::StoreItem_Platforms>(Arena*);
template<> ::StoreItem_Platforms_VRSupport* Arena::CreateMaybeMessage<::StoreItem_Platforms_VRSupport>(Arena*);
template<> ::StoreItem_PurchaseOption* Arena::CreateMaybeMessage<::StoreItem_PurchaseOption>(Arena*);
template<> ::StoreItem_PurchaseOption_Discount* Arena::CreateMaybeMessage<::StoreItem_PurchaseOption_Discount>(Arena*);
template<> ::StoreItem_RelatedItems* Arena::CreateMaybeMessage<::StoreItem_RelatedItems>(Arena*);
template<> ::StoreItem_ReleaseInfo* Arena::CreateMaybeMessage<::StoreItem_ReleaseInfo>(Arena*);
template<> ::StoreItem_Reviews* Arena::CreateMaybeMessage<::StoreItem_Reviews>(Arena*);
template<> ::StoreItem_Reviews_StoreReviewSummary* Arena::CreateMaybeMessage<::StoreItem_Reviews_StoreReviewSummary>(Arena*);
template<> ::StoreItem_Screenshots* Arena::CreateMaybeMessage<::StoreItem_Screenshots>(Arena*);
template<> ::StoreItem_Screenshots_Screenshot* Arena::CreateMaybeMessage<::StoreItem_Screenshots_Screenshot>(Arena*);
template<> ::StoreItem_SupportedLanguage* Arena::CreateMaybeMessage<::StoreItem_SupportedLanguage>(Arena*);
template<> ::StoreItem_Tag* Arena::CreateMaybeMessage<::StoreItem_Tag>(Arena*);
template<> ::StoreItem_Trailers* Arena::CreateMaybeMessage<::StoreItem_Trailers>(Arena*);
template<> ::StoreItem_Trailers_Trailer* Arena::CreateMaybeMessage<::StoreItem_Trailers_Trailer>(Arena*);
template<> ::StoreItem_Trailers_VideoSource* Arena::CreateMaybeMessage<::StoreItem_Trailers_VideoSource>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EStoreItemType : int {
  k_EStoreItemType_Invalid = -1,
  k_EStoreItemType_App = 0,
  k_EStoreItemType_Package = 1,
  k_EStoreItemType_Bundle = 2,
  k_EStoreItemType_Mtx = 3,
  k_EStoreItemType_Tag = 4,
  k_EStoreItemType_Creator = 5,
  k_EStoreItemType_HubCategory = 6
};
bool EStoreItemType_IsValid(int value);
constexpr EStoreItemType EStoreItemType_MIN = k_EStoreItemType_Invalid;
constexpr EStoreItemType EStoreItemType_MAX = k_EStoreItemType_HubCategory;
constexpr int EStoreItemType_ARRAYSIZE = EStoreItemType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreItemType_descriptor();
template<typename T>
inline const std::string& EStoreItemType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStoreItemType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStoreItemType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStoreItemType_descriptor(), enum_t_value);
}
inline bool EStoreItemType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStoreItemType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStoreItemType>(
    EStoreItemType_descriptor(), name, value);
}
enum EStoreAppType : int {
  k_EStoreAppType_Game = 0,
  k_EStoreAppType_Demo = 1,
  k_EStoreAppType_Mod = 2,
  k_EStoreAppType_Movie = 3,
  k_EStoreAppType_DLC = 4,
  k_EStoreAppType_Guide = 5,
  k_EStoreAppType_Software = 6,
  k_EStoreAppType_Video = 7,
  k_EStoreAppType_Series = 8,
  k_EStoreAppType_Episode = 9,
  k_EStoreAppType_Hardware = 10,
  k_EStoreAppType_Music = 11,
  k_EStoreAppType_Beta = 12,
  k_EStoreAppType_Tool = 13,
  k_EStoreAppType_Advertising = 14
};
bool EStoreAppType_IsValid(int value);
constexpr EStoreAppType EStoreAppType_MIN = k_EStoreAppType_Game;
constexpr EStoreAppType EStoreAppType_MAX = k_EStoreAppType_Advertising;
constexpr int EStoreAppType_ARRAYSIZE = EStoreAppType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreAppType_descriptor();
template<typename T>
inline const std::string& EStoreAppType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStoreAppType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStoreAppType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStoreAppType_descriptor(), enum_t_value);
}
inline bool EStoreAppType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStoreAppType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStoreAppType>(
    EStoreAppType_descriptor(), name, value);
}
enum EUserReviewScore : int {
  k_EUserReviewScore_None = 0,
  k_EUserReviewScore_OverwhelminglyNegative = 1,
  k_EUserReviewScore_VeryNegative = 2,
  k_EUserReviewScore_Negative = 3,
  k_EUserReviewScore_MostlyNegative = 4,
  k_EUserReviewScore_Mixed = 5,
  k_EUserReviewScore_MostlyPositive = 6,
  k_EUserReviewScore_Positive = 7,
  k_EUserReviewScore_VeryPositive = 8,
  k_EUserReviewScore_OverwhelminglyPositive = 9
};
bool EUserReviewScore_IsValid(int value);
constexpr EUserReviewScore EUserReviewScore_MIN = k_EUserReviewScore_None;
constexpr EUserReviewScore EUserReviewScore_MAX = k_EUserReviewScore_OverwhelminglyPositive;
constexpr int EUserReviewScore_ARRAYSIZE = EUserReviewScore_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EUserReviewScore_descriptor();
template<typename T>
inline const std::string& EUserReviewScore_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EUserReviewScore>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EUserReviewScore_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EUserReviewScore_descriptor(), enum_t_value);
}
inline bool EUserReviewScore_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EUserReviewScore* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EUserReviewScore>(
    EUserReviewScore_descriptor(), name, value);
}
enum EStoreCategoryType : int {
  k_EStoreCategoryType_Category = 0,
  k_EStoreCategoryType_SupportedPlayers = 1,
  k_EStoreCategoryType_Feature = 2,
  k_EStoreCategoryType_ControllerSupport = 3,
  k_EStoreCategoryType_CloudGaming = 4,
  k_EStoreCategoryType_MAX = 5
};
bool EStoreCategoryType_IsValid(int value);
constexpr EStoreCategoryType EStoreCategoryType_MIN = k_EStoreCategoryType_Category;
constexpr EStoreCategoryType EStoreCategoryType_MAX = k_EStoreCategoryType_MAX;
constexpr int EStoreCategoryType_ARRAYSIZE = EStoreCategoryType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStoreCategoryType_descriptor();
template<typename T>
inline const std::string& EStoreCategoryType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStoreCategoryType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStoreCategoryType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStoreCategoryType_descriptor(), enum_t_value);
}
inline bool EStoreCategoryType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStoreCategoryType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStoreCategoryType>(
    EStoreCategoryType_descriptor(), name, value);
}
// ===================================================================

class StoreItemID final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItemID) */ {
 public:
  inline StoreItemID() : StoreItemID(nullptr) {}
  ~StoreItemID() override;
  explicit constexpr StoreItemID(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItemID(const StoreItemID& from);
  StoreItemID(StoreItemID&& from) noexcept
    : StoreItemID() {
    *this = ::std::move(from);
  }

  inline StoreItemID& operator=(const StoreItemID& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItemID& operator=(StoreItemID&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItemID& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItemID* internal_default_instance() {
    return reinterpret_cast<const StoreItemID*>(
               &_StoreItemID_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(StoreItemID& a, StoreItemID& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItemID* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItemID* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItemID* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItemID>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItemID& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItemID& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItemID* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItemID";
  }
  protected:
  explicit StoreItemID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kPackageidFieldNumber = 2,
    kBundleidFieldNumber = 3,
    kTagidFieldNumber = 4,
    kCreatoridFieldNumber = 5,
    kHubcategoryidFieldNumber = 6,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 packageid = 2;
  bool has_packageid() const;
  private:
  bool _internal_has_packageid() const;
  public:
  void clear_packageid();
  uint32_t packageid() const;
  void set_packageid(uint32_t value);
  private:
  uint32_t _internal_packageid() const;
  void _internal_set_packageid(uint32_t value);
  public:

  // optional uint32 bundleid = 3;
  bool has_bundleid() const;
  private:
  bool _internal_has_bundleid() const;
  public:
  void clear_bundleid();
  uint32_t bundleid() const;
  void set_bundleid(uint32_t value);
  private:
  uint32_t _internal_bundleid() const;
  void _internal_set_bundleid(uint32_t value);
  public:

  // optional uint32 tagid = 4;
  bool has_tagid() const;
  private:
  bool _internal_has_tagid() const;
  public:
  void clear_tagid();
  uint32_t tagid() const;
  void set_tagid(uint32_t value);
  private:
  uint32_t _internal_tagid() const;
  void _internal_set_tagid(uint32_t value);
  public:

  // optional uint32 creatorid = 5;
  bool has_creatorid() const;
  private:
  bool _internal_has_creatorid() const;
  public:
  void clear_creatorid();
  uint32_t creatorid() const;
  void set_creatorid(uint32_t value);
  private:
  uint32_t _internal_creatorid() const;
  void _internal_set_creatorid(uint32_t value);
  public:

  // optional uint32 hubcategoryid = 6;
  bool has_hubcategoryid() const;
  private:
  bool _internal_has_hubcategoryid() const;
  public:
  void clear_hubcategoryid();
  uint32_t hubcategoryid() const;
  void set_hubcategoryid(uint32_t value);
  private:
  uint32_t _internal_hubcategoryid() const;
  void _internal_set_hubcategoryid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItemID)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t packageid_;
  uint32_t bundleid_;
  uint32_t tagid_;
  uint32_t creatorid_;
  uint32_t hubcategoryid_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreBrowseContext final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreBrowseContext) */ {
 public:
  inline StoreBrowseContext() : StoreBrowseContext(nullptr) {}
  ~StoreBrowseContext() override;
  explicit constexpr StoreBrowseContext(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreBrowseContext(const StoreBrowseContext& from);
  StoreBrowseContext(StoreBrowseContext&& from) noexcept
    : StoreBrowseContext() {
    *this = ::std::move(from);
  }

  inline StoreBrowseContext& operator=(const StoreBrowseContext& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreBrowseContext& operator=(StoreBrowseContext&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreBrowseContext& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreBrowseContext* internal_default_instance() {
    return reinterpret_cast<const StoreBrowseContext*>(
               &_StoreBrowseContext_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(StoreBrowseContext& a, StoreBrowseContext& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreBrowseContext* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreBrowseContext* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreBrowseContext* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreBrowseContext>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreBrowseContext& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreBrowseContext& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreBrowseContext* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreBrowseContext";
  }
  protected:
  explicit StoreBrowseContext(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kCountryCodeFieldNumber = 3,
    kElanguageFieldNumber = 2,
    kSteamRealmFieldNumber = 4,
  };
  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional string country_code = 3 [(.description) = "2-character country code; required"];
  bool has_country_code() const;
  private:
  bool _internal_has_country_code() const;
  public:
  void clear_country_code();
  const std::string& country_code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_country_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_country_code();
  PROTOBUF_NODISCARD std::string* release_country_code();
  void set_allocated_country_code(std::string* country_code);
  private:
  const std::string& _internal_country_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_country_code(const std::string& value);
  std::string* _internal_mutable_country_code();
  public:

  // optional int32 elanguage = 2 [(.description) = "ELanguage"];
  bool has_elanguage() const;
  private:
  bool _internal_has_elanguage() const;
  public:
  void clear_elanguage();
  int32_t elanguage() const;
  void set_elanguage(int32_t value);
  private:
  int32_t _internal_elanguage() const;
  void _internal_set_elanguage(int32_t value);
  public:

  // optional int32 steam_realm = 4 [(.description) = "ESteamRealm"];
  bool has_steam_realm() const;
  private:
  bool _internal_has_steam_realm() const;
  public:
  void clear_steam_realm();
  int32_t steam_realm() const;
  void set_steam_realm(int32_t value);
  private:
  int32_t _internal_steam_realm() const;
  void _internal_set_steam_realm(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreBrowseContext)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr country_code_;
  int32_t elanguage_;
  int32_t steam_realm_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreBrowseItemDataRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreBrowseItemDataRequest) */ {
 public:
  inline StoreBrowseItemDataRequest() : StoreBrowseItemDataRequest(nullptr) {}
  ~StoreBrowseItemDataRequest() override;
  explicit constexpr StoreBrowseItemDataRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreBrowseItemDataRequest(const StoreBrowseItemDataRequest& from);
  StoreBrowseItemDataRequest(StoreBrowseItemDataRequest&& from) noexcept
    : StoreBrowseItemDataRequest() {
    *this = ::std::move(from);
  }

  inline StoreBrowseItemDataRequest& operator=(const StoreBrowseItemDataRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreBrowseItemDataRequest& operator=(StoreBrowseItemDataRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreBrowseItemDataRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreBrowseItemDataRequest* internal_default_instance() {
    return reinterpret_cast<const StoreBrowseItemDataRequest*>(
               &_StoreBrowseItemDataRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(StoreBrowseItemDataRequest& a, StoreBrowseItemDataRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreBrowseItemDataRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreBrowseItemDataRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreBrowseItemDataRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreBrowseItemDataRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreBrowseItemDataRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreBrowseItemDataRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreBrowseItemDataRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreBrowseItemDataRequest";
  }
  protected:
  explicit StoreBrowseItemDataRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIncludeAssetsFieldNumber = 1,
    kIncludeReleaseFieldNumber = 2,
    kIncludePlatformsFieldNumber = 3,
    kIncludeAllPurchaseOptionsFieldNumber = 4,
    kIncludeScreenshotsFieldNumber = 5,
    kIncludeTrailersFieldNumber = 6,
    kIncludeRatingsFieldNumber = 7,
    kIncludeReviewsFieldNumber = 9,
    kIncludeTagCountFieldNumber = 8,
    kIncludeBasicInfoFieldNumber = 10,
    kIncludeSupportedLanguagesFieldNumber = 11,
    kIncludeFullDescriptionFieldNumber = 12,
  };
  // optional bool include_assets = 1;
  bool has_include_assets() const;
  private:
  bool _internal_has_include_assets() const;
  public:
  void clear_include_assets();
  bool include_assets() const;
  void set_include_assets(bool value);
  private:
  bool _internal_include_assets() const;
  void _internal_set_include_assets(bool value);
  public:

  // optional bool include_release = 2;
  bool has_include_release() const;
  private:
  bool _internal_has_include_release() const;
  public:
  void clear_include_release();
  bool include_release() const;
  void set_include_release(bool value);
  private:
  bool _internal_include_release() const;
  void _internal_set_include_release(bool value);
  public:

  // optional bool include_platforms = 3;
  bool has_include_platforms() const;
  private:
  bool _internal_has_include_platforms() const;
  public:
  void clear_include_platforms();
  bool include_platforms() const;
  void set_include_platforms(bool value);
  private:
  bool _internal_include_platforms() const;
  void _internal_set_include_platforms(bool value);
  public:

  // optional bool include_all_purchase_options = 4;
  bool has_include_all_purchase_options() const;
  private:
  bool _internal_has_include_all_purchase_options() const;
  public:
  void clear_include_all_purchase_options();
  bool include_all_purchase_options() const;
  void set_include_all_purchase_options(bool value);
  private:
  bool _internal_include_all_purchase_options() const;
  void _internal_set_include_all_purchase_options(bool value);
  public:

  // optional bool include_screenshots = 5;
  bool has_include_screenshots() const;
  private:
  bool _internal_has_include_screenshots() const;
  public:
  void clear_include_screenshots();
  bool include_screenshots() const;
  void set_include_screenshots(bool value);
  private:
  bool _internal_include_screenshots() const;
  void _internal_set_include_screenshots(bool value);
  public:

  // optional bool include_trailers = 6;
  bool has_include_trailers() const;
  private:
  bool _internal_has_include_trailers() const;
  public:
  void clear_include_trailers();
  bool include_trailers() const;
  void set_include_trailers(bool value);
  private:
  bool _internal_include_trailers() const;
  void _internal_set_include_trailers(bool value);
  public:

  // optional bool include_ratings = 7;
  bool has_include_ratings() const;
  private:
  bool _internal_has_include_ratings() const;
  public:
  void clear_include_ratings();
  bool include_ratings() const;
  void set_include_ratings(bool value);
  private:
  bool _internal_include_ratings() const;
  void _internal_set_include_ratings(bool value);
  public:

  // optional bool include_reviews = 9;
  bool has_include_reviews() const;
  private:
  bool _internal_has_include_reviews() const;
  public:
  void clear_include_reviews();
  bool include_reviews() const;
  void set_include_reviews(bool value);
  private:
  bool _internal_include_reviews() const;
  void _internal_set_include_reviews(bool value);
  public:

  // optional int32 include_tag_count = 8 [(.description) = "Count of tags to return, as tagids.  Maximum 20."];
  bool has_include_tag_count() const;
  private:
  bool _internal_has_include_tag_count() const;
  public:
  void clear_include_tag_count();
  int32_t include_tag_count() const;
  void set_include_tag_count(int32_t value);
  private:
  int32_t _internal_include_tag_count() const;
  void _internal_set_include_tag_count(int32_t value);
  public:

  // optional bool include_basic_info = 10 [(.description) = "Include short description, publisher, developers"];
  bool has_include_basic_info() const;
  private:
  bool _internal_has_include_basic_info() const;
  public:
  void clear_include_basic_info();
  bool include_basic_info() const;
  void set_include_basic_info(bool value);
  private:
  bool _internal_include_basic_info() const;
  void _internal_set_include_basic_info(bool value);
  public:

  // optional bool include_supported_languages = 11 [(.description) = "includes the games support for languages: supported, full_audio, subtitles"];
  bool has_include_supported_languages() const;
  private:
  bool _internal_has_include_supported_languages() const;
  public:
  void clear_include_supported_languages();
  bool include_supported_languages() const;
  void set_include_supported_languages(bool value);
  private:
  bool _internal_include_supported_languages() const;
  void _internal_set_include_supported_languages(bool value);
  public:

  // optional bool include_full_description = 12;
  bool has_include_full_description() const;
  private:
  bool _internal_has_include_full_description() const;
  public:
  void clear_include_full_description();
  bool include_full_description() const;
  void set_include_full_description(bool value);
  private:
  bool _internal_include_full_description() const;
  void _internal_set_include_full_description(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StoreBrowseItemDataRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool include_assets_;
  bool include_release_;
  bool include_platforms_;
  bool include_all_purchase_options_;
  bool include_screenshots_;
  bool include_trailers_;
  bool include_ratings_;
  bool include_reviews_;
  int32_t include_tag_count_;
  bool include_basic_info_;
  bool include_supported_languages_;
  bool include_full_description_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetItems_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetItems_Request) */ {
 public:
  inline CStoreBrowse_GetItems_Request() : CStoreBrowse_GetItems_Request(nullptr) {}
  ~CStoreBrowse_GetItems_Request() override;
  explicit constexpr CStoreBrowse_GetItems_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetItems_Request(const CStoreBrowse_GetItems_Request& from);
  CStoreBrowse_GetItems_Request(CStoreBrowse_GetItems_Request&& from) noexcept
    : CStoreBrowse_GetItems_Request() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetItems_Request& operator=(const CStoreBrowse_GetItems_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetItems_Request& operator=(CStoreBrowse_GetItems_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetItems_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetItems_Request* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetItems_Request*>(
               &_CStoreBrowse_GetItems_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CStoreBrowse_GetItems_Request& a, CStoreBrowse_GetItems_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetItems_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetItems_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetItems_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetItems_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetItems_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetItems_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetItems_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetItems_Request";
  }
  protected:
  explicit CStoreBrowse_GetItems_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdsFieldNumber = 1,
    kContextFieldNumber = 2,
    kDataRequestFieldNumber = 3,
  };
  // repeated .StoreItemID ids = 1;
  int ids_size() const;
  private:
  int _internal_ids_size() const;
  public:
  void clear_ids();
  ::StoreItemID* mutable_ids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >*
      mutable_ids();
  private:
  const ::StoreItemID& _internal_ids(int index) const;
  ::StoreItemID* _internal_add_ids();
  public:
  const ::StoreItemID& ids(int index) const;
  ::StoreItemID* add_ids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >&
      ids() const;

  // optional .StoreBrowseContext context = 2;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::StoreBrowseContext& context() const;
  PROTOBUF_NODISCARD ::StoreBrowseContext* release_context();
  ::StoreBrowseContext* mutable_context();
  void set_allocated_context(::StoreBrowseContext* context);
  private:
  const ::StoreBrowseContext& _internal_context() const;
  ::StoreBrowseContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::StoreBrowseContext* context);
  ::StoreBrowseContext* unsafe_arena_release_context();

  // optional .StoreBrowseItemDataRequest data_request = 3;
  bool has_data_request() const;
  private:
  bool _internal_has_data_request() const;
  public:
  void clear_data_request();
  const ::StoreBrowseItemDataRequest& data_request() const;
  PROTOBUF_NODISCARD ::StoreBrowseItemDataRequest* release_data_request();
  ::StoreBrowseItemDataRequest* mutable_data_request();
  void set_allocated_data_request(::StoreBrowseItemDataRequest* data_request);
  private:
  const ::StoreBrowseItemDataRequest& _internal_data_request() const;
  ::StoreBrowseItemDataRequest* _internal_mutable_data_request();
  public:
  void unsafe_arena_set_allocated_data_request(
      ::StoreBrowseItemDataRequest* data_request);
  ::StoreBrowseItemDataRequest* unsafe_arena_release_data_request();

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetItems_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID > ids_;
  ::StoreBrowseContext* context_;
  ::StoreBrowseItemDataRequest* data_request_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreGameRating final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreGameRating) */ {
 public:
  inline StoreGameRating() : StoreGameRating(nullptr) {}
  ~StoreGameRating() override;
  explicit constexpr StoreGameRating(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreGameRating(const StoreGameRating& from);
  StoreGameRating(StoreGameRating&& from) noexcept
    : StoreGameRating() {
    *this = ::std::move(from);
  }

  inline StoreGameRating& operator=(const StoreGameRating& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreGameRating& operator=(StoreGameRating&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreGameRating& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreGameRating* internal_default_instance() {
    return reinterpret_cast<const StoreGameRating*>(
               &_StoreGameRating_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(StoreGameRating& a, StoreGameRating& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreGameRating* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreGameRating* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreGameRating* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreGameRating>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreGameRating& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreGameRating& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreGameRating* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreGameRating";
  }
  protected:
  explicit StoreGameRating(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDescriptorsFieldNumber = 3,
    kTypeFieldNumber = 1,
    kRatingFieldNumber = 2,
    kInteractiveElementsFieldNumber = 4,
    kImageUrlFieldNumber = 20,
    kImageTargetFieldNumber = 21,
    kRequiredAgeFieldNumber = 10,
    kUseAgeGateFieldNumber = 11,
  };
  // repeated string descriptors = 3 [(.description) = "Additional descriptors like \'Intense Violence\', \'Strong Language\',..."];
  int descriptors_size() const;
  private:
  int _internal_descriptors_size() const;
  public:
  void clear_descriptors();
  const std::string& descriptors(int index) const;
  std::string* mutable_descriptors(int index);
  void set_descriptors(int index, const std::string& value);
  void set_descriptors(int index, std::string&& value);
  void set_descriptors(int index, const char* value);
  void set_descriptors(int index, const char* value, size_t size);
  std::string* add_descriptors();
  void add_descriptors(const std::string& value);
  void add_descriptors(std::string&& value);
  void add_descriptors(const char* value);
  void add_descriptors(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& descriptors() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_descriptors();
  private:
  const std::string& _internal_descriptors(int index) const;
  std::string* _internal_add_descriptors();
  public:

  // optional string type = 1 [(.description) = "\'esrb\', \'pegi\', ..."];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // optional string rating = 2 [(.description) = "\'t\' for teen, \'m\' for mature, ..."];
  bool has_rating() const;
  private:
  bool _internal_has_rating() const;
  public:
  void clear_rating();
  const std::string& rating() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rating(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rating();
  PROTOBUF_NODISCARD std::string* release_rating();
  void set_allocated_rating(std::string* rating);
  private:
  const std::string& _internal_rating() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rating(const std::string& value);
  std::string* _internal_mutable_rating();
  public:

  // optional string interactive_elements = 4 [(.description) = "ESRB-specific"];
  bool has_interactive_elements() const;
  private:
  bool _internal_has_interactive_elements() const;
  public:
  void clear_interactive_elements();
  const std::string& interactive_elements() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_interactive_elements(ArgT0&& arg0, ArgT... args);
  std::string* mutable_interactive_elements();
  PROTOBUF_NODISCARD std::string* release_interactive_elements();
  void set_allocated_interactive_elements(std::string* interactive_elements);
  private:
  const std::string& _internal_interactive_elements() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_interactive_elements(const std::string& value);
  std::string* _internal_mutable_interactive_elements();
  public:

  // optional string image_url = 20 [(.description) = "An image corresponding to the rating."];
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // optional string image_target = 21 [(.description) = "URL where the image should link for more information."];
  bool has_image_target() const;
  private:
  bool _internal_has_image_target() const;
  public:
  void clear_image_target();
  const std::string& image_target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_target();
  PROTOBUF_NODISCARD std::string* release_image_target();
  void set_allocated_image_target(std::string* image_target);
  private:
  const std::string& _internal_image_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_target(const std::string& value);
  std::string* _internal_mutable_image_target();
  public:

  // optional int32 required_age = 10 [(.description) = "Age in years.  Store pages will prompt with an age gate"];
  bool has_required_age() const;
  private:
  bool _internal_has_required_age() const;
  public:
  void clear_required_age();
  int32_t required_age() const;
  void set_required_age(int32_t value);
  private:
  int32_t _internal_required_age() const;
  void _internal_set_required_age(int32_t value);
  public:

  // optional bool use_age_gate = 11;
  bool has_use_age_gate() const;
  private:
  bool _internal_has_use_age_gate() const;
  public:
  void clear_use_age_gate();
  bool use_age_gate() const;
  void set_use_age_gate(bool value);
  private:
  bool _internal_use_age_gate() const;
  void _internal_set_use_age_gate(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StoreGameRating)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> descriptors_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rating_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr interactive_elements_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_target_;
  int32_t required_age_;
  bool use_age_gate_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_RelatedItems final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.RelatedItems) */ {
 public:
  inline StoreItem_RelatedItems() : StoreItem_RelatedItems(nullptr) {}
  ~StoreItem_RelatedItems() override;
  explicit constexpr StoreItem_RelatedItems(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_RelatedItems(const StoreItem_RelatedItems& from);
  StoreItem_RelatedItems(StoreItem_RelatedItems&& from) noexcept
    : StoreItem_RelatedItems() {
    *this = ::std::move(from);
  }

  inline StoreItem_RelatedItems& operator=(const StoreItem_RelatedItems& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_RelatedItems& operator=(StoreItem_RelatedItems&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_RelatedItems& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_RelatedItems* internal_default_instance() {
    return reinterpret_cast<const StoreItem_RelatedItems*>(
               &_StoreItem_RelatedItems_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(StoreItem_RelatedItems& a, StoreItem_RelatedItems& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_RelatedItems* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_RelatedItems* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_RelatedItems* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_RelatedItems>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_RelatedItems& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_RelatedItems& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_RelatedItems* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.RelatedItems";
  }
  protected:
  explicit StoreItem_RelatedItems(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kParentAppidFieldNumber = 1,
  };
  // optional uint32 parent_appid = 1 [(.description) = "For DLC, Demos, etc, this is the main app."];
  bool has_parent_appid() const;
  private:
  bool _internal_has_parent_appid() const;
  public:
  void clear_parent_appid();
  uint32_t parent_appid() const;
  void set_parent_appid(uint32_t value);
  private:
  uint32_t _internal_parent_appid() const;
  void _internal_set_parent_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.RelatedItems)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t parent_appid_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Categories final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Categories) */ {
 public:
  inline StoreItem_Categories() : StoreItem_Categories(nullptr) {}
  ~StoreItem_Categories() override;
  explicit constexpr StoreItem_Categories(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Categories(const StoreItem_Categories& from);
  StoreItem_Categories(StoreItem_Categories&& from) noexcept
    : StoreItem_Categories() {
    *this = ::std::move(from);
  }

  inline StoreItem_Categories& operator=(const StoreItem_Categories& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Categories& operator=(StoreItem_Categories&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Categories& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Categories* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Categories*>(
               &_StoreItem_Categories_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StoreItem_Categories& a, StoreItem_Categories& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Categories* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Categories* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Categories* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Categories>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Categories& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Categories& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Categories* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Categories";
  }
  protected:
  explicit StoreItem_Categories(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedPlayerCategoryidsFieldNumber = 2,
    kFeatureCategoryidsFieldNumber = 3,
    kControllerCategoryidsFieldNumber = 4,
  };
  // repeated uint32 supported_player_categoryids = 2 [(.description) = "Categories like Single Player, Multiplayer, MMO"];
  int supported_player_categoryids_size() const;
  private:
  int _internal_supported_player_categoryids_size() const;
  public:
  void clear_supported_player_categoryids();
  private:
  uint32_t _internal_supported_player_categoryids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_supported_player_categoryids() const;
  void _internal_add_supported_player_categoryids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_supported_player_categoryids();
  public:
  uint32_t supported_player_categoryids(int index) const;
  void set_supported_player_categoryids(int index, uint32_t value);
  void add_supported_player_categoryids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      supported_player_categoryids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_supported_player_categoryids();

  // repeated uint32 feature_categoryids = 3 [(.description) = "Categories indicating supported features like Steam Cloud, VAC, Achievements, etc"];
  int feature_categoryids_size() const;
  private:
  int _internal_feature_categoryids_size() const;
  public:
  void clear_feature_categoryids();
  private:
  uint32_t _internal_feature_categoryids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_feature_categoryids() const;
  void _internal_add_feature_categoryids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_feature_categoryids();
  public:
  uint32_t feature_categoryids(int index) const;
  void set_feature_categoryids(int index, uint32_t value);
  void add_feature_categoryids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      feature_categoryids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_feature_categoryids();

  // repeated uint32 controller_categoryids = 4 [(.description) = "Categories indicating controller support and full controller support."];
  int controller_categoryids_size() const;
  private:
  int _internal_controller_categoryids_size() const;
  public:
  void clear_controller_categoryids();
  private:
  uint32_t _internal_controller_categoryids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_controller_categoryids() const;
  void _internal_add_controller_categoryids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_controller_categoryids();
  public:
  uint32_t controller_categoryids(int index) const;
  void set_controller_categoryids(int index, uint32_t value);
  void add_controller_categoryids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      controller_categoryids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_controller_categoryids();

  // @@protoc_insertion_point(class_scope:StoreItem.Categories)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > supported_player_categoryids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > feature_categoryids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > controller_categoryids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Reviews_StoreReviewSummary final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Reviews.StoreReviewSummary) */ {
 public:
  inline StoreItem_Reviews_StoreReviewSummary() : StoreItem_Reviews_StoreReviewSummary(nullptr) {}
  ~StoreItem_Reviews_StoreReviewSummary() override;
  explicit constexpr StoreItem_Reviews_StoreReviewSummary(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Reviews_StoreReviewSummary(const StoreItem_Reviews_StoreReviewSummary& from);
  StoreItem_Reviews_StoreReviewSummary(StoreItem_Reviews_StoreReviewSummary&& from) noexcept
    : StoreItem_Reviews_StoreReviewSummary() {
    *this = ::std::move(from);
  }

  inline StoreItem_Reviews_StoreReviewSummary& operator=(const StoreItem_Reviews_StoreReviewSummary& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Reviews_StoreReviewSummary& operator=(StoreItem_Reviews_StoreReviewSummary&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Reviews_StoreReviewSummary& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Reviews_StoreReviewSummary* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Reviews_StoreReviewSummary*>(
               &_StoreItem_Reviews_StoreReviewSummary_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StoreItem_Reviews_StoreReviewSummary& a, StoreItem_Reviews_StoreReviewSummary& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Reviews_StoreReviewSummary* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Reviews_StoreReviewSummary* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Reviews_StoreReviewSummary* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Reviews_StoreReviewSummary>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Reviews_StoreReviewSummary& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Reviews_StoreReviewSummary& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Reviews_StoreReviewSummary* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Reviews.StoreReviewSummary";
  }
  protected:
  explicit StoreItem_Reviews_StoreReviewSummary(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kReviewScoreLabelFieldNumber = 4,
    kReviewCountFieldNumber = 1,
    kPercentPositiveFieldNumber = 2,
    kReviewScoreFieldNumber = 3,
  };
  // optional string review_score_label = 4 [(.description) = "A string like \'Mixed\', \'Negative\', \'Overwhelmingly Positive\'"];
  bool has_review_score_label() const;
  private:
  bool _internal_has_review_score_label() const;
  public:
  void clear_review_score_label();
  const std::string& review_score_label() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_review_score_label(ArgT0&& arg0, ArgT... args);
  std::string* mutable_review_score_label();
  PROTOBUF_NODISCARD std::string* release_review_score_label();
  void set_allocated_review_score_label(std::string* review_score_label);
  private:
  const std::string& _internal_review_score_label() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_review_score_label(const std::string& value);
  std::string* _internal_mutable_review_score_label();
  public:

  // optional uint32 review_count = 1;
  bool has_review_count() const;
  private:
  bool _internal_has_review_count() const;
  public:
  void clear_review_count();
  uint32_t review_count() const;
  void set_review_count(uint32_t value);
  private:
  uint32_t _internal_review_count() const;
  void _internal_set_review_count(uint32_t value);
  public:

  // optional int32 percent_positive = 2 [(.description) = "0-100"];
  bool has_percent_positive() const;
  private:
  bool _internal_has_percent_positive() const;
  public:
  void clear_percent_positive();
  int32_t percent_positive() const;
  void set_percent_positive(int32_t value);
  private:
  int32_t _internal_percent_positive() const;
  void _internal_set_percent_positive(int32_t value);
  public:

  // optional .EUserReviewScore review_score = 3 [default = k_EUserReviewScore_None];
  bool has_review_score() const;
  private:
  bool _internal_has_review_score() const;
  public:
  void clear_review_score();
  ::EUserReviewScore review_score() const;
  void set_review_score(::EUserReviewScore value);
  private:
  ::EUserReviewScore _internal_review_score() const;
  void _internal_set_review_score(::EUserReviewScore value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Reviews.StoreReviewSummary)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr review_score_label_;
  uint32_t review_count_;
  int32_t percent_positive_;
  int review_score_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Reviews final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Reviews) */ {
 public:
  inline StoreItem_Reviews() : StoreItem_Reviews(nullptr) {}
  ~StoreItem_Reviews() override;
  explicit constexpr StoreItem_Reviews(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Reviews(const StoreItem_Reviews& from);
  StoreItem_Reviews(StoreItem_Reviews&& from) noexcept
    : StoreItem_Reviews() {
    *this = ::std::move(from);
  }

  inline StoreItem_Reviews& operator=(const StoreItem_Reviews& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Reviews& operator=(StoreItem_Reviews&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Reviews& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Reviews* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Reviews*>(
               &_StoreItem_Reviews_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StoreItem_Reviews& a, StoreItem_Reviews& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Reviews* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Reviews* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Reviews* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Reviews>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Reviews& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Reviews& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Reviews* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Reviews";
  }
  protected:
  explicit StoreItem_Reviews(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_Reviews_StoreReviewSummary StoreReviewSummary;

  // accessors -------------------------------------------------------

  enum : int {
    kSummaryFilteredFieldNumber = 1,
    kSummaryUnfilteredFieldNumber = 2,
  };
  // optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1 [(.description) = "Review summary with review bombs removed (if any).  Always present (if include_reviews set in request)"];
  bool has_summary_filtered() const;
  private:
  bool _internal_has_summary_filtered() const;
  public:
  void clear_summary_filtered();
  const ::StoreItem_Reviews_StoreReviewSummary& summary_filtered() const;
  PROTOBUF_NODISCARD ::StoreItem_Reviews_StoreReviewSummary* release_summary_filtered();
  ::StoreItem_Reviews_StoreReviewSummary* mutable_summary_filtered();
  void set_allocated_summary_filtered(::StoreItem_Reviews_StoreReviewSummary* summary_filtered);
  private:
  const ::StoreItem_Reviews_StoreReviewSummary& _internal_summary_filtered() const;
  ::StoreItem_Reviews_StoreReviewSummary* _internal_mutable_summary_filtered();
  public:
  void unsafe_arena_set_allocated_summary_filtered(
      ::StoreItem_Reviews_StoreReviewSummary* summary_filtered);
  ::StoreItem_Reviews_StoreReviewSummary* unsafe_arena_release_summary_filtered();

  // optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2 [(.description) = "Review summary with review bombs included.  Only present if there are review bombs."];
  bool has_summary_unfiltered() const;
  private:
  bool _internal_has_summary_unfiltered() const;
  public:
  void clear_summary_unfiltered();
  const ::StoreItem_Reviews_StoreReviewSummary& summary_unfiltered() const;
  PROTOBUF_NODISCARD ::StoreItem_Reviews_StoreReviewSummary* release_summary_unfiltered();
  ::StoreItem_Reviews_StoreReviewSummary* mutable_summary_unfiltered();
  void set_allocated_summary_unfiltered(::StoreItem_Reviews_StoreReviewSummary* summary_unfiltered);
  private:
  const ::StoreItem_Reviews_StoreReviewSummary& _internal_summary_unfiltered() const;
  ::StoreItem_Reviews_StoreReviewSummary* _internal_mutable_summary_unfiltered();
  public:
  void unsafe_arena_set_allocated_summary_unfiltered(
      ::StoreItem_Reviews_StoreReviewSummary* summary_unfiltered);
  ::StoreItem_Reviews_StoreReviewSummary* unsafe_arena_release_summary_unfiltered();

  // @@protoc_insertion_point(class_scope:StoreItem.Reviews)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::StoreItem_Reviews_StoreReviewSummary* summary_filtered_;
  ::StoreItem_Reviews_StoreReviewSummary* summary_unfiltered_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_BasicInfo_CreatorHomeLink final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.BasicInfo.CreatorHomeLink) */ {
 public:
  inline StoreItem_BasicInfo_CreatorHomeLink() : StoreItem_BasicInfo_CreatorHomeLink(nullptr) {}
  ~StoreItem_BasicInfo_CreatorHomeLink() override;
  explicit constexpr StoreItem_BasicInfo_CreatorHomeLink(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_BasicInfo_CreatorHomeLink(const StoreItem_BasicInfo_CreatorHomeLink& from);
  StoreItem_BasicInfo_CreatorHomeLink(StoreItem_BasicInfo_CreatorHomeLink&& from) noexcept
    : StoreItem_BasicInfo_CreatorHomeLink() {
    *this = ::std::move(from);
  }

  inline StoreItem_BasicInfo_CreatorHomeLink& operator=(const StoreItem_BasicInfo_CreatorHomeLink& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_BasicInfo_CreatorHomeLink& operator=(StoreItem_BasicInfo_CreatorHomeLink&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_BasicInfo_CreatorHomeLink& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_BasicInfo_CreatorHomeLink* internal_default_instance() {
    return reinterpret_cast<const StoreItem_BasicInfo_CreatorHomeLink*>(
               &_StoreItem_BasicInfo_CreatorHomeLink_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(StoreItem_BasicInfo_CreatorHomeLink& a, StoreItem_BasicInfo_CreatorHomeLink& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_BasicInfo_CreatorHomeLink* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_BasicInfo_CreatorHomeLink* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_BasicInfo_CreatorHomeLink* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_BasicInfo_CreatorHomeLink>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_BasicInfo_CreatorHomeLink& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_BasicInfo_CreatorHomeLink& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_BasicInfo_CreatorHomeLink* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.BasicInfo.CreatorHomeLink";
  }
  protected:
  explicit StoreItem_BasicInfo_CreatorHomeLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kCreatorClanAccountIdFieldNumber = 2,
  };
  // optional string name = 1;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional uint32 creator_clan_account_id = 2 [(.description) = "Optioanl field indicating this name is associated this the creator home via the clan account id"];
  bool has_creator_clan_account_id() const;
  private:
  bool _internal_has_creator_clan_account_id() const;
  public:
  void clear_creator_clan_account_id();
  uint32_t creator_clan_account_id() const;
  void set_creator_clan_account_id(uint32_t value);
  private:
  uint32_t _internal_creator_clan_account_id() const;
  void _internal_set_creator_clan_account_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.BasicInfo.CreatorHomeLink)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  uint32_t creator_clan_account_id_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_BasicInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.BasicInfo) */ {
 public:
  inline StoreItem_BasicInfo() : StoreItem_BasicInfo(nullptr) {}
  ~StoreItem_BasicInfo() override;
  explicit constexpr StoreItem_BasicInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_BasicInfo(const StoreItem_BasicInfo& from);
  StoreItem_BasicInfo(StoreItem_BasicInfo&& from) noexcept
    : StoreItem_BasicInfo() {
    *this = ::std::move(from);
  }

  inline StoreItem_BasicInfo& operator=(const StoreItem_BasicInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_BasicInfo& operator=(StoreItem_BasicInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_BasicInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_BasicInfo* internal_default_instance() {
    return reinterpret_cast<const StoreItem_BasicInfo*>(
               &_StoreItem_BasicInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(StoreItem_BasicInfo& a, StoreItem_BasicInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_BasicInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_BasicInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_BasicInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_BasicInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_BasicInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_BasicInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_BasicInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.BasicInfo";
  }
  protected:
  explicit StoreItem_BasicInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_BasicInfo_CreatorHomeLink CreatorHomeLink;

  // accessors -------------------------------------------------------

  enum : int {
    kPublishersFieldNumber = 2,
    kDevelopersFieldNumber = 3,
    kFranchisesFieldNumber = 4,
    kShortDescriptionFieldNumber = 1,
    kCapsuleHeadlineFieldNumber = 5,
  };
  // repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;
  int publishers_size() const;
  private:
  int _internal_publishers_size() const;
  public:
  void clear_publishers();
  ::StoreItem_BasicInfo_CreatorHomeLink* mutable_publishers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
      mutable_publishers();
  private:
  const ::StoreItem_BasicInfo_CreatorHomeLink& _internal_publishers(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* _internal_add_publishers();
  public:
  const ::StoreItem_BasicInfo_CreatorHomeLink& publishers(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* add_publishers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
      publishers() const;

  // repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;
  int developers_size() const;
  private:
  int _internal_developers_size() const;
  public:
  void clear_developers();
  ::StoreItem_BasicInfo_CreatorHomeLink* mutable_developers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
      mutable_developers();
  private:
  const ::StoreItem_BasicInfo_CreatorHomeLink& _internal_developers(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* _internal_add_developers();
  public:
  const ::StoreItem_BasicInfo_CreatorHomeLink& developers(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* add_developers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
      developers() const;

  // repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;
  int franchises_size() const;
  private:
  int _internal_franchises_size() const;
  public:
  void clear_franchises();
  ::StoreItem_BasicInfo_CreatorHomeLink* mutable_franchises(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
      mutable_franchises();
  private:
  const ::StoreItem_BasicInfo_CreatorHomeLink& _internal_franchises(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* _internal_add_franchises();
  public:
  const ::StoreItem_BasicInfo_CreatorHomeLink& franchises(int index) const;
  ::StoreItem_BasicInfo_CreatorHomeLink* add_franchises();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
      franchises() const;

  // optional string short_description = 1;
  bool has_short_description() const;
  private:
  bool _internal_has_short_description() const;
  public:
  void clear_short_description();
  const std::string& short_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_short_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_short_description();
  PROTOBUF_NODISCARD std::string* release_short_description();
  void set_allocated_short_description(std::string* short_description);
  private:
  const std::string& _internal_short_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_short_description(const std::string& value);
  std::string* _internal_mutable_short_description();
  public:

  // optional string capsule_headline = 5 [(.description) = "A custom string specified by the partner for display on or around a capsule on the store, e.g. \'Just Updated!\'"];
  bool has_capsule_headline() const;
  private:
  bool _internal_has_capsule_headline() const;
  public:
  void clear_capsule_headline();
  const std::string& capsule_headline() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_capsule_headline(ArgT0&& arg0, ArgT... args);
  std::string* mutable_capsule_headline();
  PROTOBUF_NODISCARD std::string* release_capsule_headline();
  void set_allocated_capsule_headline(std::string* capsule_headline);
  private:
  const std::string& _internal_capsule_headline() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_capsule_headline(const std::string& value);
  std::string* _internal_mutable_capsule_headline();
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.BasicInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink > publishers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink > developers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink > franchises_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr short_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr capsule_headline_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Tag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Tag) */ {
 public:
  inline StoreItem_Tag() : StoreItem_Tag(nullptr) {}
  ~StoreItem_Tag() override;
  explicit constexpr StoreItem_Tag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Tag(const StoreItem_Tag& from);
  StoreItem_Tag(StoreItem_Tag&& from) noexcept
    : StoreItem_Tag() {
    *this = ::std::move(from);
  }

  inline StoreItem_Tag& operator=(const StoreItem_Tag& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Tag& operator=(StoreItem_Tag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Tag& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Tag* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Tag*>(
               &_StoreItem_Tag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(StoreItem_Tag& a, StoreItem_Tag& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Tag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Tag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Tag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Tag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Tag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Tag& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Tag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Tag";
  }
  protected:
  explicit StoreItem_Tag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagidFieldNumber = 1,
    kWeightFieldNumber = 2,
  };
  // optional uint32 tagid = 1;
  bool has_tagid() const;
  private:
  bool _internal_has_tagid() const;
  public:
  void clear_tagid();
  uint32_t tagid() const;
  void set_tagid(uint32_t value);
  private:
  uint32_t _internal_tagid() const;
  void _internal_set_tagid(uint32_t value);
  public:

  // optional uint32 weight = 2;
  bool has_weight() const;
  private:
  bool _internal_has_weight() const;
  public:
  void clear_weight();
  uint32_t weight() const;
  void set_weight(uint32_t value);
  private:
  uint32_t _internal_weight() const;
  void _internal_set_weight(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Tag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t tagid_;
  uint32_t weight_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Assets final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Assets) */ {
 public:
  inline StoreItem_Assets() : StoreItem_Assets(nullptr) {}
  ~StoreItem_Assets() override;
  explicit constexpr StoreItem_Assets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Assets(const StoreItem_Assets& from);
  StoreItem_Assets(StoreItem_Assets&& from) noexcept
    : StoreItem_Assets() {
    *this = ::std::move(from);
  }

  inline StoreItem_Assets& operator=(const StoreItem_Assets& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Assets& operator=(StoreItem_Assets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Assets& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Assets* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Assets*>(
               &_StoreItem_Assets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(StoreItem_Assets& a, StoreItem_Assets& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Assets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Assets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Assets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Assets>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Assets& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Assets& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Assets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Assets";
  }
  protected:
  explicit StoreItem_Assets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetUrlFormatFieldNumber = 1,
    kMainCapsuleFieldNumber = 2,
    kSmallCapsuleFieldNumber = 3,
    kHeaderFieldNumber = 4,
    kPackageHeaderFieldNumber = 5,
    kPageBackgroundFieldNumber = 6,
    kHeroCapsuleFieldNumber = 7,
    kHeroCapsule2XFieldNumber = 8,
    kLibraryCapsuleFieldNumber = 9,
    kLibraryCapsule2XFieldNumber = 10,
    kLibraryHeroFieldNumber = 11,
    kLibraryHero2XFieldNumber = 12,
    kCommunityIconFieldNumber = 13,
    kClanAvatarFieldNumber = 14,
  };
  // optional string asset_url_format = 1 [(.description) = "Format for URLs, should substitute the capsule name for ${FILENAME} in the URL."];
  bool has_asset_url_format() const;
  private:
  bool _internal_has_asset_url_format() const;
  public:
  void clear_asset_url_format();
  const std::string& asset_url_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_asset_url_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_asset_url_format();
  PROTOBUF_NODISCARD std::string* release_asset_url_format();
  void set_allocated_asset_url_format(std::string* asset_url_format);
  private:
  const std::string& _internal_asset_url_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_asset_url_format(const std::string& value);
  std::string* _internal_mutable_asset_url_format();
  public:

  // optional string main_capsule = 2;
  bool has_main_capsule() const;
  private:
  bool _internal_has_main_capsule() const;
  public:
  void clear_main_capsule();
  const std::string& main_capsule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_main_capsule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_main_capsule();
  PROTOBUF_NODISCARD std::string* release_main_capsule();
  void set_allocated_main_capsule(std::string* main_capsule);
  private:
  const std::string& _internal_main_capsule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_main_capsule(const std::string& value);
  std::string* _internal_mutable_main_capsule();
  public:

  // optional string small_capsule = 3;
  bool has_small_capsule() const;
  private:
  bool _internal_has_small_capsule() const;
  public:
  void clear_small_capsule();
  const std::string& small_capsule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_small_capsule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_small_capsule();
  PROTOBUF_NODISCARD std::string* release_small_capsule();
  void set_allocated_small_capsule(std::string* small_capsule);
  private:
  const std::string& _internal_small_capsule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_small_capsule(const std::string& value);
  std::string* _internal_mutable_small_capsule();
  public:

  // optional string header = 4 [(.description) = "Equivalent to GetConstantRatioHeaderImage in PHP; apps will always have this, packages and bundles may not."];
  bool has_header() const;
  private:
  bool _internal_has_header() const;
  public:
  void clear_header();
  const std::string& header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_header();
  PROTOBUF_NODISCARD std::string* release_header();
  void set_allocated_header(std::string* header);
  private:
  const std::string& _internal_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_header(const std::string& value);
  std::string* _internal_mutable_header();
  public:

  // optional string package_header = 5 [(.description) = "A wider header used on package/bundle pages.  Not set for apps."];
  bool has_package_header() const;
  private:
  bool _internal_has_package_header() const;
  public:
  void clear_package_header();
  const std::string& package_header() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_package_header(ArgT0&& arg0, ArgT... args);
  std::string* mutable_package_header();
  PROTOBUF_NODISCARD std::string* release_package_header();
  void set_allocated_package_header(std::string* package_header);
  private:
  const std::string& _internal_package_header() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_package_header(const std::string& value);
  std::string* _internal_mutable_package_header();
  public:

  // optional string page_background = 6;
  bool has_page_background() const;
  private:
  bool _internal_has_page_background() const;
  public:
  void clear_page_background();
  const std::string& page_background() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_page_background(ArgT0&& arg0, ArgT... args);
  std::string* mutable_page_background();
  PROTOBUF_NODISCARD std::string* release_page_background();
  void set_allocated_page_background(std::string* page_background);
  private:
  const std::string& _internal_page_background() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_page_background(const std::string& value);
  std::string* _internal_mutable_page_background();
  public:

  // optional string hero_capsule = 7 [(.description) = "374x448"];
  bool has_hero_capsule() const;
  private:
  bool _internal_has_hero_capsule() const;
  public:
  void clear_hero_capsule();
  const std::string& hero_capsule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hero_capsule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hero_capsule();
  PROTOBUF_NODISCARD std::string* release_hero_capsule();
  void set_allocated_hero_capsule(std::string* hero_capsule);
  private:
  const std::string& _internal_hero_capsule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hero_capsule(const std::string& value);
  std::string* _internal_mutable_hero_capsule();
  public:

  // optional string hero_capsule_2x = 8 [(.description) = "748x896 version of hero capsule."];
  bool has_hero_capsule_2x() const;
  private:
  bool _internal_has_hero_capsule_2x() const;
  public:
  void clear_hero_capsule_2x();
  const std::string& hero_capsule_2x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hero_capsule_2x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hero_capsule_2x();
  PROTOBUF_NODISCARD std::string* release_hero_capsule_2x();
  void set_allocated_hero_capsule_2x(std::string* hero_capsule_2x);
  private:
  const std::string& _internal_hero_capsule_2x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hero_capsule_2x(const std::string& value);
  std::string* _internal_mutable_hero_capsule_2x();
  public:

  // optional string library_capsule = 9 [(.description) = "300x450 - tall library asset"];
  bool has_library_capsule() const;
  private:
  bool _internal_has_library_capsule() const;
  public:
  void clear_library_capsule();
  const std::string& library_capsule() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_library_capsule(ArgT0&& arg0, ArgT... args);
  std::string* mutable_library_capsule();
  PROTOBUF_NODISCARD std::string* release_library_capsule();
  void set_allocated_library_capsule(std::string* library_capsule);
  private:
  const std::string& _internal_library_capsule() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_capsule(const std::string& value);
  std::string* _internal_mutable_library_capsule();
  public:

  // optional string library_capsule_2x = 10 [(.description) = "600x900 - tall library asset"];
  bool has_library_capsule_2x() const;
  private:
  bool _internal_has_library_capsule_2x() const;
  public:
  void clear_library_capsule_2x();
  const std::string& library_capsule_2x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_library_capsule_2x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_library_capsule_2x();
  PROTOBUF_NODISCARD std::string* release_library_capsule_2x();
  void set_allocated_library_capsule_2x(std::string* library_capsule_2x);
  private:
  const std::string& _internal_library_capsule_2x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_capsule_2x(const std::string& value);
  std::string* _internal_mutable_library_capsule_2x();
  public:

  // optional string library_hero = 11 [(.description) = "960x310 or 1920x620 - library detail background asset"];
  bool has_library_hero() const;
  private:
  bool _internal_has_library_hero() const;
  public:
  void clear_library_hero();
  const std::string& library_hero() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_library_hero(ArgT0&& arg0, ArgT... args);
  std::string* mutable_library_hero();
  PROTOBUF_NODISCARD std::string* release_library_hero();
  void set_allocated_library_hero(std::string* library_hero);
  private:
  const std::string& _internal_library_hero() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_hero(const std::string& value);
  std::string* _internal_mutable_library_hero();
  public:

  // optional string library_hero_2x = 12 [(.description) = "1920x620 or 3840x1240 - library detail background asset"];
  bool has_library_hero_2x() const;
  private:
  bool _internal_has_library_hero_2x() const;
  public:
  void clear_library_hero_2x();
  const std::string& library_hero_2x() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_library_hero_2x(ArgT0&& arg0, ArgT... args);
  std::string* mutable_library_hero_2x();
  PROTOBUF_NODISCARD std::string* release_library_hero_2x();
  void set_allocated_library_hero_2x(std::string* library_hero_2x);
  private:
  const std::string& _internal_library_hero_2x() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_library_hero_2x(const std::string& value);
  std::string* _internal_mutable_library_hero_2x();
  public:

  // optional string community_icon = 13 [(.description) = "32x32 jpg uploading via steamworks under community assets"];
  bool has_community_icon() const;
  private:
  bool _internal_has_community_icon() const;
  public:
  void clear_community_icon();
  const std::string& community_icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_community_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_community_icon();
  PROTOBUF_NODISCARD std::string* release_community_icon();
  void set_allocated_community_icon(std::string* community_icon);
  private:
  const std::string& _internal_community_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_community_icon(const std::string& value);
  std::string* _internal_mutable_community_icon();
  public:

  // optional string clan_avatar = 14;
  bool has_clan_avatar() const;
  private:
  bool _internal_has_clan_avatar() const;
  public:
  void clear_clan_avatar();
  const std::string& clan_avatar() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clan_avatar(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clan_avatar();
  PROTOBUF_NODISCARD std::string* release_clan_avatar();
  void set_allocated_clan_avatar(std::string* clan_avatar);
  private:
  const std::string& _internal_clan_avatar() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clan_avatar(const std::string& value);
  std::string* _internal_mutable_clan_avatar();
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Assets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr asset_url_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr main_capsule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr small_capsule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr package_header_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr page_background_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hero_capsule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hero_capsule_2x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_capsule_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_capsule_2x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_hero_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr library_hero_2x_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr community_icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clan_avatar_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_ReleaseInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.ReleaseInfo) */ {
 public:
  inline StoreItem_ReleaseInfo() : StoreItem_ReleaseInfo(nullptr) {}
  ~StoreItem_ReleaseInfo() override;
  explicit constexpr StoreItem_ReleaseInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_ReleaseInfo(const StoreItem_ReleaseInfo& from);
  StoreItem_ReleaseInfo(StoreItem_ReleaseInfo&& from) noexcept
    : StoreItem_ReleaseInfo() {
    *this = ::std::move(from);
  }

  inline StoreItem_ReleaseInfo& operator=(const StoreItem_ReleaseInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_ReleaseInfo& operator=(StoreItem_ReleaseInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_ReleaseInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_ReleaseInfo* internal_default_instance() {
    return reinterpret_cast<const StoreItem_ReleaseInfo*>(
               &_StoreItem_ReleaseInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(StoreItem_ReleaseInfo& a, StoreItem_ReleaseInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_ReleaseInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_ReleaseInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_ReleaseInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_ReleaseInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_ReleaseInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_ReleaseInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_ReleaseInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.ReleaseInfo";
  }
  protected:
  explicit StoreItem_ReleaseInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCustomReleaseDateMessageFieldNumber = 6,
    kComingSoonDisplayFieldNumber = 8,
    kSteamReleaseDateFieldNumber = 1,
    kOriginalReleaseDateFieldNumber = 2,
    kOriginalSteamReleaseDateFieldNumber = 3,
    kIsComingSoonFieldNumber = 4,
    kIsPreloadFieldNumber = 5,
    kIsAbridgedReleaseDateFieldNumber = 7,
    kIsEarlyAccessFieldNumber = 10,
    kMacReleaseDateFieldNumber = 20,
    kLinuxReleaseDateFieldNumber = 21,
  };
  // optional string custom_release_date_message = 6 [(.description) = "Custom release date string.  steam_release_date will be unset if this is set."];
  bool has_custom_release_date_message() const;
  private:
  bool _internal_has_custom_release_date_message() const;
  public:
  void clear_custom_release_date_message();
  const std::string& custom_release_date_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_custom_release_date_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_custom_release_date_message();
  PROTOBUF_NODISCARD std::string* release_custom_release_date_message();
  void set_allocated_custom_release_date_message(std::string* custom_release_date_message);
  private:
  const std::string& _internal_custom_release_date_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_custom_release_date_message(const std::string& value);
  std::string* _internal_mutable_custom_release_date_message();
  public:

  // optional string coming_soon_display = 8 [(.description) = "One of \'date_full\', \'date_month\', \'date_quarter\', \'date_year\', \'text_comingsoon\', \'text_tba\'"];
  bool has_coming_soon_display() const;
  private:
  bool _internal_has_coming_soon_display() const;
  public:
  void clear_coming_soon_display();
  const std::string& coming_soon_display() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_coming_soon_display(ArgT0&& arg0, ArgT... args);
  std::string* mutable_coming_soon_display();
  PROTOBUF_NODISCARD std::string* release_coming_soon_display();
  void set_allocated_coming_soon_display(std::string* coming_soon_display);
  private:
  const std::string& _internal_coming_soon_display() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_coming_soon_display(const std::string& value);
  std::string* _internal_mutable_coming_soon_display();
  public:

  // optional uint32 steam_release_date = 1 [(.description) = "The date this item first released on the Steam store.  For Early Access graduates, this is their graduation day."];
  bool has_steam_release_date() const;
  private:
  bool _internal_has_steam_release_date() const;
  public:
  void clear_steam_release_date();
  uint32_t steam_release_date() const;
  void set_steam_release_date(uint32_t value);
  private:
  uint32_t _internal_steam_release_date() const;
  void _internal_set_steam_release_date(uint32_t value);
  public:

  // optional uint32 original_release_date = 2 [(.description) = "Optional; the date this item first released elsewhere, typically back catalog items."];
  bool has_original_release_date() const;
  private:
  bool _internal_has_original_release_date() const;
  public:
  void clear_original_release_date();
  uint32_t original_release_date() const;
  void set_original_release_date(uint32_t value);
  private:
  uint32_t _internal_original_release_date() const;
  void _internal_set_original_release_date(uint32_t value);
  public:

  // optional uint32 original_steam_release_date = 3 [(.description) = "For Early Access graduates, the date the game first appeared on Steam."];
  bool has_original_steam_release_date() const;
  private:
  bool _internal_has_original_steam_release_date() const;
  public:
  void clear_original_steam_release_date();
  uint32_t original_steam_release_date() const;
  void set_original_steam_release_date(uint32_t value);
  private:
  uint32_t _internal_original_steam_release_date() const;
  void _internal_set_original_steam_release_date(uint32_t value);
  public:

  // optional bool is_coming_soon = 4 [(.description) = "Is the app coming soon?  This flag should be preferred to doing time comparisons against steam_release_date."];
  bool has_is_coming_soon() const;
  private:
  bool _internal_has_is_coming_soon() const;
  public:
  void clear_is_coming_soon();
  bool is_coming_soon() const;
  void set_is_coming_soon(bool value);
  private:
  bool _internal_is_coming_soon() const;
  void _internal_set_is_coming_soon(bool value);
  public:

  // optional bool is_preload = 5 [(.description) = "Can the app be preloaded?  Only applies to Coming Soon titles."];
  bool has_is_preload() const;
  private:
  bool _internal_has_is_preload() const;
  public:
  void clear_is_preload();
  bool is_preload() const;
  void set_is_preload(bool value);
  private:
  bool _internal_is_preload() const;
  void _internal_set_is_preload(bool value);
  public:

  // optional bool is_abridged_release_date = 7 [(.description) = "Release date should be displayed as month-year only.  steam_release_date is the last day of the month."];
  bool has_is_abridged_release_date() const;
  private:
  bool _internal_has_is_abridged_release_date() const;
  public:
  void clear_is_abridged_release_date();
  bool is_abridged_release_date() const;
  void set_is_abridged_release_date(bool value);
  private:
  bool _internal_is_abridged_release_date() const;
  void _internal_set_is_abridged_release_date(bool value);
  public:

  // optional bool is_early_access = 10;
  bool has_is_early_access() const;
  private:
  bool _internal_has_is_early_access() const;
  public:
  void clear_is_early_access();
  bool is_early_access() const;
  void set_is_early_access(bool value);
  private:
  bool _internal_is_early_access() const;
  void _internal_set_is_early_access(bool value);
  public:

  // optional uint32 mac_release_date = 20;
  bool has_mac_release_date() const;
  private:
  bool _internal_has_mac_release_date() const;
  public:
  void clear_mac_release_date();
  uint32_t mac_release_date() const;
  void set_mac_release_date(uint32_t value);
  private:
  uint32_t _internal_mac_release_date() const;
  void _internal_set_mac_release_date(uint32_t value);
  public:

  // optional uint32 linux_release_date = 21;
  bool has_linux_release_date() const;
  private:
  bool _internal_has_linux_release_date() const;
  public:
  void clear_linux_release_date();
  uint32_t linux_release_date() const;
  void set_linux_release_date(uint32_t value);
  private:
  uint32_t _internal_linux_release_date() const;
  void _internal_set_linux_release_date(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.ReleaseInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr custom_release_date_message_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr coming_soon_display_;
  uint32_t steam_release_date_;
  uint32_t original_release_date_;
  uint32_t original_steam_release_date_;
  bool is_coming_soon_;
  bool is_preload_;
  bool is_abridged_release_date_;
  bool is_early_access_;
  uint32_t mac_release_date_;
  uint32_t linux_release_date_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Platforms_VRSupport final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Platforms.VRSupport) */ {
 public:
  inline StoreItem_Platforms_VRSupport() : StoreItem_Platforms_VRSupport(nullptr) {}
  ~StoreItem_Platforms_VRSupport() override;
  explicit constexpr StoreItem_Platforms_VRSupport(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Platforms_VRSupport(const StoreItem_Platforms_VRSupport& from);
  StoreItem_Platforms_VRSupport(StoreItem_Platforms_VRSupport&& from) noexcept
    : StoreItem_Platforms_VRSupport() {
    *this = ::std::move(from);
  }

  inline StoreItem_Platforms_VRSupport& operator=(const StoreItem_Platforms_VRSupport& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Platforms_VRSupport& operator=(StoreItem_Platforms_VRSupport&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Platforms_VRSupport& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Platforms_VRSupport* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Platforms_VRSupport*>(
               &_StoreItem_Platforms_VRSupport_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(StoreItem_Platforms_VRSupport& a, StoreItem_Platforms_VRSupport& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Platforms_VRSupport* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Platforms_VRSupport* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Platforms_VRSupport* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Platforms_VRSupport>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Platforms_VRSupport& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Platforms_VRSupport& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Platforms_VRSupport* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Platforms.VRSupport";
  }
  protected:
  explicit StoreItem_Platforms_VRSupport(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kVrhmdFieldNumber = 1,
    kVrhmdOnlyFieldNumber = 2,
    kHtcViveFieldNumber = 40,
    kOculusRiftFieldNumber = 41,
    kWindowsMrFieldNumber = 42,
    kValveIndexFieldNumber = 43,
  };
  // optional bool vrhmd = 1;
  bool has_vrhmd() const;
  private:
  bool _internal_has_vrhmd() const;
  public:
  void clear_vrhmd();
  bool vrhmd() const;
  void set_vrhmd(bool value);
  private:
  bool _internal_vrhmd() const;
  void _internal_set_vrhmd(bool value);
  public:

  // optional bool vrhmd_only = 2;
  bool has_vrhmd_only() const;
  private:
  bool _internal_has_vrhmd_only() const;
  public:
  void clear_vrhmd_only();
  bool vrhmd_only() const;
  void set_vrhmd_only(bool value);
  private:
  bool _internal_vrhmd_only() const;
  void _internal_set_vrhmd_only(bool value);
  public:

  // optional bool htc_vive = 40;
  bool has_htc_vive() const;
  private:
  bool _internal_has_htc_vive() const;
  public:
  void clear_htc_vive();
  bool htc_vive() const;
  void set_htc_vive(bool value);
  private:
  bool _internal_htc_vive() const;
  void _internal_set_htc_vive(bool value);
  public:

  // optional bool oculus_rift = 41;
  bool has_oculus_rift() const;
  private:
  bool _internal_has_oculus_rift() const;
  public:
  void clear_oculus_rift();
  bool oculus_rift() const;
  void set_oculus_rift(bool value);
  private:
  bool _internal_oculus_rift() const;
  void _internal_set_oculus_rift(bool value);
  public:

  // optional bool windows_mr = 42;
  bool has_windows_mr() const;
  private:
  bool _internal_has_windows_mr() const;
  public:
  void clear_windows_mr();
  bool windows_mr() const;
  void set_windows_mr(bool value);
  private:
  bool _internal_windows_mr() const;
  void _internal_set_windows_mr(bool value);
  public:

  // optional bool valve_index = 43;
  bool has_valve_index() const;
  private:
  bool _internal_has_valve_index() const;
  public:
  void clear_valve_index();
  bool valve_index() const;
  void set_valve_index(bool value);
  private:
  bool _internal_valve_index() const;
  void _internal_set_valve_index(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Platforms.VRSupport)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool vrhmd_;
  bool vrhmd_only_;
  bool htc_vive_;
  bool oculus_rift_;
  bool windows_mr_;
  bool valve_index_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Platforms final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Platforms) */ {
 public:
  inline StoreItem_Platforms() : StoreItem_Platforms(nullptr) {}
  ~StoreItem_Platforms() override;
  explicit constexpr StoreItem_Platforms(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Platforms(const StoreItem_Platforms& from);
  StoreItem_Platforms(StoreItem_Platforms&& from) noexcept
    : StoreItem_Platforms() {
    *this = ::std::move(from);
  }

  inline StoreItem_Platforms& operator=(const StoreItem_Platforms& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Platforms& operator=(StoreItem_Platforms&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Platforms& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Platforms* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Platforms*>(
               &_StoreItem_Platforms_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(StoreItem_Platforms& a, StoreItem_Platforms& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Platforms* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Platforms* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Platforms* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Platforms>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Platforms& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Platforms& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Platforms* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Platforms";
  }
  protected:
  explicit StoreItem_Platforms(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_Platforms_VRSupport VRSupport;

  // accessors -------------------------------------------------------

  enum : int {
    kVrSupportFieldNumber = 10,
    kWindowsFieldNumber = 1,
    kMacFieldNumber = 2,
    kSteamosLinuxFieldNumber = 3,
    kSteamDeckCompatCategoryFieldNumber = 11,
  };
  // optional .StoreItem.Platforms.VRSupport vr_support = 10;
  bool has_vr_support() const;
  private:
  bool _internal_has_vr_support() const;
  public:
  void clear_vr_support();
  const ::StoreItem_Platforms_VRSupport& vr_support() const;
  PROTOBUF_NODISCARD ::StoreItem_Platforms_VRSupport* release_vr_support();
  ::StoreItem_Platforms_VRSupport* mutable_vr_support();
  void set_allocated_vr_support(::StoreItem_Platforms_VRSupport* vr_support);
  private:
  const ::StoreItem_Platforms_VRSupport& _internal_vr_support() const;
  ::StoreItem_Platforms_VRSupport* _internal_mutable_vr_support();
  public:
  void unsafe_arena_set_allocated_vr_support(
      ::StoreItem_Platforms_VRSupport* vr_support);
  ::StoreItem_Platforms_VRSupport* unsafe_arena_release_vr_support();

  // optional bool windows = 1;
  bool has_windows() const;
  private:
  bool _internal_has_windows() const;
  public:
  void clear_windows();
  bool windows() const;
  void set_windows(bool value);
  private:
  bool _internal_windows() const;
  void _internal_set_windows(bool value);
  public:

  // optional bool mac = 2;
  bool has_mac() const;
  private:
  bool _internal_has_mac() const;
  public:
  void clear_mac();
  bool mac() const;
  void set_mac(bool value);
  private:
  bool _internal_mac() const;
  void _internal_set_mac(bool value);
  public:

  // optional bool steamos_linux = 3;
  bool has_steamos_linux() const;
  private:
  bool _internal_has_steamos_linux() const;
  public:
  void clear_steamos_linux();
  bool steamos_linux() const;
  void set_steamos_linux(bool value);
  private:
  bool _internal_steamos_linux() const;
  void _internal_set_steamos_linux(bool value);
  public:

  // optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11 [default = k_ESteamDeckCompatibilityCategory_Unknown];
  bool has_steam_deck_compat_category() const;
  private:
  bool _internal_has_steam_deck_compat_category() const;
  public:
  void clear_steam_deck_compat_category();
  ::ESteamDeckCompatibilityCategory steam_deck_compat_category() const;
  void set_steam_deck_compat_category(::ESteamDeckCompatibilityCategory value);
  private:
  ::ESteamDeckCompatibilityCategory _internal_steam_deck_compat_category() const;
  void _internal_set_steam_deck_compat_category(::ESteamDeckCompatibilityCategory value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Platforms)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::StoreItem_Platforms_VRSupport* vr_support_;
  bool windows_;
  bool mac_;
  bool steamos_linux_;
  int steam_deck_compat_category_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_PurchaseOption_Discount final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.PurchaseOption.Discount) */ {
 public:
  inline StoreItem_PurchaseOption_Discount() : StoreItem_PurchaseOption_Discount(nullptr) {}
  ~StoreItem_PurchaseOption_Discount() override;
  explicit constexpr StoreItem_PurchaseOption_Discount(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_PurchaseOption_Discount(const StoreItem_PurchaseOption_Discount& from);
  StoreItem_PurchaseOption_Discount(StoreItem_PurchaseOption_Discount&& from) noexcept
    : StoreItem_PurchaseOption_Discount() {
    *this = ::std::move(from);
  }

  inline StoreItem_PurchaseOption_Discount& operator=(const StoreItem_PurchaseOption_Discount& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_PurchaseOption_Discount& operator=(StoreItem_PurchaseOption_Discount&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_PurchaseOption_Discount& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_PurchaseOption_Discount* internal_default_instance() {
    return reinterpret_cast<const StoreItem_PurchaseOption_Discount*>(
               &_StoreItem_PurchaseOption_Discount_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(StoreItem_PurchaseOption_Discount& a, StoreItem_PurchaseOption_Discount& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_PurchaseOption_Discount* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_PurchaseOption_Discount* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_PurchaseOption_Discount* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_PurchaseOption_Discount>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_PurchaseOption_Discount& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_PurchaseOption_Discount& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_PurchaseOption_Discount* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.PurchaseOption.Discount";
  }
  protected:
  explicit StoreItem_PurchaseOption_Discount(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDiscountDescriptionFieldNumber = 2,
    kDiscountAmountFieldNumber = 1,
    kDiscountEndDateFieldNumber = 3,
  };
  // optional string discount_description = 2;
  bool has_discount_description() const;
  private:
  bool _internal_has_discount_description() const;
  public:
  void clear_discount_description();
  const std::string& discount_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_discount_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_discount_description();
  PROTOBUF_NODISCARD std::string* release_discount_description();
  void set_allocated_discount_description(std::string* discount_description);
  private:
  const std::string& _internal_discount_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_discount_description(const std::string& value);
  std::string* _internal_mutable_discount_description();
  public:

  // optional int64 discount_amount = 1;
  bool has_discount_amount() const;
  private:
  bool _internal_has_discount_amount() const;
  public:
  void clear_discount_amount();
  int64_t discount_amount() const;
  void set_discount_amount(int64_t value);
  private:
  int64_t _internal_discount_amount() const;
  void _internal_set_discount_amount(int64_t value);
  public:

  // optional uint32 discount_end_date = 3;
  bool has_discount_end_date() const;
  private:
  bool _internal_has_discount_end_date() const;
  public:
  void clear_discount_end_date();
  uint32_t discount_end_date() const;
  void set_discount_end_date(uint32_t value);
  private:
  uint32_t _internal_discount_end_date() const;
  void _internal_set_discount_end_date(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.PurchaseOption.Discount)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr discount_description_;
  int64_t discount_amount_;
  uint32_t discount_end_date_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_PurchaseOption final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.PurchaseOption) */ {
 public:
  inline StoreItem_PurchaseOption() : StoreItem_PurchaseOption(nullptr) {}
  ~StoreItem_PurchaseOption() override;
  explicit constexpr StoreItem_PurchaseOption(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_PurchaseOption(const StoreItem_PurchaseOption& from);
  StoreItem_PurchaseOption(StoreItem_PurchaseOption&& from) noexcept
    : StoreItem_PurchaseOption() {
    *this = ::std::move(from);
  }

  inline StoreItem_PurchaseOption& operator=(const StoreItem_PurchaseOption& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_PurchaseOption& operator=(StoreItem_PurchaseOption&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_PurchaseOption& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_PurchaseOption* internal_default_instance() {
    return reinterpret_cast<const StoreItem_PurchaseOption*>(
               &_StoreItem_PurchaseOption_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(StoreItem_PurchaseOption& a, StoreItem_PurchaseOption& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_PurchaseOption* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_PurchaseOption* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_PurchaseOption* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_PurchaseOption>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_PurchaseOption& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_PurchaseOption& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_PurchaseOption* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.PurchaseOption";
  }
  protected:
  explicit StoreItem_PurchaseOption(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_PurchaseOption_Discount Discount;

  // accessors -------------------------------------------------------

  enum : int {
    kActiveDiscountsFieldNumber = 20,
    kUserActiveDiscountsFieldNumber = 21,
    kInactiveDiscountsFieldNumber = 22,
    kPurchaseOptionNameFieldNumber = 3,
    kFormattedFinalPriceFieldNumber = 8,
    kFormattedOriginalPriceFieldNumber = 9,
    kPackageidFieldNumber = 1,
    kBundleidFieldNumber = 2,
    kFinalPriceInCentsFieldNumber = 5,
    kOriginalPriceInCentsFieldNumber = 6,
    kUserFinalPriceInCentsFieldNumber = 7,
    kDiscountPctFieldNumber = 10,
    kUserDiscountPctFieldNumber = 11,
    kBundleDiscountPctFieldNumber = 12,
    kUserCanPurchaseFieldNumber = 30,
    kUserCanPurchaseAsGiftFieldNumber = 31,
    kIsCommercialLicenseFieldNumber = 40,
    kShouldSuppressDiscountPctFieldNumber = 41,
    kHideDiscountPctForComplianceFieldNumber = 42,
    kIncludedGameCountFieldNumber = 43,
    kLowestRecentPriceInCentsFieldNumber = 44,
  };
  // repeated .StoreItem.PurchaseOption.Discount active_discounts = 20 [(.description) = "Discounts included in discounted_price_in_cents."];
  int active_discounts_size() const;
  private:
  int _internal_active_discounts_size() const;
  public:
  void clear_active_discounts();
  ::StoreItem_PurchaseOption_Discount* mutable_active_discounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
      mutable_active_discounts();
  private:
  const ::StoreItem_PurchaseOption_Discount& _internal_active_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* _internal_add_active_discounts();
  public:
  const ::StoreItem_PurchaseOption_Discount& active_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* add_active_discounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
      active_discounts() const;

  // repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21 [(.description) = "Additional discounts included in user_discounted_price_in_cents."];
  int user_active_discounts_size() const;
  private:
  int _internal_user_active_discounts_size() const;
  public:
  void clear_user_active_discounts();
  ::StoreItem_PurchaseOption_Discount* mutable_user_active_discounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
      mutable_user_active_discounts();
  private:
  const ::StoreItem_PurchaseOption_Discount& _internal_user_active_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* _internal_add_user_active_discounts();
  public:
  const ::StoreItem_PurchaseOption_Discount& user_active_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* add_user_active_discounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
      user_active_discounts() const;

  // repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22 [(.description) = "Additional user-specific discounts that do not apply to the current user."];
  int inactive_discounts_size() const;
  private:
  int _internal_inactive_discounts_size() const;
  public:
  void clear_inactive_discounts();
  ::StoreItem_PurchaseOption_Discount* mutable_inactive_discounts(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
      mutable_inactive_discounts();
  private:
  const ::StoreItem_PurchaseOption_Discount& _internal_inactive_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* _internal_add_inactive_discounts();
  public:
  const ::StoreItem_PurchaseOption_Discount& inactive_discounts(int index) const;
  ::StoreItem_PurchaseOption_Discount* add_inactive_discounts();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
      inactive_discounts() const;

  // optional string purchase_option_name = 3 [(.description) = "The name of the package or bundle"];
  bool has_purchase_option_name() const;
  private:
  bool _internal_has_purchase_option_name() const;
  public:
  void clear_purchase_option_name();
  const std::string& purchase_option_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_purchase_option_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_purchase_option_name();
  PROTOBUF_NODISCARD std::string* release_purchase_option_name();
  void set_allocated_purchase_option_name(std::string* purchase_option_name);
  private:
  const std::string& _internal_purchase_option_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_purchase_option_name(const std::string& value);
  std::string* _internal_mutable_purchase_option_name();
  public:

  // optional string formatted_final_price = 8 [(.description) = "Always set.  Formatted with currency symbol and decimal, like \'$10.00\'."];
  bool has_formatted_final_price() const;
  private:
  bool _internal_has_formatted_final_price() const;
  public:
  void clear_formatted_final_price();
  const std::string& formatted_final_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formatted_final_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formatted_final_price();
  PROTOBUF_NODISCARD std::string* release_formatted_final_price();
  void set_allocated_formatted_final_price(std::string* formatted_final_price);
  private:
  const std::string& _internal_formatted_final_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formatted_final_price(const std::string& value);
  std::string* _internal_mutable_formatted_final_price();
  public:

  // optional string formatted_original_price = 9;
  bool has_formatted_original_price() const;
  private:
  bool _internal_has_formatted_original_price() const;
  public:
  void clear_formatted_original_price();
  const std::string& formatted_original_price() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_formatted_original_price(ArgT0&& arg0, ArgT... args);
  std::string* mutable_formatted_original_price();
  PROTOBUF_NODISCARD std::string* release_formatted_original_price();
  void set_allocated_formatted_original_price(std::string* formatted_original_price);
  private:
  const std::string& _internal_formatted_original_price() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_formatted_original_price(const std::string& value);
  std::string* _internal_mutable_formatted_original_price();
  public:

  // optional int32 packageid = 1;
  bool has_packageid() const;
  private:
  bool _internal_has_packageid() const;
  public:
  void clear_packageid();
  int32_t packageid() const;
  void set_packageid(int32_t value);
  private:
  int32_t _internal_packageid() const;
  void _internal_set_packageid(int32_t value);
  public:

  // optional int32 bundleid = 2;
  bool has_bundleid() const;
  private:
  bool _internal_has_bundleid() const;
  public:
  void clear_bundleid();
  int32_t bundleid() const;
  void set_bundleid(int32_t value);
  private:
  int32_t _internal_bundleid() const;
  void _internal_set_bundleid(int32_t value);
  public:

  // optional int64 final_price_in_cents = 5 [(.description) = "Always set.  Includes any applicable non user-specific discounts."];
  bool has_final_price_in_cents() const;
  private:
  bool _internal_has_final_price_in_cents() const;
  public:
  void clear_final_price_in_cents();
  int64_t final_price_in_cents() const;
  void set_final_price_in_cents(int64_t value);
  private:
  int64_t _internal_final_price_in_cents() const;
  void _internal_set_final_price_in_cents(int64_t value);
  public:

  // optional int64 original_price_in_cents = 6 [(.description) = "If discounted, this is the price the item would normally cost."];
  bool has_original_price_in_cents() const;
  private:
  bool _internal_has_original_price_in_cents() const;
  public:
  void clear_original_price_in_cents();
  int64_t original_price_in_cents() const;
  void set_original_price_in_cents(int64_t value);
  private:
  int64_t _internal_original_price_in_cents() const;
  void _internal_set_original_price_in_cents(int64_t value);
  public:

  // optional int64 user_final_price_in_cents = 7;
  bool has_user_final_price_in_cents() const;
  private:
  bool _internal_has_user_final_price_in_cents() const;
  public:
  void clear_user_final_price_in_cents();
  int64_t user_final_price_in_cents() const;
  void set_user_final_price_in_cents(int64_t value);
  private:
  int64_t _internal_user_final_price_in_cents() const;
  void _internal_set_user_final_price_in_cents(int64_t value);
  public:

  // optional int32 discount_pct = 10 [(.description) = "If discounted, calculated from final price and original price."];
  bool has_discount_pct() const;
  private:
  bool _internal_has_discount_pct() const;
  public:
  void clear_discount_pct();
  int32_t discount_pct() const;
  void set_discount_pct(int32_t value);
  private:
  int32_t _internal_discount_pct() const;
  void _internal_set_discount_pct(int32_t value);
  public:

  // optional int32 user_discount_pct = 11;
  bool has_user_discount_pct() const;
  private:
  bool _internal_has_user_discount_pct() const;
  public:
  void clear_user_discount_pct();
  int32_t user_discount_pct() const;
  void set_user_discount_pct(int32_t value);
  private:
  int32_t _internal_user_discount_pct() const;
  void _internal_set_user_discount_pct(int32_t value);
  public:

  // optional int32 bundle_discount_pct = 12 [(.description) = "If this is a bundle, the savings from buying the bundle.  If no bundle items are on active discount, this will be the same as discount_pct."];
  bool has_bundle_discount_pct() const;
  private:
  bool _internal_has_bundle_discount_pct() const;
  public:
  void clear_bundle_discount_pct();
  int32_t bundle_discount_pct() const;
  void set_bundle_discount_pct(int32_t value);
  private:
  int32_t _internal_bundle_discount_pct() const;
  void _internal_set_bundle_discount_pct(int32_t value);
  public:

  // optional bool user_can_purchase = 30;
  bool has_user_can_purchase() const;
  private:
  bool _internal_has_user_can_purchase() const;
  public:
  void clear_user_can_purchase();
  bool user_can_purchase() const;
  void set_user_can_purchase(bool value);
  private:
  bool _internal_user_can_purchase() const;
  void _internal_set_user_can_purchase(bool value);
  public:

  // optional bool user_can_purchase_as_gift = 31;
  bool has_user_can_purchase_as_gift() const;
  private:
  bool _internal_has_user_can_purchase_as_gift() const;
  public:
  void clear_user_can_purchase_as_gift();
  bool user_can_purchase_as_gift() const;
  void set_user_can_purchase_as_gift(bool value);
  private:
  bool _internal_user_can_purchase_as_gift() const;
  void _internal_set_user_can_purchase_as_gift(bool value);
  public:

  // optional bool is_commercial_license = 40 [(.description) = "This is a commercial license"];
  bool has_is_commercial_license() const;
  private:
  bool _internal_has_is_commercial_license() const;
  public:
  void clear_is_commercial_license();
  bool is_commercial_license() const;
  void set_is_commercial_license(bool value);
  private:
  bool _internal_is_commercial_license() const;
  void _internal_set_is_commercial_license(bool value);
  public:

  // optional bool should_suppress_discount_pct = 41 [(.description) = "Don\'t show the discount percentage on a store capsule for this item."];
  bool has_should_suppress_discount_pct() const;
  private:
  bool _internal_has_should_suppress_discount_pct() const;
  public:
  void clear_should_suppress_discount_pct();
  bool should_suppress_discount_pct() const;
  void set_should_suppress_discount_pct(bool value);
  private:
  bool _internal_should_suppress_discount_pct() const;
  void _internal_set_should_suppress_discount_pct(bool value);
  public:

  // optional bool hide_discount_pct_for_compliance = 42 [default = false, (.description) = "Don\'t show the discount percent because there was a discount in the last 30 days."];
  bool has_hide_discount_pct_for_compliance() const;
  private:
  bool _internal_has_hide_discount_pct_for_compliance() const;
  public:
  void clear_hide_discount_pct_for_compliance();
  bool hide_discount_pct_for_compliance() const;
  void set_hide_discount_pct_for_compliance(bool value);
  private:
  bool _internal_hide_discount_pct_for_compliance() const;
  void _internal_set_hide_discount_pct_for_compliance(bool value);
  public:

  // optional int32 included_game_count = 43 [(.description) = "How many games are included in this purchase option."];
  bool has_included_game_count() const;
  private:
  bool _internal_has_included_game_count() const;
  public:
  void clear_included_game_count();
  int32_t included_game_count() const;
  void set_included_game_count(int32_t value);
  private:
  int32_t _internal_included_game_count() const;
  void _internal_set_included_game_count(int32_t value);
  public:

  // optional int64 lowest_recent_price_in_cents = 44 [(.description) = "Lowest recent price in cents.  If not set, then there is no data so we ignore."];
  bool has_lowest_recent_price_in_cents() const;
  private:
  bool _internal_has_lowest_recent_price_in_cents() const;
  public:
  void clear_lowest_recent_price_in_cents();
  int64_t lowest_recent_price_in_cents() const;
  void set_lowest_recent_price_in_cents(int64_t value);
  private:
  int64_t _internal_lowest_recent_price_in_cents() const;
  void _internal_set_lowest_recent_price_in_cents(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.PurchaseOption)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount > active_discounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount > user_active_discounts_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount > inactive_discounts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr purchase_option_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formatted_final_price_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr formatted_original_price_;
  int32_t packageid_;
  int32_t bundleid_;
  int64_t final_price_in_cents_;
  int64_t original_price_in_cents_;
  int64_t user_final_price_in_cents_;
  int32_t discount_pct_;
  int32_t user_discount_pct_;
  int32_t bundle_discount_pct_;
  bool user_can_purchase_;
  bool user_can_purchase_as_gift_;
  bool is_commercial_license_;
  bool should_suppress_discount_pct_;
  bool hide_discount_pct_for_compliance_;
  int32_t included_game_count_;
  int64_t lowest_recent_price_in_cents_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Screenshots_Screenshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Screenshots.Screenshot) */ {
 public:
  inline StoreItem_Screenshots_Screenshot() : StoreItem_Screenshots_Screenshot(nullptr) {}
  ~StoreItem_Screenshots_Screenshot() override;
  explicit constexpr StoreItem_Screenshots_Screenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Screenshots_Screenshot(const StoreItem_Screenshots_Screenshot& from);
  StoreItem_Screenshots_Screenshot(StoreItem_Screenshots_Screenshot&& from) noexcept
    : StoreItem_Screenshots_Screenshot() {
    *this = ::std::move(from);
  }

  inline StoreItem_Screenshots_Screenshot& operator=(const StoreItem_Screenshots_Screenshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Screenshots_Screenshot& operator=(StoreItem_Screenshots_Screenshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Screenshots_Screenshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Screenshots_Screenshot* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Screenshots_Screenshot*>(
               &_StoreItem_Screenshots_Screenshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(StoreItem_Screenshots_Screenshot& a, StoreItem_Screenshots_Screenshot& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Screenshots_Screenshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Screenshots_Screenshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Screenshots_Screenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Screenshots_Screenshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Screenshots_Screenshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Screenshots_Screenshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Screenshots_Screenshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Screenshots.Screenshot";
  }
  protected:
  explicit StoreItem_Screenshots_Screenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kOrdinalFieldNumber = 2,
  };
  // optional string filename = 1 [(.description) = "Path to file on media CDN.  Can access sized version by appending to SHA: \'.1920x1080\', \'.600x338\', \'.116x65\'"];
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional int32 ordinal = 2 [(.description) = "Screenshots should be displayed in order of ascending ordinal; they are returned in-order but client may need to merge all_ages and mature_content_screenshots."];
  bool has_ordinal() const;
  private:
  bool _internal_has_ordinal() const;
  public:
  void clear_ordinal();
  int32_t ordinal() const;
  void set_ordinal(int32_t value);
  private:
  int32_t _internal_ordinal() const;
  void _internal_set_ordinal(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Screenshots.Screenshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  int32_t ordinal_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Screenshots final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Screenshots) */ {
 public:
  inline StoreItem_Screenshots() : StoreItem_Screenshots(nullptr) {}
  ~StoreItem_Screenshots() override;
  explicit constexpr StoreItem_Screenshots(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Screenshots(const StoreItem_Screenshots& from);
  StoreItem_Screenshots(StoreItem_Screenshots&& from) noexcept
    : StoreItem_Screenshots() {
    *this = ::std::move(from);
  }

  inline StoreItem_Screenshots& operator=(const StoreItem_Screenshots& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Screenshots& operator=(StoreItem_Screenshots&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Screenshots& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Screenshots* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Screenshots*>(
               &_StoreItem_Screenshots_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(StoreItem_Screenshots& a, StoreItem_Screenshots& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Screenshots* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Screenshots* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Screenshots* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Screenshots>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Screenshots& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Screenshots& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Screenshots* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Screenshots";
  }
  protected:
  explicit StoreItem_Screenshots(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_Screenshots_Screenshot Screenshot;

  // accessors -------------------------------------------------------

  enum : int {
    kAllAgesScreenshotsFieldNumber = 2,
    kMatureContentScreenshotsFieldNumber = 3,
  };
  // repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2 [(.description) = "Screenshots suitable for all ages."];
  int all_ages_screenshots_size() const;
  private:
  int _internal_all_ages_screenshots_size() const;
  public:
  void clear_all_ages_screenshots();
  ::StoreItem_Screenshots_Screenshot* mutable_all_ages_screenshots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >*
      mutable_all_ages_screenshots();
  private:
  const ::StoreItem_Screenshots_Screenshot& _internal_all_ages_screenshots(int index) const;
  ::StoreItem_Screenshots_Screenshot* _internal_add_all_ages_screenshots();
  public:
  const ::StoreItem_Screenshots_Screenshot& all_ages_screenshots(int index) const;
  ::StoreItem_Screenshots_Screenshot* add_all_ages_screenshots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >&
      all_ages_screenshots() const;

  // repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3 [(.description) = "Screenshots that may contain mature content; these should only be shown after verifying age (age gate)."];
  int mature_content_screenshots_size() const;
  private:
  int _internal_mature_content_screenshots_size() const;
  public:
  void clear_mature_content_screenshots();
  ::StoreItem_Screenshots_Screenshot* mutable_mature_content_screenshots(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >*
      mutable_mature_content_screenshots();
  private:
  const ::StoreItem_Screenshots_Screenshot& _internal_mature_content_screenshots(int index) const;
  ::StoreItem_Screenshots_Screenshot* _internal_add_mature_content_screenshots();
  public:
  const ::StoreItem_Screenshots_Screenshot& mature_content_screenshots(int index) const;
  ::StoreItem_Screenshots_Screenshot* add_mature_content_screenshots();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >&
      mature_content_screenshots() const;

  // @@protoc_insertion_point(class_scope:StoreItem.Screenshots)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot > all_ages_screenshots_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot > mature_content_screenshots_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Trailers_VideoSource final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Trailers.VideoSource) */ {
 public:
  inline StoreItem_Trailers_VideoSource() : StoreItem_Trailers_VideoSource(nullptr) {}
  ~StoreItem_Trailers_VideoSource() override;
  explicit constexpr StoreItem_Trailers_VideoSource(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Trailers_VideoSource(const StoreItem_Trailers_VideoSource& from);
  StoreItem_Trailers_VideoSource(StoreItem_Trailers_VideoSource&& from) noexcept
    : StoreItem_Trailers_VideoSource() {
    *this = ::std::move(from);
  }

  inline StoreItem_Trailers_VideoSource& operator=(const StoreItem_Trailers_VideoSource& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Trailers_VideoSource& operator=(StoreItem_Trailers_VideoSource&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Trailers_VideoSource& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Trailers_VideoSource* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Trailers_VideoSource*>(
               &_StoreItem_Trailers_VideoSource_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(StoreItem_Trailers_VideoSource& a, StoreItem_Trailers_VideoSource& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Trailers_VideoSource* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Trailers_VideoSource* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Trailers_VideoSource* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Trailers_VideoSource>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Trailers_VideoSource& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Trailers_VideoSource& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Trailers_VideoSource* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Trailers.VideoSource";
  }
  protected:
  explicit StoreItem_Trailers_VideoSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilenameFieldNumber = 1,
    kTypeFieldNumber = 2,
  };
  // optional string filename = 1 [(.description) = "Substitute into trailer_url_format"];
  bool has_filename() const;
  private:
  bool _internal_has_filename() const;
  public:
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // optional string type = 2 [(.description) = "\'video/webm\' or \'video/mp4\'; can just put this directly in to a <source> tag."];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_NODISCARD std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Trailers.VideoSource)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Trailers_Trailer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Trailers.Trailer) */ {
 public:
  inline StoreItem_Trailers_Trailer() : StoreItem_Trailers_Trailer(nullptr) {}
  ~StoreItem_Trailers_Trailer() override;
  explicit constexpr StoreItem_Trailers_Trailer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Trailers_Trailer(const StoreItem_Trailers_Trailer& from);
  StoreItem_Trailers_Trailer(StoreItem_Trailers_Trailer&& from) noexcept
    : StoreItem_Trailers_Trailer() {
    *this = ::std::move(from);
  }

  inline StoreItem_Trailers_Trailer& operator=(const StoreItem_Trailers_Trailer& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Trailers_Trailer& operator=(StoreItem_Trailers_Trailer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Trailers_Trailer& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Trailers_Trailer* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Trailers_Trailer*>(
               &_StoreItem_Trailers_Trailer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(StoreItem_Trailers_Trailer& a, StoreItem_Trailers_Trailer& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Trailers_Trailer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Trailers_Trailer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Trailers_Trailer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Trailers_Trailer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Trailers_Trailer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Trailers_Trailer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Trailers_Trailer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Trailers.Trailer";
  }
  protected:
  explicit StoreItem_Trailers_Trailer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTrailer480PFieldNumber = 3,
    kTrailerMaxFieldNumber = 4,
    kMicrotrailerFieldNumber = 5,
    kTrailerNameFieldNumber = 1,
    kTrailerUrlFormatFieldNumber = 2,
    kScreenshotMediumFieldNumber = 10,
    kScreenshotFullFieldNumber = 11,
    kTrailerBaseIdFieldNumber = 12,
  };
  // repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;
  int trailer_480p_size() const;
  private:
  int _internal_trailer_480p_size() const;
  public:
  void clear_trailer_480p();
  ::StoreItem_Trailers_VideoSource* mutable_trailer_480p(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
      mutable_trailer_480p();
  private:
  const ::StoreItem_Trailers_VideoSource& _internal_trailer_480p(int index) const;
  ::StoreItem_Trailers_VideoSource* _internal_add_trailer_480p();
  public:
  const ::StoreItem_Trailers_VideoSource& trailer_480p(int index) const;
  ::StoreItem_Trailers_VideoSource* add_trailer_480p();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
      trailer_480p() const;

  // repeated .StoreItem.Trailers.VideoSource trailer_max = 4;
  int trailer_max_size() const;
  private:
  int _internal_trailer_max_size() const;
  public:
  void clear_trailer_max();
  ::StoreItem_Trailers_VideoSource* mutable_trailer_max(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
      mutable_trailer_max();
  private:
  const ::StoreItem_Trailers_VideoSource& _internal_trailer_max(int index) const;
  ::StoreItem_Trailers_VideoSource* _internal_add_trailer_max();
  public:
  const ::StoreItem_Trailers_VideoSource& trailer_max(int index) const;
  ::StoreItem_Trailers_VideoSource* add_trailer_max();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
      trailer_max() const;

  // repeated .StoreItem.Trailers.VideoSource microtrailer = 5;
  int microtrailer_size() const;
  private:
  int _internal_microtrailer_size() const;
  public:
  void clear_microtrailer();
  ::StoreItem_Trailers_VideoSource* mutable_microtrailer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
      mutable_microtrailer();
  private:
  const ::StoreItem_Trailers_VideoSource& _internal_microtrailer(int index) const;
  ::StoreItem_Trailers_VideoSource* _internal_add_microtrailer();
  public:
  const ::StoreItem_Trailers_VideoSource& microtrailer(int index) const;
  ::StoreItem_Trailers_VideoSource* add_microtrailer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
      microtrailer() const;

  // optional string trailer_name = 1;
  bool has_trailer_name() const;
  private:
  bool _internal_has_trailer_name() const;
  public:
  void clear_trailer_name();
  const std::string& trailer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trailer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trailer_name();
  PROTOBUF_NODISCARD std::string* release_trailer_name();
  void set_allocated_trailer_name(std::string* trailer_name);
  private:
  const std::string& _internal_trailer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trailer_name(const std::string& value);
  std::string* _internal_mutable_trailer_name();
  public:

  // optional string trailer_url_format = 2 [(.description) = "Format for URLs, should substitute filename for ${FILENAME} in the URL."];
  bool has_trailer_url_format() const;
  private:
  bool _internal_has_trailer_url_format() const;
  public:
  void clear_trailer_url_format();
  const std::string& trailer_url_format() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_trailer_url_format(ArgT0&& arg0, ArgT... args);
  std::string* mutable_trailer_url_format();
  PROTOBUF_NODISCARD std::string* release_trailer_url_format();
  void set_allocated_trailer_url_format(std::string* trailer_url_format);
  private:
  const std::string& _internal_trailer_url_format() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_trailer_url_format(const std::string& value);
  std::string* _internal_mutable_trailer_url_format();
  public:

  // optional string screenshot_medium = 10 [(.description) = "293x165px.  Use trailer_url_format."];
  bool has_screenshot_medium() const;
  private:
  bool _internal_has_screenshot_medium() const;
  public:
  void clear_screenshot_medium();
  const std::string& screenshot_medium() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenshot_medium(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenshot_medium();
  PROTOBUF_NODISCARD std::string* release_screenshot_medium();
  void set_allocated_screenshot_medium(std::string* screenshot_medium);
  private:
  const std::string& _internal_screenshot_medium() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenshot_medium(const std::string& value);
  std::string* _internal_mutable_screenshot_medium();
  public:

  // optional string screenshot_full = 11 [(.description) = "Same size as trailer_max.  Use trailer_url_format."];
  bool has_screenshot_full() const;
  private:
  bool _internal_has_screenshot_full() const;
  public:
  void clear_screenshot_full();
  const std::string& screenshot_full() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenshot_full(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenshot_full();
  PROTOBUF_NODISCARD std::string* release_screenshot_full();
  void set_allocated_screenshot_full(std::string* screenshot_full);
  private:
  const std::string& _internal_screenshot_full() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenshot_full(const std::string& value);
  std::string* _internal_mutable_screenshot_full();
  public:

  // optional int32 trailer_base_id = 12 [(.description) = "Trailer ID.  For localized trailers, this will be the original trailer\'s ID"];
  bool has_trailer_base_id() const;
  private:
  bool _internal_has_trailer_base_id() const;
  public:
  void clear_trailer_base_id();
  int32_t trailer_base_id() const;
  void set_trailer_base_id(int32_t value);
  private:
  int32_t _internal_trailer_base_id() const;
  void _internal_set_trailer_base_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.Trailers.Trailer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource > trailer_480p_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource > trailer_max_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource > microtrailer_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trailer_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trailer_url_format_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenshot_medium_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenshot_full_;
  int32_t trailer_base_id_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_Trailers final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.Trailers) */ {
 public:
  inline StoreItem_Trailers() : StoreItem_Trailers(nullptr) {}
  ~StoreItem_Trailers() override;
  explicit constexpr StoreItem_Trailers(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_Trailers(const StoreItem_Trailers& from);
  StoreItem_Trailers(StoreItem_Trailers&& from) noexcept
    : StoreItem_Trailers() {
    *this = ::std::move(from);
  }

  inline StoreItem_Trailers& operator=(const StoreItem_Trailers& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_Trailers& operator=(StoreItem_Trailers&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_Trailers& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_Trailers* internal_default_instance() {
    return reinterpret_cast<const StoreItem_Trailers*>(
               &_StoreItem_Trailers_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(StoreItem_Trailers& a, StoreItem_Trailers& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_Trailers* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_Trailers* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_Trailers* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_Trailers>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_Trailers& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_Trailers& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_Trailers* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.Trailers";
  }
  protected:
  explicit StoreItem_Trailers(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_Trailers_VideoSource VideoSource;
  typedef StoreItem_Trailers_Trailer Trailer;

  // accessors -------------------------------------------------------

  enum : int {
    kHighlightsFieldNumber = 1,
    kOtherTrailersFieldNumber = 2,
  };
  // repeated .StoreItem.Trailers.Trailer highlights = 1 [(.description) = "Primary trailers for this app"];
  int highlights_size() const;
  private:
  int _internal_highlights_size() const;
  public:
  void clear_highlights();
  ::StoreItem_Trailers_Trailer* mutable_highlights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >*
      mutable_highlights();
  private:
  const ::StoreItem_Trailers_Trailer& _internal_highlights(int index) const;
  ::StoreItem_Trailers_Trailer* _internal_add_highlights();
  public:
  const ::StoreItem_Trailers_Trailer& highlights(int index) const;
  ::StoreItem_Trailers_Trailer* add_highlights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >&
      highlights() const;

  // repeated .StoreItem.Trailers.Trailer other_trailers = 2 [(.description) = "Additional trailers; on the app page, these are shown after screenshots (highlights shown before)"];
  int other_trailers_size() const;
  private:
  int _internal_other_trailers_size() const;
  public:
  void clear_other_trailers();
  ::StoreItem_Trailers_Trailer* mutable_other_trailers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >*
      mutable_other_trailers();
  private:
  const ::StoreItem_Trailers_Trailer& _internal_other_trailers(int index) const;
  ::StoreItem_Trailers_Trailer* _internal_add_other_trailers();
  public:
  const ::StoreItem_Trailers_Trailer& other_trailers(int index) const;
  ::StoreItem_Trailers_Trailer* add_other_trailers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >&
      other_trailers() const;

  // @@protoc_insertion_point(class_scope:StoreItem.Trailers)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer > highlights_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer > other_trailers_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_SupportedLanguage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.SupportedLanguage) */ {
 public:
  inline StoreItem_SupportedLanguage() : StoreItem_SupportedLanguage(nullptr) {}
  ~StoreItem_SupportedLanguage() override;
  explicit constexpr StoreItem_SupportedLanguage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_SupportedLanguage(const StoreItem_SupportedLanguage& from);
  StoreItem_SupportedLanguage(StoreItem_SupportedLanguage&& from) noexcept
    : StoreItem_SupportedLanguage() {
    *this = ::std::move(from);
  }

  inline StoreItem_SupportedLanguage& operator=(const StoreItem_SupportedLanguage& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_SupportedLanguage& operator=(StoreItem_SupportedLanguage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_SupportedLanguage& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_SupportedLanguage* internal_default_instance() {
    return reinterpret_cast<const StoreItem_SupportedLanguage*>(
               &_StoreItem_SupportedLanguage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(StoreItem_SupportedLanguage& a, StoreItem_SupportedLanguage& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_SupportedLanguage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_SupportedLanguage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_SupportedLanguage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_SupportedLanguage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_SupportedLanguage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_SupportedLanguage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_SupportedLanguage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.SupportedLanguage";
  }
  protected:
  explicit StoreItem_SupportedLanguage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElanguageFieldNumber = 1,
    kSupportedFieldNumber = 2,
    kFullAudioFieldNumber = 3,
    kSubtitlesFieldNumber = 4,
  };
  // optional int32 elanguage = 1 [(.description) = "ELanguage"];
  bool has_elanguage() const;
  private:
  bool _internal_has_elanguage() const;
  public:
  void clear_elanguage();
  int32_t elanguage() const;
  void set_elanguage(int32_t value);
  private:
  int32_t _internal_elanguage() const;
  void _internal_set_elanguage(int32_t value);
  public:

  // optional bool supported = 2;
  bool has_supported() const;
  private:
  bool _internal_has_supported() const;
  public:
  void clear_supported();
  bool supported() const;
  void set_supported(bool value);
  private:
  bool _internal_supported() const;
  void _internal_set_supported(bool value);
  public:

  // optional bool full_audio = 3;
  bool has_full_audio() const;
  private:
  bool _internal_has_full_audio() const;
  public:
  void clear_full_audio();
  bool full_audio() const;
  void set_full_audio(bool value);
  private:
  bool _internal_full_audio() const;
  void _internal_set_full_audio(bool value);
  public:

  // optional bool subtitles = 4;
  bool has_subtitles() const;
  private:
  bool _internal_has_subtitles() const;
  public:
  void clear_subtitles();
  bool subtitles() const;
  void set_subtitles(bool value);
  private:
  bool _internal_subtitles() const;
  void _internal_set_subtitles(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.SupportedLanguage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t elanguage_;
  bool supported_;
  bool full_audio_;
  bool subtitles_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem_FreeWeekend final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem.FreeWeekend) */ {
 public:
  inline StoreItem_FreeWeekend() : StoreItem_FreeWeekend(nullptr) {}
  ~StoreItem_FreeWeekend() override;
  explicit constexpr StoreItem_FreeWeekend(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem_FreeWeekend(const StoreItem_FreeWeekend& from);
  StoreItem_FreeWeekend(StoreItem_FreeWeekend&& from) noexcept
    : StoreItem_FreeWeekend() {
    *this = ::std::move(from);
  }

  inline StoreItem_FreeWeekend& operator=(const StoreItem_FreeWeekend& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem_FreeWeekend& operator=(StoreItem_FreeWeekend&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem_FreeWeekend& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem_FreeWeekend* internal_default_instance() {
    return reinterpret_cast<const StoreItem_FreeWeekend*>(
               &_StoreItem_FreeWeekend_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(StoreItem_FreeWeekend& a, StoreItem_FreeWeekend& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem_FreeWeekend* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem_FreeWeekend* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem_FreeWeekend* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem_FreeWeekend>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem_FreeWeekend& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem_FreeWeekend& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem_FreeWeekend* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem.FreeWeekend";
  }
  protected:
  explicit StoreItem_FreeWeekend(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 3,
    kStartTimeFieldNumber = 1,
    kEndTimeFieldNumber = 2,
  };
  // optional string text = 3 [(.description) = "Text to show as a description of the free weekend."];
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // optional uint32 start_time = 1 [(.description) = "When the free weekend starts."];
  bool has_start_time() const;
  private:
  bool _internal_has_start_time() const;
  public:
  void clear_start_time();
  uint32_t start_time() const;
  void set_start_time(uint32_t value);
  private:
  uint32_t _internal_start_time() const;
  void _internal_set_start_time(uint32_t value);
  public:

  // optional uint32 end_time = 2 [(.description) = "When the free weekend ends."];
  bool has_end_time() const;
  private:
  bool _internal_has_end_time() const;
  public:
  void clear_end_time();
  uint32_t end_time() const;
  void set_end_time(uint32_t value);
  private:
  uint32_t _internal_end_time() const;
  void _internal_set_end_time(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem.FreeWeekend)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  uint32_t start_time_;
  uint32_t end_time_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class StoreItem final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StoreItem) */ {
 public:
  inline StoreItem() : StoreItem(nullptr) {}
  ~StoreItem() override;
  explicit constexpr StoreItem(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StoreItem(const StoreItem& from);
  StoreItem(StoreItem&& from) noexcept
    : StoreItem() {
    *this = ::std::move(from);
  }

  inline StoreItem& operator=(const StoreItem& from) {
    CopyFrom(from);
    return *this;
  }
  inline StoreItem& operator=(StoreItem&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StoreItem& default_instance() {
    return *internal_default_instance();
  }
  static inline const StoreItem* internal_default_instance() {
    return reinterpret_cast<const StoreItem*>(
               &_StoreItem_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(StoreItem& a, StoreItem& b) {
    a.Swap(&b);
  }
  inline void Swap(StoreItem* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StoreItem* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StoreItem* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StoreItem>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StoreItem& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StoreItem& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StoreItem* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StoreItem";
  }
  protected:
  explicit StoreItem(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef StoreItem_RelatedItems RelatedItems;
  typedef StoreItem_Categories Categories;
  typedef StoreItem_Reviews Reviews;
  typedef StoreItem_BasicInfo BasicInfo;
  typedef StoreItem_Tag Tag;
  typedef StoreItem_Assets Assets;
  typedef StoreItem_ReleaseInfo ReleaseInfo;
  typedef StoreItem_Platforms Platforms;
  typedef StoreItem_PurchaseOption PurchaseOption;
  typedef StoreItem_Screenshots Screenshots;
  typedef StoreItem_Trailers Trailers;
  typedef StoreItem_SupportedLanguage SupportedLanguage;
  typedef StoreItem_FreeWeekend FreeWeekend;

  // accessors -------------------------------------------------------

  enum : int {
    kIncludedTypesFieldNumber = 11,
    kIncludedAppidsFieldNumber = 12,
    kContentDescriptoridsFieldNumber = 20,
    kTagidsFieldNumber = 21,
    kTagsFieldNumber = 25,
    kPurchaseOptionsFieldNumber = 41,
    kAccessoriesFieldNumber = 42,
    kSupportedLanguagesFieldNumber = 52,
    kNameFieldNumber = 6,
    kStoreUrlPathFieldNumber = 7,
    kStoreUrlPathOverrideFieldNumber = 53,
    kInternalNameFieldNumber = 57,
    kFullDescriptionFieldNumber = 58,
    kRelatedItemsFieldNumber = 15,
    kCategoriesFieldNumber = 22,
    kReviewsFieldNumber = 23,
    kBasicInfoFieldNumber = 24,
    kAssetsFieldNumber = 30,
    kReleaseFieldNumber = 31,
    kPlatformsFieldNumber = 32,
    kGameRatingFieldNumber = 33,
    kBestPurchaseOptionFieldNumber = 40,
    kScreenshotsFieldNumber = 50,
    kTrailersFieldNumber = 51,
    kFreeWeekendFieldNumber = 54,
    kIdFieldNumber = 2,
    kSuccessFieldNumber = 3,
    kAppidFieldNumber = 9,
    kVisibleFieldNumber = 4,
    kUnvailableForCountryRestrictionFieldNumber = 5,
    kIsFreeFieldNumber = 13,
    kIsEarlyAccessFieldNumber = 14,
    kTypeFieldNumber = 10,
    kUnlistedFieldNumber = 55,
    kGameCountFieldNumber = 56,
    kItemTypeFieldNumber = 1,
  };
  // repeated .EStoreAppType included_types = 11 [(.description) = "For packages/bundles, all types of included items"];
  int included_types_size() const;
  private:
  int _internal_included_types_size() const;
  public:
  void clear_included_types();
  private:
  ::EStoreAppType _internal_included_types(int index) const;
  void _internal_add_included_types(::EStoreAppType value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_included_types();
  public:
  ::EStoreAppType included_types(int index) const;
  void set_included_types(int index, ::EStoreAppType value);
  void add_included_types(::EStoreAppType value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& included_types() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_included_types();

  // repeated uint32 included_appids = 12 [(.description) = "For packages/bundles, all included appids"];
  int included_appids_size() const;
  private:
  int _internal_included_appids_size() const;
  public:
  void clear_included_appids();
  private:
  uint32_t _internal_included_appids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_included_appids() const;
  void _internal_add_included_appids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_included_appids();
  public:
  uint32_t included_appids(int index) const;
  void set_included_appids(int index, uint32_t value);
  void add_included_appids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      included_appids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_included_appids();

  // repeated .EContentDescriptorID content_descriptorids = 20;
  int content_descriptorids_size() const;
  private:
  int _internal_content_descriptorids_size() const;
  public:
  void clear_content_descriptorids();
  private:
  ::EContentDescriptorID _internal_content_descriptorids(int index) const;
  void _internal_add_content_descriptorids(::EContentDescriptorID value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_content_descriptorids();
  public:
  ::EContentDescriptorID content_descriptorids(int index) const;
  void set_content_descriptorids(int index, ::EContentDescriptorID value);
  void add_content_descriptorids(::EContentDescriptorID value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& content_descriptorids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_content_descriptorids();

  // repeated uint32 tagids = 21;
  int tagids_size() const;
  private:
  int _internal_tagids_size() const;
  public:
  void clear_tagids();
  private:
  uint32_t _internal_tagids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_tagids() const;
  void _internal_add_tagids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_tagids();
  public:
  uint32_t tagids(int index) const;
  void set_tagids(int index, uint32_t value);
  void add_tagids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      tagids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_tagids();

  // repeated .StoreItem.Tag tags = 25;
  int tags_size() const;
  private:
  int _internal_tags_size() const;
  public:
  void clear_tags();
  ::StoreItem_Tag* mutable_tags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Tag >*
      mutable_tags();
  private:
  const ::StoreItem_Tag& _internal_tags(int index) const;
  ::StoreItem_Tag* _internal_add_tags();
  public:
  const ::StoreItem_Tag& tags(int index) const;
  ::StoreItem_Tag* add_tags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Tag >&
      tags() const;

  // repeated .StoreItem.PurchaseOption purchase_options = 41 [(.description) = "Different ways to buy this app or packages (packages can be purchased directly, but may also be included in bundles)."];
  int purchase_options_size() const;
  private:
  int _internal_purchase_options_size() const;
  public:
  void clear_purchase_options();
  ::StoreItem_PurchaseOption* mutable_purchase_options(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >*
      mutable_purchase_options();
  private:
  const ::StoreItem_PurchaseOption& _internal_purchase_options(int index) const;
  ::StoreItem_PurchaseOption* _internal_add_purchase_options();
  public:
  const ::StoreItem_PurchaseOption& purchase_options(int index) const;
  ::StoreItem_PurchaseOption* add_purchase_options();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >&
      purchase_options() const;

  // repeated .StoreItem.PurchaseOption accessories = 42 [(.description) = "Additional packages or bundles associated with an app, but that do not contain the app."];
  int accessories_size() const;
  private:
  int _internal_accessories_size() const;
  public:
  void clear_accessories();
  ::StoreItem_PurchaseOption* mutable_accessories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >*
      mutable_accessories();
  private:
  const ::StoreItem_PurchaseOption& _internal_accessories(int index) const;
  ::StoreItem_PurchaseOption* _internal_add_accessories();
  public:
  const ::StoreItem_PurchaseOption& accessories(int index) const;
  ::StoreItem_PurchaseOption* add_accessories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >&
      accessories() const;

  // repeated .StoreItem.SupportedLanguage supported_languages = 52;
  int supported_languages_size() const;
  private:
  int _internal_supported_languages_size() const;
  public:
  void clear_supported_languages();
  ::StoreItem_SupportedLanguage* mutable_supported_languages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_SupportedLanguage >*
      mutable_supported_languages();
  private:
  const ::StoreItem_SupportedLanguage& _internal_supported_languages(int index) const;
  ::StoreItem_SupportedLanguage* _internal_add_supported_languages();
  public:
  const ::StoreItem_SupportedLanguage& supported_languages(int index) const;
  ::StoreItem_SupportedLanguage* add_supported_languages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_SupportedLanguage >&
      supported_languages() const;

  // optional string name = 6;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string store_url_path = 7 [(.description) = "The URL of this item\'s store page, to be appended to STORE_BASE_URL."];
  bool has_store_url_path() const;
  private:
  bool _internal_has_store_url_path() const;
  public:
  void clear_store_url_path();
  const std::string& store_url_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_url_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_url_path();
  PROTOBUF_NODISCARD std::string* release_store_url_path();
  void set_allocated_store_url_path(std::string* store_url_path);
  private:
  const std::string& _internal_store_url_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_url_path(const std::string& value);
  std::string* _internal_mutable_store_url_path();
  public:

  // optional string store_url_path_override = 53 [(.description) = "Navigate to this URL (relative to store home) when the store capsule for this item is clicked, instead of the default /app/... URL. Used by advertising apps that point to a sale page."];
  bool has_store_url_path_override() const;
  private:
  bool _internal_has_store_url_path_override() const;
  public:
  void clear_store_url_path_override();
  const std::string& store_url_path_override() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_store_url_path_override(ArgT0&& arg0, ArgT... args);
  std::string* mutable_store_url_path_override();
  PROTOBUF_NODISCARD std::string* release_store_url_path_override();
  void set_allocated_store_url_path_override(std::string* store_url_path_override);
  private:
  const std::string& _internal_store_url_path_override() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_store_url_path_override(const std::string& value);
  std::string* _internal_mutable_store_url_path_override();
  public:

  // optional string internal_name = 57 [(.description) = "For hub categories, the internal name (handle) of the category"];
  bool has_internal_name() const;
  private:
  bool _internal_has_internal_name() const;
  public:
  void clear_internal_name();
  const std::string& internal_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_internal_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_internal_name();
  PROTOBUF_NODISCARD std::string* release_internal_name();
  void set_allocated_internal_name(std::string* internal_name);
  private:
  const std::string& _internal_internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_internal_name(const std::string& value);
  std::string* _internal_mutable_internal_name();
  public:

  // optional string full_description = 58 [(.description) = "About this game section on the store page"];
  bool has_full_description() const;
  private:
  bool _internal_has_full_description() const;
  public:
  void clear_full_description();
  const std::string& full_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_full_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_full_description();
  PROTOBUF_NODISCARD std::string* release_full_description();
  void set_allocated_full_description(std::string* full_description);
  private:
  const std::string& _internal_full_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_full_description(const std::string& value);
  std::string* _internal_mutable_full_description();
  public:

  // optional .StoreItem.RelatedItems related_items = 15;
  bool has_related_items() const;
  private:
  bool _internal_has_related_items() const;
  public:
  void clear_related_items();
  const ::StoreItem_RelatedItems& related_items() const;
  PROTOBUF_NODISCARD ::StoreItem_RelatedItems* release_related_items();
  ::StoreItem_RelatedItems* mutable_related_items();
  void set_allocated_related_items(::StoreItem_RelatedItems* related_items);
  private:
  const ::StoreItem_RelatedItems& _internal_related_items() const;
  ::StoreItem_RelatedItems* _internal_mutable_related_items();
  public:
  void unsafe_arena_set_allocated_related_items(
      ::StoreItem_RelatedItems* related_items);
  ::StoreItem_RelatedItems* unsafe_arena_release_related_items();

  // optional .StoreItem.Categories categories = 22;
  bool has_categories() const;
  private:
  bool _internal_has_categories() const;
  public:
  void clear_categories();
  const ::StoreItem_Categories& categories() const;
  PROTOBUF_NODISCARD ::StoreItem_Categories* release_categories();
  ::StoreItem_Categories* mutable_categories();
  void set_allocated_categories(::StoreItem_Categories* categories);
  private:
  const ::StoreItem_Categories& _internal_categories() const;
  ::StoreItem_Categories* _internal_mutable_categories();
  public:
  void unsafe_arena_set_allocated_categories(
      ::StoreItem_Categories* categories);
  ::StoreItem_Categories* unsafe_arena_release_categories();

  // optional .StoreItem.Reviews reviews = 23;
  bool has_reviews() const;
  private:
  bool _internal_has_reviews() const;
  public:
  void clear_reviews();
  const ::StoreItem_Reviews& reviews() const;
  PROTOBUF_NODISCARD ::StoreItem_Reviews* release_reviews();
  ::StoreItem_Reviews* mutable_reviews();
  void set_allocated_reviews(::StoreItem_Reviews* reviews);
  private:
  const ::StoreItem_Reviews& _internal_reviews() const;
  ::StoreItem_Reviews* _internal_mutable_reviews();
  public:
  void unsafe_arena_set_allocated_reviews(
      ::StoreItem_Reviews* reviews);
  ::StoreItem_Reviews* unsafe_arena_release_reviews();

  // optional .StoreItem.BasicInfo basic_info = 24;
  bool has_basic_info() const;
  private:
  bool _internal_has_basic_info() const;
  public:
  void clear_basic_info();
  const ::StoreItem_BasicInfo& basic_info() const;
  PROTOBUF_NODISCARD ::StoreItem_BasicInfo* release_basic_info();
  ::StoreItem_BasicInfo* mutable_basic_info();
  void set_allocated_basic_info(::StoreItem_BasicInfo* basic_info);
  private:
  const ::StoreItem_BasicInfo& _internal_basic_info() const;
  ::StoreItem_BasicInfo* _internal_mutable_basic_info();
  public:
  void unsafe_arena_set_allocated_basic_info(
      ::StoreItem_BasicInfo* basic_info);
  ::StoreItem_BasicInfo* unsafe_arena_release_basic_info();

  // optional .StoreItem.Assets assets = 30;
  bool has_assets() const;
  private:
  bool _internal_has_assets() const;
  public:
  void clear_assets();
  const ::StoreItem_Assets& assets() const;
  PROTOBUF_NODISCARD ::StoreItem_Assets* release_assets();
  ::StoreItem_Assets* mutable_assets();
  void set_allocated_assets(::StoreItem_Assets* assets);
  private:
  const ::StoreItem_Assets& _internal_assets() const;
  ::StoreItem_Assets* _internal_mutable_assets();
  public:
  void unsafe_arena_set_allocated_assets(
      ::StoreItem_Assets* assets);
  ::StoreItem_Assets* unsafe_arena_release_assets();

  // optional .StoreItem.ReleaseInfo release = 31;
  bool has_release() const;
  private:
  bool _internal_has_release() const;
  public:
  void clear_release();
  const ::StoreItem_ReleaseInfo& release() const;
  PROTOBUF_NODISCARD ::StoreItem_ReleaseInfo* release_release();
  ::StoreItem_ReleaseInfo* mutable_release();
  void set_allocated_release(::StoreItem_ReleaseInfo* release);
  private:
  const ::StoreItem_ReleaseInfo& _internal_release() const;
  ::StoreItem_ReleaseInfo* _internal_mutable_release();
  public:
  void unsafe_arena_set_allocated_release(
      ::StoreItem_ReleaseInfo* release);
  ::StoreItem_ReleaseInfo* unsafe_arena_release_release();

  // optional .StoreItem.Platforms platforms = 32;
  bool has_platforms() const;
  private:
  bool _internal_has_platforms() const;
  public:
  void clear_platforms();
  const ::StoreItem_Platforms& platforms() const;
  PROTOBUF_NODISCARD ::StoreItem_Platforms* release_platforms();
  ::StoreItem_Platforms* mutable_platforms();
  void set_allocated_platforms(::StoreItem_Platforms* platforms);
  private:
  const ::StoreItem_Platforms& _internal_platforms() const;
  ::StoreItem_Platforms* _internal_mutable_platforms();
  public:
  void unsafe_arena_set_allocated_platforms(
      ::StoreItem_Platforms* platforms);
  ::StoreItem_Platforms* unsafe_arena_release_platforms();

  // optional .StoreGameRating game_rating = 33 [(.description) = "Local ratings agency information, like ESRB or PEGI"];
  bool has_game_rating() const;
  private:
  bool _internal_has_game_rating() const;
  public:
  void clear_game_rating();
  const ::StoreGameRating& game_rating() const;
  PROTOBUF_NODISCARD ::StoreGameRating* release_game_rating();
  ::StoreGameRating* mutable_game_rating();
  void set_allocated_game_rating(::StoreGameRating* game_rating);
  private:
  const ::StoreGameRating& _internal_game_rating() const;
  ::StoreGameRating* _internal_mutable_game_rating();
  public:
  void unsafe_arena_set_allocated_game_rating(
      ::StoreGameRating* game_rating);
  ::StoreGameRating* unsafe_arena_release_game_rating();

  // optional .StoreItem.PurchaseOption best_purchase_option = 40 [(.description) = "The cheapest way for the user to acquire this app or package (may be a bundle)."];
  bool has_best_purchase_option() const;
  private:
  bool _internal_has_best_purchase_option() const;
  public:
  void clear_best_purchase_option();
  const ::StoreItem_PurchaseOption& best_purchase_option() const;
  PROTOBUF_NODISCARD ::StoreItem_PurchaseOption* release_best_purchase_option();
  ::StoreItem_PurchaseOption* mutable_best_purchase_option();
  void set_allocated_best_purchase_option(::StoreItem_PurchaseOption* best_purchase_option);
  private:
  const ::StoreItem_PurchaseOption& _internal_best_purchase_option() const;
  ::StoreItem_PurchaseOption* _internal_mutable_best_purchase_option();
  public:
  void unsafe_arena_set_allocated_best_purchase_option(
      ::StoreItem_PurchaseOption* best_purchase_option);
  ::StoreItem_PurchaseOption* unsafe_arena_release_best_purchase_option();

  // optional .StoreItem.Screenshots screenshots = 50;
  bool has_screenshots() const;
  private:
  bool _internal_has_screenshots() const;
  public:
  void clear_screenshots();
  const ::StoreItem_Screenshots& screenshots() const;
  PROTOBUF_NODISCARD ::StoreItem_Screenshots* release_screenshots();
  ::StoreItem_Screenshots* mutable_screenshots();
  void set_allocated_screenshots(::StoreItem_Screenshots* screenshots);
  private:
  const ::StoreItem_Screenshots& _internal_screenshots() const;
  ::StoreItem_Screenshots* _internal_mutable_screenshots();
  public:
  void unsafe_arena_set_allocated_screenshots(
      ::StoreItem_Screenshots* screenshots);
  ::StoreItem_Screenshots* unsafe_arena_release_screenshots();

  // optional .StoreItem.Trailers trailers = 51;
  bool has_trailers() const;
  private:
  bool _internal_has_trailers() const;
  public:
  void clear_trailers();
  const ::StoreItem_Trailers& trailers() const;
  PROTOBUF_NODISCARD ::StoreItem_Trailers* release_trailers();
  ::StoreItem_Trailers* mutable_trailers();
  void set_allocated_trailers(::StoreItem_Trailers* trailers);
  private:
  const ::StoreItem_Trailers& _internal_trailers() const;
  ::StoreItem_Trailers* _internal_mutable_trailers();
  public:
  void unsafe_arena_set_allocated_trailers(
      ::StoreItem_Trailers* trailers);
  ::StoreItem_Trailers* unsafe_arena_release_trailers();

  // optional .StoreItem.FreeWeekend free_weekend = 54 [(.description) = "Information about a free weekend offer."];
  bool has_free_weekend() const;
  private:
  bool _internal_has_free_weekend() const;
  public:
  void clear_free_weekend();
  const ::StoreItem_FreeWeekend& free_weekend() const;
  PROTOBUF_NODISCARD ::StoreItem_FreeWeekend* release_free_weekend();
  ::StoreItem_FreeWeekend* mutable_free_weekend();
  void set_allocated_free_weekend(::StoreItem_FreeWeekend* free_weekend);
  private:
  const ::StoreItem_FreeWeekend& _internal_free_weekend() const;
  ::StoreItem_FreeWeekend* _internal_mutable_free_weekend();
  public:
  void unsafe_arena_set_allocated_free_weekend(
      ::StoreItem_FreeWeekend* free_weekend);
  ::StoreItem_FreeWeekend* unsafe_arena_release_free_weekend();

  // optional uint32 id = 2;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  uint32_t id() const;
  void set_id(uint32_t value);
  private:
  uint32_t _internal_id() const;
  void _internal_set_id(uint32_t value);
  public:

  // optional uint32 success = 3 [(.description) = "EResult of this lookup action"];
  bool has_success() const;
  private:
  bool _internal_has_success() const;
  public:
  void clear_success();
  uint32_t success() const;
  void set_success(uint32_t value);
  private:
  uint32_t _internal_success() const;
  void _internal_set_success(uint32_t value);
  public:

  // optional uint32 appid = 9 [(.description) = "If this is an app, or a single-app package, the steamworks appid."];
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional bool visible = 4;
  bool has_visible() const;
  private:
  bool _internal_has_visible() const;
  public:
  void clear_visible();
  bool visible() const;
  void set_visible(bool value);
  private:
  bool _internal_visible() const;
  void _internal_set_visible(bool value);
  public:

  // optional bool unvailable_for_country_restriction = 5 [(.description) = "Indicates this app is visible in other regions, but not the requested reagion"];
  bool has_unvailable_for_country_restriction() const;
  private:
  bool _internal_has_unvailable_for_country_restriction() const;
  public:
  void clear_unvailable_for_country_restriction();
  bool unvailable_for_country_restriction() const;
  void set_unvailable_for_country_restriction(bool value);
  private:
  bool _internal_unvailable_for_country_restriction() const;
  void _internal_set_unvailable_for_country_restriction(bool value);
  public:

  // optional bool is_free = 13;
  bool has_is_free() const;
  private:
  bool _internal_has_is_free() const;
  public:
  void clear_is_free();
  bool is_free() const;
  void set_is_free(bool value);
  private:
  bool _internal_is_free() const;
  void _internal_set_is_free(bool value);
  public:

  // optional bool is_early_access = 14;
  bool has_is_early_access() const;
  private:
  bool _internal_has_is_early_access() const;
  public:
  void clear_is_early_access();
  bool is_early_access() const;
  void set_is_early_access(bool value);
  private:
  bool _internal_is_early_access() const;
  void _internal_set_is_early_access(bool value);
  public:

  // optional .EStoreAppType type = 10 [default = k_EStoreAppType_Game, (.description) = "Type of app (Game, Software, Music).  For packages/bundles, this will be the most interesting type (eg Game + Soundtrack bundle will have type Game)"];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::EStoreAppType type() const;
  void set_type(::EStoreAppType value);
  private:
  ::EStoreAppType _internal_type() const;
  void _internal_set_type(::EStoreAppType value);
  public:

  // optional bool unlisted = 55 [(.description) = "If true, item is only accessible on store via a direct link"];
  bool has_unlisted() const;
  private:
  bool _internal_has_unlisted() const;
  public:
  void clear_unlisted();
  bool unlisted() const;
  void set_unlisted(bool value);
  private:
  bool _internal_unlisted() const;
  void _internal_set_unlisted(bool value);
  public:

  // optional uint32 game_count = 56 [(.description) = "For creators and tags, how many games belong to them"];
  bool has_game_count() const;
  private:
  bool _internal_has_game_count() const;
  public:
  void clear_game_count();
  uint32_t game_count() const;
  void set_game_count(uint32_t value);
  private:
  uint32_t _internal_game_count() const;
  void _internal_set_game_count(uint32_t value);
  public:

  // optional .EStoreItemType item_type = 1 [default = k_EStoreItemType_Invalid];
  bool has_item_type() const;
  private:
  bool _internal_has_item_type() const;
  public:
  void clear_item_type();
  ::EStoreItemType item_type() const;
  void set_item_type(::EStoreItemType value);
  private:
  ::EStoreItemType _internal_item_type() const;
  void _internal_set_item_type(::EStoreItemType value);
  public:

  // @@protoc_insertion_point(class_scope:StoreItem)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> included_types_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > included_appids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> content_descriptorids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > tagids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Tag > tags_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption > purchase_options_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption > accessories_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_SupportedLanguage > supported_languages_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_url_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr store_url_path_override_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr internal_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr full_description_;
  ::StoreItem_RelatedItems* related_items_;
  ::StoreItem_Categories* categories_;
  ::StoreItem_Reviews* reviews_;
  ::StoreItem_BasicInfo* basic_info_;
  ::StoreItem_Assets* assets_;
  ::StoreItem_ReleaseInfo* release_;
  ::StoreItem_Platforms* platforms_;
  ::StoreGameRating* game_rating_;
  ::StoreItem_PurchaseOption* best_purchase_option_;
  ::StoreItem_Screenshots* screenshots_;
  ::StoreItem_Trailers* trailers_;
  ::StoreItem_FreeWeekend* free_weekend_;
  uint32_t id_;
  uint32_t success_;
  uint32_t appid_;
  bool visible_;
  bool unvailable_for_country_restriction_;
  bool is_free_;
  bool is_early_access_;
  int type_;
  bool unlisted_;
  uint32_t game_count_;
  int item_type_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetItems_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetItems_Response) */ {
 public:
  inline CStoreBrowse_GetItems_Response() : CStoreBrowse_GetItems_Response(nullptr) {}
  ~CStoreBrowse_GetItems_Response() override;
  explicit constexpr CStoreBrowse_GetItems_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetItems_Response(const CStoreBrowse_GetItems_Response& from);
  CStoreBrowse_GetItems_Response(CStoreBrowse_GetItems_Response&& from) noexcept
    : CStoreBrowse_GetItems_Response() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetItems_Response& operator=(const CStoreBrowse_GetItems_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetItems_Response& operator=(CStoreBrowse_GetItems_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetItems_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetItems_Response* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetItems_Response*>(
               &_CStoreBrowse_GetItems_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CStoreBrowse_GetItems_Response& a, CStoreBrowse_GetItems_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetItems_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetItems_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetItems_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetItems_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetItems_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetItems_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetItems_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetItems_Response";
  }
  protected:
  explicit CStoreBrowse_GetItems_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStoreItemsFieldNumber = 1,
  };
  // repeated .StoreItem store_items = 1;
  int store_items_size() const;
  private:
  int _internal_store_items_size() const;
  public:
  void clear_store_items();
  ::StoreItem* mutable_store_items(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem >*
      mutable_store_items();
  private:
  const ::StoreItem& _internal_store_items(int index) const;
  ::StoreItem* _internal_add_store_items();
  public:
  const ::StoreItem& store_items(int index) const;
  ::StoreItem* add_store_items();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem >&
      store_items() const;

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetItems_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem > store_items_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetStoreCategories_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetStoreCategories_Request) */ {
 public:
  inline CStoreBrowse_GetStoreCategories_Request() : CStoreBrowse_GetStoreCategories_Request(nullptr) {}
  ~CStoreBrowse_GetStoreCategories_Request() override;
  explicit constexpr CStoreBrowse_GetStoreCategories_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetStoreCategories_Request(const CStoreBrowse_GetStoreCategories_Request& from);
  CStoreBrowse_GetStoreCategories_Request(CStoreBrowse_GetStoreCategories_Request&& from) noexcept
    : CStoreBrowse_GetStoreCategories_Request() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetStoreCategories_Request& operator=(const CStoreBrowse_GetStoreCategories_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetStoreCategories_Request& operator=(CStoreBrowse_GetStoreCategories_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetStoreCategories_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetStoreCategories_Request* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetStoreCategories_Request*>(
               &_CStoreBrowse_GetStoreCategories_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CStoreBrowse_GetStoreCategories_Request& a, CStoreBrowse_GetStoreCategories_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetStoreCategories_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetStoreCategories_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetStoreCategories_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetStoreCategories_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetStoreCategories_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetStoreCategories_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetStoreCategories_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetStoreCategories_Request";
  }
  protected:
  explicit CStoreBrowse_GetStoreCategories_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLanguageFieldNumber = 1,
    kElanguageFieldNumber = 2,
  };
  // optional string language = 1;
  bool has_language() const;
  private:
  bool _internal_has_language() const;
  public:
  void clear_language();
  const std::string& language() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_language(ArgT0&& arg0, ArgT... args);
  std::string* mutable_language();
  PROTOBUF_NODISCARD std::string* release_language();
  void set_allocated_language(std::string* language);
  private:
  const std::string& _internal_language() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_language(const std::string& value);
  std::string* _internal_mutable_language();
  public:

  // optional int32 elanguage = 2 [default = -1, (.description) = "ELanguage"];
  bool has_elanguage() const;
  private:
  bool _internal_has_elanguage() const;
  public:
  void clear_elanguage();
  int32_t elanguage() const;
  void set_elanguage(int32_t value);
  private:
  int32_t _internal_elanguage() const;
  void _internal_set_elanguage(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetStoreCategories_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr language_;
  int32_t elanguage_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetStoreCategories_Response_Category final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetStoreCategories_Response.Category) */ {
 public:
  inline CStoreBrowse_GetStoreCategories_Response_Category() : CStoreBrowse_GetStoreCategories_Response_Category(nullptr) {}
  ~CStoreBrowse_GetStoreCategories_Response_Category() override;
  explicit constexpr CStoreBrowse_GetStoreCategories_Response_Category(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetStoreCategories_Response_Category(const CStoreBrowse_GetStoreCategories_Response_Category& from);
  CStoreBrowse_GetStoreCategories_Response_Category(CStoreBrowse_GetStoreCategories_Response_Category&& from) noexcept
    : CStoreBrowse_GetStoreCategories_Response_Category() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetStoreCategories_Response_Category& operator=(const CStoreBrowse_GetStoreCategories_Response_Category& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetStoreCategories_Response_Category& operator=(CStoreBrowse_GetStoreCategories_Response_Category&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetStoreCategories_Response_Category& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetStoreCategories_Response_Category* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetStoreCategories_Response_Category*>(
               &_CStoreBrowse_GetStoreCategories_Response_Category_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CStoreBrowse_GetStoreCategories_Response_Category& a, CStoreBrowse_GetStoreCategories_Response_Category& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetStoreCategories_Response_Category* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetStoreCategories_Response_Category* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetStoreCategories_Response_Category* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetStoreCategories_Response_Category>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetStoreCategories_Response_Category& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetStoreCategories_Response_Category& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetStoreCategories_Response_Category* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetStoreCategories_Response.Category";
  }
  protected:
  explicit CStoreBrowse_GetStoreCategories_Response_Category(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInternalNameFieldNumber = 3,
    kDisplayNameFieldNumber = 4,
    kImageUrlFieldNumber = 5,
    kCategoryidFieldNumber = 1,
    kTypeFieldNumber = 2,
    kShowInSearchFieldNumber = 6,
  };
  // optional string internal_name = 3;
  bool has_internal_name() const;
  private:
  bool _internal_has_internal_name() const;
  public:
  void clear_internal_name();
  const std::string& internal_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_internal_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_internal_name();
  PROTOBUF_NODISCARD std::string* release_internal_name();
  void set_allocated_internal_name(std::string* internal_name);
  private:
  const std::string& _internal_internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_internal_name(const std::string& value);
  std::string* _internal_mutable_internal_name();
  public:

  // optional string display_name = 4;
  bool has_display_name() const;
  private:
  bool _internal_has_display_name() const;
  public:
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_NODISCARD std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // optional string image_url = 5 [(.description) = "Append to STORE_CDN_URL"];
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // optional uint32 categoryid = 1;
  bool has_categoryid() const;
  private:
  bool _internal_has_categoryid() const;
  public:
  void clear_categoryid();
  uint32_t categoryid() const;
  void set_categoryid(uint32_t value);
  private:
  uint32_t _internal_categoryid() const;
  void _internal_set_categoryid(uint32_t value);
  public:

  // optional .EStoreCategoryType type = 2 [default = k_EStoreCategoryType_Category];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::EStoreCategoryType type() const;
  void set_type(::EStoreCategoryType value);
  private:
  ::EStoreCategoryType _internal_type() const;
  void _internal_set_type(::EStoreCategoryType value);
  public:

  // optional bool show_in_search = 6 [(.description) = "Indicates this category can link to search results showing all items in category."];
  bool has_show_in_search() const;
  private:
  bool _internal_has_show_in_search() const;
  public:
  void clear_show_in_search();
  bool show_in_search() const;
  void set_show_in_search(bool value);
  private:
  bool _internal_show_in_search() const;
  void _internal_set_show_in_search(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetStoreCategories_Response.Category)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr internal_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  uint32_t categoryid_;
  int type_;
  bool show_in_search_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetStoreCategories_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetStoreCategories_Response) */ {
 public:
  inline CStoreBrowse_GetStoreCategories_Response() : CStoreBrowse_GetStoreCategories_Response(nullptr) {}
  ~CStoreBrowse_GetStoreCategories_Response() override;
  explicit constexpr CStoreBrowse_GetStoreCategories_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetStoreCategories_Response(const CStoreBrowse_GetStoreCategories_Response& from);
  CStoreBrowse_GetStoreCategories_Response(CStoreBrowse_GetStoreCategories_Response&& from) noexcept
    : CStoreBrowse_GetStoreCategories_Response() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetStoreCategories_Response& operator=(const CStoreBrowse_GetStoreCategories_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetStoreCategories_Response& operator=(CStoreBrowse_GetStoreCategories_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetStoreCategories_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetStoreCategories_Response* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetStoreCategories_Response*>(
               &_CStoreBrowse_GetStoreCategories_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CStoreBrowse_GetStoreCategories_Response& a, CStoreBrowse_GetStoreCategories_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetStoreCategories_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetStoreCategories_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetStoreCategories_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetStoreCategories_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetStoreCategories_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetStoreCategories_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetStoreCategories_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetStoreCategories_Response";
  }
  protected:
  explicit CStoreBrowse_GetStoreCategories_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CStoreBrowse_GetStoreCategories_Response_Category Category;

  // accessors -------------------------------------------------------

  enum : int {
    kCategoriesFieldNumber = 1,
  };
  // repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;
  int categories_size() const;
  private:
  int _internal_categories_size() const;
  public:
  void clear_categories();
  ::CStoreBrowse_GetStoreCategories_Response_Category* mutable_categories(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetStoreCategories_Response_Category >*
      mutable_categories();
  private:
  const ::CStoreBrowse_GetStoreCategories_Response_Category& _internal_categories(int index) const;
  ::CStoreBrowse_GetStoreCategories_Response_Category* _internal_add_categories();
  public:
  const ::CStoreBrowse_GetStoreCategories_Response_Category& categories(int index) const;
  ::CStoreBrowse_GetStoreCategories_Response_Category* add_categories();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetStoreCategories_Response_Category >&
      categories() const;

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetStoreCategories_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetStoreCategories_Response_Category > categories_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForApps_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForApps_Request) */ {
 public:
  inline CStoreBrowse_GetDLCForApps_Request() : CStoreBrowse_GetDLCForApps_Request(nullptr) {}
  ~CStoreBrowse_GetDLCForApps_Request() override;
  explicit constexpr CStoreBrowse_GetDLCForApps_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForApps_Request(const CStoreBrowse_GetDLCForApps_Request& from);
  CStoreBrowse_GetDLCForApps_Request(CStoreBrowse_GetDLCForApps_Request&& from) noexcept
    : CStoreBrowse_GetDLCForApps_Request() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForApps_Request& operator=(const CStoreBrowse_GetDLCForApps_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForApps_Request& operator=(CStoreBrowse_GetDLCForApps_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForApps_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForApps_Request* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForApps_Request*>(
               &_CStoreBrowse_GetDLCForApps_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CStoreBrowse_GetDLCForApps_Request& a, CStoreBrowse_GetDLCForApps_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForApps_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForApps_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForApps_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForApps_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForApps_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForApps_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForApps_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForApps_Request";
  }
  protected:
  explicit CStoreBrowse_GetDLCForApps_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidsFieldNumber = 3,
    kContextFieldNumber = 1,
    kStorePageFilterFieldNumber = 2,
    kSteamidFieldNumber = 4,
  };
  // repeated .StoreItemID appids = 3 [(.description) = "Apps for which we want DLC information."];
  int appids_size() const;
  private:
  int _internal_appids_size() const;
  public:
  void clear_appids();
  ::StoreItemID* mutable_appids(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >*
      mutable_appids();
  private:
  const ::StoreItemID& _internal_appids(int index) const;
  ::StoreItemID* _internal_add_appids();
  public:
  const ::StoreItemID& appids(int index) const;
  ::StoreItemID* add_appids();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >&
      appids() const;

  // optional .StoreBrowseContext context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::StoreBrowseContext& context() const;
  PROTOBUF_NODISCARD ::StoreBrowseContext* release_context();
  ::StoreBrowseContext* mutable_context();
  void set_allocated_context(::StoreBrowseContext* context);
  private:
  const ::StoreBrowseContext& _internal_context() const;
  ::StoreBrowseContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::StoreBrowseContext* context);
  ::StoreBrowseContext* unsafe_arena_release_context();

  // optional .CStorePageFilter store_page_filter = 2;
  bool has_store_page_filter() const;
  private:
  bool _internal_has_store_page_filter() const;
  public:
  void clear_store_page_filter();
  const ::CStorePageFilter& store_page_filter() const;
  PROTOBUF_NODISCARD ::CStorePageFilter* release_store_page_filter();
  ::CStorePageFilter* mutable_store_page_filter();
  void set_allocated_store_page_filter(::CStorePageFilter* store_page_filter);
  private:
  const ::CStorePageFilter& _internal_store_page_filter() const;
  ::CStorePageFilter* _internal_mutable_store_page_filter();
  public:
  void unsafe_arena_set_allocated_store_page_filter(
      ::CStorePageFilter* store_page_filter);
  ::CStorePageFilter* unsafe_arena_release_store_page_filter();

  // optional uint64 steamid = 4 [(.description) = "If specified, we want DLC information for all apps owned by this user."];
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForApps_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID > appids_;
  ::StoreBrowseContext* context_;
  ::CStorePageFilter* store_page_filter_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForApps_Response_DLCData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForApps_Response.DLCData) */ {
 public:
  inline CStoreBrowse_GetDLCForApps_Response_DLCData() : CStoreBrowse_GetDLCForApps_Response_DLCData(nullptr) {}
  ~CStoreBrowse_GetDLCForApps_Response_DLCData() override;
  explicit constexpr CStoreBrowse_GetDLCForApps_Response_DLCData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForApps_Response_DLCData(const CStoreBrowse_GetDLCForApps_Response_DLCData& from);
  CStoreBrowse_GetDLCForApps_Response_DLCData(CStoreBrowse_GetDLCForApps_Response_DLCData&& from) noexcept
    : CStoreBrowse_GetDLCForApps_Response_DLCData() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForApps_Response_DLCData& operator=(const CStoreBrowse_GetDLCForApps_Response_DLCData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForApps_Response_DLCData& operator=(CStoreBrowse_GetDLCForApps_Response_DLCData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForApps_Response_DLCData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForApps_Response_DLCData* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForApps_Response_DLCData*>(
               &_CStoreBrowse_GetDLCForApps_Response_DLCData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CStoreBrowse_GetDLCForApps_Response_DLCData& a, CStoreBrowse_GetDLCForApps_Response_DLCData& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForApps_Response_DLCData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForApps_Response_DLCData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForApps_Response_DLCData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForApps_Response_DLCData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForApps_Response_DLCData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForApps_Response_DLCData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForApps_Response_DLCData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForApps_Response.DLCData";
  }
  protected:
  explicit CStoreBrowse_GetDLCForApps_Response_DLCData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kParentappidFieldNumber = 2,
    kReleaseDateFieldNumber = 3,
    kComingSoonFieldNumber = 4,
    kFreeFieldNumber = 7,
    kPriceFieldNumber = 5,
    kDiscountFieldNumber = 6,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 parentappid = 2;
  bool has_parentappid() const;
  private:
  bool _internal_has_parentappid() const;
  public:
  void clear_parentappid();
  uint32_t parentappid() const;
  void set_parentappid(uint32_t value);
  private:
  uint32_t _internal_parentappid() const;
  void _internal_set_parentappid(uint32_t value);
  public:

  // optional uint32 release_date = 3;
  bool has_release_date() const;
  private:
  bool _internal_has_release_date() const;
  public:
  void clear_release_date();
  uint32_t release_date() const;
  void set_release_date(uint32_t value);
  private:
  uint32_t _internal_release_date() const;
  void _internal_set_release_date(uint32_t value);
  public:

  // optional bool coming_soon = 4;
  bool has_coming_soon() const;
  private:
  bool _internal_has_coming_soon() const;
  public:
  void clear_coming_soon();
  bool coming_soon() const;
  void set_coming_soon(bool value);
  private:
  bool _internal_coming_soon() const;
  void _internal_set_coming_soon(bool value);
  public:

  // optional bool free = 7;
  bool has_free() const;
  private:
  bool _internal_has_free() const;
  public:
  void clear_free();
  bool free() const;
  void set_free(bool value);
  private:
  bool _internal_free() const;
  void _internal_set_free(bool value);
  public:

  // optional int64 price = 5;
  bool has_price() const;
  private:
  bool _internal_has_price() const;
  public:
  void clear_price();
  int64_t price() const;
  void set_price(int64_t value);
  private:
  int64_t _internal_price() const;
  void _internal_set_price(int64_t value);
  public:

  // optional uint32 discount = 6;
  bool has_discount() const;
  private:
  bool _internal_has_discount() const;
  public:
  void clear_discount();
  uint32_t discount() const;
  void set_discount(uint32_t value);
  private:
  uint32_t _internal_discount() const;
  void _internal_set_discount(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForApps_Response.DLCData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t parentappid_;
  uint32_t release_date_;
  bool coming_soon_;
  bool free_;
  int64_t price_;
  uint32_t discount_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp) */ {
 public:
  inline CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp() : CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(nullptr) {}
  ~CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp() override;
  explicit constexpr CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from);
  CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp&& from) noexcept
    : CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& operator=(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& operator=(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp*>(
               &_CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& a, CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp";
  }
  protected:
  explicit CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kPlaytimeFieldNumber = 2,
    kLastPlayedFieldNumber = 3,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 playtime = 2 [(.description) = "Total time played over all time."];
  bool has_playtime() const;
  private:
  bool _internal_has_playtime() const;
  public:
  void clear_playtime();
  uint32_t playtime() const;
  void set_playtime(uint32_t value);
  private:
  uint32_t _internal_playtime() const;
  void _internal_set_playtime(uint32_t value);
  public:

  // optional uint32 last_played = 3 [(.description) = "Time last played on any platform."];
  bool has_last_played() const;
  private:
  bool _internal_has_last_played() const;
  public:
  void clear_last_played();
  uint32_t last_played() const;
  void set_last_played(uint32_t value);
  private:
  uint32_t _internal_last_played() const;
  void _internal_set_last_played(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t playtime_;
  uint32_t last_played_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForApps_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForApps_Response) */ {
 public:
  inline CStoreBrowse_GetDLCForApps_Response() : CStoreBrowse_GetDLCForApps_Response(nullptr) {}
  ~CStoreBrowse_GetDLCForApps_Response() override;
  explicit constexpr CStoreBrowse_GetDLCForApps_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForApps_Response(const CStoreBrowse_GetDLCForApps_Response& from);
  CStoreBrowse_GetDLCForApps_Response(CStoreBrowse_GetDLCForApps_Response&& from) noexcept
    : CStoreBrowse_GetDLCForApps_Response() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForApps_Response& operator=(const CStoreBrowse_GetDLCForApps_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForApps_Response& operator=(CStoreBrowse_GetDLCForApps_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForApps_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForApps_Response* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForApps_Response*>(
               &_CStoreBrowse_GetDLCForApps_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CStoreBrowse_GetDLCForApps_Response& a, CStoreBrowse_GetDLCForApps_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForApps_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForApps_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForApps_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForApps_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForApps_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForApps_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForApps_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForApps_Response";
  }
  protected:
  explicit CStoreBrowse_GetDLCForApps_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CStoreBrowse_GetDLCForApps_Response_DLCData DLCData;
  typedef CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp PlaytimeForApp;

  // accessors -------------------------------------------------------

  enum : int {
    kDlcDataFieldNumber = 1,
    kPlaytimeFieldNumber = 2,
  };
  // repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;
  int dlc_data_size() const;
  private:
  int _internal_dlc_data_size() const;
  public:
  void clear_dlc_data();
  ::CStoreBrowse_GetDLCForApps_Response_DLCData* mutable_dlc_data(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_DLCData >*
      mutable_dlc_data();
  private:
  const ::CStoreBrowse_GetDLCForApps_Response_DLCData& _internal_dlc_data(int index) const;
  ::CStoreBrowse_GetDLCForApps_Response_DLCData* _internal_add_dlc_data();
  public:
  const ::CStoreBrowse_GetDLCForApps_Response_DLCData& dlc_data(int index) const;
  ::CStoreBrowse_GetDLCForApps_Response_DLCData* add_dlc_data();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_DLCData >&
      dlc_data() const;

  // repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;
  int playtime_size() const;
  private:
  int _internal_playtime_size() const;
  public:
  void clear_playtime();
  ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* mutable_playtime(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >*
      mutable_playtime();
  private:
  const ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& _internal_playtime(int index) const;
  ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* _internal_add_playtime();
  public:
  const ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& playtime(int index) const;
  ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* add_playtime();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >&
      playtime() const;

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForApps_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_DLCData > dlc_data_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp > playtime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForAppsSolr_Request final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForAppsSolr_Request) */ {
 public:
  inline CStoreBrowse_GetDLCForAppsSolr_Request() : CStoreBrowse_GetDLCForAppsSolr_Request(nullptr) {}
  ~CStoreBrowse_GetDLCForAppsSolr_Request() override;
  explicit constexpr CStoreBrowse_GetDLCForAppsSolr_Request(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForAppsSolr_Request(const CStoreBrowse_GetDLCForAppsSolr_Request& from);
  CStoreBrowse_GetDLCForAppsSolr_Request(CStoreBrowse_GetDLCForAppsSolr_Request&& from) noexcept
    : CStoreBrowse_GetDLCForAppsSolr_Request() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForAppsSolr_Request& operator=(const CStoreBrowse_GetDLCForAppsSolr_Request& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForAppsSolr_Request& operator=(CStoreBrowse_GetDLCForAppsSolr_Request&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForAppsSolr_Request& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForAppsSolr_Request* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForAppsSolr_Request*>(
               &_CStoreBrowse_GetDLCForAppsSolr_Request_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CStoreBrowse_GetDLCForAppsSolr_Request& a, CStoreBrowse_GetDLCForAppsSolr_Request& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForAppsSolr_Request* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForAppsSolr_Request* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForAppsSolr_Request* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForAppsSolr_Request>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Request& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Request& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Request* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForAppsSolr_Request";
  }
  protected:
  explicit CStoreBrowse_GetDLCForAppsSolr_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidsFieldNumber = 2,
    kFlavorFieldNumber = 3,
    kContextFieldNumber = 1,
    kStorePageFilterFieldNumber = 5,
    kCountFieldNumber = 4,
  };
  // repeated uint32 appids = 2;
  int appids_size() const;
  private:
  int _internal_appids_size() const;
  public:
  void clear_appids();
  private:
  uint32_t _internal_appids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_appids() const;
  void _internal_add_appids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_appids();
  public:
  uint32_t appids(int index) const;
  void set_appids(int index, uint32_t value);
  void add_appids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      appids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_appids();

  // optional string flavor = 3;
  bool has_flavor() const;
  private:
  bool _internal_has_flavor() const;
  public:
  void clear_flavor();
  const std::string& flavor() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_flavor(ArgT0&& arg0, ArgT... args);
  std::string* mutable_flavor();
  PROTOBUF_NODISCARD std::string* release_flavor();
  void set_allocated_flavor(std::string* flavor);
  private:
  const std::string& _internal_flavor() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_flavor(const std::string& value);
  std::string* _internal_mutable_flavor();
  public:

  // optional .StoreBrowseContext context = 1;
  bool has_context() const;
  private:
  bool _internal_has_context() const;
  public:
  void clear_context();
  const ::StoreBrowseContext& context() const;
  PROTOBUF_NODISCARD ::StoreBrowseContext* release_context();
  ::StoreBrowseContext* mutable_context();
  void set_allocated_context(::StoreBrowseContext* context);
  private:
  const ::StoreBrowseContext& _internal_context() const;
  ::StoreBrowseContext* _internal_mutable_context();
  public:
  void unsafe_arena_set_allocated_context(
      ::StoreBrowseContext* context);
  ::StoreBrowseContext* unsafe_arena_release_context();

  // optional .CStorePageFilter store_page_filter = 5;
  bool has_store_page_filter() const;
  private:
  bool _internal_has_store_page_filter() const;
  public:
  void clear_store_page_filter();
  const ::CStorePageFilter& store_page_filter() const;
  PROTOBUF_NODISCARD ::CStorePageFilter* release_store_page_filter();
  ::CStorePageFilter* mutable_store_page_filter();
  void set_allocated_store_page_filter(::CStorePageFilter* store_page_filter);
  private:
  const ::CStorePageFilter& _internal_store_page_filter() const;
  ::CStorePageFilter* _internal_mutable_store_page_filter();
  public:
  void unsafe_arena_set_allocated_store_page_filter(
      ::CStorePageFilter* store_page_filter);
  ::CStorePageFilter* unsafe_arena_release_store_page_filter();

  // optional uint32 count = 4;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForAppsSolr_Request)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > appids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr flavor_;
  ::StoreBrowseContext* context_;
  ::CStorePageFilter* store_page_filter_;
  uint32_t count_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForAppsSolr_Response_DLCList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList) */ {
 public:
  inline CStoreBrowse_GetDLCForAppsSolr_Response_DLCList() : CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(nullptr) {}
  ~CStoreBrowse_GetDLCForAppsSolr_Response_DLCList() override;
  explicit constexpr CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from);
  CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList&& from) noexcept
    : CStoreBrowse_GetDLCForAppsSolr_Response_DLCList() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& operator=(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& operator=(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList*>(
               &_CStoreBrowse_GetDLCForAppsSolr_Response_DLCList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& a, CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForAppsSolr_Response_DLCList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForAppsSolr_Response.DLCList";
  }
  protected:
  explicit CStoreBrowse_GetDLCForAppsSolr_Response_DLCList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDlcAppidsFieldNumber = 2,
    kParentAppidFieldNumber = 1,
  };
  // repeated uint32 dlc_appids = 2;
  int dlc_appids_size() const;
  private:
  int _internal_dlc_appids_size() const;
  public:
  void clear_dlc_appids();
  private:
  uint32_t _internal_dlc_appids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_dlc_appids() const;
  void _internal_add_dlc_appids(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_dlc_appids();
  public:
  uint32_t dlc_appids(int index) const;
  void set_dlc_appids(int index, uint32_t value);
  void add_dlc_appids(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      dlc_appids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_dlc_appids();

  // optional uint32 parent_appid = 1;
  bool has_parent_appid() const;
  private:
  bool _internal_has_parent_appid() const;
  public:
  void clear_parent_appid();
  uint32_t parent_appid() const;
  void set_parent_appid(uint32_t value);
  private:
  uint32_t _internal_parent_appid() const;
  void _internal_set_parent_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > dlc_appids_;
  uint32_t parent_appid_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// -------------------------------------------------------------------

class CStoreBrowse_GetDLCForAppsSolr_Response final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStoreBrowse_GetDLCForAppsSolr_Response) */ {
 public:
  inline CStoreBrowse_GetDLCForAppsSolr_Response() : CStoreBrowse_GetDLCForAppsSolr_Response(nullptr) {}
  ~CStoreBrowse_GetDLCForAppsSolr_Response() override;
  explicit constexpr CStoreBrowse_GetDLCForAppsSolr_Response(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStoreBrowse_GetDLCForAppsSolr_Response(const CStoreBrowse_GetDLCForAppsSolr_Response& from);
  CStoreBrowse_GetDLCForAppsSolr_Response(CStoreBrowse_GetDLCForAppsSolr_Response&& from) noexcept
    : CStoreBrowse_GetDLCForAppsSolr_Response() {
    *this = ::std::move(from);
  }

  inline CStoreBrowse_GetDLCForAppsSolr_Response& operator=(const CStoreBrowse_GetDLCForAppsSolr_Response& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStoreBrowse_GetDLCForAppsSolr_Response& operator=(CStoreBrowse_GetDLCForAppsSolr_Response&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStoreBrowse_GetDLCForAppsSolr_Response& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStoreBrowse_GetDLCForAppsSolr_Response* internal_default_instance() {
    return reinterpret_cast<const CStoreBrowse_GetDLCForAppsSolr_Response*>(
               &_CStoreBrowse_GetDLCForAppsSolr_Response_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CStoreBrowse_GetDLCForAppsSolr_Response& a, CStoreBrowse_GetDLCForAppsSolr_Response& b) {
    a.Swap(&b);
  }
  inline void Swap(CStoreBrowse_GetDLCForAppsSolr_Response* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStoreBrowse_GetDLCForAppsSolr_Response* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStoreBrowse_GetDLCForAppsSolr_Response* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStoreBrowse_GetDLCForAppsSolr_Response>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStoreBrowse_GetDLCForAppsSolr_Response& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStoreBrowse_GetDLCForAppsSolr_Response& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStoreBrowse_GetDLCForAppsSolr_Response* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStoreBrowse_GetDLCForAppsSolr_Response";
  }
  protected:
  explicit CStoreBrowse_GetDLCForAppsSolr_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CStoreBrowse_GetDLCForAppsSolr_Response_DLCList DLCList;

  // accessors -------------------------------------------------------

  enum : int {
    kDlcListsFieldNumber = 1,
  };
  // repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;
  int dlc_lists_size() const;
  private:
  int _internal_dlc_lists_size() const;
  public:
  void clear_dlc_lists();
  ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* mutable_dlc_lists(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >*
      mutable_dlc_lists();
  private:
  const ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& _internal_dlc_lists(int index) const;
  ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* _internal_add_dlc_lists();
  public:
  const ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& dlc_lists(int index) const;
  ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* add_dlc_lists();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >&
      dlc_lists() const;

  // @@protoc_insertion_point(class_scope:CStoreBrowse_GetDLCForAppsSolr_Response)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList > dlc_lists_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fstorebrowse_2esteamclient_2eproto;
};
// ===================================================================

class StoreBrowse_Stub;

class StoreBrowse : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline StoreBrowse() {};
 public:
  virtual ~StoreBrowse();

  typedef StoreBrowse_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GetItems(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetItems_Request* request,
                       ::CStoreBrowse_GetItems_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetStoreCategories(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetStoreCategories_Request* request,
                       ::CStoreBrowse_GetStoreCategories_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetDLCForApps(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetDLCForApps_Request* request,
                       ::CStoreBrowse_GetDLCForApps_Response* response,
                       ::google::protobuf::Closure* done);
  virtual void GetDLCForAppsSolr(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetDLCForAppsSolr_Request* request,
                       ::CStoreBrowse_GetDLCForAppsSolr_Response* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StoreBrowse);
};

class StoreBrowse_Stub : public StoreBrowse {
 public:
  StoreBrowse_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  StoreBrowse_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~StoreBrowse_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements StoreBrowse ------------------------------------------

  void GetItems(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetItems_Request* request,
                       ::CStoreBrowse_GetItems_Response* response,
                       ::google::protobuf::Closure* done);
  void GetStoreCategories(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetStoreCategories_Request* request,
                       ::CStoreBrowse_GetStoreCategories_Response* response,
                       ::google::protobuf::Closure* done);
  void GetDLCForApps(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetDLCForApps_Request* request,
                       ::CStoreBrowse_GetDLCForApps_Response* response,
                       ::google::protobuf::Closure* done);
  void GetDLCForAppsSolr(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::CStoreBrowse_GetDLCForAppsSolr_Request* request,
                       ::CStoreBrowse_GetDLCForAppsSolr_Response* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(StoreBrowse_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// StoreItemID

// optional uint32 appid = 1;
inline bool StoreItemID::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItemID::has_appid() const {
  return _internal_has_appid();
}
inline void StoreItemID::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StoreItemID::_internal_appid() const {
  return appid_;
}
inline uint32_t StoreItemID::appid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.appid)
  return _internal_appid();
}
inline void StoreItemID::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void StoreItemID::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.appid)
}

// optional uint32 packageid = 2;
inline bool StoreItemID::_internal_has_packageid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItemID::has_packageid() const {
  return _internal_has_packageid();
}
inline void StoreItemID::clear_packageid() {
  packageid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StoreItemID::_internal_packageid() const {
  return packageid_;
}
inline uint32_t StoreItemID::packageid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.packageid)
  return _internal_packageid();
}
inline void StoreItemID::_internal_set_packageid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  packageid_ = value;
}
inline void StoreItemID::set_packageid(uint32_t value) {
  _internal_set_packageid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.packageid)
}

// optional uint32 bundleid = 3;
inline bool StoreItemID::_internal_has_bundleid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItemID::has_bundleid() const {
  return _internal_has_bundleid();
}
inline void StoreItemID::clear_bundleid() {
  bundleid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StoreItemID::_internal_bundleid() const {
  return bundleid_;
}
inline uint32_t StoreItemID::bundleid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.bundleid)
  return _internal_bundleid();
}
inline void StoreItemID::_internal_set_bundleid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  bundleid_ = value;
}
inline void StoreItemID::set_bundleid(uint32_t value) {
  _internal_set_bundleid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.bundleid)
}

// optional uint32 tagid = 4;
inline bool StoreItemID::_internal_has_tagid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItemID::has_tagid() const {
  return _internal_has_tagid();
}
inline void StoreItemID::clear_tagid() {
  tagid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StoreItemID::_internal_tagid() const {
  return tagid_;
}
inline uint32_t StoreItemID::tagid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.tagid)
  return _internal_tagid();
}
inline void StoreItemID::_internal_set_tagid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  tagid_ = value;
}
inline void StoreItemID::set_tagid(uint32_t value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.tagid)
}

// optional uint32 creatorid = 5;
inline bool StoreItemID::_internal_has_creatorid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItemID::has_creatorid() const {
  return _internal_has_creatorid();
}
inline void StoreItemID::clear_creatorid() {
  creatorid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t StoreItemID::_internal_creatorid() const {
  return creatorid_;
}
inline uint32_t StoreItemID::creatorid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.creatorid)
  return _internal_creatorid();
}
inline void StoreItemID::_internal_set_creatorid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  creatorid_ = value;
}
inline void StoreItemID::set_creatorid(uint32_t value) {
  _internal_set_creatorid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.creatorid)
}

// optional uint32 hubcategoryid = 6;
inline bool StoreItemID::_internal_has_hubcategoryid() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreItemID::has_hubcategoryid() const {
  return _internal_has_hubcategoryid();
}
inline void StoreItemID::clear_hubcategoryid() {
  hubcategoryid_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t StoreItemID::_internal_hubcategoryid() const {
  return hubcategoryid_;
}
inline uint32_t StoreItemID::hubcategoryid() const {
  // @@protoc_insertion_point(field_get:StoreItemID.hubcategoryid)
  return _internal_hubcategoryid();
}
inline void StoreItemID::_internal_set_hubcategoryid(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  hubcategoryid_ = value;
}
inline void StoreItemID::set_hubcategoryid(uint32_t value) {
  _internal_set_hubcategoryid(value);
  // @@protoc_insertion_point(field_set:StoreItemID.hubcategoryid)
}

// -------------------------------------------------------------------

// StoreBrowseContext

// optional string language = 1;
inline bool StoreBrowseContext::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreBrowseContext::has_language() const {
  return _internal_has_language();
}
inline void StoreBrowseContext::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreBrowseContext::language() const {
  // @@protoc_insertion_point(field_get:StoreBrowseContext.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreBrowseContext::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreBrowseContext.language)
}
inline std::string* StoreBrowseContext::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:StoreBrowseContext.language)
  return _s;
}
inline const std::string& StoreBrowseContext::_internal_language() const {
  return language_.Get();
}
inline void StoreBrowseContext::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreBrowseContext::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000001u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreBrowseContext::release_language() {
  // @@protoc_insertion_point(field_release:StoreBrowseContext.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreBrowseContext::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreBrowseContext.language)
}

// optional int32 elanguage = 2 [(.description) = "ELanguage"];
inline bool StoreBrowseContext::_internal_has_elanguage() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreBrowseContext::has_elanguage() const {
  return _internal_has_elanguage();
}
inline void StoreBrowseContext::clear_elanguage() {
  elanguage_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t StoreBrowseContext::_internal_elanguage() const {
  return elanguage_;
}
inline int32_t StoreBrowseContext::elanguage() const {
  // @@protoc_insertion_point(field_get:StoreBrowseContext.elanguage)
  return _internal_elanguage();
}
inline void StoreBrowseContext::_internal_set_elanguage(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  elanguage_ = value;
}
inline void StoreBrowseContext::set_elanguage(int32_t value) {
  _internal_set_elanguage(value);
  // @@protoc_insertion_point(field_set:StoreBrowseContext.elanguage)
}

// optional string country_code = 3 [(.description) = "2-character country code; required"];
inline bool StoreBrowseContext::_internal_has_country_code() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreBrowseContext::has_country_code() const {
  return _internal_has_country_code();
}
inline void StoreBrowseContext::clear_country_code() {
  country_code_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreBrowseContext::country_code() const {
  // @@protoc_insertion_point(field_get:StoreBrowseContext.country_code)
  return _internal_country_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreBrowseContext::set_country_code(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreBrowseContext.country_code)
}
inline std::string* StoreBrowseContext::mutable_country_code() {
  std::string* _s = _internal_mutable_country_code();
  // @@protoc_insertion_point(field_mutable:StoreBrowseContext.country_code)
  return _s;
}
inline const std::string& StoreBrowseContext::_internal_country_code() const {
  return country_code_.Get();
}
inline void StoreBrowseContext::_internal_set_country_code(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  country_code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreBrowseContext::_internal_mutable_country_code() {
  _has_bits_[0] |= 0x00000002u;
  return country_code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreBrowseContext::release_country_code() {
  // @@protoc_insertion_point(field_release:StoreBrowseContext.country_code)
  if (!_internal_has_country_code()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = country_code_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreBrowseContext::set_allocated_country_code(std::string* country_code) {
  if (country_code != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  country_code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), country_code,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (country_code_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    country_code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreBrowseContext.country_code)
}

// optional int32 steam_realm = 4 [(.description) = "ESteamRealm"];
inline bool StoreBrowseContext::_internal_has_steam_realm() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreBrowseContext::has_steam_realm() const {
  return _internal_has_steam_realm();
}
inline void StoreBrowseContext::clear_steam_realm() {
  steam_realm_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t StoreBrowseContext::_internal_steam_realm() const {
  return steam_realm_;
}
inline int32_t StoreBrowseContext::steam_realm() const {
  // @@protoc_insertion_point(field_get:StoreBrowseContext.steam_realm)
  return _internal_steam_realm();
}
inline void StoreBrowseContext::_internal_set_steam_realm(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  steam_realm_ = value;
}
inline void StoreBrowseContext::set_steam_realm(int32_t value) {
  _internal_set_steam_realm(value);
  // @@protoc_insertion_point(field_set:StoreBrowseContext.steam_realm)
}

// -------------------------------------------------------------------

// StoreBrowseItemDataRequest

// optional bool include_assets = 1;
inline bool StoreBrowseItemDataRequest::_internal_has_include_assets() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_assets() const {
  return _internal_has_include_assets();
}
inline void StoreBrowseItemDataRequest::clear_include_assets() {
  include_assets_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_assets() const {
  return include_assets_;
}
inline bool StoreBrowseItemDataRequest::include_assets() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_assets)
  return _internal_include_assets();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_assets(bool value) {
  _has_bits_[0] |= 0x00000001u;
  include_assets_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_assets(bool value) {
  _internal_set_include_assets(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_assets)
}

// optional bool include_release = 2;
inline bool StoreBrowseItemDataRequest::_internal_has_include_release() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_release() const {
  return _internal_has_include_release();
}
inline void StoreBrowseItemDataRequest::clear_include_release() {
  include_release_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_release() const {
  return include_release_;
}
inline bool StoreBrowseItemDataRequest::include_release() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_release)
  return _internal_include_release();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_release(bool value) {
  _has_bits_[0] |= 0x00000002u;
  include_release_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_release(bool value) {
  _internal_set_include_release(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_release)
}

// optional bool include_platforms = 3;
inline bool StoreBrowseItemDataRequest::_internal_has_include_platforms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_platforms() const {
  return _internal_has_include_platforms();
}
inline void StoreBrowseItemDataRequest::clear_include_platforms() {
  include_platforms_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_platforms() const {
  return include_platforms_;
}
inline bool StoreBrowseItemDataRequest::include_platforms() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_platforms)
  return _internal_include_platforms();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_platforms(bool value) {
  _has_bits_[0] |= 0x00000004u;
  include_platforms_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_platforms(bool value) {
  _internal_set_include_platforms(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_platforms)
}

// optional bool include_all_purchase_options = 4;
inline bool StoreBrowseItemDataRequest::_internal_has_include_all_purchase_options() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_all_purchase_options() const {
  return _internal_has_include_all_purchase_options();
}
inline void StoreBrowseItemDataRequest::clear_include_all_purchase_options() {
  include_all_purchase_options_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_all_purchase_options() const {
  return include_all_purchase_options_;
}
inline bool StoreBrowseItemDataRequest::include_all_purchase_options() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_all_purchase_options)
  return _internal_include_all_purchase_options();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_all_purchase_options(bool value) {
  _has_bits_[0] |= 0x00000008u;
  include_all_purchase_options_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_all_purchase_options(bool value) {
  _internal_set_include_all_purchase_options(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_all_purchase_options)
}

// optional bool include_screenshots = 5;
inline bool StoreBrowseItemDataRequest::_internal_has_include_screenshots() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_screenshots() const {
  return _internal_has_include_screenshots();
}
inline void StoreBrowseItemDataRequest::clear_include_screenshots() {
  include_screenshots_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_screenshots() const {
  return include_screenshots_;
}
inline bool StoreBrowseItemDataRequest::include_screenshots() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_screenshots)
  return _internal_include_screenshots();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_screenshots(bool value) {
  _has_bits_[0] |= 0x00000010u;
  include_screenshots_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_screenshots(bool value) {
  _internal_set_include_screenshots(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_screenshots)
}

// optional bool include_trailers = 6;
inline bool StoreBrowseItemDataRequest::_internal_has_include_trailers() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_trailers() const {
  return _internal_has_include_trailers();
}
inline void StoreBrowseItemDataRequest::clear_include_trailers() {
  include_trailers_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_trailers() const {
  return include_trailers_;
}
inline bool StoreBrowseItemDataRequest::include_trailers() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_trailers)
  return _internal_include_trailers();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_trailers(bool value) {
  _has_bits_[0] |= 0x00000020u;
  include_trailers_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_trailers(bool value) {
  _internal_set_include_trailers(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_trailers)
}

// optional bool include_ratings = 7;
inline bool StoreBrowseItemDataRequest::_internal_has_include_ratings() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_ratings() const {
  return _internal_has_include_ratings();
}
inline void StoreBrowseItemDataRequest::clear_include_ratings() {
  include_ratings_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_ratings() const {
  return include_ratings_;
}
inline bool StoreBrowseItemDataRequest::include_ratings() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_ratings)
  return _internal_include_ratings();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_ratings(bool value) {
  _has_bits_[0] |= 0x00000040u;
  include_ratings_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_ratings(bool value) {
  _internal_set_include_ratings(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_ratings)
}

// optional int32 include_tag_count = 8 [(.description) = "Count of tags to return, as tagids.  Maximum 20."];
inline bool StoreBrowseItemDataRequest::_internal_has_include_tag_count() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_tag_count() const {
  return _internal_has_include_tag_count();
}
inline void StoreBrowseItemDataRequest::clear_include_tag_count() {
  include_tag_count_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t StoreBrowseItemDataRequest::_internal_include_tag_count() const {
  return include_tag_count_;
}
inline int32_t StoreBrowseItemDataRequest::include_tag_count() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_tag_count)
  return _internal_include_tag_count();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_tag_count(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  include_tag_count_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_tag_count(int32_t value) {
  _internal_set_include_tag_count(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_tag_count)
}

// optional bool include_reviews = 9;
inline bool StoreBrowseItemDataRequest::_internal_has_include_reviews() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_reviews() const {
  return _internal_has_include_reviews();
}
inline void StoreBrowseItemDataRequest::clear_include_reviews() {
  include_reviews_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_reviews() const {
  return include_reviews_;
}
inline bool StoreBrowseItemDataRequest::include_reviews() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_reviews)
  return _internal_include_reviews();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_reviews(bool value) {
  _has_bits_[0] |= 0x00000080u;
  include_reviews_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_reviews(bool value) {
  _internal_set_include_reviews(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_reviews)
}

// optional bool include_basic_info = 10 [(.description) = "Include short description, publisher, developers"];
inline bool StoreBrowseItemDataRequest::_internal_has_include_basic_info() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_basic_info() const {
  return _internal_has_include_basic_info();
}
inline void StoreBrowseItemDataRequest::clear_include_basic_info() {
  include_basic_info_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_basic_info() const {
  return include_basic_info_;
}
inline bool StoreBrowseItemDataRequest::include_basic_info() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_basic_info)
  return _internal_include_basic_info();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_basic_info(bool value) {
  _has_bits_[0] |= 0x00000200u;
  include_basic_info_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_basic_info(bool value) {
  _internal_set_include_basic_info(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_basic_info)
}

// optional bool include_supported_languages = 11 [(.description) = "includes the games support for languages: supported, full_audio, subtitles"];
inline bool StoreBrowseItemDataRequest::_internal_has_include_supported_languages() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_supported_languages() const {
  return _internal_has_include_supported_languages();
}
inline void StoreBrowseItemDataRequest::clear_include_supported_languages() {
  include_supported_languages_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_supported_languages() const {
  return include_supported_languages_;
}
inline bool StoreBrowseItemDataRequest::include_supported_languages() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_supported_languages)
  return _internal_include_supported_languages();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_supported_languages(bool value) {
  _has_bits_[0] |= 0x00000400u;
  include_supported_languages_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_supported_languages(bool value) {
  _internal_set_include_supported_languages(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_supported_languages)
}

// optional bool include_full_description = 12;
inline bool StoreBrowseItemDataRequest::_internal_has_include_full_description() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StoreBrowseItemDataRequest::has_include_full_description() const {
  return _internal_has_include_full_description();
}
inline void StoreBrowseItemDataRequest::clear_include_full_description() {
  include_full_description_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool StoreBrowseItemDataRequest::_internal_include_full_description() const {
  return include_full_description_;
}
inline bool StoreBrowseItemDataRequest::include_full_description() const {
  // @@protoc_insertion_point(field_get:StoreBrowseItemDataRequest.include_full_description)
  return _internal_include_full_description();
}
inline void StoreBrowseItemDataRequest::_internal_set_include_full_description(bool value) {
  _has_bits_[0] |= 0x00000800u;
  include_full_description_ = value;
}
inline void StoreBrowseItemDataRequest::set_include_full_description(bool value) {
  _internal_set_include_full_description(value);
  // @@protoc_insertion_point(field_set:StoreBrowseItemDataRequest.include_full_description)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetItems_Request

// repeated .StoreItemID ids = 1;
inline int CStoreBrowse_GetItems_Request::_internal_ids_size() const {
  return ids_.size();
}
inline int CStoreBrowse_GetItems_Request::ids_size() const {
  return _internal_ids_size();
}
inline void CStoreBrowse_GetItems_Request::clear_ids() {
  ids_.Clear();
}
inline ::StoreItemID* CStoreBrowse_GetItems_Request::mutable_ids(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetItems_Request.ids)
  return ids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >*
CStoreBrowse_GetItems_Request::mutable_ids() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetItems_Request.ids)
  return &ids_;
}
inline const ::StoreItemID& CStoreBrowse_GetItems_Request::_internal_ids(int index) const {
  return ids_.Get(index);
}
inline const ::StoreItemID& CStoreBrowse_GetItems_Request::ids(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetItems_Request.ids)
  return _internal_ids(index);
}
inline ::StoreItemID* CStoreBrowse_GetItems_Request::_internal_add_ids() {
  return ids_.Add();
}
inline ::StoreItemID* CStoreBrowse_GetItems_Request::add_ids() {
  ::StoreItemID* _add = _internal_add_ids();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetItems_Request.ids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >&
CStoreBrowse_GetItems_Request::ids() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetItems_Request.ids)
  return ids_;
}

// optional .StoreBrowseContext context = 2;
inline bool CStoreBrowse_GetItems_Request::_internal_has_context() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || context_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetItems_Request::has_context() const {
  return _internal_has_context();
}
inline void CStoreBrowse_GetItems_Request::clear_context() {
  if (context_ != nullptr) context_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::StoreBrowseContext& CStoreBrowse_GetItems_Request::_internal_context() const {
  const ::StoreBrowseContext* p = context_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreBrowseContext&>(
      ::_StoreBrowseContext_default_instance_);
}
inline const ::StoreBrowseContext& CStoreBrowse_GetItems_Request::context() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetItems_Request.context)
  return _internal_context();
}
inline void CStoreBrowse_GetItems_Request::unsafe_arena_set_allocated_context(
    ::StoreBrowseContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetItems_Request.context)
}
inline ::StoreBrowseContext* CStoreBrowse_GetItems_Request::release_context() {
  _has_bits_[0] &= ~0x00000001u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetItems_Request::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetItems_Request.context)
  _has_bits_[0] &= ~0x00000001u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetItems_Request::_internal_mutable_context() {
  _has_bits_[0] |= 0x00000001u;
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreBrowseContext>(GetArenaForAllocation());
    context_ = p;
  }
  return context_;
}
inline ::StoreBrowseContext* CStoreBrowse_GetItems_Request::mutable_context() {
  ::StoreBrowseContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetItems_Request.context)
  return _msg;
}
inline void CStoreBrowse_GetItems_Request::set_allocated_context(::StoreBrowseContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreBrowseContext>::GetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetItems_Request.context)
}

// optional .StoreBrowseItemDataRequest data_request = 3;
inline bool CStoreBrowse_GetItems_Request::_internal_has_data_request() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || data_request_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetItems_Request::has_data_request() const {
  return _internal_has_data_request();
}
inline void CStoreBrowse_GetItems_Request::clear_data_request() {
  if (data_request_ != nullptr) data_request_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::StoreBrowseItemDataRequest& CStoreBrowse_GetItems_Request::_internal_data_request() const {
  const ::StoreBrowseItemDataRequest* p = data_request_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreBrowseItemDataRequest&>(
      ::_StoreBrowseItemDataRequest_default_instance_);
}
inline const ::StoreBrowseItemDataRequest& CStoreBrowse_GetItems_Request::data_request() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetItems_Request.data_request)
  return _internal_data_request();
}
inline void CStoreBrowse_GetItems_Request::unsafe_arena_set_allocated_data_request(
    ::StoreBrowseItemDataRequest* data_request) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(data_request_);
  }
  data_request_ = data_request;
  if (data_request) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetItems_Request.data_request)
}
inline ::StoreBrowseItemDataRequest* CStoreBrowse_GetItems_Request::release_data_request() {
  _has_bits_[0] &= ~0x00000002u;
  ::StoreBrowseItemDataRequest* temp = data_request_;
  data_request_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreBrowseItemDataRequest* CStoreBrowse_GetItems_Request::unsafe_arena_release_data_request() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetItems_Request.data_request)
  _has_bits_[0] &= ~0x00000002u;
  ::StoreBrowseItemDataRequest* temp = data_request_;
  data_request_ = nullptr;
  return temp;
}
inline ::StoreBrowseItemDataRequest* CStoreBrowse_GetItems_Request::_internal_mutable_data_request() {
  _has_bits_[0] |= 0x00000002u;
  if (data_request_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreBrowseItemDataRequest>(GetArenaForAllocation());
    data_request_ = p;
  }
  return data_request_;
}
inline ::StoreBrowseItemDataRequest* CStoreBrowse_GetItems_Request::mutable_data_request() {
  ::StoreBrowseItemDataRequest* _msg = _internal_mutable_data_request();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetItems_Request.data_request)
  return _msg;
}
inline void CStoreBrowse_GetItems_Request::set_allocated_data_request(::StoreBrowseItemDataRequest* data_request) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete data_request_;
  }
  if (data_request) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreBrowseItemDataRequest>::GetOwningArena(data_request);
    if (message_arena != submessage_arena) {
      data_request = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, data_request, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_request_ = data_request;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetItems_Request.data_request)
}

// -------------------------------------------------------------------

// StoreGameRating

// optional string type = 1 [(.description) = "\'esrb\', \'pegi\', ..."];
inline bool StoreGameRating::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreGameRating::has_type() const {
  return _internal_has_type();
}
inline void StoreGameRating::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreGameRating::type() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGameRating::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreGameRating.type)
}
inline std::string* StoreGameRating::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:StoreGameRating.type)
  return _s;
}
inline const std::string& StoreGameRating::_internal_type() const {
  return type_.Get();
}
inline void StoreGameRating::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreGameRating::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreGameRating::release_type() {
  // @@protoc_insertion_point(field_release:StoreGameRating.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGameRating::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreGameRating.type)
}

// optional string rating = 2 [(.description) = "\'t\' for teen, \'m\' for mature, ..."];
inline bool StoreGameRating::_internal_has_rating() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreGameRating::has_rating() const {
  return _internal_has_rating();
}
inline void StoreGameRating::clear_rating() {
  rating_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreGameRating::rating() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.rating)
  return _internal_rating();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGameRating::set_rating(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 rating_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreGameRating.rating)
}
inline std::string* StoreGameRating::mutable_rating() {
  std::string* _s = _internal_mutable_rating();
  // @@protoc_insertion_point(field_mutable:StoreGameRating.rating)
  return _s;
}
inline const std::string& StoreGameRating::_internal_rating() const {
  return rating_.Get();
}
inline void StoreGameRating::_internal_set_rating(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  rating_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreGameRating::_internal_mutable_rating() {
  _has_bits_[0] |= 0x00000002u;
  return rating_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreGameRating::release_rating() {
  // @@protoc_insertion_point(field_release:StoreGameRating.rating)
  if (!_internal_has_rating()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = rating_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rating_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rating_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGameRating::set_allocated_rating(std::string* rating) {
  if (rating != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  rating_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rating,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rating_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rating_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreGameRating.rating)
}

// repeated string descriptors = 3 [(.description) = "Additional descriptors like \'Intense Violence\', \'Strong Language\',..."];
inline int StoreGameRating::_internal_descriptors_size() const {
  return descriptors_.size();
}
inline int StoreGameRating::descriptors_size() const {
  return _internal_descriptors_size();
}
inline void StoreGameRating::clear_descriptors() {
  descriptors_.Clear();
}
inline std::string* StoreGameRating::add_descriptors() {
  std::string* _s = _internal_add_descriptors();
  // @@protoc_insertion_point(field_add_mutable:StoreGameRating.descriptors)
  return _s;
}
inline const std::string& StoreGameRating::_internal_descriptors(int index) const {
  return descriptors_.Get(index);
}
inline const std::string& StoreGameRating::descriptors(int index) const {
  // @@protoc_insertion_point(field_get:StoreGameRating.descriptors)
  return _internal_descriptors(index);
}
inline std::string* StoreGameRating::mutable_descriptors(int index) {
  // @@protoc_insertion_point(field_mutable:StoreGameRating.descriptors)
  return descriptors_.Mutable(index);
}
inline void StoreGameRating::set_descriptors(int index, const std::string& value) {
  descriptors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:StoreGameRating.descriptors)
}
inline void StoreGameRating::set_descriptors(int index, std::string&& value) {
  descriptors_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:StoreGameRating.descriptors)
}
inline void StoreGameRating::set_descriptors(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  descriptors_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:StoreGameRating.descriptors)
}
inline void StoreGameRating::set_descriptors(int index, const char* value, size_t size) {
  descriptors_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:StoreGameRating.descriptors)
}
inline std::string* StoreGameRating::_internal_add_descriptors() {
  return descriptors_.Add();
}
inline void StoreGameRating::add_descriptors(const std::string& value) {
  descriptors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:StoreGameRating.descriptors)
}
inline void StoreGameRating::add_descriptors(std::string&& value) {
  descriptors_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:StoreGameRating.descriptors)
}
inline void StoreGameRating::add_descriptors(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  descriptors_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:StoreGameRating.descriptors)
}
inline void StoreGameRating::add_descriptors(const char* value, size_t size) {
  descriptors_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:StoreGameRating.descriptors)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
StoreGameRating::descriptors() const {
  // @@protoc_insertion_point(field_list:StoreGameRating.descriptors)
  return descriptors_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
StoreGameRating::mutable_descriptors() {
  // @@protoc_insertion_point(field_mutable_list:StoreGameRating.descriptors)
  return &descriptors_;
}

// optional string interactive_elements = 4 [(.description) = "ESRB-specific"];
inline bool StoreGameRating::_internal_has_interactive_elements() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreGameRating::has_interactive_elements() const {
  return _internal_has_interactive_elements();
}
inline void StoreGameRating::clear_interactive_elements() {
  interactive_elements_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreGameRating::interactive_elements() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.interactive_elements)
  return _internal_interactive_elements();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGameRating::set_interactive_elements(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 interactive_elements_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreGameRating.interactive_elements)
}
inline std::string* StoreGameRating::mutable_interactive_elements() {
  std::string* _s = _internal_mutable_interactive_elements();
  // @@protoc_insertion_point(field_mutable:StoreGameRating.interactive_elements)
  return _s;
}
inline const std::string& StoreGameRating::_internal_interactive_elements() const {
  return interactive_elements_.Get();
}
inline void StoreGameRating::_internal_set_interactive_elements(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  interactive_elements_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreGameRating::_internal_mutable_interactive_elements() {
  _has_bits_[0] |= 0x00000004u;
  return interactive_elements_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreGameRating::release_interactive_elements() {
  // @@protoc_insertion_point(field_release:StoreGameRating.interactive_elements)
  if (!_internal_has_interactive_elements()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = interactive_elements_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (interactive_elements_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    interactive_elements_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGameRating::set_allocated_interactive_elements(std::string* interactive_elements) {
  if (interactive_elements != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  interactive_elements_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), interactive_elements,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (interactive_elements_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    interactive_elements_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreGameRating.interactive_elements)
}

// optional int32 required_age = 10 [(.description) = "Age in years.  Store pages will prompt with an age gate"];
inline bool StoreGameRating::_internal_has_required_age() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreGameRating::has_required_age() const {
  return _internal_has_required_age();
}
inline void StoreGameRating::clear_required_age() {
  required_age_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t StoreGameRating::_internal_required_age() const {
  return required_age_;
}
inline int32_t StoreGameRating::required_age() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.required_age)
  return _internal_required_age();
}
inline void StoreGameRating::_internal_set_required_age(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  required_age_ = value;
}
inline void StoreGameRating::set_required_age(int32_t value) {
  _internal_set_required_age(value);
  // @@protoc_insertion_point(field_set:StoreGameRating.required_age)
}

// optional bool use_age_gate = 11;
inline bool StoreGameRating::_internal_has_use_age_gate() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StoreGameRating::has_use_age_gate() const {
  return _internal_has_use_age_gate();
}
inline void StoreGameRating::clear_use_age_gate() {
  use_age_gate_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool StoreGameRating::_internal_use_age_gate() const {
  return use_age_gate_;
}
inline bool StoreGameRating::use_age_gate() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.use_age_gate)
  return _internal_use_age_gate();
}
inline void StoreGameRating::_internal_set_use_age_gate(bool value) {
  _has_bits_[0] |= 0x00000040u;
  use_age_gate_ = value;
}
inline void StoreGameRating::set_use_age_gate(bool value) {
  _internal_set_use_age_gate(value);
  // @@protoc_insertion_point(field_set:StoreGameRating.use_age_gate)
}

// optional string image_url = 20 [(.description) = "An image corresponding to the rating."];
inline bool StoreGameRating::_internal_has_image_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreGameRating::has_image_url() const {
  return _internal_has_image_url();
}
inline void StoreGameRating::clear_image_url() {
  image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StoreGameRating::image_url() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGameRating::set_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreGameRating.image_url)
}
inline std::string* StoreGameRating::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:StoreGameRating.image_url)
  return _s;
}
inline const std::string& StoreGameRating::_internal_image_url() const {
  return image_url_.Get();
}
inline void StoreGameRating::_internal_set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreGameRating::_internal_mutable_image_url() {
  _has_bits_[0] |= 0x00000008u;
  return image_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreGameRating::release_image_url() {
  // @@protoc_insertion_point(field_release:StoreGameRating.image_url)
  if (!_internal_has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = image_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGameRating::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  image_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreGameRating.image_url)
}

// optional string image_target = 21 [(.description) = "URL where the image should link for more information."];
inline bool StoreGameRating::_internal_has_image_target() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreGameRating::has_image_target() const {
  return _internal_has_image_target();
}
inline void StoreGameRating::clear_image_target() {
  image_target_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StoreGameRating::image_target() const {
  // @@protoc_insertion_point(field_get:StoreGameRating.image_target)
  return _internal_image_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreGameRating::set_image_target(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 image_target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreGameRating.image_target)
}
inline std::string* StoreGameRating::mutable_image_target() {
  std::string* _s = _internal_mutable_image_target();
  // @@protoc_insertion_point(field_mutable:StoreGameRating.image_target)
  return _s;
}
inline const std::string& StoreGameRating::_internal_image_target() const {
  return image_target_.Get();
}
inline void StoreGameRating::_internal_set_image_target(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  image_target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreGameRating::_internal_mutable_image_target() {
  _has_bits_[0] |= 0x00000010u;
  return image_target_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreGameRating::release_image_target() {
  // @@protoc_insertion_point(field_release:StoreGameRating.image_target)
  if (!_internal_has_image_target()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = image_target_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_target_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreGameRating::set_allocated_image_target(std::string* image_target) {
  if (image_target != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  image_target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_target,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_target_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_target_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreGameRating.image_target)
}

// -------------------------------------------------------------------

// StoreItem_RelatedItems

// optional uint32 parent_appid = 1 [(.description) = "For DLC, Demos, etc, this is the main app."];
inline bool StoreItem_RelatedItems::_internal_has_parent_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_RelatedItems::has_parent_appid() const {
  return _internal_has_parent_appid();
}
inline void StoreItem_RelatedItems::clear_parent_appid() {
  parent_appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StoreItem_RelatedItems::_internal_parent_appid() const {
  return parent_appid_;
}
inline uint32_t StoreItem_RelatedItems::parent_appid() const {
  // @@protoc_insertion_point(field_get:StoreItem.RelatedItems.parent_appid)
  return _internal_parent_appid();
}
inline void StoreItem_RelatedItems::_internal_set_parent_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  parent_appid_ = value;
}
inline void StoreItem_RelatedItems::set_parent_appid(uint32_t value) {
  _internal_set_parent_appid(value);
  // @@protoc_insertion_point(field_set:StoreItem.RelatedItems.parent_appid)
}

// -------------------------------------------------------------------

// StoreItem_Categories

// repeated uint32 supported_player_categoryids = 2 [(.description) = "Categories like Single Player, Multiplayer, MMO"];
inline int StoreItem_Categories::_internal_supported_player_categoryids_size() const {
  return supported_player_categoryids_.size();
}
inline int StoreItem_Categories::supported_player_categoryids_size() const {
  return _internal_supported_player_categoryids_size();
}
inline void StoreItem_Categories::clear_supported_player_categoryids() {
  supported_player_categoryids_.Clear();
}
inline uint32_t StoreItem_Categories::_internal_supported_player_categoryids(int index) const {
  return supported_player_categoryids_.Get(index);
}
inline uint32_t StoreItem_Categories::supported_player_categoryids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Categories.supported_player_categoryids)
  return _internal_supported_player_categoryids(index);
}
inline void StoreItem_Categories::set_supported_player_categoryids(int index, uint32_t value) {
  supported_player_categoryids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.Categories.supported_player_categoryids)
}
inline void StoreItem_Categories::_internal_add_supported_player_categoryids(uint32_t value) {
  supported_player_categoryids_.Add(value);
}
inline void StoreItem_Categories::add_supported_player_categoryids(uint32_t value) {
  _internal_add_supported_player_categoryids(value);
  // @@protoc_insertion_point(field_add:StoreItem.Categories.supported_player_categoryids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::_internal_supported_player_categoryids() const {
  return supported_player_categoryids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::supported_player_categoryids() const {
  // @@protoc_insertion_point(field_list:StoreItem.Categories.supported_player_categoryids)
  return _internal_supported_player_categoryids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::_internal_mutable_supported_player_categoryids() {
  return &supported_player_categoryids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::mutable_supported_player_categoryids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Categories.supported_player_categoryids)
  return _internal_mutable_supported_player_categoryids();
}

// repeated uint32 feature_categoryids = 3 [(.description) = "Categories indicating supported features like Steam Cloud, VAC, Achievements, etc"];
inline int StoreItem_Categories::_internal_feature_categoryids_size() const {
  return feature_categoryids_.size();
}
inline int StoreItem_Categories::feature_categoryids_size() const {
  return _internal_feature_categoryids_size();
}
inline void StoreItem_Categories::clear_feature_categoryids() {
  feature_categoryids_.Clear();
}
inline uint32_t StoreItem_Categories::_internal_feature_categoryids(int index) const {
  return feature_categoryids_.Get(index);
}
inline uint32_t StoreItem_Categories::feature_categoryids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Categories.feature_categoryids)
  return _internal_feature_categoryids(index);
}
inline void StoreItem_Categories::set_feature_categoryids(int index, uint32_t value) {
  feature_categoryids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.Categories.feature_categoryids)
}
inline void StoreItem_Categories::_internal_add_feature_categoryids(uint32_t value) {
  feature_categoryids_.Add(value);
}
inline void StoreItem_Categories::add_feature_categoryids(uint32_t value) {
  _internal_add_feature_categoryids(value);
  // @@protoc_insertion_point(field_add:StoreItem.Categories.feature_categoryids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::_internal_feature_categoryids() const {
  return feature_categoryids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::feature_categoryids() const {
  // @@protoc_insertion_point(field_list:StoreItem.Categories.feature_categoryids)
  return _internal_feature_categoryids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::_internal_mutable_feature_categoryids() {
  return &feature_categoryids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::mutable_feature_categoryids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Categories.feature_categoryids)
  return _internal_mutable_feature_categoryids();
}

// repeated uint32 controller_categoryids = 4 [(.description) = "Categories indicating controller support and full controller support."];
inline int StoreItem_Categories::_internal_controller_categoryids_size() const {
  return controller_categoryids_.size();
}
inline int StoreItem_Categories::controller_categoryids_size() const {
  return _internal_controller_categoryids_size();
}
inline void StoreItem_Categories::clear_controller_categoryids() {
  controller_categoryids_.Clear();
}
inline uint32_t StoreItem_Categories::_internal_controller_categoryids(int index) const {
  return controller_categoryids_.Get(index);
}
inline uint32_t StoreItem_Categories::controller_categoryids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Categories.controller_categoryids)
  return _internal_controller_categoryids(index);
}
inline void StoreItem_Categories::set_controller_categoryids(int index, uint32_t value) {
  controller_categoryids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.Categories.controller_categoryids)
}
inline void StoreItem_Categories::_internal_add_controller_categoryids(uint32_t value) {
  controller_categoryids_.Add(value);
}
inline void StoreItem_Categories::add_controller_categoryids(uint32_t value) {
  _internal_add_controller_categoryids(value);
  // @@protoc_insertion_point(field_add:StoreItem.Categories.controller_categoryids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::_internal_controller_categoryids() const {
  return controller_categoryids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem_Categories::controller_categoryids() const {
  // @@protoc_insertion_point(field_list:StoreItem.Categories.controller_categoryids)
  return _internal_controller_categoryids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::_internal_mutable_controller_categoryids() {
  return &controller_categoryids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem_Categories::mutable_controller_categoryids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Categories.controller_categoryids)
  return _internal_mutable_controller_categoryids();
}

// -------------------------------------------------------------------

// StoreItem_Reviews_StoreReviewSummary

// optional uint32 review_count = 1;
inline bool StoreItem_Reviews_StoreReviewSummary::_internal_has_review_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Reviews_StoreReviewSummary::has_review_count() const {
  return _internal_has_review_count();
}
inline void StoreItem_Reviews_StoreReviewSummary::clear_review_count() {
  review_count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StoreItem_Reviews_StoreReviewSummary::_internal_review_count() const {
  return review_count_;
}
inline uint32_t StoreItem_Reviews_StoreReviewSummary::review_count() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.StoreReviewSummary.review_count)
  return _internal_review_count();
}
inline void StoreItem_Reviews_StoreReviewSummary::_internal_set_review_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  review_count_ = value;
}
inline void StoreItem_Reviews_StoreReviewSummary::set_review_count(uint32_t value) {
  _internal_set_review_count(value);
  // @@protoc_insertion_point(field_set:StoreItem.Reviews.StoreReviewSummary.review_count)
}

// optional int32 percent_positive = 2 [(.description) = "0-100"];
inline bool StoreItem_Reviews_StoreReviewSummary::_internal_has_percent_positive() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_Reviews_StoreReviewSummary::has_percent_positive() const {
  return _internal_has_percent_positive();
}
inline void StoreItem_Reviews_StoreReviewSummary::clear_percent_positive() {
  percent_positive_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t StoreItem_Reviews_StoreReviewSummary::_internal_percent_positive() const {
  return percent_positive_;
}
inline int32_t StoreItem_Reviews_StoreReviewSummary::percent_positive() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.StoreReviewSummary.percent_positive)
  return _internal_percent_positive();
}
inline void StoreItem_Reviews_StoreReviewSummary::_internal_set_percent_positive(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  percent_positive_ = value;
}
inline void StoreItem_Reviews_StoreReviewSummary::set_percent_positive(int32_t value) {
  _internal_set_percent_positive(value);
  // @@protoc_insertion_point(field_set:StoreItem.Reviews.StoreReviewSummary.percent_positive)
}

// optional .EUserReviewScore review_score = 3 [default = k_EUserReviewScore_None];
inline bool StoreItem_Reviews_StoreReviewSummary::_internal_has_review_score() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_Reviews_StoreReviewSummary::has_review_score() const {
  return _internal_has_review_score();
}
inline void StoreItem_Reviews_StoreReviewSummary::clear_review_score() {
  review_score_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EUserReviewScore StoreItem_Reviews_StoreReviewSummary::_internal_review_score() const {
  return static_cast< ::EUserReviewScore >(review_score_);
}
inline ::EUserReviewScore StoreItem_Reviews_StoreReviewSummary::review_score() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.StoreReviewSummary.review_score)
  return _internal_review_score();
}
inline void StoreItem_Reviews_StoreReviewSummary::_internal_set_review_score(::EUserReviewScore value) {
  assert(::EUserReviewScore_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  review_score_ = value;
}
inline void StoreItem_Reviews_StoreReviewSummary::set_review_score(::EUserReviewScore value) {
  _internal_set_review_score(value);
  // @@protoc_insertion_point(field_set:StoreItem.Reviews.StoreReviewSummary.review_score)
}

// optional string review_score_label = 4 [(.description) = "A string like \'Mixed\', \'Negative\', \'Overwhelmingly Positive\'"];
inline bool StoreItem_Reviews_StoreReviewSummary::_internal_has_review_score_label() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Reviews_StoreReviewSummary::has_review_score_label() const {
  return _internal_has_review_score_label();
}
inline void StoreItem_Reviews_StoreReviewSummary::clear_review_score_label() {
  review_score_label_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_Reviews_StoreReviewSummary::review_score_label() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.StoreReviewSummary.review_score_label)
  return _internal_review_score_label();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Reviews_StoreReviewSummary::set_review_score_label(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 review_score_label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Reviews.StoreReviewSummary.review_score_label)
}
inline std::string* StoreItem_Reviews_StoreReviewSummary::mutable_review_score_label() {
  std::string* _s = _internal_mutable_review_score_label();
  // @@protoc_insertion_point(field_mutable:StoreItem.Reviews.StoreReviewSummary.review_score_label)
  return _s;
}
inline const std::string& StoreItem_Reviews_StoreReviewSummary::_internal_review_score_label() const {
  return review_score_label_.Get();
}
inline void StoreItem_Reviews_StoreReviewSummary::_internal_set_review_score_label(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  review_score_label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Reviews_StoreReviewSummary::_internal_mutable_review_score_label() {
  _has_bits_[0] |= 0x00000001u;
  return review_score_label_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Reviews_StoreReviewSummary::release_review_score_label() {
  // @@protoc_insertion_point(field_release:StoreItem.Reviews.StoreReviewSummary.review_score_label)
  if (!_internal_has_review_score_label()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = review_score_label_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (review_score_label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    review_score_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Reviews_StoreReviewSummary::set_allocated_review_score_label(std::string* review_score_label) {
  if (review_score_label != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  review_score_label_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), review_score_label,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (review_score_label_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    review_score_label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Reviews.StoreReviewSummary.review_score_label)
}

// -------------------------------------------------------------------

// StoreItem_Reviews

// optional .StoreItem.Reviews.StoreReviewSummary summary_filtered = 1 [(.description) = "Review summary with review bombs removed (if any).  Always present (if include_reviews set in request)"];
inline bool StoreItem_Reviews::_internal_has_summary_filtered() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || summary_filtered_ != nullptr);
  return value;
}
inline bool StoreItem_Reviews::has_summary_filtered() const {
  return _internal_has_summary_filtered();
}
inline void StoreItem_Reviews::clear_summary_filtered() {
  if (summary_filtered_ != nullptr) summary_filtered_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::StoreItem_Reviews_StoreReviewSummary& StoreItem_Reviews::_internal_summary_filtered() const {
  const ::StoreItem_Reviews_StoreReviewSummary* p = summary_filtered_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Reviews_StoreReviewSummary&>(
      ::_StoreItem_Reviews_StoreReviewSummary_default_instance_);
}
inline const ::StoreItem_Reviews_StoreReviewSummary& StoreItem_Reviews::summary_filtered() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.summary_filtered)
  return _internal_summary_filtered();
}
inline void StoreItem_Reviews::unsafe_arena_set_allocated_summary_filtered(
    ::StoreItem_Reviews_StoreReviewSummary* summary_filtered) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(summary_filtered_);
  }
  summary_filtered_ = summary_filtered;
  if (summary_filtered) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.Reviews.summary_filtered)
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::release_summary_filtered() {
  _has_bits_[0] &= ~0x00000001u;
  ::StoreItem_Reviews_StoreReviewSummary* temp = summary_filtered_;
  summary_filtered_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::unsafe_arena_release_summary_filtered() {
  // @@protoc_insertion_point(field_release:StoreItem.Reviews.summary_filtered)
  _has_bits_[0] &= ~0x00000001u;
  ::StoreItem_Reviews_StoreReviewSummary* temp = summary_filtered_;
  summary_filtered_ = nullptr;
  return temp;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::_internal_mutable_summary_filtered() {
  _has_bits_[0] |= 0x00000001u;
  if (summary_filtered_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Reviews_StoreReviewSummary>(GetArenaForAllocation());
    summary_filtered_ = p;
  }
  return summary_filtered_;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::mutable_summary_filtered() {
  ::StoreItem_Reviews_StoreReviewSummary* _msg = _internal_mutable_summary_filtered();
  // @@protoc_insertion_point(field_mutable:StoreItem.Reviews.summary_filtered)
  return _msg;
}
inline void StoreItem_Reviews::set_allocated_summary_filtered(::StoreItem_Reviews_StoreReviewSummary* summary_filtered) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete summary_filtered_;
  }
  if (summary_filtered) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Reviews_StoreReviewSummary>::GetOwningArena(summary_filtered);
    if (message_arena != submessage_arena) {
      summary_filtered = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary_filtered, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  summary_filtered_ = summary_filtered;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Reviews.summary_filtered)
}

// optional .StoreItem.Reviews.StoreReviewSummary summary_unfiltered = 2 [(.description) = "Review summary with review bombs included.  Only present if there are review bombs."];
inline bool StoreItem_Reviews::_internal_has_summary_unfiltered() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || summary_unfiltered_ != nullptr);
  return value;
}
inline bool StoreItem_Reviews::has_summary_unfiltered() const {
  return _internal_has_summary_unfiltered();
}
inline void StoreItem_Reviews::clear_summary_unfiltered() {
  if (summary_unfiltered_ != nullptr) summary_unfiltered_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::StoreItem_Reviews_StoreReviewSummary& StoreItem_Reviews::_internal_summary_unfiltered() const {
  const ::StoreItem_Reviews_StoreReviewSummary* p = summary_unfiltered_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Reviews_StoreReviewSummary&>(
      ::_StoreItem_Reviews_StoreReviewSummary_default_instance_);
}
inline const ::StoreItem_Reviews_StoreReviewSummary& StoreItem_Reviews::summary_unfiltered() const {
  // @@protoc_insertion_point(field_get:StoreItem.Reviews.summary_unfiltered)
  return _internal_summary_unfiltered();
}
inline void StoreItem_Reviews::unsafe_arena_set_allocated_summary_unfiltered(
    ::StoreItem_Reviews_StoreReviewSummary* summary_unfiltered) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(summary_unfiltered_);
  }
  summary_unfiltered_ = summary_unfiltered;
  if (summary_unfiltered) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.Reviews.summary_unfiltered)
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::release_summary_unfiltered() {
  _has_bits_[0] &= ~0x00000002u;
  ::StoreItem_Reviews_StoreReviewSummary* temp = summary_unfiltered_;
  summary_unfiltered_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::unsafe_arena_release_summary_unfiltered() {
  // @@protoc_insertion_point(field_release:StoreItem.Reviews.summary_unfiltered)
  _has_bits_[0] &= ~0x00000002u;
  ::StoreItem_Reviews_StoreReviewSummary* temp = summary_unfiltered_;
  summary_unfiltered_ = nullptr;
  return temp;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::_internal_mutable_summary_unfiltered() {
  _has_bits_[0] |= 0x00000002u;
  if (summary_unfiltered_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Reviews_StoreReviewSummary>(GetArenaForAllocation());
    summary_unfiltered_ = p;
  }
  return summary_unfiltered_;
}
inline ::StoreItem_Reviews_StoreReviewSummary* StoreItem_Reviews::mutable_summary_unfiltered() {
  ::StoreItem_Reviews_StoreReviewSummary* _msg = _internal_mutable_summary_unfiltered();
  // @@protoc_insertion_point(field_mutable:StoreItem.Reviews.summary_unfiltered)
  return _msg;
}
inline void StoreItem_Reviews::set_allocated_summary_unfiltered(::StoreItem_Reviews_StoreReviewSummary* summary_unfiltered) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete summary_unfiltered_;
  }
  if (summary_unfiltered) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Reviews_StoreReviewSummary>::GetOwningArena(summary_unfiltered);
    if (message_arena != submessage_arena) {
      summary_unfiltered = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, summary_unfiltered, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  summary_unfiltered_ = summary_unfiltered;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Reviews.summary_unfiltered)
}

// -------------------------------------------------------------------

// StoreItem_BasicInfo_CreatorHomeLink

// optional string name = 1;
inline bool StoreItem_BasicInfo_CreatorHomeLink::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_BasicInfo_CreatorHomeLink::has_name() const {
  return _internal_has_name();
}
inline void StoreItem_BasicInfo_CreatorHomeLink::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_BasicInfo_CreatorHomeLink::name() const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.CreatorHomeLink.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_BasicInfo_CreatorHomeLink::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.BasicInfo.CreatorHomeLink.name)
}
inline std::string* StoreItem_BasicInfo_CreatorHomeLink::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.CreatorHomeLink.name)
  return _s;
}
inline const std::string& StoreItem_BasicInfo_CreatorHomeLink::_internal_name() const {
  return name_.Get();
}
inline void StoreItem_BasicInfo_CreatorHomeLink::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo_CreatorHomeLink::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo_CreatorHomeLink::release_name() {
  // @@protoc_insertion_point(field_release:StoreItem.BasicInfo.CreatorHomeLink.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_BasicInfo_CreatorHomeLink::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.BasicInfo.CreatorHomeLink.name)
}

// optional uint32 creator_clan_account_id = 2 [(.description) = "Optioanl field indicating this name is associated this the creator home via the clan account id"];
inline bool StoreItem_BasicInfo_CreatorHomeLink::_internal_has_creator_clan_account_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_BasicInfo_CreatorHomeLink::has_creator_clan_account_id() const {
  return _internal_has_creator_clan_account_id();
}
inline void StoreItem_BasicInfo_CreatorHomeLink::clear_creator_clan_account_id() {
  creator_clan_account_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StoreItem_BasicInfo_CreatorHomeLink::_internal_creator_clan_account_id() const {
  return creator_clan_account_id_;
}
inline uint32_t StoreItem_BasicInfo_CreatorHomeLink::creator_clan_account_id() const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.CreatorHomeLink.creator_clan_account_id)
  return _internal_creator_clan_account_id();
}
inline void StoreItem_BasicInfo_CreatorHomeLink::_internal_set_creator_clan_account_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  creator_clan_account_id_ = value;
}
inline void StoreItem_BasicInfo_CreatorHomeLink::set_creator_clan_account_id(uint32_t value) {
  _internal_set_creator_clan_account_id(value);
  // @@protoc_insertion_point(field_set:StoreItem.BasicInfo.CreatorHomeLink.creator_clan_account_id)
}

// -------------------------------------------------------------------

// StoreItem_BasicInfo

// optional string short_description = 1;
inline bool StoreItem_BasicInfo::_internal_has_short_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_BasicInfo::has_short_description() const {
  return _internal_has_short_description();
}
inline void StoreItem_BasicInfo::clear_short_description() {
  short_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_BasicInfo::short_description() const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.short_description)
  return _internal_short_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_BasicInfo::set_short_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 short_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.BasicInfo.short_description)
}
inline std::string* StoreItem_BasicInfo::mutable_short_description() {
  std::string* _s = _internal_mutable_short_description();
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.short_description)
  return _s;
}
inline const std::string& StoreItem_BasicInfo::_internal_short_description() const {
  return short_description_.Get();
}
inline void StoreItem_BasicInfo::_internal_set_short_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  short_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo::_internal_mutable_short_description() {
  _has_bits_[0] |= 0x00000001u;
  return short_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo::release_short_description() {
  // @@protoc_insertion_point(field_release:StoreItem.BasicInfo.short_description)
  if (!_internal_has_short_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = short_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (short_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    short_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_BasicInfo::set_allocated_short_description(std::string* short_description) {
  if (short_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  short_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), short_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (short_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    short_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.BasicInfo.short_description)
}

// repeated .StoreItem.BasicInfo.CreatorHomeLink publishers = 2;
inline int StoreItem_BasicInfo::_internal_publishers_size() const {
  return publishers_.size();
}
inline int StoreItem_BasicInfo::publishers_size() const {
  return _internal_publishers_size();
}
inline void StoreItem_BasicInfo::clear_publishers() {
  publishers_.Clear();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::mutable_publishers(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.publishers)
  return publishers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
StoreItem_BasicInfo::mutable_publishers() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.BasicInfo.publishers)
  return &publishers_;
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::_internal_publishers(int index) const {
  return publishers_.Get(index);
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::publishers(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.publishers)
  return _internal_publishers(index);
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::_internal_add_publishers() {
  return publishers_.Add();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::add_publishers() {
  ::StoreItem_BasicInfo_CreatorHomeLink* _add = _internal_add_publishers();
  // @@protoc_insertion_point(field_add:StoreItem.BasicInfo.publishers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
StoreItem_BasicInfo::publishers() const {
  // @@protoc_insertion_point(field_list:StoreItem.BasicInfo.publishers)
  return publishers_;
}

// repeated .StoreItem.BasicInfo.CreatorHomeLink developers = 3;
inline int StoreItem_BasicInfo::_internal_developers_size() const {
  return developers_.size();
}
inline int StoreItem_BasicInfo::developers_size() const {
  return _internal_developers_size();
}
inline void StoreItem_BasicInfo::clear_developers() {
  developers_.Clear();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::mutable_developers(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.developers)
  return developers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
StoreItem_BasicInfo::mutable_developers() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.BasicInfo.developers)
  return &developers_;
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::_internal_developers(int index) const {
  return developers_.Get(index);
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::developers(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.developers)
  return _internal_developers(index);
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::_internal_add_developers() {
  return developers_.Add();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::add_developers() {
  ::StoreItem_BasicInfo_CreatorHomeLink* _add = _internal_add_developers();
  // @@protoc_insertion_point(field_add:StoreItem.BasicInfo.developers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
StoreItem_BasicInfo::developers() const {
  // @@protoc_insertion_point(field_list:StoreItem.BasicInfo.developers)
  return developers_;
}

// repeated .StoreItem.BasicInfo.CreatorHomeLink franchises = 4;
inline int StoreItem_BasicInfo::_internal_franchises_size() const {
  return franchises_.size();
}
inline int StoreItem_BasicInfo::franchises_size() const {
  return _internal_franchises_size();
}
inline void StoreItem_BasicInfo::clear_franchises() {
  franchises_.Clear();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::mutable_franchises(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.franchises)
  return franchises_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >*
StoreItem_BasicInfo::mutable_franchises() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.BasicInfo.franchises)
  return &franchises_;
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::_internal_franchises(int index) const {
  return franchises_.Get(index);
}
inline const ::StoreItem_BasicInfo_CreatorHomeLink& StoreItem_BasicInfo::franchises(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.franchises)
  return _internal_franchises(index);
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::_internal_add_franchises() {
  return franchises_.Add();
}
inline ::StoreItem_BasicInfo_CreatorHomeLink* StoreItem_BasicInfo::add_franchises() {
  ::StoreItem_BasicInfo_CreatorHomeLink* _add = _internal_add_franchises();
  // @@protoc_insertion_point(field_add:StoreItem.BasicInfo.franchises)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_BasicInfo_CreatorHomeLink >&
StoreItem_BasicInfo::franchises() const {
  // @@protoc_insertion_point(field_list:StoreItem.BasicInfo.franchises)
  return franchises_;
}

// optional string capsule_headline = 5 [(.description) = "A custom string specified by the partner for display on or around a capsule on the store, e.g. \'Just Updated!\'"];
inline bool StoreItem_BasicInfo::_internal_has_capsule_headline() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_BasicInfo::has_capsule_headline() const {
  return _internal_has_capsule_headline();
}
inline void StoreItem_BasicInfo::clear_capsule_headline() {
  capsule_headline_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_BasicInfo::capsule_headline() const {
  // @@protoc_insertion_point(field_get:StoreItem.BasicInfo.capsule_headline)
  return _internal_capsule_headline();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_BasicInfo::set_capsule_headline(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 capsule_headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.BasicInfo.capsule_headline)
}
inline std::string* StoreItem_BasicInfo::mutable_capsule_headline() {
  std::string* _s = _internal_mutable_capsule_headline();
  // @@protoc_insertion_point(field_mutable:StoreItem.BasicInfo.capsule_headline)
  return _s;
}
inline const std::string& StoreItem_BasicInfo::_internal_capsule_headline() const {
  return capsule_headline_.Get();
}
inline void StoreItem_BasicInfo::_internal_set_capsule_headline(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  capsule_headline_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo::_internal_mutable_capsule_headline() {
  _has_bits_[0] |= 0x00000002u;
  return capsule_headline_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_BasicInfo::release_capsule_headline() {
  // @@protoc_insertion_point(field_release:StoreItem.BasicInfo.capsule_headline)
  if (!_internal_has_capsule_headline()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = capsule_headline_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (capsule_headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    capsule_headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_BasicInfo::set_allocated_capsule_headline(std::string* capsule_headline) {
  if (capsule_headline != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  capsule_headline_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), capsule_headline,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (capsule_headline_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    capsule_headline_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.BasicInfo.capsule_headline)
}

// -------------------------------------------------------------------

// StoreItem_Tag

// optional uint32 tagid = 1;
inline bool StoreItem_Tag::_internal_has_tagid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Tag::has_tagid() const {
  return _internal_has_tagid();
}
inline void StoreItem_Tag::clear_tagid() {
  tagid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t StoreItem_Tag::_internal_tagid() const {
  return tagid_;
}
inline uint32_t StoreItem_Tag::tagid() const {
  // @@protoc_insertion_point(field_get:StoreItem.Tag.tagid)
  return _internal_tagid();
}
inline void StoreItem_Tag::_internal_set_tagid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  tagid_ = value;
}
inline void StoreItem_Tag::set_tagid(uint32_t value) {
  _internal_set_tagid(value);
  // @@protoc_insertion_point(field_set:StoreItem.Tag.tagid)
}

// optional uint32 weight = 2;
inline bool StoreItem_Tag::_internal_has_weight() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Tag::has_weight() const {
  return _internal_has_weight();
}
inline void StoreItem_Tag::clear_weight() {
  weight_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StoreItem_Tag::_internal_weight() const {
  return weight_;
}
inline uint32_t StoreItem_Tag::weight() const {
  // @@protoc_insertion_point(field_get:StoreItem.Tag.weight)
  return _internal_weight();
}
inline void StoreItem_Tag::_internal_set_weight(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  weight_ = value;
}
inline void StoreItem_Tag::set_weight(uint32_t value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:StoreItem.Tag.weight)
}

// -------------------------------------------------------------------

// StoreItem_Assets

// optional string asset_url_format = 1 [(.description) = "Format for URLs, should substitute the capsule name for ${FILENAME} in the URL."];
inline bool StoreItem_Assets::_internal_has_asset_url_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_asset_url_format() const {
  return _internal_has_asset_url_format();
}
inline void StoreItem_Assets::clear_asset_url_format() {
  asset_url_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_Assets::asset_url_format() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.asset_url_format)
  return _internal_asset_url_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_asset_url_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 asset_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.asset_url_format)
}
inline std::string* StoreItem_Assets::mutable_asset_url_format() {
  std::string* _s = _internal_mutable_asset_url_format();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.asset_url_format)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_asset_url_format() const {
  return asset_url_format_.Get();
}
inline void StoreItem_Assets::_internal_set_asset_url_format(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  asset_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_asset_url_format() {
  _has_bits_[0] |= 0x00000001u;
  return asset_url_format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_asset_url_format() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.asset_url_format)
  if (!_internal_has_asset_url_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = asset_url_format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_url_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_asset_url_format(std::string* asset_url_format) {
  if (asset_url_format != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  asset_url_format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), asset_url_format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (asset_url_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    asset_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.asset_url_format)
}

// optional string main_capsule = 2;
inline bool StoreItem_Assets::_internal_has_main_capsule() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_main_capsule() const {
  return _internal_has_main_capsule();
}
inline void StoreItem_Assets::clear_main_capsule() {
  main_capsule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_Assets::main_capsule() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.main_capsule)
  return _internal_main_capsule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_main_capsule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 main_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.main_capsule)
}
inline std::string* StoreItem_Assets::mutable_main_capsule() {
  std::string* _s = _internal_mutable_main_capsule();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.main_capsule)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_main_capsule() const {
  return main_capsule_.Get();
}
inline void StoreItem_Assets::_internal_set_main_capsule(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  main_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_main_capsule() {
  _has_bits_[0] |= 0x00000002u;
  return main_capsule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_main_capsule() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.main_capsule)
  if (!_internal_has_main_capsule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = main_capsule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (main_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    main_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_main_capsule(std::string* main_capsule) {
  if (main_capsule != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  main_capsule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), main_capsule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (main_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    main_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.main_capsule)
}

// optional string small_capsule = 3;
inline bool StoreItem_Assets::_internal_has_small_capsule() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_small_capsule() const {
  return _internal_has_small_capsule();
}
inline void StoreItem_Assets::clear_small_capsule() {
  small_capsule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreItem_Assets::small_capsule() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.small_capsule)
  return _internal_small_capsule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_small_capsule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 small_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.small_capsule)
}
inline std::string* StoreItem_Assets::mutable_small_capsule() {
  std::string* _s = _internal_mutable_small_capsule();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.small_capsule)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_small_capsule() const {
  return small_capsule_.Get();
}
inline void StoreItem_Assets::_internal_set_small_capsule(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  small_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_small_capsule() {
  _has_bits_[0] |= 0x00000004u;
  return small_capsule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_small_capsule() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.small_capsule)
  if (!_internal_has_small_capsule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = small_capsule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (small_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    small_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_small_capsule(std::string* small_capsule) {
  if (small_capsule != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  small_capsule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), small_capsule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (small_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    small_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.small_capsule)
}

// optional string header = 4 [(.description) = "Equivalent to GetConstantRatioHeaderImage in PHP; apps will always have this, packages and bundles may not."];
inline bool StoreItem_Assets::_internal_has_header() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_header() const {
  return _internal_has_header();
}
inline void StoreItem_Assets::clear_header() {
  header_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StoreItem_Assets::header() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.header)
  return _internal_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_header(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.header)
}
inline std::string* StoreItem_Assets::mutable_header() {
  std::string* _s = _internal_mutable_header();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.header)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_header() const {
  return header_.Get();
}
inline void StoreItem_Assets::_internal_set_header(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_header() {
  _has_bits_[0] |= 0x00000008u;
  return header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_header() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.header)
  if (!_internal_has_header()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = header_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_header(std::string* header) {
  if (header != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.header)
}

// optional string package_header = 5 [(.description) = "A wider header used on package/bundle pages.  Not set for apps."];
inline bool StoreItem_Assets::_internal_has_package_header() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_package_header() const {
  return _internal_has_package_header();
}
inline void StoreItem_Assets::clear_package_header() {
  package_header_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StoreItem_Assets::package_header() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.package_header)
  return _internal_package_header();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_package_header(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 package_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.package_header)
}
inline std::string* StoreItem_Assets::mutable_package_header() {
  std::string* _s = _internal_mutable_package_header();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.package_header)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_package_header() const {
  return package_header_.Get();
}
inline void StoreItem_Assets::_internal_set_package_header(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  package_header_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_package_header() {
  _has_bits_[0] |= 0x00000010u;
  return package_header_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_package_header() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.package_header)
  if (!_internal_has_package_header()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = package_header_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (package_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    package_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_package_header(std::string* package_header) {
  if (package_header != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  package_header_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), package_header,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (package_header_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    package_header_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.package_header)
}

// optional string page_background = 6;
inline bool StoreItem_Assets::_internal_has_page_background() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_page_background() const {
  return _internal_has_page_background();
}
inline void StoreItem_Assets::clear_page_background() {
  page_background_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& StoreItem_Assets::page_background() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.page_background)
  return _internal_page_background();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_page_background(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 page_background_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.page_background)
}
inline std::string* StoreItem_Assets::mutable_page_background() {
  std::string* _s = _internal_mutable_page_background();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.page_background)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_page_background() const {
  return page_background_.Get();
}
inline void StoreItem_Assets::_internal_set_page_background(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  page_background_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_page_background() {
  _has_bits_[0] |= 0x00000020u;
  return page_background_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_page_background() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.page_background)
  if (!_internal_has_page_background()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = page_background_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_background_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_background_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_page_background(std::string* page_background) {
  if (page_background != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  page_background_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), page_background,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (page_background_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    page_background_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.page_background)
}

// optional string hero_capsule = 7 [(.description) = "374x448"];
inline bool StoreItem_Assets::_internal_has_hero_capsule() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_hero_capsule() const {
  return _internal_has_hero_capsule();
}
inline void StoreItem_Assets::clear_hero_capsule() {
  hero_capsule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& StoreItem_Assets::hero_capsule() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.hero_capsule)
  return _internal_hero_capsule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_hero_capsule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 hero_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.hero_capsule)
}
inline std::string* StoreItem_Assets::mutable_hero_capsule() {
  std::string* _s = _internal_mutable_hero_capsule();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.hero_capsule)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_hero_capsule() const {
  return hero_capsule_.Get();
}
inline void StoreItem_Assets::_internal_set_hero_capsule(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  hero_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_hero_capsule() {
  _has_bits_[0] |= 0x00000040u;
  return hero_capsule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_hero_capsule() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.hero_capsule)
  if (!_internal_has_hero_capsule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = hero_capsule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hero_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hero_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_hero_capsule(std::string* hero_capsule) {
  if (hero_capsule != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  hero_capsule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hero_capsule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hero_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hero_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.hero_capsule)
}

// optional string hero_capsule_2x = 8 [(.description) = "748x896 version of hero capsule."];
inline bool StoreItem_Assets::_internal_has_hero_capsule_2x() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_hero_capsule_2x() const {
  return _internal_has_hero_capsule_2x();
}
inline void StoreItem_Assets::clear_hero_capsule_2x() {
  hero_capsule_2x_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& StoreItem_Assets::hero_capsule_2x() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.hero_capsule_2x)
  return _internal_hero_capsule_2x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_hero_capsule_2x(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 hero_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.hero_capsule_2x)
}
inline std::string* StoreItem_Assets::mutable_hero_capsule_2x() {
  std::string* _s = _internal_mutable_hero_capsule_2x();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.hero_capsule_2x)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_hero_capsule_2x() const {
  return hero_capsule_2x_.Get();
}
inline void StoreItem_Assets::_internal_set_hero_capsule_2x(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  hero_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_hero_capsule_2x() {
  _has_bits_[0] |= 0x00000080u;
  return hero_capsule_2x_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_hero_capsule_2x() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.hero_capsule_2x)
  if (!_internal_has_hero_capsule_2x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = hero_capsule_2x_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hero_capsule_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hero_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_hero_capsule_2x(std::string* hero_capsule_2x) {
  if (hero_capsule_2x != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  hero_capsule_2x_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hero_capsule_2x,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hero_capsule_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hero_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.hero_capsule_2x)
}

// optional string library_capsule = 9 [(.description) = "300x450 - tall library asset"];
inline bool StoreItem_Assets::_internal_has_library_capsule() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_library_capsule() const {
  return _internal_has_library_capsule();
}
inline void StoreItem_Assets::clear_library_capsule() {
  library_capsule_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& StoreItem_Assets::library_capsule() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.library_capsule)
  return _internal_library_capsule();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_library_capsule(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 library_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.library_capsule)
}
inline std::string* StoreItem_Assets::mutable_library_capsule() {
  std::string* _s = _internal_mutable_library_capsule();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.library_capsule)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_library_capsule() const {
  return library_capsule_.Get();
}
inline void StoreItem_Assets::_internal_set_library_capsule(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  library_capsule_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_library_capsule() {
  _has_bits_[0] |= 0x00000100u;
  return library_capsule_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_library_capsule() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.library_capsule)
  if (!_internal_has_library_capsule()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = library_capsule_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_library_capsule(std::string* library_capsule) {
  if (library_capsule != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  library_capsule_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), library_capsule,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_capsule_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_capsule_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.library_capsule)
}

// optional string library_capsule_2x = 10 [(.description) = "600x900 - tall library asset"];
inline bool StoreItem_Assets::_internal_has_library_capsule_2x() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_library_capsule_2x() const {
  return _internal_has_library_capsule_2x();
}
inline void StoreItem_Assets::clear_library_capsule_2x() {
  library_capsule_2x_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& StoreItem_Assets::library_capsule_2x() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.library_capsule_2x)
  return _internal_library_capsule_2x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_library_capsule_2x(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 library_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.library_capsule_2x)
}
inline std::string* StoreItem_Assets::mutable_library_capsule_2x() {
  std::string* _s = _internal_mutable_library_capsule_2x();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.library_capsule_2x)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_library_capsule_2x() const {
  return library_capsule_2x_.Get();
}
inline void StoreItem_Assets::_internal_set_library_capsule_2x(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  library_capsule_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_library_capsule_2x() {
  _has_bits_[0] |= 0x00000200u;
  return library_capsule_2x_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_library_capsule_2x() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.library_capsule_2x)
  if (!_internal_has_library_capsule_2x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = library_capsule_2x_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_capsule_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_library_capsule_2x(std::string* library_capsule_2x) {
  if (library_capsule_2x != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  library_capsule_2x_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), library_capsule_2x,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_capsule_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_capsule_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.library_capsule_2x)
}

// optional string library_hero = 11 [(.description) = "960x310 or 1920x620 - library detail background asset"];
inline bool StoreItem_Assets::_internal_has_library_hero() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_library_hero() const {
  return _internal_has_library_hero();
}
inline void StoreItem_Assets::clear_library_hero() {
  library_hero_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& StoreItem_Assets::library_hero() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.library_hero)
  return _internal_library_hero();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_library_hero(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 library_hero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.library_hero)
}
inline std::string* StoreItem_Assets::mutable_library_hero() {
  std::string* _s = _internal_mutable_library_hero();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.library_hero)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_library_hero() const {
  return library_hero_.Get();
}
inline void StoreItem_Assets::_internal_set_library_hero(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  library_hero_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_library_hero() {
  _has_bits_[0] |= 0x00000400u;
  return library_hero_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_library_hero() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.library_hero)
  if (!_internal_has_library_hero()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = library_hero_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_hero_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_hero_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_library_hero(std::string* library_hero) {
  if (library_hero != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  library_hero_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), library_hero,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_hero_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_hero_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.library_hero)
}

// optional string library_hero_2x = 12 [(.description) = "1920x620 or 3840x1240 - library detail background asset"];
inline bool StoreItem_Assets::_internal_has_library_hero_2x() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_library_hero_2x() const {
  return _internal_has_library_hero_2x();
}
inline void StoreItem_Assets::clear_library_hero_2x() {
  library_hero_2x_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& StoreItem_Assets::library_hero_2x() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.library_hero_2x)
  return _internal_library_hero_2x();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_library_hero_2x(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 library_hero_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.library_hero_2x)
}
inline std::string* StoreItem_Assets::mutable_library_hero_2x() {
  std::string* _s = _internal_mutable_library_hero_2x();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.library_hero_2x)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_library_hero_2x() const {
  return library_hero_2x_.Get();
}
inline void StoreItem_Assets::_internal_set_library_hero_2x(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  library_hero_2x_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_library_hero_2x() {
  _has_bits_[0] |= 0x00000800u;
  return library_hero_2x_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_library_hero_2x() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.library_hero_2x)
  if (!_internal_has_library_hero_2x()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = library_hero_2x_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_hero_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_hero_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_library_hero_2x(std::string* library_hero_2x) {
  if (library_hero_2x != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  library_hero_2x_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), library_hero_2x,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (library_hero_2x_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    library_hero_2x_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.library_hero_2x)
}

// optional string community_icon = 13 [(.description) = "32x32 jpg uploading via steamworks under community assets"];
inline bool StoreItem_Assets::_internal_has_community_icon() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_community_icon() const {
  return _internal_has_community_icon();
}
inline void StoreItem_Assets::clear_community_icon() {
  community_icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00001000u;
}
inline const std::string& StoreItem_Assets::community_icon() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.community_icon)
  return _internal_community_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_community_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00001000u;
 community_icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.community_icon)
}
inline std::string* StoreItem_Assets::mutable_community_icon() {
  std::string* _s = _internal_mutable_community_icon();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.community_icon)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_community_icon() const {
  return community_icon_.Get();
}
inline void StoreItem_Assets::_internal_set_community_icon(const std::string& value) {
  _has_bits_[0] |= 0x00001000u;
  community_icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_community_icon() {
  _has_bits_[0] |= 0x00001000u;
  return community_icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_community_icon() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.community_icon)
  if (!_internal_has_community_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00001000u;
  auto* p = community_icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (community_icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    community_icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_community_icon(std::string* community_icon) {
  if (community_icon != nullptr) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  community_icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), community_icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (community_icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    community_icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.community_icon)
}

// optional string clan_avatar = 14;
inline bool StoreItem_Assets::_internal_has_clan_avatar() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StoreItem_Assets::has_clan_avatar() const {
  return _internal_has_clan_avatar();
}
inline void StoreItem_Assets::clear_clan_avatar() {
  clan_avatar_.ClearToEmpty();
  _has_bits_[0] &= ~0x00002000u;
}
inline const std::string& StoreItem_Assets::clan_avatar() const {
  // @@protoc_insertion_point(field_get:StoreItem.Assets.clan_avatar)
  return _internal_clan_avatar();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Assets::set_clan_avatar(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00002000u;
 clan_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Assets.clan_avatar)
}
inline std::string* StoreItem_Assets::mutable_clan_avatar() {
  std::string* _s = _internal_mutable_clan_avatar();
  // @@protoc_insertion_point(field_mutable:StoreItem.Assets.clan_avatar)
  return _s;
}
inline const std::string& StoreItem_Assets::_internal_clan_avatar() const {
  return clan_avatar_.Get();
}
inline void StoreItem_Assets::_internal_set_clan_avatar(const std::string& value) {
  _has_bits_[0] |= 0x00002000u;
  clan_avatar_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::_internal_mutable_clan_avatar() {
  _has_bits_[0] |= 0x00002000u;
  return clan_avatar_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Assets::release_clan_avatar() {
  // @@protoc_insertion_point(field_release:StoreItem.Assets.clan_avatar)
  if (!_internal_has_clan_avatar()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00002000u;
  auto* p = clan_avatar_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clan_avatar_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clan_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Assets::set_allocated_clan_avatar(std::string* clan_avatar) {
  if (clan_avatar != nullptr) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  clan_avatar_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), clan_avatar,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (clan_avatar_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    clan_avatar_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Assets.clan_avatar)
}

// -------------------------------------------------------------------

// StoreItem_ReleaseInfo

// optional uint32 steam_release_date = 1 [(.description) = "The date this item first released on the Steam store.  For Early Access graduates, this is their graduation day."];
inline bool StoreItem_ReleaseInfo::_internal_has_steam_release_date() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_steam_release_date() const {
  return _internal_has_steam_release_date();
}
inline void StoreItem_ReleaseInfo::clear_steam_release_date() {
  steam_release_date_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StoreItem_ReleaseInfo::_internal_steam_release_date() const {
  return steam_release_date_;
}
inline uint32_t StoreItem_ReleaseInfo::steam_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.steam_release_date)
  return _internal_steam_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_steam_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  steam_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_steam_release_date(uint32_t value) {
  _internal_set_steam_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.steam_release_date)
}

// optional uint32 original_release_date = 2 [(.description) = "Optional; the date this item first released elsewhere, typically back catalog items."];
inline bool StoreItem_ReleaseInfo::_internal_has_original_release_date() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_original_release_date() const {
  return _internal_has_original_release_date();
}
inline void StoreItem_ReleaseInfo::clear_original_release_date() {
  original_release_date_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t StoreItem_ReleaseInfo::_internal_original_release_date() const {
  return original_release_date_;
}
inline uint32_t StoreItem_ReleaseInfo::original_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.original_release_date)
  return _internal_original_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_original_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  original_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_original_release_date(uint32_t value) {
  _internal_set_original_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.original_release_date)
}

// optional uint32 original_steam_release_date = 3 [(.description) = "For Early Access graduates, the date the game first appeared on Steam."];
inline bool StoreItem_ReleaseInfo::_internal_has_original_steam_release_date() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_original_steam_release_date() const {
  return _internal_has_original_steam_release_date();
}
inline void StoreItem_ReleaseInfo::clear_original_steam_release_date() {
  original_steam_release_date_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t StoreItem_ReleaseInfo::_internal_original_steam_release_date() const {
  return original_steam_release_date_;
}
inline uint32_t StoreItem_ReleaseInfo::original_steam_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.original_steam_release_date)
  return _internal_original_steam_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_original_steam_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  original_steam_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_original_steam_release_date(uint32_t value) {
  _internal_set_original_steam_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.original_steam_release_date)
}

// optional bool is_coming_soon = 4 [(.description) = "Is the app coming soon?  This flag should be preferred to doing time comparisons against steam_release_date."];
inline bool StoreItem_ReleaseInfo::_internal_has_is_coming_soon() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_is_coming_soon() const {
  return _internal_has_is_coming_soon();
}
inline void StoreItem_ReleaseInfo::clear_is_coming_soon() {
  is_coming_soon_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool StoreItem_ReleaseInfo::_internal_is_coming_soon() const {
  return is_coming_soon_;
}
inline bool StoreItem_ReleaseInfo::is_coming_soon() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.is_coming_soon)
  return _internal_is_coming_soon();
}
inline void StoreItem_ReleaseInfo::_internal_set_is_coming_soon(bool value) {
  _has_bits_[0] |= 0x00000020u;
  is_coming_soon_ = value;
}
inline void StoreItem_ReleaseInfo::set_is_coming_soon(bool value) {
  _internal_set_is_coming_soon(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.is_coming_soon)
}

// optional bool is_preload = 5 [(.description) = "Can the app be preloaded?  Only applies to Coming Soon titles."];
inline bool StoreItem_ReleaseInfo::_internal_has_is_preload() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_is_preload() const {
  return _internal_has_is_preload();
}
inline void StoreItem_ReleaseInfo::clear_is_preload() {
  is_preload_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool StoreItem_ReleaseInfo::_internal_is_preload() const {
  return is_preload_;
}
inline bool StoreItem_ReleaseInfo::is_preload() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.is_preload)
  return _internal_is_preload();
}
inline void StoreItem_ReleaseInfo::_internal_set_is_preload(bool value) {
  _has_bits_[0] |= 0x00000040u;
  is_preload_ = value;
}
inline void StoreItem_ReleaseInfo::set_is_preload(bool value) {
  _internal_set_is_preload(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.is_preload)
}

// optional string custom_release_date_message = 6 [(.description) = "Custom release date string.  steam_release_date will be unset if this is set."];
inline bool StoreItem_ReleaseInfo::_internal_has_custom_release_date_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_custom_release_date_message() const {
  return _internal_has_custom_release_date_message();
}
inline void StoreItem_ReleaseInfo::clear_custom_release_date_message() {
  custom_release_date_message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_ReleaseInfo::custom_release_date_message() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.custom_release_date_message)
  return _internal_custom_release_date_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_ReleaseInfo::set_custom_release_date_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 custom_release_date_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.custom_release_date_message)
}
inline std::string* StoreItem_ReleaseInfo::mutable_custom_release_date_message() {
  std::string* _s = _internal_mutable_custom_release_date_message();
  // @@protoc_insertion_point(field_mutable:StoreItem.ReleaseInfo.custom_release_date_message)
  return _s;
}
inline const std::string& StoreItem_ReleaseInfo::_internal_custom_release_date_message() const {
  return custom_release_date_message_.Get();
}
inline void StoreItem_ReleaseInfo::_internal_set_custom_release_date_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  custom_release_date_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_ReleaseInfo::_internal_mutable_custom_release_date_message() {
  _has_bits_[0] |= 0x00000001u;
  return custom_release_date_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_ReleaseInfo::release_custom_release_date_message() {
  // @@protoc_insertion_point(field_release:StoreItem.ReleaseInfo.custom_release_date_message)
  if (!_internal_has_custom_release_date_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = custom_release_date_message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (custom_release_date_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    custom_release_date_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_ReleaseInfo::set_allocated_custom_release_date_message(std::string* custom_release_date_message) {
  if (custom_release_date_message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  custom_release_date_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), custom_release_date_message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (custom_release_date_message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    custom_release_date_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.ReleaseInfo.custom_release_date_message)
}

// optional bool is_abridged_release_date = 7 [(.description) = "Release date should be displayed as month-year only.  steam_release_date is the last day of the month."];
inline bool StoreItem_ReleaseInfo::_internal_has_is_abridged_release_date() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_is_abridged_release_date() const {
  return _internal_has_is_abridged_release_date();
}
inline void StoreItem_ReleaseInfo::clear_is_abridged_release_date() {
  is_abridged_release_date_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool StoreItem_ReleaseInfo::_internal_is_abridged_release_date() const {
  return is_abridged_release_date_;
}
inline bool StoreItem_ReleaseInfo::is_abridged_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.is_abridged_release_date)
  return _internal_is_abridged_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_is_abridged_release_date(bool value) {
  _has_bits_[0] |= 0x00000080u;
  is_abridged_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_is_abridged_release_date(bool value) {
  _internal_set_is_abridged_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.is_abridged_release_date)
}

// optional string coming_soon_display = 8 [(.description) = "One of \'date_full\', \'date_month\', \'date_quarter\', \'date_year\', \'text_comingsoon\', \'text_tba\'"];
inline bool StoreItem_ReleaseInfo::_internal_has_coming_soon_display() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_coming_soon_display() const {
  return _internal_has_coming_soon_display();
}
inline void StoreItem_ReleaseInfo::clear_coming_soon_display() {
  coming_soon_display_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_ReleaseInfo::coming_soon_display() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.coming_soon_display)
  return _internal_coming_soon_display();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_ReleaseInfo::set_coming_soon_display(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 coming_soon_display_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.coming_soon_display)
}
inline std::string* StoreItem_ReleaseInfo::mutable_coming_soon_display() {
  std::string* _s = _internal_mutable_coming_soon_display();
  // @@protoc_insertion_point(field_mutable:StoreItem.ReleaseInfo.coming_soon_display)
  return _s;
}
inline const std::string& StoreItem_ReleaseInfo::_internal_coming_soon_display() const {
  return coming_soon_display_.Get();
}
inline void StoreItem_ReleaseInfo::_internal_set_coming_soon_display(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  coming_soon_display_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_ReleaseInfo::_internal_mutable_coming_soon_display() {
  _has_bits_[0] |= 0x00000002u;
  return coming_soon_display_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_ReleaseInfo::release_coming_soon_display() {
  // @@protoc_insertion_point(field_release:StoreItem.ReleaseInfo.coming_soon_display)
  if (!_internal_has_coming_soon_display()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = coming_soon_display_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coming_soon_display_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coming_soon_display_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_ReleaseInfo::set_allocated_coming_soon_display(std::string* coming_soon_display) {
  if (coming_soon_display != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  coming_soon_display_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), coming_soon_display,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (coming_soon_display_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    coming_soon_display_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.ReleaseInfo.coming_soon_display)
}

// optional bool is_early_access = 10;
inline bool StoreItem_ReleaseInfo::_internal_has_is_early_access() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_is_early_access() const {
  return _internal_has_is_early_access();
}
inline void StoreItem_ReleaseInfo::clear_is_early_access() {
  is_early_access_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool StoreItem_ReleaseInfo::_internal_is_early_access() const {
  return is_early_access_;
}
inline bool StoreItem_ReleaseInfo::is_early_access() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.is_early_access)
  return _internal_is_early_access();
}
inline void StoreItem_ReleaseInfo::_internal_set_is_early_access(bool value) {
  _has_bits_[0] |= 0x00000100u;
  is_early_access_ = value;
}
inline void StoreItem_ReleaseInfo::set_is_early_access(bool value) {
  _internal_set_is_early_access(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.is_early_access)
}

// optional uint32 mac_release_date = 20;
inline bool StoreItem_ReleaseInfo::_internal_has_mac_release_date() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_mac_release_date() const {
  return _internal_has_mac_release_date();
}
inline void StoreItem_ReleaseInfo::clear_mac_release_date() {
  mac_release_date_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t StoreItem_ReleaseInfo::_internal_mac_release_date() const {
  return mac_release_date_;
}
inline uint32_t StoreItem_ReleaseInfo::mac_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.mac_release_date)
  return _internal_mac_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_mac_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  mac_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_mac_release_date(uint32_t value) {
  _internal_set_mac_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.mac_release_date)
}

// optional uint32 linux_release_date = 21;
inline bool StoreItem_ReleaseInfo::_internal_has_linux_release_date() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreItem_ReleaseInfo::has_linux_release_date() const {
  return _internal_has_linux_release_date();
}
inline void StoreItem_ReleaseInfo::clear_linux_release_date() {
  linux_release_date_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t StoreItem_ReleaseInfo::_internal_linux_release_date() const {
  return linux_release_date_;
}
inline uint32_t StoreItem_ReleaseInfo::linux_release_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.ReleaseInfo.linux_release_date)
  return _internal_linux_release_date();
}
inline void StoreItem_ReleaseInfo::_internal_set_linux_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  linux_release_date_ = value;
}
inline void StoreItem_ReleaseInfo::set_linux_release_date(uint32_t value) {
  _internal_set_linux_release_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.ReleaseInfo.linux_release_date)
}

// -------------------------------------------------------------------

// StoreItem_Platforms_VRSupport

// optional bool vrhmd = 1;
inline bool StoreItem_Platforms_VRSupport::_internal_has_vrhmd() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_vrhmd() const {
  return _internal_has_vrhmd();
}
inline void StoreItem_Platforms_VRSupport::clear_vrhmd() {
  vrhmd_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_vrhmd() const {
  return vrhmd_;
}
inline bool StoreItem_Platforms_VRSupport::vrhmd() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.vrhmd)
  return _internal_vrhmd();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_vrhmd(bool value) {
  _has_bits_[0] |= 0x00000001u;
  vrhmd_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_vrhmd(bool value) {
  _internal_set_vrhmd(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.vrhmd)
}

// optional bool vrhmd_only = 2;
inline bool StoreItem_Platforms_VRSupport::_internal_has_vrhmd_only() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_vrhmd_only() const {
  return _internal_has_vrhmd_only();
}
inline void StoreItem_Platforms_VRSupport::clear_vrhmd_only() {
  vrhmd_only_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_vrhmd_only() const {
  return vrhmd_only_;
}
inline bool StoreItem_Platforms_VRSupport::vrhmd_only() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.vrhmd_only)
  return _internal_vrhmd_only();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_vrhmd_only(bool value) {
  _has_bits_[0] |= 0x00000002u;
  vrhmd_only_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_vrhmd_only(bool value) {
  _internal_set_vrhmd_only(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.vrhmd_only)
}

// optional bool htc_vive = 40;
inline bool StoreItem_Platforms_VRSupport::_internal_has_htc_vive() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_htc_vive() const {
  return _internal_has_htc_vive();
}
inline void StoreItem_Platforms_VRSupport::clear_htc_vive() {
  htc_vive_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_htc_vive() const {
  return htc_vive_;
}
inline bool StoreItem_Platforms_VRSupport::htc_vive() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.htc_vive)
  return _internal_htc_vive();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_htc_vive(bool value) {
  _has_bits_[0] |= 0x00000004u;
  htc_vive_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_htc_vive(bool value) {
  _internal_set_htc_vive(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.htc_vive)
}

// optional bool oculus_rift = 41;
inline bool StoreItem_Platforms_VRSupport::_internal_has_oculus_rift() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_oculus_rift() const {
  return _internal_has_oculus_rift();
}
inline void StoreItem_Platforms_VRSupport::clear_oculus_rift() {
  oculus_rift_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_oculus_rift() const {
  return oculus_rift_;
}
inline bool StoreItem_Platforms_VRSupport::oculus_rift() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.oculus_rift)
  return _internal_oculus_rift();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_oculus_rift(bool value) {
  _has_bits_[0] |= 0x00000008u;
  oculus_rift_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_oculus_rift(bool value) {
  _internal_set_oculus_rift(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.oculus_rift)
}

// optional bool windows_mr = 42;
inline bool StoreItem_Platforms_VRSupport::_internal_has_windows_mr() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_windows_mr() const {
  return _internal_has_windows_mr();
}
inline void StoreItem_Platforms_VRSupport::clear_windows_mr() {
  windows_mr_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_windows_mr() const {
  return windows_mr_;
}
inline bool StoreItem_Platforms_VRSupport::windows_mr() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.windows_mr)
  return _internal_windows_mr();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_windows_mr(bool value) {
  _has_bits_[0] |= 0x00000010u;
  windows_mr_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_windows_mr(bool value) {
  _internal_set_windows_mr(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.windows_mr)
}

// optional bool valve_index = 43;
inline bool StoreItem_Platforms_VRSupport::_internal_has_valve_index() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreItem_Platforms_VRSupport::has_valve_index() const {
  return _internal_has_valve_index();
}
inline void StoreItem_Platforms_VRSupport::clear_valve_index() {
  valve_index_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool StoreItem_Platforms_VRSupport::_internal_valve_index() const {
  return valve_index_;
}
inline bool StoreItem_Platforms_VRSupport::valve_index() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.VRSupport.valve_index)
  return _internal_valve_index();
}
inline void StoreItem_Platforms_VRSupport::_internal_set_valve_index(bool value) {
  _has_bits_[0] |= 0x00000020u;
  valve_index_ = value;
}
inline void StoreItem_Platforms_VRSupport::set_valve_index(bool value) {
  _internal_set_valve_index(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.VRSupport.valve_index)
}

// -------------------------------------------------------------------

// StoreItem_Platforms

// optional bool windows = 1;
inline bool StoreItem_Platforms::_internal_has_windows() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Platforms::has_windows() const {
  return _internal_has_windows();
}
inline void StoreItem_Platforms::clear_windows() {
  windows_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StoreItem_Platforms::_internal_windows() const {
  return windows_;
}
inline bool StoreItem_Platforms::windows() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.windows)
  return _internal_windows();
}
inline void StoreItem_Platforms::_internal_set_windows(bool value) {
  _has_bits_[0] |= 0x00000002u;
  windows_ = value;
}
inline void StoreItem_Platforms::set_windows(bool value) {
  _internal_set_windows(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.windows)
}

// optional bool mac = 2;
inline bool StoreItem_Platforms::_internal_has_mac() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_Platforms::has_mac() const {
  return _internal_has_mac();
}
inline void StoreItem_Platforms::clear_mac() {
  mac_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StoreItem_Platforms::_internal_mac() const {
  return mac_;
}
inline bool StoreItem_Platforms::mac() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.mac)
  return _internal_mac();
}
inline void StoreItem_Platforms::_internal_set_mac(bool value) {
  _has_bits_[0] |= 0x00000004u;
  mac_ = value;
}
inline void StoreItem_Platforms::set_mac(bool value) {
  _internal_set_mac(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.mac)
}

// optional bool steamos_linux = 3;
inline bool StoreItem_Platforms::_internal_has_steamos_linux() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_Platforms::has_steamos_linux() const {
  return _internal_has_steamos_linux();
}
inline void StoreItem_Platforms::clear_steamos_linux() {
  steamos_linux_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StoreItem_Platforms::_internal_steamos_linux() const {
  return steamos_linux_;
}
inline bool StoreItem_Platforms::steamos_linux() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.steamos_linux)
  return _internal_steamos_linux();
}
inline void StoreItem_Platforms::_internal_set_steamos_linux(bool value) {
  _has_bits_[0] |= 0x00000008u;
  steamos_linux_ = value;
}
inline void StoreItem_Platforms::set_steamos_linux(bool value) {
  _internal_set_steamos_linux(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.steamos_linux)
}

// optional .StoreItem.Platforms.VRSupport vr_support = 10;
inline bool StoreItem_Platforms::_internal_has_vr_support() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || vr_support_ != nullptr);
  return value;
}
inline bool StoreItem_Platforms::has_vr_support() const {
  return _internal_has_vr_support();
}
inline void StoreItem_Platforms::clear_vr_support() {
  if (vr_support_ != nullptr) vr_support_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::StoreItem_Platforms_VRSupport& StoreItem_Platforms::_internal_vr_support() const {
  const ::StoreItem_Platforms_VRSupport* p = vr_support_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Platforms_VRSupport&>(
      ::_StoreItem_Platforms_VRSupport_default_instance_);
}
inline const ::StoreItem_Platforms_VRSupport& StoreItem_Platforms::vr_support() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.vr_support)
  return _internal_vr_support();
}
inline void StoreItem_Platforms::unsafe_arena_set_allocated_vr_support(
    ::StoreItem_Platforms_VRSupport* vr_support) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(vr_support_);
  }
  vr_support_ = vr_support;
  if (vr_support) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.Platforms.vr_support)
}
inline ::StoreItem_Platforms_VRSupport* StoreItem_Platforms::release_vr_support() {
  _has_bits_[0] &= ~0x00000001u;
  ::StoreItem_Platforms_VRSupport* temp = vr_support_;
  vr_support_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Platforms_VRSupport* StoreItem_Platforms::unsafe_arena_release_vr_support() {
  // @@protoc_insertion_point(field_release:StoreItem.Platforms.vr_support)
  _has_bits_[0] &= ~0x00000001u;
  ::StoreItem_Platforms_VRSupport* temp = vr_support_;
  vr_support_ = nullptr;
  return temp;
}
inline ::StoreItem_Platforms_VRSupport* StoreItem_Platforms::_internal_mutable_vr_support() {
  _has_bits_[0] |= 0x00000001u;
  if (vr_support_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Platforms_VRSupport>(GetArenaForAllocation());
    vr_support_ = p;
  }
  return vr_support_;
}
inline ::StoreItem_Platforms_VRSupport* StoreItem_Platforms::mutable_vr_support() {
  ::StoreItem_Platforms_VRSupport* _msg = _internal_mutable_vr_support();
  // @@protoc_insertion_point(field_mutable:StoreItem.Platforms.vr_support)
  return _msg;
}
inline void StoreItem_Platforms::set_allocated_vr_support(::StoreItem_Platforms_VRSupport* vr_support) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete vr_support_;
  }
  if (vr_support) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Platforms_VRSupport>::GetOwningArena(vr_support);
    if (message_arena != submessage_arena) {
      vr_support = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, vr_support, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  vr_support_ = vr_support;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Platforms.vr_support)
}

// optional .ESteamDeckCompatibilityCategory steam_deck_compat_category = 11 [default = k_ESteamDeckCompatibilityCategory_Unknown];
inline bool StoreItem_Platforms::_internal_has_steam_deck_compat_category() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_Platforms::has_steam_deck_compat_category() const {
  return _internal_has_steam_deck_compat_category();
}
inline void StoreItem_Platforms::clear_steam_deck_compat_category() {
  steam_deck_compat_category_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ESteamDeckCompatibilityCategory StoreItem_Platforms::_internal_steam_deck_compat_category() const {
  return static_cast< ::ESteamDeckCompatibilityCategory >(steam_deck_compat_category_);
}
inline ::ESteamDeckCompatibilityCategory StoreItem_Platforms::steam_deck_compat_category() const {
  // @@protoc_insertion_point(field_get:StoreItem.Platforms.steam_deck_compat_category)
  return _internal_steam_deck_compat_category();
}
inline void StoreItem_Platforms::_internal_set_steam_deck_compat_category(::ESteamDeckCompatibilityCategory value) {
  assert(::ESteamDeckCompatibilityCategory_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  steam_deck_compat_category_ = value;
}
inline void StoreItem_Platforms::set_steam_deck_compat_category(::ESteamDeckCompatibilityCategory value) {
  _internal_set_steam_deck_compat_category(value);
  // @@protoc_insertion_point(field_set:StoreItem.Platforms.steam_deck_compat_category)
}

// -------------------------------------------------------------------

// StoreItem_PurchaseOption_Discount

// optional int64 discount_amount = 1;
inline bool StoreItem_PurchaseOption_Discount::_internal_has_discount_amount() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption_Discount::has_discount_amount() const {
  return _internal_has_discount_amount();
}
inline void StoreItem_PurchaseOption_Discount::clear_discount_amount() {
  discount_amount_ = int64_t{0};
  _has_bits_[0] &= ~0x00000002u;
}
inline int64_t StoreItem_PurchaseOption_Discount::_internal_discount_amount() const {
  return discount_amount_;
}
inline int64_t StoreItem_PurchaseOption_Discount::discount_amount() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.Discount.discount_amount)
  return _internal_discount_amount();
}
inline void StoreItem_PurchaseOption_Discount::_internal_set_discount_amount(int64_t value) {
  _has_bits_[0] |= 0x00000002u;
  discount_amount_ = value;
}
inline void StoreItem_PurchaseOption_Discount::set_discount_amount(int64_t value) {
  _internal_set_discount_amount(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.Discount.discount_amount)
}

// optional string discount_description = 2;
inline bool StoreItem_PurchaseOption_Discount::_internal_has_discount_description() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption_Discount::has_discount_description() const {
  return _internal_has_discount_description();
}
inline void StoreItem_PurchaseOption_Discount::clear_discount_description() {
  discount_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_PurchaseOption_Discount::discount_description() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.Discount.discount_description)
  return _internal_discount_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_PurchaseOption_Discount::set_discount_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 discount_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.Discount.discount_description)
}
inline std::string* StoreItem_PurchaseOption_Discount::mutable_discount_description() {
  std::string* _s = _internal_mutable_discount_description();
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.Discount.discount_description)
  return _s;
}
inline const std::string& StoreItem_PurchaseOption_Discount::_internal_discount_description() const {
  return discount_description_.Get();
}
inline void StoreItem_PurchaseOption_Discount::_internal_set_discount_description(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  discount_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption_Discount::_internal_mutable_discount_description() {
  _has_bits_[0] |= 0x00000001u;
  return discount_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption_Discount::release_discount_description() {
  // @@protoc_insertion_point(field_release:StoreItem.PurchaseOption.Discount.discount_description)
  if (!_internal_has_discount_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = discount_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discount_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discount_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_PurchaseOption_Discount::set_allocated_discount_description(std::string* discount_description) {
  if (discount_description != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  discount_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), discount_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (discount_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    discount_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.PurchaseOption.Discount.discount_description)
}

// optional uint32 discount_end_date = 3;
inline bool StoreItem_PurchaseOption_Discount::_internal_has_discount_end_date() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption_Discount::has_discount_end_date() const {
  return _internal_has_discount_end_date();
}
inline void StoreItem_PurchaseOption_Discount::clear_discount_end_date() {
  discount_end_date_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StoreItem_PurchaseOption_Discount::_internal_discount_end_date() const {
  return discount_end_date_;
}
inline uint32_t StoreItem_PurchaseOption_Discount::discount_end_date() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.Discount.discount_end_date)
  return _internal_discount_end_date();
}
inline void StoreItem_PurchaseOption_Discount::_internal_set_discount_end_date(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  discount_end_date_ = value;
}
inline void StoreItem_PurchaseOption_Discount::set_discount_end_date(uint32_t value) {
  _internal_set_discount_end_date(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.Discount.discount_end_date)
}

// -------------------------------------------------------------------

// StoreItem_PurchaseOption

// optional int32 packageid = 1;
inline bool StoreItem_PurchaseOption::_internal_has_packageid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_packageid() const {
  return _internal_has_packageid();
}
inline void StoreItem_PurchaseOption::clear_packageid() {
  packageid_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t StoreItem_PurchaseOption::_internal_packageid() const {
  return packageid_;
}
inline int32_t StoreItem_PurchaseOption::packageid() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.packageid)
  return _internal_packageid();
}
inline void StoreItem_PurchaseOption::_internal_set_packageid(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  packageid_ = value;
}
inline void StoreItem_PurchaseOption::set_packageid(int32_t value) {
  _internal_set_packageid(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.packageid)
}

// optional int32 bundleid = 2;
inline bool StoreItem_PurchaseOption::_internal_has_bundleid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_bundleid() const {
  return _internal_has_bundleid();
}
inline void StoreItem_PurchaseOption::clear_bundleid() {
  bundleid_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t StoreItem_PurchaseOption::_internal_bundleid() const {
  return bundleid_;
}
inline int32_t StoreItem_PurchaseOption::bundleid() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.bundleid)
  return _internal_bundleid();
}
inline void StoreItem_PurchaseOption::_internal_set_bundleid(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  bundleid_ = value;
}
inline void StoreItem_PurchaseOption::set_bundleid(int32_t value) {
  _internal_set_bundleid(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.bundleid)
}

// optional string purchase_option_name = 3 [(.description) = "The name of the package or bundle"];
inline bool StoreItem_PurchaseOption::_internal_has_purchase_option_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_purchase_option_name() const {
  return _internal_has_purchase_option_name();
}
inline void StoreItem_PurchaseOption::clear_purchase_option_name() {
  purchase_option_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_PurchaseOption::purchase_option_name() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.purchase_option_name)
  return _internal_purchase_option_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_PurchaseOption::set_purchase_option_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 purchase_option_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.purchase_option_name)
}
inline std::string* StoreItem_PurchaseOption::mutable_purchase_option_name() {
  std::string* _s = _internal_mutable_purchase_option_name();
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.purchase_option_name)
  return _s;
}
inline const std::string& StoreItem_PurchaseOption::_internal_purchase_option_name() const {
  return purchase_option_name_.Get();
}
inline void StoreItem_PurchaseOption::_internal_set_purchase_option_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  purchase_option_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::_internal_mutable_purchase_option_name() {
  _has_bits_[0] |= 0x00000001u;
  return purchase_option_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::release_purchase_option_name() {
  // @@protoc_insertion_point(field_release:StoreItem.PurchaseOption.purchase_option_name)
  if (!_internal_has_purchase_option_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = purchase_option_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (purchase_option_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    purchase_option_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_PurchaseOption::set_allocated_purchase_option_name(std::string* purchase_option_name) {
  if (purchase_option_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  purchase_option_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), purchase_option_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (purchase_option_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    purchase_option_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.PurchaseOption.purchase_option_name)
}

// optional int64 final_price_in_cents = 5 [(.description) = "Always set.  Includes any applicable non user-specific discounts."];
inline bool StoreItem_PurchaseOption::_internal_has_final_price_in_cents() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_final_price_in_cents() const {
  return _internal_has_final_price_in_cents();
}
inline void StoreItem_PurchaseOption::clear_final_price_in_cents() {
  final_price_in_cents_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t StoreItem_PurchaseOption::_internal_final_price_in_cents() const {
  return final_price_in_cents_;
}
inline int64_t StoreItem_PurchaseOption::final_price_in_cents() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.final_price_in_cents)
  return _internal_final_price_in_cents();
}
inline void StoreItem_PurchaseOption::_internal_set_final_price_in_cents(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  final_price_in_cents_ = value;
}
inline void StoreItem_PurchaseOption::set_final_price_in_cents(int64_t value) {
  _internal_set_final_price_in_cents(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.final_price_in_cents)
}

// optional int64 original_price_in_cents = 6 [(.description) = "If discounted, this is the price the item would normally cost."];
inline bool StoreItem_PurchaseOption::_internal_has_original_price_in_cents() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_original_price_in_cents() const {
  return _internal_has_original_price_in_cents();
}
inline void StoreItem_PurchaseOption::clear_original_price_in_cents() {
  original_price_in_cents_ = int64_t{0};
  _has_bits_[0] &= ~0x00000040u;
}
inline int64_t StoreItem_PurchaseOption::_internal_original_price_in_cents() const {
  return original_price_in_cents_;
}
inline int64_t StoreItem_PurchaseOption::original_price_in_cents() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.original_price_in_cents)
  return _internal_original_price_in_cents();
}
inline void StoreItem_PurchaseOption::_internal_set_original_price_in_cents(int64_t value) {
  _has_bits_[0] |= 0x00000040u;
  original_price_in_cents_ = value;
}
inline void StoreItem_PurchaseOption::set_original_price_in_cents(int64_t value) {
  _internal_set_original_price_in_cents(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.original_price_in_cents)
}

// optional int64 user_final_price_in_cents = 7;
inline bool StoreItem_PurchaseOption::_internal_has_user_final_price_in_cents() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_user_final_price_in_cents() const {
  return _internal_has_user_final_price_in_cents();
}
inline void StoreItem_PurchaseOption::clear_user_final_price_in_cents() {
  user_final_price_in_cents_ = int64_t{0};
  _has_bits_[0] &= ~0x00000080u;
}
inline int64_t StoreItem_PurchaseOption::_internal_user_final_price_in_cents() const {
  return user_final_price_in_cents_;
}
inline int64_t StoreItem_PurchaseOption::user_final_price_in_cents() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.user_final_price_in_cents)
  return _internal_user_final_price_in_cents();
}
inline void StoreItem_PurchaseOption::_internal_set_user_final_price_in_cents(int64_t value) {
  _has_bits_[0] |= 0x00000080u;
  user_final_price_in_cents_ = value;
}
inline void StoreItem_PurchaseOption::set_user_final_price_in_cents(int64_t value) {
  _internal_set_user_final_price_in_cents(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.user_final_price_in_cents)
}

// optional string formatted_final_price = 8 [(.description) = "Always set.  Formatted with currency symbol and decimal, like \'$10.00\'."];
inline bool StoreItem_PurchaseOption::_internal_has_formatted_final_price() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_formatted_final_price() const {
  return _internal_has_formatted_final_price();
}
inline void StoreItem_PurchaseOption::clear_formatted_final_price() {
  formatted_final_price_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_PurchaseOption::formatted_final_price() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.formatted_final_price)
  return _internal_formatted_final_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_PurchaseOption::set_formatted_final_price(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 formatted_final_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.formatted_final_price)
}
inline std::string* StoreItem_PurchaseOption::mutable_formatted_final_price() {
  std::string* _s = _internal_mutable_formatted_final_price();
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.formatted_final_price)
  return _s;
}
inline const std::string& StoreItem_PurchaseOption::_internal_formatted_final_price() const {
  return formatted_final_price_.Get();
}
inline void StoreItem_PurchaseOption::_internal_set_formatted_final_price(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  formatted_final_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::_internal_mutable_formatted_final_price() {
  _has_bits_[0] |= 0x00000002u;
  return formatted_final_price_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::release_formatted_final_price() {
  // @@protoc_insertion_point(field_release:StoreItem.PurchaseOption.formatted_final_price)
  if (!_internal_has_formatted_final_price()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = formatted_final_price_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (formatted_final_price_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    formatted_final_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_PurchaseOption::set_allocated_formatted_final_price(std::string* formatted_final_price) {
  if (formatted_final_price != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  formatted_final_price_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), formatted_final_price,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (formatted_final_price_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    formatted_final_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.PurchaseOption.formatted_final_price)
}

// optional string formatted_original_price = 9;
inline bool StoreItem_PurchaseOption::_internal_has_formatted_original_price() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_formatted_original_price() const {
  return _internal_has_formatted_original_price();
}
inline void StoreItem_PurchaseOption::clear_formatted_original_price() {
  formatted_original_price_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreItem_PurchaseOption::formatted_original_price() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.formatted_original_price)
  return _internal_formatted_original_price();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_PurchaseOption::set_formatted_original_price(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 formatted_original_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.formatted_original_price)
}
inline std::string* StoreItem_PurchaseOption::mutable_formatted_original_price() {
  std::string* _s = _internal_mutable_formatted_original_price();
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.formatted_original_price)
  return _s;
}
inline const std::string& StoreItem_PurchaseOption::_internal_formatted_original_price() const {
  return formatted_original_price_.Get();
}
inline void StoreItem_PurchaseOption::_internal_set_formatted_original_price(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  formatted_original_price_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::_internal_mutable_formatted_original_price() {
  _has_bits_[0] |= 0x00000004u;
  return formatted_original_price_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_PurchaseOption::release_formatted_original_price() {
  // @@protoc_insertion_point(field_release:StoreItem.PurchaseOption.formatted_original_price)
  if (!_internal_has_formatted_original_price()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = formatted_original_price_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (formatted_original_price_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    formatted_original_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_PurchaseOption::set_allocated_formatted_original_price(std::string* formatted_original_price) {
  if (formatted_original_price != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  formatted_original_price_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), formatted_original_price,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (formatted_original_price_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    formatted_original_price_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.PurchaseOption.formatted_original_price)
}

// optional int32 discount_pct = 10 [(.description) = "If discounted, calculated from final price and original price."];
inline bool StoreItem_PurchaseOption::_internal_has_discount_pct() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_discount_pct() const {
  return _internal_has_discount_pct();
}
inline void StoreItem_PurchaseOption::clear_discount_pct() {
  discount_pct_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t StoreItem_PurchaseOption::_internal_discount_pct() const {
  return discount_pct_;
}
inline int32_t StoreItem_PurchaseOption::discount_pct() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.discount_pct)
  return _internal_discount_pct();
}
inline void StoreItem_PurchaseOption::_internal_set_discount_pct(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  discount_pct_ = value;
}
inline void StoreItem_PurchaseOption::set_discount_pct(int32_t value) {
  _internal_set_discount_pct(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.discount_pct)
}

// optional int32 user_discount_pct = 11;
inline bool StoreItem_PurchaseOption::_internal_has_user_discount_pct() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_user_discount_pct() const {
  return _internal_has_user_discount_pct();
}
inline void StoreItem_PurchaseOption::clear_user_discount_pct() {
  user_discount_pct_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline int32_t StoreItem_PurchaseOption::_internal_user_discount_pct() const {
  return user_discount_pct_;
}
inline int32_t StoreItem_PurchaseOption::user_discount_pct() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.user_discount_pct)
  return _internal_user_discount_pct();
}
inline void StoreItem_PurchaseOption::_internal_set_user_discount_pct(int32_t value) {
  _has_bits_[0] |= 0x00000200u;
  user_discount_pct_ = value;
}
inline void StoreItem_PurchaseOption::set_user_discount_pct(int32_t value) {
  _internal_set_user_discount_pct(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.user_discount_pct)
}

// optional int32 bundle_discount_pct = 12 [(.description) = "If this is a bundle, the savings from buying the bundle.  If no bundle items are on active discount, this will be the same as discount_pct."];
inline bool StoreItem_PurchaseOption::_internal_has_bundle_discount_pct() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_bundle_discount_pct() const {
  return _internal_has_bundle_discount_pct();
}
inline void StoreItem_PurchaseOption::clear_bundle_discount_pct() {
  bundle_discount_pct_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline int32_t StoreItem_PurchaseOption::_internal_bundle_discount_pct() const {
  return bundle_discount_pct_;
}
inline int32_t StoreItem_PurchaseOption::bundle_discount_pct() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.bundle_discount_pct)
  return _internal_bundle_discount_pct();
}
inline void StoreItem_PurchaseOption::_internal_set_bundle_discount_pct(int32_t value) {
  _has_bits_[0] |= 0x00000400u;
  bundle_discount_pct_ = value;
}
inline void StoreItem_PurchaseOption::set_bundle_discount_pct(int32_t value) {
  _internal_set_bundle_discount_pct(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.bundle_discount_pct)
}

// repeated .StoreItem.PurchaseOption.Discount active_discounts = 20 [(.description) = "Discounts included in discounted_price_in_cents."];
inline int StoreItem_PurchaseOption::_internal_active_discounts_size() const {
  return active_discounts_.size();
}
inline int StoreItem_PurchaseOption::active_discounts_size() const {
  return _internal_active_discounts_size();
}
inline void StoreItem_PurchaseOption::clear_active_discounts() {
  active_discounts_.Clear();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::mutable_active_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.active_discounts)
  return active_discounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
StoreItem_PurchaseOption::mutable_active_discounts() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.PurchaseOption.active_discounts)
  return &active_discounts_;
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::_internal_active_discounts(int index) const {
  return active_discounts_.Get(index);
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::active_discounts(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.active_discounts)
  return _internal_active_discounts(index);
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::_internal_add_active_discounts() {
  return active_discounts_.Add();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::add_active_discounts() {
  ::StoreItem_PurchaseOption_Discount* _add = _internal_add_active_discounts();
  // @@protoc_insertion_point(field_add:StoreItem.PurchaseOption.active_discounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
StoreItem_PurchaseOption::active_discounts() const {
  // @@protoc_insertion_point(field_list:StoreItem.PurchaseOption.active_discounts)
  return active_discounts_;
}

// repeated .StoreItem.PurchaseOption.Discount user_active_discounts = 21 [(.description) = "Additional discounts included in user_discounted_price_in_cents."];
inline int StoreItem_PurchaseOption::_internal_user_active_discounts_size() const {
  return user_active_discounts_.size();
}
inline int StoreItem_PurchaseOption::user_active_discounts_size() const {
  return _internal_user_active_discounts_size();
}
inline void StoreItem_PurchaseOption::clear_user_active_discounts() {
  user_active_discounts_.Clear();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::mutable_user_active_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.user_active_discounts)
  return user_active_discounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
StoreItem_PurchaseOption::mutable_user_active_discounts() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.PurchaseOption.user_active_discounts)
  return &user_active_discounts_;
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::_internal_user_active_discounts(int index) const {
  return user_active_discounts_.Get(index);
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::user_active_discounts(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.user_active_discounts)
  return _internal_user_active_discounts(index);
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::_internal_add_user_active_discounts() {
  return user_active_discounts_.Add();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::add_user_active_discounts() {
  ::StoreItem_PurchaseOption_Discount* _add = _internal_add_user_active_discounts();
  // @@protoc_insertion_point(field_add:StoreItem.PurchaseOption.user_active_discounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
StoreItem_PurchaseOption::user_active_discounts() const {
  // @@protoc_insertion_point(field_list:StoreItem.PurchaseOption.user_active_discounts)
  return user_active_discounts_;
}

// repeated .StoreItem.PurchaseOption.Discount inactive_discounts = 22 [(.description) = "Additional user-specific discounts that do not apply to the current user."];
inline int StoreItem_PurchaseOption::_internal_inactive_discounts_size() const {
  return inactive_discounts_.size();
}
inline int StoreItem_PurchaseOption::inactive_discounts_size() const {
  return _internal_inactive_discounts_size();
}
inline void StoreItem_PurchaseOption::clear_inactive_discounts() {
  inactive_discounts_.Clear();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::mutable_inactive_discounts(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.PurchaseOption.inactive_discounts)
  return inactive_discounts_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >*
StoreItem_PurchaseOption::mutable_inactive_discounts() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.PurchaseOption.inactive_discounts)
  return &inactive_discounts_;
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::_internal_inactive_discounts(int index) const {
  return inactive_discounts_.Get(index);
}
inline const ::StoreItem_PurchaseOption_Discount& StoreItem_PurchaseOption::inactive_discounts(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.inactive_discounts)
  return _internal_inactive_discounts(index);
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::_internal_add_inactive_discounts() {
  return inactive_discounts_.Add();
}
inline ::StoreItem_PurchaseOption_Discount* StoreItem_PurchaseOption::add_inactive_discounts() {
  ::StoreItem_PurchaseOption_Discount* _add = _internal_add_inactive_discounts();
  // @@protoc_insertion_point(field_add:StoreItem.PurchaseOption.inactive_discounts)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption_Discount >&
StoreItem_PurchaseOption::inactive_discounts() const {
  // @@protoc_insertion_point(field_list:StoreItem.PurchaseOption.inactive_discounts)
  return inactive_discounts_;
}

// optional bool user_can_purchase = 30;
inline bool StoreItem_PurchaseOption::_internal_has_user_can_purchase() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_user_can_purchase() const {
  return _internal_has_user_can_purchase();
}
inline void StoreItem_PurchaseOption::clear_user_can_purchase() {
  user_can_purchase_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool StoreItem_PurchaseOption::_internal_user_can_purchase() const {
  return user_can_purchase_;
}
inline bool StoreItem_PurchaseOption::user_can_purchase() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.user_can_purchase)
  return _internal_user_can_purchase();
}
inline void StoreItem_PurchaseOption::_internal_set_user_can_purchase(bool value) {
  _has_bits_[0] |= 0x00000800u;
  user_can_purchase_ = value;
}
inline void StoreItem_PurchaseOption::set_user_can_purchase(bool value) {
  _internal_set_user_can_purchase(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.user_can_purchase)
}

// optional bool user_can_purchase_as_gift = 31;
inline bool StoreItem_PurchaseOption::_internal_has_user_can_purchase_as_gift() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_user_can_purchase_as_gift() const {
  return _internal_has_user_can_purchase_as_gift();
}
inline void StoreItem_PurchaseOption::clear_user_can_purchase_as_gift() {
  user_can_purchase_as_gift_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool StoreItem_PurchaseOption::_internal_user_can_purchase_as_gift() const {
  return user_can_purchase_as_gift_;
}
inline bool StoreItem_PurchaseOption::user_can_purchase_as_gift() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.user_can_purchase_as_gift)
  return _internal_user_can_purchase_as_gift();
}
inline void StoreItem_PurchaseOption::_internal_set_user_can_purchase_as_gift(bool value) {
  _has_bits_[0] |= 0x00001000u;
  user_can_purchase_as_gift_ = value;
}
inline void StoreItem_PurchaseOption::set_user_can_purchase_as_gift(bool value) {
  _internal_set_user_can_purchase_as_gift(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.user_can_purchase_as_gift)
}

// optional bool is_commercial_license = 40 [(.description) = "This is a commercial license"];
inline bool StoreItem_PurchaseOption::_internal_has_is_commercial_license() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_is_commercial_license() const {
  return _internal_has_is_commercial_license();
}
inline void StoreItem_PurchaseOption::clear_is_commercial_license() {
  is_commercial_license_ = false;
  _has_bits_[0] &= ~0x00002000u;
}
inline bool StoreItem_PurchaseOption::_internal_is_commercial_license() const {
  return is_commercial_license_;
}
inline bool StoreItem_PurchaseOption::is_commercial_license() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.is_commercial_license)
  return _internal_is_commercial_license();
}
inline void StoreItem_PurchaseOption::_internal_set_is_commercial_license(bool value) {
  _has_bits_[0] |= 0x00002000u;
  is_commercial_license_ = value;
}
inline void StoreItem_PurchaseOption::set_is_commercial_license(bool value) {
  _internal_set_is_commercial_license(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.is_commercial_license)
}

// optional bool should_suppress_discount_pct = 41 [(.description) = "Don\'t show the discount percentage on a store capsule for this item."];
inline bool StoreItem_PurchaseOption::_internal_has_should_suppress_discount_pct() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_should_suppress_discount_pct() const {
  return _internal_has_should_suppress_discount_pct();
}
inline void StoreItem_PurchaseOption::clear_should_suppress_discount_pct() {
  should_suppress_discount_pct_ = false;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool StoreItem_PurchaseOption::_internal_should_suppress_discount_pct() const {
  return should_suppress_discount_pct_;
}
inline bool StoreItem_PurchaseOption::should_suppress_discount_pct() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.should_suppress_discount_pct)
  return _internal_should_suppress_discount_pct();
}
inline void StoreItem_PurchaseOption::_internal_set_should_suppress_discount_pct(bool value) {
  _has_bits_[0] |= 0x00004000u;
  should_suppress_discount_pct_ = value;
}
inline void StoreItem_PurchaseOption::set_should_suppress_discount_pct(bool value) {
  _internal_set_should_suppress_discount_pct(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.should_suppress_discount_pct)
}

// optional bool hide_discount_pct_for_compliance = 42 [default = false, (.description) = "Don\'t show the discount percent because there was a discount in the last 30 days."];
inline bool StoreItem_PurchaseOption::_internal_has_hide_discount_pct_for_compliance() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_hide_discount_pct_for_compliance() const {
  return _internal_has_hide_discount_pct_for_compliance();
}
inline void StoreItem_PurchaseOption::clear_hide_discount_pct_for_compliance() {
  hide_discount_pct_for_compliance_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool StoreItem_PurchaseOption::_internal_hide_discount_pct_for_compliance() const {
  return hide_discount_pct_for_compliance_;
}
inline bool StoreItem_PurchaseOption::hide_discount_pct_for_compliance() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.hide_discount_pct_for_compliance)
  return _internal_hide_discount_pct_for_compliance();
}
inline void StoreItem_PurchaseOption::_internal_set_hide_discount_pct_for_compliance(bool value) {
  _has_bits_[0] |= 0x00008000u;
  hide_discount_pct_for_compliance_ = value;
}
inline void StoreItem_PurchaseOption::set_hide_discount_pct_for_compliance(bool value) {
  _internal_set_hide_discount_pct_for_compliance(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.hide_discount_pct_for_compliance)
}

// optional int32 included_game_count = 43 [(.description) = "How many games are included in this purchase option."];
inline bool StoreItem_PurchaseOption::_internal_has_included_game_count() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_included_game_count() const {
  return _internal_has_included_game_count();
}
inline void StoreItem_PurchaseOption::clear_included_game_count() {
  included_game_count_ = 0;
  _has_bits_[0] &= ~0x00010000u;
}
inline int32_t StoreItem_PurchaseOption::_internal_included_game_count() const {
  return included_game_count_;
}
inline int32_t StoreItem_PurchaseOption::included_game_count() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.included_game_count)
  return _internal_included_game_count();
}
inline void StoreItem_PurchaseOption::_internal_set_included_game_count(int32_t value) {
  _has_bits_[0] |= 0x00010000u;
  included_game_count_ = value;
}
inline void StoreItem_PurchaseOption::set_included_game_count(int32_t value) {
  _internal_set_included_game_count(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.included_game_count)
}

// optional int64 lowest_recent_price_in_cents = 44 [(.description) = "Lowest recent price in cents.  If not set, then there is no data so we ignore."];
inline bool StoreItem_PurchaseOption::_internal_has_lowest_recent_price_in_cents() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool StoreItem_PurchaseOption::has_lowest_recent_price_in_cents() const {
  return _internal_has_lowest_recent_price_in_cents();
}
inline void StoreItem_PurchaseOption::clear_lowest_recent_price_in_cents() {
  lowest_recent_price_in_cents_ = int64_t{0};
  _has_bits_[0] &= ~0x00020000u;
}
inline int64_t StoreItem_PurchaseOption::_internal_lowest_recent_price_in_cents() const {
  return lowest_recent_price_in_cents_;
}
inline int64_t StoreItem_PurchaseOption::lowest_recent_price_in_cents() const {
  // @@protoc_insertion_point(field_get:StoreItem.PurchaseOption.lowest_recent_price_in_cents)
  return _internal_lowest_recent_price_in_cents();
}
inline void StoreItem_PurchaseOption::_internal_set_lowest_recent_price_in_cents(int64_t value) {
  _has_bits_[0] |= 0x00020000u;
  lowest_recent_price_in_cents_ = value;
}
inline void StoreItem_PurchaseOption::set_lowest_recent_price_in_cents(int64_t value) {
  _internal_set_lowest_recent_price_in_cents(value);
  // @@protoc_insertion_point(field_set:StoreItem.PurchaseOption.lowest_recent_price_in_cents)
}

// -------------------------------------------------------------------

// StoreItem_Screenshots_Screenshot

// optional string filename = 1 [(.description) = "Path to file on media CDN.  Can access sized version by appending to SHA: \'.1920x1080\', \'.600x338\', \'.116x65\'"];
inline bool StoreItem_Screenshots_Screenshot::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Screenshots_Screenshot::has_filename() const {
  return _internal_has_filename();
}
inline void StoreItem_Screenshots_Screenshot::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_Screenshots_Screenshot::filename() const {
  // @@protoc_insertion_point(field_get:StoreItem.Screenshots.Screenshot.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Screenshots_Screenshot::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Screenshots.Screenshot.filename)
}
inline std::string* StoreItem_Screenshots_Screenshot::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:StoreItem.Screenshots.Screenshot.filename)
  return _s;
}
inline const std::string& StoreItem_Screenshots_Screenshot::_internal_filename() const {
  return filename_.Get();
}
inline void StoreItem_Screenshots_Screenshot::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Screenshots_Screenshot::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Screenshots_Screenshot::release_filename() {
  // @@protoc_insertion_point(field_release:StoreItem.Screenshots.Screenshot.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Screenshots_Screenshot::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Screenshots.Screenshot.filename)
}

// optional int32 ordinal = 2 [(.description) = "Screenshots should be displayed in order of ascending ordinal; they are returned in-order but client may need to merge all_ages and mature_content_screenshots."];
inline bool StoreItem_Screenshots_Screenshot::_internal_has_ordinal() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Screenshots_Screenshot::has_ordinal() const {
  return _internal_has_ordinal();
}
inline void StoreItem_Screenshots_Screenshot::clear_ordinal() {
  ordinal_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t StoreItem_Screenshots_Screenshot::_internal_ordinal() const {
  return ordinal_;
}
inline int32_t StoreItem_Screenshots_Screenshot::ordinal() const {
  // @@protoc_insertion_point(field_get:StoreItem.Screenshots.Screenshot.ordinal)
  return _internal_ordinal();
}
inline void StoreItem_Screenshots_Screenshot::_internal_set_ordinal(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  ordinal_ = value;
}
inline void StoreItem_Screenshots_Screenshot::set_ordinal(int32_t value) {
  _internal_set_ordinal(value);
  // @@protoc_insertion_point(field_set:StoreItem.Screenshots.Screenshot.ordinal)
}

// -------------------------------------------------------------------

// StoreItem_Screenshots

// repeated .StoreItem.Screenshots.Screenshot all_ages_screenshots = 2 [(.description) = "Screenshots suitable for all ages."];
inline int StoreItem_Screenshots::_internal_all_ages_screenshots_size() const {
  return all_ages_screenshots_.size();
}
inline int StoreItem_Screenshots::all_ages_screenshots_size() const {
  return _internal_all_ages_screenshots_size();
}
inline void StoreItem_Screenshots::clear_all_ages_screenshots() {
  all_ages_screenshots_.Clear();
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::mutable_all_ages_screenshots(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Screenshots.all_ages_screenshots)
  return all_ages_screenshots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >*
StoreItem_Screenshots::mutable_all_ages_screenshots() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Screenshots.all_ages_screenshots)
  return &all_ages_screenshots_;
}
inline const ::StoreItem_Screenshots_Screenshot& StoreItem_Screenshots::_internal_all_ages_screenshots(int index) const {
  return all_ages_screenshots_.Get(index);
}
inline const ::StoreItem_Screenshots_Screenshot& StoreItem_Screenshots::all_ages_screenshots(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Screenshots.all_ages_screenshots)
  return _internal_all_ages_screenshots(index);
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::_internal_add_all_ages_screenshots() {
  return all_ages_screenshots_.Add();
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::add_all_ages_screenshots() {
  ::StoreItem_Screenshots_Screenshot* _add = _internal_add_all_ages_screenshots();
  // @@protoc_insertion_point(field_add:StoreItem.Screenshots.all_ages_screenshots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >&
StoreItem_Screenshots::all_ages_screenshots() const {
  // @@protoc_insertion_point(field_list:StoreItem.Screenshots.all_ages_screenshots)
  return all_ages_screenshots_;
}

// repeated .StoreItem.Screenshots.Screenshot mature_content_screenshots = 3 [(.description) = "Screenshots that may contain mature content; these should only be shown after verifying age (age gate)."];
inline int StoreItem_Screenshots::_internal_mature_content_screenshots_size() const {
  return mature_content_screenshots_.size();
}
inline int StoreItem_Screenshots::mature_content_screenshots_size() const {
  return _internal_mature_content_screenshots_size();
}
inline void StoreItem_Screenshots::clear_mature_content_screenshots() {
  mature_content_screenshots_.Clear();
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::mutable_mature_content_screenshots(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Screenshots.mature_content_screenshots)
  return mature_content_screenshots_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >*
StoreItem_Screenshots::mutable_mature_content_screenshots() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Screenshots.mature_content_screenshots)
  return &mature_content_screenshots_;
}
inline const ::StoreItem_Screenshots_Screenshot& StoreItem_Screenshots::_internal_mature_content_screenshots(int index) const {
  return mature_content_screenshots_.Get(index);
}
inline const ::StoreItem_Screenshots_Screenshot& StoreItem_Screenshots::mature_content_screenshots(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Screenshots.mature_content_screenshots)
  return _internal_mature_content_screenshots(index);
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::_internal_add_mature_content_screenshots() {
  return mature_content_screenshots_.Add();
}
inline ::StoreItem_Screenshots_Screenshot* StoreItem_Screenshots::add_mature_content_screenshots() {
  ::StoreItem_Screenshots_Screenshot* _add = _internal_add_mature_content_screenshots();
  // @@protoc_insertion_point(field_add:StoreItem.Screenshots.mature_content_screenshots)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Screenshots_Screenshot >&
StoreItem_Screenshots::mature_content_screenshots() const {
  // @@protoc_insertion_point(field_list:StoreItem.Screenshots.mature_content_screenshots)
  return mature_content_screenshots_;
}

// -------------------------------------------------------------------

// StoreItem_Trailers_VideoSource

// optional string filename = 1 [(.description) = "Substitute into trailer_url_format"];
inline bool StoreItem_Trailers_VideoSource::_internal_has_filename() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Trailers_VideoSource::has_filename() const {
  return _internal_has_filename();
}
inline void StoreItem_Trailers_VideoSource::clear_filename() {
  filename_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_Trailers_VideoSource::filename() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.VideoSource.filename)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_VideoSource::set_filename(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.VideoSource.filename)
}
inline std::string* StoreItem_Trailers_VideoSource::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.VideoSource.filename)
  return _s;
}
inline const std::string& StoreItem_Trailers_VideoSource::_internal_filename() const {
  return filename_.Get();
}
inline void StoreItem_Trailers_VideoSource::_internal_set_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_VideoSource::_internal_mutable_filename() {
  _has_bits_[0] |= 0x00000001u;
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_VideoSource::release_filename() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.VideoSource.filename)
  if (!_internal_has_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filename_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_VideoSource::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.VideoSource.filename)
}

// optional string type = 2 [(.description) = "\'video/webm\' or \'video/mp4\'; can just put this directly in to a <source> tag."];
inline bool StoreItem_Trailers_VideoSource::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Trailers_VideoSource::has_type() const {
  return _internal_has_type();
}
inline void StoreItem_Trailers_VideoSource::clear_type() {
  type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_Trailers_VideoSource::type() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.VideoSource.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_VideoSource::set_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.VideoSource.type)
}
inline std::string* StoreItem_Trailers_VideoSource::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.VideoSource.type)
  return _s;
}
inline const std::string& StoreItem_Trailers_VideoSource::_internal_type() const {
  return type_.Get();
}
inline void StoreItem_Trailers_VideoSource::_internal_set_type(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_VideoSource::_internal_mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_VideoSource::release_type() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.VideoSource.type)
  if (!_internal_has_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_VideoSource::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.VideoSource.type)
}

// -------------------------------------------------------------------

// StoreItem_Trailers_Trailer

// optional string trailer_name = 1;
inline bool StoreItem_Trailers_Trailer::_internal_has_trailer_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_Trailers_Trailer::has_trailer_name() const {
  return _internal_has_trailer_name();
}
inline void StoreItem_Trailers_Trailer::clear_trailer_name() {
  trailer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_Trailers_Trailer::trailer_name() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.trailer_name)
  return _internal_trailer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_Trailer::set_trailer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 trailer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.Trailer.trailer_name)
}
inline std::string* StoreItem_Trailers_Trailer::mutable_trailer_name() {
  std::string* _s = _internal_mutable_trailer_name();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.trailer_name)
  return _s;
}
inline const std::string& StoreItem_Trailers_Trailer::_internal_trailer_name() const {
  return trailer_name_.Get();
}
inline void StoreItem_Trailers_Trailer::_internal_set_trailer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  trailer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::_internal_mutable_trailer_name() {
  _has_bits_[0] |= 0x00000001u;
  return trailer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::release_trailer_name() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.Trailer.trailer_name)
  if (!_internal_has_trailer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = trailer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trailer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trailer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_Trailer::set_allocated_trailer_name(std::string* trailer_name) {
  if (trailer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  trailer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trailer_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trailer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trailer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.Trailer.trailer_name)
}

// optional string trailer_url_format = 2 [(.description) = "Format for URLs, should substitute filename for ${FILENAME} in the URL."];
inline bool StoreItem_Trailers_Trailer::_internal_has_trailer_url_format() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_Trailers_Trailer::has_trailer_url_format() const {
  return _internal_has_trailer_url_format();
}
inline void StoreItem_Trailers_Trailer::clear_trailer_url_format() {
  trailer_url_format_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem_Trailers_Trailer::trailer_url_format() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.trailer_url_format)
  return _internal_trailer_url_format();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_Trailer::set_trailer_url_format(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 trailer_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.Trailer.trailer_url_format)
}
inline std::string* StoreItem_Trailers_Trailer::mutable_trailer_url_format() {
  std::string* _s = _internal_mutable_trailer_url_format();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.trailer_url_format)
  return _s;
}
inline const std::string& StoreItem_Trailers_Trailer::_internal_trailer_url_format() const {
  return trailer_url_format_.Get();
}
inline void StoreItem_Trailers_Trailer::_internal_set_trailer_url_format(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  trailer_url_format_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::_internal_mutable_trailer_url_format() {
  _has_bits_[0] |= 0x00000002u;
  return trailer_url_format_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::release_trailer_url_format() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.Trailer.trailer_url_format)
  if (!_internal_has_trailer_url_format()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = trailer_url_format_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trailer_url_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trailer_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_Trailer::set_allocated_trailer_url_format(std::string* trailer_url_format) {
  if (trailer_url_format != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  trailer_url_format_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trailer_url_format,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (trailer_url_format_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    trailer_url_format_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.Trailer.trailer_url_format)
}

// repeated .StoreItem.Trailers.VideoSource trailer_480p = 3;
inline int StoreItem_Trailers_Trailer::_internal_trailer_480p_size() const {
  return trailer_480p_.size();
}
inline int StoreItem_Trailers_Trailer::trailer_480p_size() const {
  return _internal_trailer_480p_size();
}
inline void StoreItem_Trailers_Trailer::clear_trailer_480p() {
  trailer_480p_.Clear();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::mutable_trailer_480p(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.trailer_480p)
  return trailer_480p_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
StoreItem_Trailers_Trailer::mutable_trailer_480p() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Trailers.Trailer.trailer_480p)
  return &trailer_480p_;
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::_internal_trailer_480p(int index) const {
  return trailer_480p_.Get(index);
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::trailer_480p(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.trailer_480p)
  return _internal_trailer_480p(index);
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::_internal_add_trailer_480p() {
  return trailer_480p_.Add();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::add_trailer_480p() {
  ::StoreItem_Trailers_VideoSource* _add = _internal_add_trailer_480p();
  // @@protoc_insertion_point(field_add:StoreItem.Trailers.Trailer.trailer_480p)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
StoreItem_Trailers_Trailer::trailer_480p() const {
  // @@protoc_insertion_point(field_list:StoreItem.Trailers.Trailer.trailer_480p)
  return trailer_480p_;
}

// repeated .StoreItem.Trailers.VideoSource trailer_max = 4;
inline int StoreItem_Trailers_Trailer::_internal_trailer_max_size() const {
  return trailer_max_.size();
}
inline int StoreItem_Trailers_Trailer::trailer_max_size() const {
  return _internal_trailer_max_size();
}
inline void StoreItem_Trailers_Trailer::clear_trailer_max() {
  trailer_max_.Clear();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::mutable_trailer_max(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.trailer_max)
  return trailer_max_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
StoreItem_Trailers_Trailer::mutable_trailer_max() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Trailers.Trailer.trailer_max)
  return &trailer_max_;
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::_internal_trailer_max(int index) const {
  return trailer_max_.Get(index);
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::trailer_max(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.trailer_max)
  return _internal_trailer_max(index);
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::_internal_add_trailer_max() {
  return trailer_max_.Add();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::add_trailer_max() {
  ::StoreItem_Trailers_VideoSource* _add = _internal_add_trailer_max();
  // @@protoc_insertion_point(field_add:StoreItem.Trailers.Trailer.trailer_max)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
StoreItem_Trailers_Trailer::trailer_max() const {
  // @@protoc_insertion_point(field_list:StoreItem.Trailers.Trailer.trailer_max)
  return trailer_max_;
}

// repeated .StoreItem.Trailers.VideoSource microtrailer = 5;
inline int StoreItem_Trailers_Trailer::_internal_microtrailer_size() const {
  return microtrailer_.size();
}
inline int StoreItem_Trailers_Trailer::microtrailer_size() const {
  return _internal_microtrailer_size();
}
inline void StoreItem_Trailers_Trailer::clear_microtrailer() {
  microtrailer_.Clear();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::mutable_microtrailer(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.microtrailer)
  return microtrailer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >*
StoreItem_Trailers_Trailer::mutable_microtrailer() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Trailers.Trailer.microtrailer)
  return &microtrailer_;
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::_internal_microtrailer(int index) const {
  return microtrailer_.Get(index);
}
inline const ::StoreItem_Trailers_VideoSource& StoreItem_Trailers_Trailer::microtrailer(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.microtrailer)
  return _internal_microtrailer(index);
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::_internal_add_microtrailer() {
  return microtrailer_.Add();
}
inline ::StoreItem_Trailers_VideoSource* StoreItem_Trailers_Trailer::add_microtrailer() {
  ::StoreItem_Trailers_VideoSource* _add = _internal_add_microtrailer();
  // @@protoc_insertion_point(field_add:StoreItem.Trailers.Trailer.microtrailer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_VideoSource >&
StoreItem_Trailers_Trailer::microtrailer() const {
  // @@protoc_insertion_point(field_list:StoreItem.Trailers.Trailer.microtrailer)
  return microtrailer_;
}

// optional string screenshot_medium = 10 [(.description) = "293x165px.  Use trailer_url_format."];
inline bool StoreItem_Trailers_Trailer::_internal_has_screenshot_medium() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_Trailers_Trailer::has_screenshot_medium() const {
  return _internal_has_screenshot_medium();
}
inline void StoreItem_Trailers_Trailer::clear_screenshot_medium() {
  screenshot_medium_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreItem_Trailers_Trailer::screenshot_medium() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.screenshot_medium)
  return _internal_screenshot_medium();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_Trailer::set_screenshot_medium(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 screenshot_medium_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.Trailer.screenshot_medium)
}
inline std::string* StoreItem_Trailers_Trailer::mutable_screenshot_medium() {
  std::string* _s = _internal_mutable_screenshot_medium();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.screenshot_medium)
  return _s;
}
inline const std::string& StoreItem_Trailers_Trailer::_internal_screenshot_medium() const {
  return screenshot_medium_.Get();
}
inline void StoreItem_Trailers_Trailer::_internal_set_screenshot_medium(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  screenshot_medium_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::_internal_mutable_screenshot_medium() {
  _has_bits_[0] |= 0x00000004u;
  return screenshot_medium_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::release_screenshot_medium() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.Trailer.screenshot_medium)
  if (!_internal_has_screenshot_medium()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = screenshot_medium_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_medium_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_medium_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_Trailer::set_allocated_screenshot_medium(std::string* screenshot_medium) {
  if (screenshot_medium != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  screenshot_medium_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), screenshot_medium,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_medium_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_medium_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.Trailer.screenshot_medium)
}

// optional string screenshot_full = 11 [(.description) = "Same size as trailer_max.  Use trailer_url_format."];
inline bool StoreItem_Trailers_Trailer::_internal_has_screenshot_full() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_Trailers_Trailer::has_screenshot_full() const {
  return _internal_has_screenshot_full();
}
inline void StoreItem_Trailers_Trailer::clear_screenshot_full() {
  screenshot_full_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StoreItem_Trailers_Trailer::screenshot_full() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.screenshot_full)
  return _internal_screenshot_full();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_Trailers_Trailer::set_screenshot_full(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 screenshot_full_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.Trailer.screenshot_full)
}
inline std::string* StoreItem_Trailers_Trailer::mutable_screenshot_full() {
  std::string* _s = _internal_mutable_screenshot_full();
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.Trailer.screenshot_full)
  return _s;
}
inline const std::string& StoreItem_Trailers_Trailer::_internal_screenshot_full() const {
  return screenshot_full_.Get();
}
inline void StoreItem_Trailers_Trailer::_internal_set_screenshot_full(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  screenshot_full_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::_internal_mutable_screenshot_full() {
  _has_bits_[0] |= 0x00000008u;
  return screenshot_full_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_Trailers_Trailer::release_screenshot_full() {
  // @@protoc_insertion_point(field_release:StoreItem.Trailers.Trailer.screenshot_full)
  if (!_internal_has_screenshot_full()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = screenshot_full_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_full_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_full_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_Trailers_Trailer::set_allocated_screenshot_full(std::string* screenshot_full) {
  if (screenshot_full != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  screenshot_full_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), screenshot_full,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_full_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_full_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.Trailers.Trailer.screenshot_full)
}

// optional int32 trailer_base_id = 12 [(.description) = "Trailer ID.  For localized trailers, this will be the original trailer\'s ID"];
inline bool StoreItem_Trailers_Trailer::_internal_has_trailer_base_id() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem_Trailers_Trailer::has_trailer_base_id() const {
  return _internal_has_trailer_base_id();
}
inline void StoreItem_Trailers_Trailer::clear_trailer_base_id() {
  trailer_base_id_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t StoreItem_Trailers_Trailer::_internal_trailer_base_id() const {
  return trailer_base_id_;
}
inline int32_t StoreItem_Trailers_Trailer::trailer_base_id() const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.Trailer.trailer_base_id)
  return _internal_trailer_base_id();
}
inline void StoreItem_Trailers_Trailer::_internal_set_trailer_base_id(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  trailer_base_id_ = value;
}
inline void StoreItem_Trailers_Trailer::set_trailer_base_id(int32_t value) {
  _internal_set_trailer_base_id(value);
  // @@protoc_insertion_point(field_set:StoreItem.Trailers.Trailer.trailer_base_id)
}

// -------------------------------------------------------------------

// StoreItem_Trailers

// repeated .StoreItem.Trailers.Trailer highlights = 1 [(.description) = "Primary trailers for this app"];
inline int StoreItem_Trailers::_internal_highlights_size() const {
  return highlights_.size();
}
inline int StoreItem_Trailers::highlights_size() const {
  return _internal_highlights_size();
}
inline void StoreItem_Trailers::clear_highlights() {
  highlights_.Clear();
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::mutable_highlights(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.highlights)
  return highlights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >*
StoreItem_Trailers::mutable_highlights() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Trailers.highlights)
  return &highlights_;
}
inline const ::StoreItem_Trailers_Trailer& StoreItem_Trailers::_internal_highlights(int index) const {
  return highlights_.Get(index);
}
inline const ::StoreItem_Trailers_Trailer& StoreItem_Trailers::highlights(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.highlights)
  return _internal_highlights(index);
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::_internal_add_highlights() {
  return highlights_.Add();
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::add_highlights() {
  ::StoreItem_Trailers_Trailer* _add = _internal_add_highlights();
  // @@protoc_insertion_point(field_add:StoreItem.Trailers.highlights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >&
StoreItem_Trailers::highlights() const {
  // @@protoc_insertion_point(field_list:StoreItem.Trailers.highlights)
  return highlights_;
}

// repeated .StoreItem.Trailers.Trailer other_trailers = 2 [(.description) = "Additional trailers; on the app page, these are shown after screenshots (highlights shown before)"];
inline int StoreItem_Trailers::_internal_other_trailers_size() const {
  return other_trailers_.size();
}
inline int StoreItem_Trailers::other_trailers_size() const {
  return _internal_other_trailers_size();
}
inline void StoreItem_Trailers::clear_other_trailers() {
  other_trailers_.Clear();
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::mutable_other_trailers(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.Trailers.other_trailers)
  return other_trailers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >*
StoreItem_Trailers::mutable_other_trailers() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.Trailers.other_trailers)
  return &other_trailers_;
}
inline const ::StoreItem_Trailers_Trailer& StoreItem_Trailers::_internal_other_trailers(int index) const {
  return other_trailers_.Get(index);
}
inline const ::StoreItem_Trailers_Trailer& StoreItem_Trailers::other_trailers(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.Trailers.other_trailers)
  return _internal_other_trailers(index);
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::_internal_add_other_trailers() {
  return other_trailers_.Add();
}
inline ::StoreItem_Trailers_Trailer* StoreItem_Trailers::add_other_trailers() {
  ::StoreItem_Trailers_Trailer* _add = _internal_add_other_trailers();
  // @@protoc_insertion_point(field_add:StoreItem.Trailers.other_trailers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Trailers_Trailer >&
StoreItem_Trailers::other_trailers() const {
  // @@protoc_insertion_point(field_list:StoreItem.Trailers.other_trailers)
  return other_trailers_;
}

// -------------------------------------------------------------------

// StoreItem_SupportedLanguage

// optional int32 elanguage = 1 [(.description) = "ELanguage"];
inline bool StoreItem_SupportedLanguage::_internal_has_elanguage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_SupportedLanguage::has_elanguage() const {
  return _internal_has_elanguage();
}
inline void StoreItem_SupportedLanguage::clear_elanguage() {
  elanguage_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t StoreItem_SupportedLanguage::_internal_elanguage() const {
  return elanguage_;
}
inline int32_t StoreItem_SupportedLanguage::elanguage() const {
  // @@protoc_insertion_point(field_get:StoreItem.SupportedLanguage.elanguage)
  return _internal_elanguage();
}
inline void StoreItem_SupportedLanguage::_internal_set_elanguage(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  elanguage_ = value;
}
inline void StoreItem_SupportedLanguage::set_elanguage(int32_t value) {
  _internal_set_elanguage(value);
  // @@protoc_insertion_point(field_set:StoreItem.SupportedLanguage.elanguage)
}

// optional bool supported = 2;
inline bool StoreItem_SupportedLanguage::_internal_has_supported() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_SupportedLanguage::has_supported() const {
  return _internal_has_supported();
}
inline void StoreItem_SupportedLanguage::clear_supported() {
  supported_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool StoreItem_SupportedLanguage::_internal_supported() const {
  return supported_;
}
inline bool StoreItem_SupportedLanguage::supported() const {
  // @@protoc_insertion_point(field_get:StoreItem.SupportedLanguage.supported)
  return _internal_supported();
}
inline void StoreItem_SupportedLanguage::_internal_set_supported(bool value) {
  _has_bits_[0] |= 0x00000002u;
  supported_ = value;
}
inline void StoreItem_SupportedLanguage::set_supported(bool value) {
  _internal_set_supported(value);
  // @@protoc_insertion_point(field_set:StoreItem.SupportedLanguage.supported)
}

// optional bool full_audio = 3;
inline bool StoreItem_SupportedLanguage::_internal_has_full_audio() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_SupportedLanguage::has_full_audio() const {
  return _internal_has_full_audio();
}
inline void StoreItem_SupportedLanguage::clear_full_audio() {
  full_audio_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool StoreItem_SupportedLanguage::_internal_full_audio() const {
  return full_audio_;
}
inline bool StoreItem_SupportedLanguage::full_audio() const {
  // @@protoc_insertion_point(field_get:StoreItem.SupportedLanguage.full_audio)
  return _internal_full_audio();
}
inline void StoreItem_SupportedLanguage::_internal_set_full_audio(bool value) {
  _has_bits_[0] |= 0x00000004u;
  full_audio_ = value;
}
inline void StoreItem_SupportedLanguage::set_full_audio(bool value) {
  _internal_set_full_audio(value);
  // @@protoc_insertion_point(field_set:StoreItem.SupportedLanguage.full_audio)
}

// optional bool subtitles = 4;
inline bool StoreItem_SupportedLanguage::_internal_has_subtitles() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem_SupportedLanguage::has_subtitles() const {
  return _internal_has_subtitles();
}
inline void StoreItem_SupportedLanguage::clear_subtitles() {
  subtitles_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool StoreItem_SupportedLanguage::_internal_subtitles() const {
  return subtitles_;
}
inline bool StoreItem_SupportedLanguage::subtitles() const {
  // @@protoc_insertion_point(field_get:StoreItem.SupportedLanguage.subtitles)
  return _internal_subtitles();
}
inline void StoreItem_SupportedLanguage::_internal_set_subtitles(bool value) {
  _has_bits_[0] |= 0x00000008u;
  subtitles_ = value;
}
inline void StoreItem_SupportedLanguage::set_subtitles(bool value) {
  _internal_set_subtitles(value);
  // @@protoc_insertion_point(field_set:StoreItem.SupportedLanguage.subtitles)
}

// -------------------------------------------------------------------

// StoreItem_FreeWeekend

// optional uint32 start_time = 1 [(.description) = "When the free weekend starts."];
inline bool StoreItem_FreeWeekend::_internal_has_start_time() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem_FreeWeekend::has_start_time() const {
  return _internal_has_start_time();
}
inline void StoreItem_FreeWeekend::clear_start_time() {
  start_time_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t StoreItem_FreeWeekend::_internal_start_time() const {
  return start_time_;
}
inline uint32_t StoreItem_FreeWeekend::start_time() const {
  // @@protoc_insertion_point(field_get:StoreItem.FreeWeekend.start_time)
  return _internal_start_time();
}
inline void StoreItem_FreeWeekend::_internal_set_start_time(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  start_time_ = value;
}
inline void StoreItem_FreeWeekend::set_start_time(uint32_t value) {
  _internal_set_start_time(value);
  // @@protoc_insertion_point(field_set:StoreItem.FreeWeekend.start_time)
}

// optional uint32 end_time = 2 [(.description) = "When the free weekend ends."];
inline bool StoreItem_FreeWeekend::_internal_has_end_time() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem_FreeWeekend::has_end_time() const {
  return _internal_has_end_time();
}
inline void StoreItem_FreeWeekend::clear_end_time() {
  end_time_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t StoreItem_FreeWeekend::_internal_end_time() const {
  return end_time_;
}
inline uint32_t StoreItem_FreeWeekend::end_time() const {
  // @@protoc_insertion_point(field_get:StoreItem.FreeWeekend.end_time)
  return _internal_end_time();
}
inline void StoreItem_FreeWeekend::_internal_set_end_time(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  end_time_ = value;
}
inline void StoreItem_FreeWeekend::set_end_time(uint32_t value) {
  _internal_set_end_time(value);
  // @@protoc_insertion_point(field_set:StoreItem.FreeWeekend.end_time)
}

// optional string text = 3 [(.description) = "Text to show as a description of the free weekend."];
inline bool StoreItem_FreeWeekend::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem_FreeWeekend::has_text() const {
  return _internal_has_text();
}
inline void StoreItem_FreeWeekend::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem_FreeWeekend::text() const {
  // @@protoc_insertion_point(field_get:StoreItem.FreeWeekend.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem_FreeWeekend::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.FreeWeekend.text)
}
inline std::string* StoreItem_FreeWeekend::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:StoreItem.FreeWeekend.text)
  return _s;
}
inline const std::string& StoreItem_FreeWeekend::_internal_text() const {
  return text_.Get();
}
inline void StoreItem_FreeWeekend::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem_FreeWeekend::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem_FreeWeekend::release_text() {
  // @@protoc_insertion_point(field_release:StoreItem.FreeWeekend.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem_FreeWeekend::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.FreeWeekend.text)
}

// -------------------------------------------------------------------

// StoreItem

// optional .EStoreItemType item_type = 1 [default = k_EStoreItemType_Invalid];
inline bool StoreItem::_internal_has_item_type() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool StoreItem::has_item_type() const {
  return _internal_has_item_type();
}
inline void StoreItem::clear_item_type() {
  item_type_ = -1;
  _has_bits_[0] &= ~0x08000000u;
}
inline ::EStoreItemType StoreItem::_internal_item_type() const {
  return static_cast< ::EStoreItemType >(item_type_);
}
inline ::EStoreItemType StoreItem::item_type() const {
  // @@protoc_insertion_point(field_get:StoreItem.item_type)
  return _internal_item_type();
}
inline void StoreItem::_internal_set_item_type(::EStoreItemType value) {
  assert(::EStoreItemType_IsValid(value));
  _has_bits_[0] |= 0x08000000u;
  item_type_ = value;
}
inline void StoreItem::set_item_type(::EStoreItemType value) {
  _internal_set_item_type(value);
  // @@protoc_insertion_point(field_set:StoreItem.item_type)
}

// optional uint32 id = 2;
inline bool StoreItem::_internal_has_id() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool StoreItem::has_id() const {
  return _internal_has_id();
}
inline void StoreItem::clear_id() {
  id_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t StoreItem::_internal_id() const {
  return id_;
}
inline uint32_t StoreItem::id() const {
  // @@protoc_insertion_point(field_get:StoreItem.id)
  return _internal_id();
}
inline void StoreItem::_internal_set_id(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  id_ = value;
}
inline void StoreItem::set_id(uint32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:StoreItem.id)
}

// optional uint32 success = 3 [(.description) = "EResult of this lookup action"];
inline bool StoreItem::_internal_has_success() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool StoreItem::has_success() const {
  return _internal_has_success();
}
inline void StoreItem::clear_success() {
  success_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t StoreItem::_internal_success() const {
  return success_;
}
inline uint32_t StoreItem::success() const {
  // @@protoc_insertion_point(field_get:StoreItem.success)
  return _internal_success();
}
inline void StoreItem::_internal_set_success(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  success_ = value;
}
inline void StoreItem::set_success(uint32_t value) {
  _internal_set_success(value);
  // @@protoc_insertion_point(field_set:StoreItem.success)
}

// optional bool visible = 4;
inline bool StoreItem::_internal_has_visible() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool StoreItem::has_visible() const {
  return _internal_has_visible();
}
inline void StoreItem::clear_visible() {
  visible_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool StoreItem::_internal_visible() const {
  return visible_;
}
inline bool StoreItem::visible() const {
  // @@protoc_insertion_point(field_get:StoreItem.visible)
  return _internal_visible();
}
inline void StoreItem::_internal_set_visible(bool value) {
  _has_bits_[0] |= 0x00100000u;
  visible_ = value;
}
inline void StoreItem::set_visible(bool value) {
  _internal_set_visible(value);
  // @@protoc_insertion_point(field_set:StoreItem.visible)
}

// optional bool unvailable_for_country_restriction = 5 [(.description) = "Indicates this app is visible in other regions, but not the requested reagion"];
inline bool StoreItem::_internal_has_unvailable_for_country_restriction() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool StoreItem::has_unvailable_for_country_restriction() const {
  return _internal_has_unvailable_for_country_restriction();
}
inline void StoreItem::clear_unvailable_for_country_restriction() {
  unvailable_for_country_restriction_ = false;
  _has_bits_[0] &= ~0x00200000u;
}
inline bool StoreItem::_internal_unvailable_for_country_restriction() const {
  return unvailable_for_country_restriction_;
}
inline bool StoreItem::unvailable_for_country_restriction() const {
  // @@protoc_insertion_point(field_get:StoreItem.unvailable_for_country_restriction)
  return _internal_unvailable_for_country_restriction();
}
inline void StoreItem::_internal_set_unvailable_for_country_restriction(bool value) {
  _has_bits_[0] |= 0x00200000u;
  unvailable_for_country_restriction_ = value;
}
inline void StoreItem::set_unvailable_for_country_restriction(bool value) {
  _internal_set_unvailable_for_country_restriction(value);
  // @@protoc_insertion_point(field_set:StoreItem.unvailable_for_country_restriction)
}

// optional string name = 6;
inline bool StoreItem::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool StoreItem::has_name() const {
  return _internal_has_name();
}
inline void StoreItem::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& StoreItem::name() const {
  // @@protoc_insertion_point(field_get:StoreItem.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.name)
}
inline std::string* StoreItem::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:StoreItem.name)
  return _s;
}
inline const std::string& StoreItem::_internal_name() const {
  return name_.Get();
}
inline void StoreItem::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem::release_name() {
  // @@protoc_insertion_point(field_release:StoreItem.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.name)
}

// optional string store_url_path = 7 [(.description) = "The URL of this item\'s store page, to be appended to STORE_BASE_URL."];
inline bool StoreItem::_internal_has_store_url_path() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool StoreItem::has_store_url_path() const {
  return _internal_has_store_url_path();
}
inline void StoreItem::clear_store_url_path() {
  store_url_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& StoreItem::store_url_path() const {
  // @@protoc_insertion_point(field_get:StoreItem.store_url_path)
  return _internal_store_url_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem::set_store_url_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 store_url_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.store_url_path)
}
inline std::string* StoreItem::mutable_store_url_path() {
  std::string* _s = _internal_mutable_store_url_path();
  // @@protoc_insertion_point(field_mutable:StoreItem.store_url_path)
  return _s;
}
inline const std::string& StoreItem::_internal_store_url_path() const {
  return store_url_path_.Get();
}
inline void StoreItem::_internal_set_store_url_path(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  store_url_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem::_internal_mutable_store_url_path() {
  _has_bits_[0] |= 0x00000002u;
  return store_url_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem::release_store_url_path() {
  // @@protoc_insertion_point(field_release:StoreItem.store_url_path)
  if (!_internal_has_store_url_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = store_url_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_url_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_url_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem::set_allocated_store_url_path(std::string* store_url_path) {
  if (store_url_path != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_url_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_url_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_url_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_url_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.store_url_path)
}

// optional uint32 appid = 9 [(.description) = "If this is an app, or a single-app package, the steamworks appid."];
inline bool StoreItem::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool StoreItem::has_appid() const {
  return _internal_has_appid();
}
inline void StoreItem::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline uint32_t StoreItem::_internal_appid() const {
  return appid_;
}
inline uint32_t StoreItem::appid() const {
  // @@protoc_insertion_point(field_get:StoreItem.appid)
  return _internal_appid();
}
inline void StoreItem::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00080000u;
  appid_ = value;
}
inline void StoreItem::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:StoreItem.appid)
}

// optional .EStoreAppType type = 10 [default = k_EStoreAppType_Game, (.description) = "Type of app (Game, Software, Music).  For packages/bundles, this will be the most interesting type (eg Game + Soundtrack bundle will have type Game)"];
inline bool StoreItem::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool StoreItem::has_type() const {
  return _internal_has_type();
}
inline void StoreItem::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x01000000u;
}
inline ::EStoreAppType StoreItem::_internal_type() const {
  return static_cast< ::EStoreAppType >(type_);
}
inline ::EStoreAppType StoreItem::type() const {
  // @@protoc_insertion_point(field_get:StoreItem.type)
  return _internal_type();
}
inline void StoreItem::_internal_set_type(::EStoreAppType value) {
  assert(::EStoreAppType_IsValid(value));
  _has_bits_[0] |= 0x01000000u;
  type_ = value;
}
inline void StoreItem::set_type(::EStoreAppType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:StoreItem.type)
}

// repeated .EStoreAppType included_types = 11 [(.description) = "For packages/bundles, all types of included items"];
inline int StoreItem::_internal_included_types_size() const {
  return included_types_.size();
}
inline int StoreItem::included_types_size() const {
  return _internal_included_types_size();
}
inline void StoreItem::clear_included_types() {
  included_types_.Clear();
}
inline ::EStoreAppType StoreItem::_internal_included_types(int index) const {
  return static_cast< ::EStoreAppType >(included_types_.Get(index));
}
inline ::EStoreAppType StoreItem::included_types(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.included_types)
  return _internal_included_types(index);
}
inline void StoreItem::set_included_types(int index, ::EStoreAppType value) {
  assert(::EStoreAppType_IsValid(value));
  included_types_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.included_types)
}
inline void StoreItem::_internal_add_included_types(::EStoreAppType value) {
  assert(::EStoreAppType_IsValid(value));
  included_types_.Add(value);
}
inline void StoreItem::add_included_types(::EStoreAppType value) {
  _internal_add_included_types(value);
  // @@protoc_insertion_point(field_add:StoreItem.included_types)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
StoreItem::included_types() const {
  // @@protoc_insertion_point(field_list:StoreItem.included_types)
  return included_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StoreItem::_internal_mutable_included_types() {
  return &included_types_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StoreItem::mutable_included_types() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.included_types)
  return _internal_mutable_included_types();
}

// repeated uint32 included_appids = 12 [(.description) = "For packages/bundles, all included appids"];
inline int StoreItem::_internal_included_appids_size() const {
  return included_appids_.size();
}
inline int StoreItem::included_appids_size() const {
  return _internal_included_appids_size();
}
inline void StoreItem::clear_included_appids() {
  included_appids_.Clear();
}
inline uint32_t StoreItem::_internal_included_appids(int index) const {
  return included_appids_.Get(index);
}
inline uint32_t StoreItem::included_appids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.included_appids)
  return _internal_included_appids(index);
}
inline void StoreItem::set_included_appids(int index, uint32_t value) {
  included_appids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.included_appids)
}
inline void StoreItem::_internal_add_included_appids(uint32_t value) {
  included_appids_.Add(value);
}
inline void StoreItem::add_included_appids(uint32_t value) {
  _internal_add_included_appids(value);
  // @@protoc_insertion_point(field_add:StoreItem.included_appids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem::_internal_included_appids() const {
  return included_appids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem::included_appids() const {
  // @@protoc_insertion_point(field_list:StoreItem.included_appids)
  return _internal_included_appids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem::_internal_mutable_included_appids() {
  return &included_appids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem::mutable_included_appids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.included_appids)
  return _internal_mutable_included_appids();
}

// optional bool is_free = 13;
inline bool StoreItem::_internal_has_is_free() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool StoreItem::has_is_free() const {
  return _internal_has_is_free();
}
inline void StoreItem::clear_is_free() {
  is_free_ = false;
  _has_bits_[0] &= ~0x00400000u;
}
inline bool StoreItem::_internal_is_free() const {
  return is_free_;
}
inline bool StoreItem::is_free() const {
  // @@protoc_insertion_point(field_get:StoreItem.is_free)
  return _internal_is_free();
}
inline void StoreItem::_internal_set_is_free(bool value) {
  _has_bits_[0] |= 0x00400000u;
  is_free_ = value;
}
inline void StoreItem::set_is_free(bool value) {
  _internal_set_is_free(value);
  // @@protoc_insertion_point(field_set:StoreItem.is_free)
}

// optional bool is_early_access = 14;
inline bool StoreItem::_internal_has_is_early_access() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool StoreItem::has_is_early_access() const {
  return _internal_has_is_early_access();
}
inline void StoreItem::clear_is_early_access() {
  is_early_access_ = false;
  _has_bits_[0] &= ~0x00800000u;
}
inline bool StoreItem::_internal_is_early_access() const {
  return is_early_access_;
}
inline bool StoreItem::is_early_access() const {
  // @@protoc_insertion_point(field_get:StoreItem.is_early_access)
  return _internal_is_early_access();
}
inline void StoreItem::_internal_set_is_early_access(bool value) {
  _has_bits_[0] |= 0x00800000u;
  is_early_access_ = value;
}
inline void StoreItem::set_is_early_access(bool value) {
  _internal_set_is_early_access(value);
  // @@protoc_insertion_point(field_set:StoreItem.is_early_access)
}

// optional .StoreItem.RelatedItems related_items = 15;
inline bool StoreItem::_internal_has_related_items() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || related_items_ != nullptr);
  return value;
}
inline bool StoreItem::has_related_items() const {
  return _internal_has_related_items();
}
inline void StoreItem::clear_related_items() {
  if (related_items_ != nullptr) related_items_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::StoreItem_RelatedItems& StoreItem::_internal_related_items() const {
  const ::StoreItem_RelatedItems* p = related_items_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_RelatedItems&>(
      ::_StoreItem_RelatedItems_default_instance_);
}
inline const ::StoreItem_RelatedItems& StoreItem::related_items() const {
  // @@protoc_insertion_point(field_get:StoreItem.related_items)
  return _internal_related_items();
}
inline void StoreItem::unsafe_arena_set_allocated_related_items(
    ::StoreItem_RelatedItems* related_items) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(related_items_);
  }
  related_items_ = related_items;
  if (related_items) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.related_items)
}
inline ::StoreItem_RelatedItems* StoreItem::release_related_items() {
  _has_bits_[0] &= ~0x00000020u;
  ::StoreItem_RelatedItems* temp = related_items_;
  related_items_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_RelatedItems* StoreItem::unsafe_arena_release_related_items() {
  // @@protoc_insertion_point(field_release:StoreItem.related_items)
  _has_bits_[0] &= ~0x00000020u;
  ::StoreItem_RelatedItems* temp = related_items_;
  related_items_ = nullptr;
  return temp;
}
inline ::StoreItem_RelatedItems* StoreItem::_internal_mutable_related_items() {
  _has_bits_[0] |= 0x00000020u;
  if (related_items_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_RelatedItems>(GetArenaForAllocation());
    related_items_ = p;
  }
  return related_items_;
}
inline ::StoreItem_RelatedItems* StoreItem::mutable_related_items() {
  ::StoreItem_RelatedItems* _msg = _internal_mutable_related_items();
  // @@protoc_insertion_point(field_mutable:StoreItem.related_items)
  return _msg;
}
inline void StoreItem::set_allocated_related_items(::StoreItem_RelatedItems* related_items) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete related_items_;
  }
  if (related_items) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_RelatedItems>::GetOwningArena(related_items);
    if (message_arena != submessage_arena) {
      related_items = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, related_items, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  related_items_ = related_items;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.related_items)
}

// repeated .EContentDescriptorID content_descriptorids = 20;
inline int StoreItem::_internal_content_descriptorids_size() const {
  return content_descriptorids_.size();
}
inline int StoreItem::content_descriptorids_size() const {
  return _internal_content_descriptorids_size();
}
inline void StoreItem::clear_content_descriptorids() {
  content_descriptorids_.Clear();
}
inline ::EContentDescriptorID StoreItem::_internal_content_descriptorids(int index) const {
  return static_cast< ::EContentDescriptorID >(content_descriptorids_.Get(index));
}
inline ::EContentDescriptorID StoreItem::content_descriptorids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.content_descriptorids)
  return _internal_content_descriptorids(index);
}
inline void StoreItem::set_content_descriptorids(int index, ::EContentDescriptorID value) {
  assert(::EContentDescriptorID_IsValid(value));
  content_descriptorids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.content_descriptorids)
}
inline void StoreItem::_internal_add_content_descriptorids(::EContentDescriptorID value) {
  assert(::EContentDescriptorID_IsValid(value));
  content_descriptorids_.Add(value);
}
inline void StoreItem::add_content_descriptorids(::EContentDescriptorID value) {
  _internal_add_content_descriptorids(value);
  // @@protoc_insertion_point(field_add:StoreItem.content_descriptorids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
StoreItem::content_descriptorids() const {
  // @@protoc_insertion_point(field_list:StoreItem.content_descriptorids)
  return content_descriptorids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StoreItem::_internal_mutable_content_descriptorids() {
  return &content_descriptorids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
StoreItem::mutable_content_descriptorids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.content_descriptorids)
  return _internal_mutable_content_descriptorids();
}

// repeated uint32 tagids = 21;
inline int StoreItem::_internal_tagids_size() const {
  return tagids_.size();
}
inline int StoreItem::tagids_size() const {
  return _internal_tagids_size();
}
inline void StoreItem::clear_tagids() {
  tagids_.Clear();
}
inline uint32_t StoreItem::_internal_tagids(int index) const {
  return tagids_.Get(index);
}
inline uint32_t StoreItem::tagids(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.tagids)
  return _internal_tagids(index);
}
inline void StoreItem::set_tagids(int index, uint32_t value) {
  tagids_.Set(index, value);
  // @@protoc_insertion_point(field_set:StoreItem.tagids)
}
inline void StoreItem::_internal_add_tagids(uint32_t value) {
  tagids_.Add(value);
}
inline void StoreItem::add_tagids(uint32_t value) {
  _internal_add_tagids(value);
  // @@protoc_insertion_point(field_add:StoreItem.tagids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem::_internal_tagids() const {
  return tagids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
StoreItem::tagids() const {
  // @@protoc_insertion_point(field_list:StoreItem.tagids)
  return _internal_tagids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem::_internal_mutable_tagids() {
  return &tagids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
StoreItem::mutable_tagids() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.tagids)
  return _internal_mutable_tagids();
}

// optional .StoreItem.Categories categories = 22;
inline bool StoreItem::_internal_has_categories() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || categories_ != nullptr);
  return value;
}
inline bool StoreItem::has_categories() const {
  return _internal_has_categories();
}
inline void StoreItem::clear_categories() {
  if (categories_ != nullptr) categories_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::StoreItem_Categories& StoreItem::_internal_categories() const {
  const ::StoreItem_Categories* p = categories_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Categories&>(
      ::_StoreItem_Categories_default_instance_);
}
inline const ::StoreItem_Categories& StoreItem::categories() const {
  // @@protoc_insertion_point(field_get:StoreItem.categories)
  return _internal_categories();
}
inline void StoreItem::unsafe_arena_set_allocated_categories(
    ::StoreItem_Categories* categories) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(categories_);
  }
  categories_ = categories;
  if (categories) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.categories)
}
inline ::StoreItem_Categories* StoreItem::release_categories() {
  _has_bits_[0] &= ~0x00000040u;
  ::StoreItem_Categories* temp = categories_;
  categories_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Categories* StoreItem::unsafe_arena_release_categories() {
  // @@protoc_insertion_point(field_release:StoreItem.categories)
  _has_bits_[0] &= ~0x00000040u;
  ::StoreItem_Categories* temp = categories_;
  categories_ = nullptr;
  return temp;
}
inline ::StoreItem_Categories* StoreItem::_internal_mutable_categories() {
  _has_bits_[0] |= 0x00000040u;
  if (categories_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Categories>(GetArenaForAllocation());
    categories_ = p;
  }
  return categories_;
}
inline ::StoreItem_Categories* StoreItem::mutable_categories() {
  ::StoreItem_Categories* _msg = _internal_mutable_categories();
  // @@protoc_insertion_point(field_mutable:StoreItem.categories)
  return _msg;
}
inline void StoreItem::set_allocated_categories(::StoreItem_Categories* categories) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete categories_;
  }
  if (categories) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Categories>::GetOwningArena(categories);
    if (message_arena != submessage_arena) {
      categories = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, categories, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  categories_ = categories;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.categories)
}

// optional .StoreItem.Reviews reviews = 23;
inline bool StoreItem::_internal_has_reviews() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || reviews_ != nullptr);
  return value;
}
inline bool StoreItem::has_reviews() const {
  return _internal_has_reviews();
}
inline void StoreItem::clear_reviews() {
  if (reviews_ != nullptr) reviews_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::StoreItem_Reviews& StoreItem::_internal_reviews() const {
  const ::StoreItem_Reviews* p = reviews_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Reviews&>(
      ::_StoreItem_Reviews_default_instance_);
}
inline const ::StoreItem_Reviews& StoreItem::reviews() const {
  // @@protoc_insertion_point(field_get:StoreItem.reviews)
  return _internal_reviews();
}
inline void StoreItem::unsafe_arena_set_allocated_reviews(
    ::StoreItem_Reviews* reviews) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(reviews_);
  }
  reviews_ = reviews;
  if (reviews) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.reviews)
}
inline ::StoreItem_Reviews* StoreItem::release_reviews() {
  _has_bits_[0] &= ~0x00000080u;
  ::StoreItem_Reviews* temp = reviews_;
  reviews_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Reviews* StoreItem::unsafe_arena_release_reviews() {
  // @@protoc_insertion_point(field_release:StoreItem.reviews)
  _has_bits_[0] &= ~0x00000080u;
  ::StoreItem_Reviews* temp = reviews_;
  reviews_ = nullptr;
  return temp;
}
inline ::StoreItem_Reviews* StoreItem::_internal_mutable_reviews() {
  _has_bits_[0] |= 0x00000080u;
  if (reviews_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Reviews>(GetArenaForAllocation());
    reviews_ = p;
  }
  return reviews_;
}
inline ::StoreItem_Reviews* StoreItem::mutable_reviews() {
  ::StoreItem_Reviews* _msg = _internal_mutable_reviews();
  // @@protoc_insertion_point(field_mutable:StoreItem.reviews)
  return _msg;
}
inline void StoreItem::set_allocated_reviews(::StoreItem_Reviews* reviews) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reviews_;
  }
  if (reviews) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Reviews>::GetOwningArena(reviews);
    if (message_arena != submessage_arena) {
      reviews = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, reviews, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  reviews_ = reviews;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.reviews)
}

// optional .StoreItem.BasicInfo basic_info = 24;
inline bool StoreItem::_internal_has_basic_info() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || basic_info_ != nullptr);
  return value;
}
inline bool StoreItem::has_basic_info() const {
  return _internal_has_basic_info();
}
inline void StoreItem::clear_basic_info() {
  if (basic_info_ != nullptr) basic_info_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::StoreItem_BasicInfo& StoreItem::_internal_basic_info() const {
  const ::StoreItem_BasicInfo* p = basic_info_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_BasicInfo&>(
      ::_StoreItem_BasicInfo_default_instance_);
}
inline const ::StoreItem_BasicInfo& StoreItem::basic_info() const {
  // @@protoc_insertion_point(field_get:StoreItem.basic_info)
  return _internal_basic_info();
}
inline void StoreItem::unsafe_arena_set_allocated_basic_info(
    ::StoreItem_BasicInfo* basic_info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(basic_info_);
  }
  basic_info_ = basic_info;
  if (basic_info) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.basic_info)
}
inline ::StoreItem_BasicInfo* StoreItem::release_basic_info() {
  _has_bits_[0] &= ~0x00000100u;
  ::StoreItem_BasicInfo* temp = basic_info_;
  basic_info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_BasicInfo* StoreItem::unsafe_arena_release_basic_info() {
  // @@protoc_insertion_point(field_release:StoreItem.basic_info)
  _has_bits_[0] &= ~0x00000100u;
  ::StoreItem_BasicInfo* temp = basic_info_;
  basic_info_ = nullptr;
  return temp;
}
inline ::StoreItem_BasicInfo* StoreItem::_internal_mutable_basic_info() {
  _has_bits_[0] |= 0x00000100u;
  if (basic_info_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_BasicInfo>(GetArenaForAllocation());
    basic_info_ = p;
  }
  return basic_info_;
}
inline ::StoreItem_BasicInfo* StoreItem::mutable_basic_info() {
  ::StoreItem_BasicInfo* _msg = _internal_mutable_basic_info();
  // @@protoc_insertion_point(field_mutable:StoreItem.basic_info)
  return _msg;
}
inline void StoreItem::set_allocated_basic_info(::StoreItem_BasicInfo* basic_info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete basic_info_;
  }
  if (basic_info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_BasicInfo>::GetOwningArena(basic_info);
    if (message_arena != submessage_arena) {
      basic_info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, basic_info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  basic_info_ = basic_info;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.basic_info)
}

// repeated .StoreItem.Tag tags = 25;
inline int StoreItem::_internal_tags_size() const {
  return tags_.size();
}
inline int StoreItem::tags_size() const {
  return _internal_tags_size();
}
inline void StoreItem::clear_tags() {
  tags_.Clear();
}
inline ::StoreItem_Tag* StoreItem::mutable_tags(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.tags)
  return tags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Tag >*
StoreItem::mutable_tags() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.tags)
  return &tags_;
}
inline const ::StoreItem_Tag& StoreItem::_internal_tags(int index) const {
  return tags_.Get(index);
}
inline const ::StoreItem_Tag& StoreItem::tags(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.tags)
  return _internal_tags(index);
}
inline ::StoreItem_Tag* StoreItem::_internal_add_tags() {
  return tags_.Add();
}
inline ::StoreItem_Tag* StoreItem::add_tags() {
  ::StoreItem_Tag* _add = _internal_add_tags();
  // @@protoc_insertion_point(field_add:StoreItem.tags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_Tag >&
StoreItem::tags() const {
  // @@protoc_insertion_point(field_list:StoreItem.tags)
  return tags_;
}

// optional .StoreItem.Assets assets = 30;
inline bool StoreItem::_internal_has_assets() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || assets_ != nullptr);
  return value;
}
inline bool StoreItem::has_assets() const {
  return _internal_has_assets();
}
inline void StoreItem::clear_assets() {
  if (assets_ != nullptr) assets_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::StoreItem_Assets& StoreItem::_internal_assets() const {
  const ::StoreItem_Assets* p = assets_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Assets&>(
      ::_StoreItem_Assets_default_instance_);
}
inline const ::StoreItem_Assets& StoreItem::assets() const {
  // @@protoc_insertion_point(field_get:StoreItem.assets)
  return _internal_assets();
}
inline void StoreItem::unsafe_arena_set_allocated_assets(
    ::StoreItem_Assets* assets) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(assets_);
  }
  assets_ = assets;
  if (assets) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.assets)
}
inline ::StoreItem_Assets* StoreItem::release_assets() {
  _has_bits_[0] &= ~0x00000200u;
  ::StoreItem_Assets* temp = assets_;
  assets_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Assets* StoreItem::unsafe_arena_release_assets() {
  // @@protoc_insertion_point(field_release:StoreItem.assets)
  _has_bits_[0] &= ~0x00000200u;
  ::StoreItem_Assets* temp = assets_;
  assets_ = nullptr;
  return temp;
}
inline ::StoreItem_Assets* StoreItem::_internal_mutable_assets() {
  _has_bits_[0] |= 0x00000200u;
  if (assets_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Assets>(GetArenaForAllocation());
    assets_ = p;
  }
  return assets_;
}
inline ::StoreItem_Assets* StoreItem::mutable_assets() {
  ::StoreItem_Assets* _msg = _internal_mutable_assets();
  // @@protoc_insertion_point(field_mutable:StoreItem.assets)
  return _msg;
}
inline void StoreItem::set_allocated_assets(::StoreItem_Assets* assets) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete assets_;
  }
  if (assets) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Assets>::GetOwningArena(assets);
    if (message_arena != submessage_arena) {
      assets = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, assets, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  assets_ = assets;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.assets)
}

// optional .StoreItem.ReleaseInfo release = 31;
inline bool StoreItem::_internal_has_release() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || release_ != nullptr);
  return value;
}
inline bool StoreItem::has_release() const {
  return _internal_has_release();
}
inline void StoreItem::clear_release() {
  if (release_ != nullptr) release_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::StoreItem_ReleaseInfo& StoreItem::_internal_release() const {
  const ::StoreItem_ReleaseInfo* p = release_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_ReleaseInfo&>(
      ::_StoreItem_ReleaseInfo_default_instance_);
}
inline const ::StoreItem_ReleaseInfo& StoreItem::release() const {
  // @@protoc_insertion_point(field_get:StoreItem.release)
  return _internal_release();
}
inline void StoreItem::unsafe_arena_set_allocated_release(
    ::StoreItem_ReleaseInfo* release) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(release_);
  }
  release_ = release;
  if (release) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.release)
}
inline ::StoreItem_ReleaseInfo* StoreItem::release_release() {
  _has_bits_[0] &= ~0x00000400u;
  ::StoreItem_ReleaseInfo* temp = release_;
  release_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_ReleaseInfo* StoreItem::unsafe_arena_release_release() {
  // @@protoc_insertion_point(field_release:StoreItem.release)
  _has_bits_[0] &= ~0x00000400u;
  ::StoreItem_ReleaseInfo* temp = release_;
  release_ = nullptr;
  return temp;
}
inline ::StoreItem_ReleaseInfo* StoreItem::_internal_mutable_release() {
  _has_bits_[0] |= 0x00000400u;
  if (release_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_ReleaseInfo>(GetArenaForAllocation());
    release_ = p;
  }
  return release_;
}
inline ::StoreItem_ReleaseInfo* StoreItem::mutable_release() {
  ::StoreItem_ReleaseInfo* _msg = _internal_mutable_release();
  // @@protoc_insertion_point(field_mutable:StoreItem.release)
  return _msg;
}
inline void StoreItem::set_allocated_release(::StoreItem_ReleaseInfo* release) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete release_;
  }
  if (release) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_ReleaseInfo>::GetOwningArena(release);
    if (message_arena != submessage_arena) {
      release = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, release, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  release_ = release;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.release)
}

// optional .StoreItem.Platforms platforms = 32;
inline bool StoreItem::_internal_has_platforms() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  PROTOBUF_ASSUME(!value || platforms_ != nullptr);
  return value;
}
inline bool StoreItem::has_platforms() const {
  return _internal_has_platforms();
}
inline void StoreItem::clear_platforms() {
  if (platforms_ != nullptr) platforms_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::StoreItem_Platforms& StoreItem::_internal_platforms() const {
  const ::StoreItem_Platforms* p = platforms_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Platforms&>(
      ::_StoreItem_Platforms_default_instance_);
}
inline const ::StoreItem_Platforms& StoreItem::platforms() const {
  // @@protoc_insertion_point(field_get:StoreItem.platforms)
  return _internal_platforms();
}
inline void StoreItem::unsafe_arena_set_allocated_platforms(
    ::StoreItem_Platforms* platforms) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(platforms_);
  }
  platforms_ = platforms;
  if (platforms) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.platforms)
}
inline ::StoreItem_Platforms* StoreItem::release_platforms() {
  _has_bits_[0] &= ~0x00000800u;
  ::StoreItem_Platforms* temp = platforms_;
  platforms_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Platforms* StoreItem::unsafe_arena_release_platforms() {
  // @@protoc_insertion_point(field_release:StoreItem.platforms)
  _has_bits_[0] &= ~0x00000800u;
  ::StoreItem_Platforms* temp = platforms_;
  platforms_ = nullptr;
  return temp;
}
inline ::StoreItem_Platforms* StoreItem::_internal_mutable_platforms() {
  _has_bits_[0] |= 0x00000800u;
  if (platforms_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Platforms>(GetArenaForAllocation());
    platforms_ = p;
  }
  return platforms_;
}
inline ::StoreItem_Platforms* StoreItem::mutable_platforms() {
  ::StoreItem_Platforms* _msg = _internal_mutable_platforms();
  // @@protoc_insertion_point(field_mutable:StoreItem.platforms)
  return _msg;
}
inline void StoreItem::set_allocated_platforms(::StoreItem_Platforms* platforms) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete platforms_;
  }
  if (platforms) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Platforms>::GetOwningArena(platforms);
    if (message_arena != submessage_arena) {
      platforms = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, platforms, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  platforms_ = platforms;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.platforms)
}

// optional .StoreGameRating game_rating = 33 [(.description) = "Local ratings agency information, like ESRB or PEGI"];
inline bool StoreItem::_internal_has_game_rating() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  PROTOBUF_ASSUME(!value || game_rating_ != nullptr);
  return value;
}
inline bool StoreItem::has_game_rating() const {
  return _internal_has_game_rating();
}
inline void StoreItem::clear_game_rating() {
  if (game_rating_ != nullptr) game_rating_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::StoreGameRating& StoreItem::_internal_game_rating() const {
  const ::StoreGameRating* p = game_rating_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreGameRating&>(
      ::_StoreGameRating_default_instance_);
}
inline const ::StoreGameRating& StoreItem::game_rating() const {
  // @@protoc_insertion_point(field_get:StoreItem.game_rating)
  return _internal_game_rating();
}
inline void StoreItem::unsafe_arena_set_allocated_game_rating(
    ::StoreGameRating* game_rating) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(game_rating_);
  }
  game_rating_ = game_rating;
  if (game_rating) {
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.game_rating)
}
inline ::StoreGameRating* StoreItem::release_game_rating() {
  _has_bits_[0] &= ~0x00001000u;
  ::StoreGameRating* temp = game_rating_;
  game_rating_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreGameRating* StoreItem::unsafe_arena_release_game_rating() {
  // @@protoc_insertion_point(field_release:StoreItem.game_rating)
  _has_bits_[0] &= ~0x00001000u;
  ::StoreGameRating* temp = game_rating_;
  game_rating_ = nullptr;
  return temp;
}
inline ::StoreGameRating* StoreItem::_internal_mutable_game_rating() {
  _has_bits_[0] |= 0x00001000u;
  if (game_rating_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreGameRating>(GetArenaForAllocation());
    game_rating_ = p;
  }
  return game_rating_;
}
inline ::StoreGameRating* StoreItem::mutable_game_rating() {
  ::StoreGameRating* _msg = _internal_mutable_game_rating();
  // @@protoc_insertion_point(field_mutable:StoreItem.game_rating)
  return _msg;
}
inline void StoreItem::set_allocated_game_rating(::StoreGameRating* game_rating) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete game_rating_;
  }
  if (game_rating) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreGameRating>::GetOwningArena(game_rating);
    if (message_arena != submessage_arena) {
      game_rating = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, game_rating, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  game_rating_ = game_rating;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.game_rating)
}

// optional .StoreItem.PurchaseOption best_purchase_option = 40 [(.description) = "The cheapest way for the user to acquire this app or package (may be a bundle)."];
inline bool StoreItem::_internal_has_best_purchase_option() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  PROTOBUF_ASSUME(!value || best_purchase_option_ != nullptr);
  return value;
}
inline bool StoreItem::has_best_purchase_option() const {
  return _internal_has_best_purchase_option();
}
inline void StoreItem::clear_best_purchase_option() {
  if (best_purchase_option_ != nullptr) best_purchase_option_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::StoreItem_PurchaseOption& StoreItem::_internal_best_purchase_option() const {
  const ::StoreItem_PurchaseOption* p = best_purchase_option_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_PurchaseOption&>(
      ::_StoreItem_PurchaseOption_default_instance_);
}
inline const ::StoreItem_PurchaseOption& StoreItem::best_purchase_option() const {
  // @@protoc_insertion_point(field_get:StoreItem.best_purchase_option)
  return _internal_best_purchase_option();
}
inline void StoreItem::unsafe_arena_set_allocated_best_purchase_option(
    ::StoreItem_PurchaseOption* best_purchase_option) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(best_purchase_option_);
  }
  best_purchase_option_ = best_purchase_option;
  if (best_purchase_option) {
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.best_purchase_option)
}
inline ::StoreItem_PurchaseOption* StoreItem::release_best_purchase_option() {
  _has_bits_[0] &= ~0x00002000u;
  ::StoreItem_PurchaseOption* temp = best_purchase_option_;
  best_purchase_option_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_PurchaseOption* StoreItem::unsafe_arena_release_best_purchase_option() {
  // @@protoc_insertion_point(field_release:StoreItem.best_purchase_option)
  _has_bits_[0] &= ~0x00002000u;
  ::StoreItem_PurchaseOption* temp = best_purchase_option_;
  best_purchase_option_ = nullptr;
  return temp;
}
inline ::StoreItem_PurchaseOption* StoreItem::_internal_mutable_best_purchase_option() {
  _has_bits_[0] |= 0x00002000u;
  if (best_purchase_option_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_PurchaseOption>(GetArenaForAllocation());
    best_purchase_option_ = p;
  }
  return best_purchase_option_;
}
inline ::StoreItem_PurchaseOption* StoreItem::mutable_best_purchase_option() {
  ::StoreItem_PurchaseOption* _msg = _internal_mutable_best_purchase_option();
  // @@protoc_insertion_point(field_mutable:StoreItem.best_purchase_option)
  return _msg;
}
inline void StoreItem::set_allocated_best_purchase_option(::StoreItem_PurchaseOption* best_purchase_option) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete best_purchase_option_;
  }
  if (best_purchase_option) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_PurchaseOption>::GetOwningArena(best_purchase_option);
    if (message_arena != submessage_arena) {
      best_purchase_option = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, best_purchase_option, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  best_purchase_option_ = best_purchase_option;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.best_purchase_option)
}

// repeated .StoreItem.PurchaseOption purchase_options = 41 [(.description) = "Different ways to buy this app or packages (packages can be purchased directly, but may also be included in bundles)."];
inline int StoreItem::_internal_purchase_options_size() const {
  return purchase_options_.size();
}
inline int StoreItem::purchase_options_size() const {
  return _internal_purchase_options_size();
}
inline void StoreItem::clear_purchase_options() {
  purchase_options_.Clear();
}
inline ::StoreItem_PurchaseOption* StoreItem::mutable_purchase_options(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.purchase_options)
  return purchase_options_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >*
StoreItem::mutable_purchase_options() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.purchase_options)
  return &purchase_options_;
}
inline const ::StoreItem_PurchaseOption& StoreItem::_internal_purchase_options(int index) const {
  return purchase_options_.Get(index);
}
inline const ::StoreItem_PurchaseOption& StoreItem::purchase_options(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.purchase_options)
  return _internal_purchase_options(index);
}
inline ::StoreItem_PurchaseOption* StoreItem::_internal_add_purchase_options() {
  return purchase_options_.Add();
}
inline ::StoreItem_PurchaseOption* StoreItem::add_purchase_options() {
  ::StoreItem_PurchaseOption* _add = _internal_add_purchase_options();
  // @@protoc_insertion_point(field_add:StoreItem.purchase_options)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >&
StoreItem::purchase_options() const {
  // @@protoc_insertion_point(field_list:StoreItem.purchase_options)
  return purchase_options_;
}

// repeated .StoreItem.PurchaseOption accessories = 42 [(.description) = "Additional packages or bundles associated with an app, but that do not contain the app."];
inline int StoreItem::_internal_accessories_size() const {
  return accessories_.size();
}
inline int StoreItem::accessories_size() const {
  return _internal_accessories_size();
}
inline void StoreItem::clear_accessories() {
  accessories_.Clear();
}
inline ::StoreItem_PurchaseOption* StoreItem::mutable_accessories(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.accessories)
  return accessories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >*
StoreItem::mutable_accessories() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.accessories)
  return &accessories_;
}
inline const ::StoreItem_PurchaseOption& StoreItem::_internal_accessories(int index) const {
  return accessories_.Get(index);
}
inline const ::StoreItem_PurchaseOption& StoreItem::accessories(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.accessories)
  return _internal_accessories(index);
}
inline ::StoreItem_PurchaseOption* StoreItem::_internal_add_accessories() {
  return accessories_.Add();
}
inline ::StoreItem_PurchaseOption* StoreItem::add_accessories() {
  ::StoreItem_PurchaseOption* _add = _internal_add_accessories();
  // @@protoc_insertion_point(field_add:StoreItem.accessories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_PurchaseOption >&
StoreItem::accessories() const {
  // @@protoc_insertion_point(field_list:StoreItem.accessories)
  return accessories_;
}

// optional .StoreItem.Screenshots screenshots = 50;
inline bool StoreItem::_internal_has_screenshots() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  PROTOBUF_ASSUME(!value || screenshots_ != nullptr);
  return value;
}
inline bool StoreItem::has_screenshots() const {
  return _internal_has_screenshots();
}
inline void StoreItem::clear_screenshots() {
  if (screenshots_ != nullptr) screenshots_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::StoreItem_Screenshots& StoreItem::_internal_screenshots() const {
  const ::StoreItem_Screenshots* p = screenshots_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Screenshots&>(
      ::_StoreItem_Screenshots_default_instance_);
}
inline const ::StoreItem_Screenshots& StoreItem::screenshots() const {
  // @@protoc_insertion_point(field_get:StoreItem.screenshots)
  return _internal_screenshots();
}
inline void StoreItem::unsafe_arena_set_allocated_screenshots(
    ::StoreItem_Screenshots* screenshots) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(screenshots_);
  }
  screenshots_ = screenshots;
  if (screenshots) {
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.screenshots)
}
inline ::StoreItem_Screenshots* StoreItem::release_screenshots() {
  _has_bits_[0] &= ~0x00004000u;
  ::StoreItem_Screenshots* temp = screenshots_;
  screenshots_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Screenshots* StoreItem::unsafe_arena_release_screenshots() {
  // @@protoc_insertion_point(field_release:StoreItem.screenshots)
  _has_bits_[0] &= ~0x00004000u;
  ::StoreItem_Screenshots* temp = screenshots_;
  screenshots_ = nullptr;
  return temp;
}
inline ::StoreItem_Screenshots* StoreItem::_internal_mutable_screenshots() {
  _has_bits_[0] |= 0x00004000u;
  if (screenshots_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Screenshots>(GetArenaForAllocation());
    screenshots_ = p;
  }
  return screenshots_;
}
inline ::StoreItem_Screenshots* StoreItem::mutable_screenshots() {
  ::StoreItem_Screenshots* _msg = _internal_mutable_screenshots();
  // @@protoc_insertion_point(field_mutable:StoreItem.screenshots)
  return _msg;
}
inline void StoreItem::set_allocated_screenshots(::StoreItem_Screenshots* screenshots) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete screenshots_;
  }
  if (screenshots) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Screenshots>::GetOwningArena(screenshots);
    if (message_arena != submessage_arena) {
      screenshots = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, screenshots, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  screenshots_ = screenshots;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.screenshots)
}

// optional .StoreItem.Trailers trailers = 51;
inline bool StoreItem::_internal_has_trailers() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  PROTOBUF_ASSUME(!value || trailers_ != nullptr);
  return value;
}
inline bool StoreItem::has_trailers() const {
  return _internal_has_trailers();
}
inline void StoreItem::clear_trailers() {
  if (trailers_ != nullptr) trailers_->Clear();
  _has_bits_[0] &= ~0x00008000u;
}
inline const ::StoreItem_Trailers& StoreItem::_internal_trailers() const {
  const ::StoreItem_Trailers* p = trailers_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_Trailers&>(
      ::_StoreItem_Trailers_default_instance_);
}
inline const ::StoreItem_Trailers& StoreItem::trailers() const {
  // @@protoc_insertion_point(field_get:StoreItem.trailers)
  return _internal_trailers();
}
inline void StoreItem::unsafe_arena_set_allocated_trailers(
    ::StoreItem_Trailers* trailers) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(trailers_);
  }
  trailers_ = trailers;
  if (trailers) {
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.trailers)
}
inline ::StoreItem_Trailers* StoreItem::release_trailers() {
  _has_bits_[0] &= ~0x00008000u;
  ::StoreItem_Trailers* temp = trailers_;
  trailers_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_Trailers* StoreItem::unsafe_arena_release_trailers() {
  // @@protoc_insertion_point(field_release:StoreItem.trailers)
  _has_bits_[0] &= ~0x00008000u;
  ::StoreItem_Trailers* temp = trailers_;
  trailers_ = nullptr;
  return temp;
}
inline ::StoreItem_Trailers* StoreItem::_internal_mutable_trailers() {
  _has_bits_[0] |= 0x00008000u;
  if (trailers_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_Trailers>(GetArenaForAllocation());
    trailers_ = p;
  }
  return trailers_;
}
inline ::StoreItem_Trailers* StoreItem::mutable_trailers() {
  ::StoreItem_Trailers* _msg = _internal_mutable_trailers();
  // @@protoc_insertion_point(field_mutable:StoreItem.trailers)
  return _msg;
}
inline void StoreItem::set_allocated_trailers(::StoreItem_Trailers* trailers) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete trailers_;
  }
  if (trailers) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_Trailers>::GetOwningArena(trailers);
    if (message_arena != submessage_arena) {
      trailers = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, trailers, submessage_arena);
    }
    _has_bits_[0] |= 0x00008000u;
  } else {
    _has_bits_[0] &= ~0x00008000u;
  }
  trailers_ = trailers;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.trailers)
}

// repeated .StoreItem.SupportedLanguage supported_languages = 52;
inline int StoreItem::_internal_supported_languages_size() const {
  return supported_languages_.size();
}
inline int StoreItem::supported_languages_size() const {
  return _internal_supported_languages_size();
}
inline void StoreItem::clear_supported_languages() {
  supported_languages_.Clear();
}
inline ::StoreItem_SupportedLanguage* StoreItem::mutable_supported_languages(int index) {
  // @@protoc_insertion_point(field_mutable:StoreItem.supported_languages)
  return supported_languages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_SupportedLanguage >*
StoreItem::mutable_supported_languages() {
  // @@protoc_insertion_point(field_mutable_list:StoreItem.supported_languages)
  return &supported_languages_;
}
inline const ::StoreItem_SupportedLanguage& StoreItem::_internal_supported_languages(int index) const {
  return supported_languages_.Get(index);
}
inline const ::StoreItem_SupportedLanguage& StoreItem::supported_languages(int index) const {
  // @@protoc_insertion_point(field_get:StoreItem.supported_languages)
  return _internal_supported_languages(index);
}
inline ::StoreItem_SupportedLanguage* StoreItem::_internal_add_supported_languages() {
  return supported_languages_.Add();
}
inline ::StoreItem_SupportedLanguage* StoreItem::add_supported_languages() {
  ::StoreItem_SupportedLanguage* _add = _internal_add_supported_languages();
  // @@protoc_insertion_point(field_add:StoreItem.supported_languages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem_SupportedLanguage >&
StoreItem::supported_languages() const {
  // @@protoc_insertion_point(field_list:StoreItem.supported_languages)
  return supported_languages_;
}

// optional string store_url_path_override = 53 [(.description) = "Navigate to this URL (relative to store home) when the store capsule for this item is clicked, instead of the default /app/... URL. Used by advertising apps that point to a sale page."];
inline bool StoreItem::_internal_has_store_url_path_override() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool StoreItem::has_store_url_path_override() const {
  return _internal_has_store_url_path_override();
}
inline void StoreItem::clear_store_url_path_override() {
  store_url_path_override_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& StoreItem::store_url_path_override() const {
  // @@protoc_insertion_point(field_get:StoreItem.store_url_path_override)
  return _internal_store_url_path_override();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem::set_store_url_path_override(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 store_url_path_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.store_url_path_override)
}
inline std::string* StoreItem::mutable_store_url_path_override() {
  std::string* _s = _internal_mutable_store_url_path_override();
  // @@protoc_insertion_point(field_mutable:StoreItem.store_url_path_override)
  return _s;
}
inline const std::string& StoreItem::_internal_store_url_path_override() const {
  return store_url_path_override_.Get();
}
inline void StoreItem::_internal_set_store_url_path_override(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  store_url_path_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem::_internal_mutable_store_url_path_override() {
  _has_bits_[0] |= 0x00000004u;
  return store_url_path_override_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem::release_store_url_path_override() {
  // @@protoc_insertion_point(field_release:StoreItem.store_url_path_override)
  if (!_internal_has_store_url_path_override()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = store_url_path_override_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_url_path_override_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_url_path_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem::set_allocated_store_url_path_override(std::string* store_url_path_override) {
  if (store_url_path_override != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  store_url_path_override_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), store_url_path_override,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (store_url_path_override_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    store_url_path_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.store_url_path_override)
}

// optional .StoreItem.FreeWeekend free_weekend = 54 [(.description) = "Information about a free weekend offer."];
inline bool StoreItem::_internal_has_free_weekend() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  PROTOBUF_ASSUME(!value || free_weekend_ != nullptr);
  return value;
}
inline bool StoreItem::has_free_weekend() const {
  return _internal_has_free_weekend();
}
inline void StoreItem::clear_free_weekend() {
  if (free_weekend_ != nullptr) free_weekend_->Clear();
  _has_bits_[0] &= ~0x00010000u;
}
inline const ::StoreItem_FreeWeekend& StoreItem::_internal_free_weekend() const {
  const ::StoreItem_FreeWeekend* p = free_weekend_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreItem_FreeWeekend&>(
      ::_StoreItem_FreeWeekend_default_instance_);
}
inline const ::StoreItem_FreeWeekend& StoreItem::free_weekend() const {
  // @@protoc_insertion_point(field_get:StoreItem.free_weekend)
  return _internal_free_weekend();
}
inline void StoreItem::unsafe_arena_set_allocated_free_weekend(
    ::StoreItem_FreeWeekend* free_weekend) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(free_weekend_);
  }
  free_weekend_ = free_weekend;
  if (free_weekend) {
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StoreItem.free_weekend)
}
inline ::StoreItem_FreeWeekend* StoreItem::release_free_weekend() {
  _has_bits_[0] &= ~0x00010000u;
  ::StoreItem_FreeWeekend* temp = free_weekend_;
  free_weekend_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreItem_FreeWeekend* StoreItem::unsafe_arena_release_free_weekend() {
  // @@protoc_insertion_point(field_release:StoreItem.free_weekend)
  _has_bits_[0] &= ~0x00010000u;
  ::StoreItem_FreeWeekend* temp = free_weekend_;
  free_weekend_ = nullptr;
  return temp;
}
inline ::StoreItem_FreeWeekend* StoreItem::_internal_mutable_free_weekend() {
  _has_bits_[0] |= 0x00010000u;
  if (free_weekend_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreItem_FreeWeekend>(GetArenaForAllocation());
    free_weekend_ = p;
  }
  return free_weekend_;
}
inline ::StoreItem_FreeWeekend* StoreItem::mutable_free_weekend() {
  ::StoreItem_FreeWeekend* _msg = _internal_mutable_free_weekend();
  // @@protoc_insertion_point(field_mutable:StoreItem.free_weekend)
  return _msg;
}
inline void StoreItem::set_allocated_free_weekend(::StoreItem_FreeWeekend* free_weekend) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete free_weekend_;
  }
  if (free_weekend) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreItem_FreeWeekend>::GetOwningArena(free_weekend);
    if (message_arena != submessage_arena) {
      free_weekend = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, free_weekend, submessage_arena);
    }
    _has_bits_[0] |= 0x00010000u;
  } else {
    _has_bits_[0] &= ~0x00010000u;
  }
  free_weekend_ = free_weekend;
  // @@protoc_insertion_point(field_set_allocated:StoreItem.free_weekend)
}

// optional bool unlisted = 55 [(.description) = "If true, item is only accessible on store via a direct link"];
inline bool StoreItem::_internal_has_unlisted() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool StoreItem::has_unlisted() const {
  return _internal_has_unlisted();
}
inline void StoreItem::clear_unlisted() {
  unlisted_ = false;
  _has_bits_[0] &= ~0x02000000u;
}
inline bool StoreItem::_internal_unlisted() const {
  return unlisted_;
}
inline bool StoreItem::unlisted() const {
  // @@protoc_insertion_point(field_get:StoreItem.unlisted)
  return _internal_unlisted();
}
inline void StoreItem::_internal_set_unlisted(bool value) {
  _has_bits_[0] |= 0x02000000u;
  unlisted_ = value;
}
inline void StoreItem::set_unlisted(bool value) {
  _internal_set_unlisted(value);
  // @@protoc_insertion_point(field_set:StoreItem.unlisted)
}

// optional uint32 game_count = 56 [(.description) = "For creators and tags, how many games belong to them"];
inline bool StoreItem::_internal_has_game_count() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool StoreItem::has_game_count() const {
  return _internal_has_game_count();
}
inline void StoreItem::clear_game_count() {
  game_count_ = 0u;
  _has_bits_[0] &= ~0x04000000u;
}
inline uint32_t StoreItem::_internal_game_count() const {
  return game_count_;
}
inline uint32_t StoreItem::game_count() const {
  // @@protoc_insertion_point(field_get:StoreItem.game_count)
  return _internal_game_count();
}
inline void StoreItem::_internal_set_game_count(uint32_t value) {
  _has_bits_[0] |= 0x04000000u;
  game_count_ = value;
}
inline void StoreItem::set_game_count(uint32_t value) {
  _internal_set_game_count(value);
  // @@protoc_insertion_point(field_set:StoreItem.game_count)
}

// optional string internal_name = 57 [(.description) = "For hub categories, the internal name (handle) of the category"];
inline bool StoreItem::_internal_has_internal_name() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool StoreItem::has_internal_name() const {
  return _internal_has_internal_name();
}
inline void StoreItem::clear_internal_name() {
  internal_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& StoreItem::internal_name() const {
  // @@protoc_insertion_point(field_get:StoreItem.internal_name)
  return _internal_internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem::set_internal_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.internal_name)
}
inline std::string* StoreItem::mutable_internal_name() {
  std::string* _s = _internal_mutable_internal_name();
  // @@protoc_insertion_point(field_mutable:StoreItem.internal_name)
  return _s;
}
inline const std::string& StoreItem::_internal_internal_name() const {
  return internal_name_.Get();
}
inline void StoreItem::_internal_set_internal_name(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem::_internal_mutable_internal_name() {
  _has_bits_[0] |= 0x00000008u;
  return internal_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem::release_internal_name() {
  // @@protoc_insertion_point(field_release:StoreItem.internal_name)
  if (!_internal_has_internal_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = internal_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (internal_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem::set_allocated_internal_name(std::string* internal_name) {
  if (internal_name != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  internal_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), internal_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (internal_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.internal_name)
}

// optional string full_description = 58 [(.description) = "About this game section on the store page"];
inline bool StoreItem::_internal_has_full_description() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool StoreItem::has_full_description() const {
  return _internal_has_full_description();
}
inline void StoreItem::clear_full_description() {
  full_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& StoreItem::full_description() const {
  // @@protoc_insertion_point(field_get:StoreItem.full_description)
  return _internal_full_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void StoreItem::set_full_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 full_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:StoreItem.full_description)
}
inline std::string* StoreItem::mutable_full_description() {
  std::string* _s = _internal_mutable_full_description();
  // @@protoc_insertion_point(field_mutable:StoreItem.full_description)
  return _s;
}
inline const std::string& StoreItem::_internal_full_description() const {
  return full_description_.Get();
}
inline void StoreItem::_internal_set_full_description(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  full_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* StoreItem::_internal_mutable_full_description() {
  _has_bits_[0] |= 0x00000010u;
  return full_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* StoreItem::release_full_description() {
  // @@protoc_insertion_point(field_release:StoreItem.full_description)
  if (!_internal_has_full_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = full_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    full_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void StoreItem::set_allocated_full_description(std::string* full_description) {
  if (full_description != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  full_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), full_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (full_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    full_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:StoreItem.full_description)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetItems_Response

// repeated .StoreItem store_items = 1;
inline int CStoreBrowse_GetItems_Response::_internal_store_items_size() const {
  return store_items_.size();
}
inline int CStoreBrowse_GetItems_Response::store_items_size() const {
  return _internal_store_items_size();
}
inline void CStoreBrowse_GetItems_Response::clear_store_items() {
  store_items_.Clear();
}
inline ::StoreItem* CStoreBrowse_GetItems_Response::mutable_store_items(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetItems_Response.store_items)
  return store_items_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem >*
CStoreBrowse_GetItems_Response::mutable_store_items() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetItems_Response.store_items)
  return &store_items_;
}
inline const ::StoreItem& CStoreBrowse_GetItems_Response::_internal_store_items(int index) const {
  return store_items_.Get(index);
}
inline const ::StoreItem& CStoreBrowse_GetItems_Response::store_items(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetItems_Response.store_items)
  return _internal_store_items(index);
}
inline ::StoreItem* CStoreBrowse_GetItems_Response::_internal_add_store_items() {
  return store_items_.Add();
}
inline ::StoreItem* CStoreBrowse_GetItems_Response::add_store_items() {
  ::StoreItem* _add = _internal_add_store_items();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetItems_Response.store_items)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItem >&
CStoreBrowse_GetItems_Response::store_items() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetItems_Response.store_items)
  return store_items_;
}

// -------------------------------------------------------------------

// CStoreBrowse_GetStoreCategories_Request

// optional string language = 1;
inline bool CStoreBrowse_GetStoreCategories_Request::_internal_has_language() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Request::has_language() const {
  return _internal_has_language();
}
inline void CStoreBrowse_GetStoreCategories_Request::clear_language() {
  language_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Request::language() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Request.language)
  return _internal_language();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStoreBrowse_GetStoreCategories_Request::set_language(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Request.language)
}
inline std::string* CStoreBrowse_GetStoreCategories_Request::mutable_language() {
  std::string* _s = _internal_mutable_language();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetStoreCategories_Request.language)
  return _s;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Request::_internal_language() const {
  return language_.Get();
}
inline void CStoreBrowse_GetStoreCategories_Request::_internal_set_language(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Request::_internal_mutable_language() {
  _has_bits_[0] |= 0x00000001u;
  return language_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Request::release_language() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetStoreCategories_Request.language)
  if (!_internal_has_language()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = language_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStoreBrowse_GetStoreCategories_Request::set_allocated_language(std::string* language) {
  if (language != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  language_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), language,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (language_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetStoreCategories_Request.language)
}

// optional int32 elanguage = 2 [default = -1, (.description) = "ELanguage"];
inline bool CStoreBrowse_GetStoreCategories_Request::_internal_has_elanguage() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Request::has_elanguage() const {
  return _internal_has_elanguage();
}
inline void CStoreBrowse_GetStoreCategories_Request::clear_elanguage() {
  elanguage_ = -1;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CStoreBrowse_GetStoreCategories_Request::_internal_elanguage() const {
  return elanguage_;
}
inline int32_t CStoreBrowse_GetStoreCategories_Request::elanguage() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Request.elanguage)
  return _internal_elanguage();
}
inline void CStoreBrowse_GetStoreCategories_Request::_internal_set_elanguage(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  elanguage_ = value;
}
inline void CStoreBrowse_GetStoreCategories_Request::set_elanguage(int32_t value) {
  _internal_set_elanguage(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Request.elanguage)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetStoreCategories_Response_Category

// optional uint32 categoryid = 1;
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_categoryid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_categoryid() const {
  return _internal_has_categoryid();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_categoryid() {
  categoryid_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStoreBrowse_GetStoreCategories_Response_Category::_internal_categoryid() const {
  return categoryid_;
}
inline uint32_t CStoreBrowse_GetStoreCategories_Response_Category::categoryid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.categoryid)
  return _internal_categoryid();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_categoryid(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  categoryid_ = value;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_categoryid(uint32_t value) {
  _internal_set_categoryid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.categoryid)
}

// optional .EStoreCategoryType type = 2 [default = k_EStoreCategoryType_Category];
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_type() const {
  return _internal_has_type();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::EStoreCategoryType CStoreBrowse_GetStoreCategories_Response_Category::_internal_type() const {
  return static_cast< ::EStoreCategoryType >(type_);
}
inline ::EStoreCategoryType CStoreBrowse_GetStoreCategories_Response_Category::type() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.type)
  return _internal_type();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_type(::EStoreCategoryType value) {
  assert(::EStoreCategoryType_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_type(::EStoreCategoryType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.type)
}

// optional string internal_name = 3;
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_internal_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_internal_name() const {
  return _internal_has_internal_name();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_internal_name() {
  internal_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::internal_name() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
  return _internal_internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStoreBrowse_GetStoreCategories_Response_Category::set_internal_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::mutable_internal_name() {
  std::string* _s = _internal_mutable_internal_name();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
  return _s;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::_internal_internal_name() const {
  return internal_name_.Get();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_internal_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  internal_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::_internal_mutable_internal_name() {
  _has_bits_[0] |= 0x00000001u;
  return internal_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::release_internal_name() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
  if (!_internal_has_internal_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = internal_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (internal_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_allocated_internal_name(std::string* internal_name) {
  if (internal_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  internal_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), internal_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (internal_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    internal_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetStoreCategories_Response.Category.internal_name)
}

// optional string display_name = 4;
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_display_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_display_name() const {
  return _internal_has_display_name();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_display_name() {
  display_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::display_name() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStoreBrowse_GetStoreCategories_Response_Category::set_display_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
  return _s;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::_internal_display_name() const {
  return display_name_.Get();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_display_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::_internal_mutable_display_name() {
  _has_bits_[0] |= 0x00000002u;
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::release_display_name() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
  if (!_internal_has_display_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = display_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (display_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetStoreCategories_Response.Category.display_name)
}

// optional string image_url = 5 [(.description) = "Append to STORE_CDN_URL"];
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_image_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_image_url() const {
  return _internal_has_image_url();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_image_url() {
  image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::image_url() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStoreBrowse_GetStoreCategories_Response_Category::set_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
  return _s;
}
inline const std::string& CStoreBrowse_GetStoreCategories_Response_Category::_internal_image_url() const {
  return image_url_.Get();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::_internal_mutable_image_url() {
  _has_bits_[0] |= 0x00000004u;
  return image_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetStoreCategories_Response_Category::release_image_url() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
  if (!_internal_has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = image_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  image_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetStoreCategories_Response.Category.image_url)
}

// optional bool show_in_search = 6 [(.description) = "Indicates this category can link to search results showing all items in category."];
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_has_show_in_search() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::has_show_in_search() const {
  return _internal_has_show_in_search();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::clear_show_in_search() {
  show_in_search_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::_internal_show_in_search() const {
  return show_in_search_;
}
inline bool CStoreBrowse_GetStoreCategories_Response_Category::show_in_search() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.Category.show_in_search)
  return _internal_show_in_search();
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::_internal_set_show_in_search(bool value) {
  _has_bits_[0] |= 0x00000020u;
  show_in_search_ = value;
}
inline void CStoreBrowse_GetStoreCategories_Response_Category::set_show_in_search(bool value) {
  _internal_set_show_in_search(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetStoreCategories_Response.Category.show_in_search)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetStoreCategories_Response

// repeated .CStoreBrowse_GetStoreCategories_Response.Category categories = 1;
inline int CStoreBrowse_GetStoreCategories_Response::_internal_categories_size() const {
  return categories_.size();
}
inline int CStoreBrowse_GetStoreCategories_Response::categories_size() const {
  return _internal_categories_size();
}
inline void CStoreBrowse_GetStoreCategories_Response::clear_categories() {
  categories_.Clear();
}
inline ::CStoreBrowse_GetStoreCategories_Response_Category* CStoreBrowse_GetStoreCategories_Response::mutable_categories(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetStoreCategories_Response.categories)
  return categories_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetStoreCategories_Response_Category >*
CStoreBrowse_GetStoreCategories_Response::mutable_categories() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetStoreCategories_Response.categories)
  return &categories_;
}
inline const ::CStoreBrowse_GetStoreCategories_Response_Category& CStoreBrowse_GetStoreCategories_Response::_internal_categories(int index) const {
  return categories_.Get(index);
}
inline const ::CStoreBrowse_GetStoreCategories_Response_Category& CStoreBrowse_GetStoreCategories_Response::categories(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetStoreCategories_Response.categories)
  return _internal_categories(index);
}
inline ::CStoreBrowse_GetStoreCategories_Response_Category* CStoreBrowse_GetStoreCategories_Response::_internal_add_categories() {
  return categories_.Add();
}
inline ::CStoreBrowse_GetStoreCategories_Response_Category* CStoreBrowse_GetStoreCategories_Response::add_categories() {
  ::CStoreBrowse_GetStoreCategories_Response_Category* _add = _internal_add_categories();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetStoreCategories_Response.categories)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetStoreCategories_Response_Category >&
CStoreBrowse_GetStoreCategories_Response::categories() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetStoreCategories_Response.categories)
  return categories_;
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForApps_Request

// optional .StoreBrowseContext context = 1;
inline bool CStoreBrowse_GetDLCForApps_Request::_internal_has_context() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || context_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Request::has_context() const {
  return _internal_has_context();
}
inline void CStoreBrowse_GetDLCForApps_Request::clear_context() {
  if (context_ != nullptr) context_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::StoreBrowseContext& CStoreBrowse_GetDLCForApps_Request::_internal_context() const {
  const ::StoreBrowseContext* p = context_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreBrowseContext&>(
      ::_StoreBrowseContext_default_instance_);
}
inline const ::StoreBrowseContext& CStoreBrowse_GetDLCForApps_Request::context() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Request.context)
  return _internal_context();
}
inline void CStoreBrowse_GetDLCForApps_Request::unsafe_arena_set_allocated_context(
    ::StoreBrowseContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetDLCForApps_Request.context)
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForApps_Request::release_context() {
  _has_bits_[0] &= ~0x00000001u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForApps_Request::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetDLCForApps_Request.context)
  _has_bits_[0] &= ~0x00000001u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForApps_Request::_internal_mutable_context() {
  _has_bits_[0] |= 0x00000001u;
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreBrowseContext>(GetArenaForAllocation());
    context_ = p;
  }
  return context_;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForApps_Request::mutable_context() {
  ::StoreBrowseContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForApps_Request.context)
  return _msg;
}
inline void CStoreBrowse_GetDLCForApps_Request::set_allocated_context(::StoreBrowseContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreBrowseContext>::GetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetDLCForApps_Request.context)
}

// optional .CStorePageFilter store_page_filter = 2;
inline bool CStoreBrowse_GetDLCForApps_Request::_internal_has_store_page_filter() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || store_page_filter_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Request::has_store_page_filter() const {
  return _internal_has_store_page_filter();
}
inline const ::CStorePageFilter& CStoreBrowse_GetDLCForApps_Request::_internal_store_page_filter() const {
  const ::CStorePageFilter* p = store_page_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStorePageFilter&>(
      ::_CStorePageFilter_default_instance_);
}
inline const ::CStorePageFilter& CStoreBrowse_GetDLCForApps_Request::store_page_filter() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
  return _internal_store_page_filter();
}
inline void CStoreBrowse_GetDLCForApps_Request::unsafe_arena_set_allocated_store_page_filter(
    ::CStorePageFilter* store_page_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter_);
  }
  store_page_filter_ = store_page_filter;
  if (store_page_filter) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForApps_Request::release_store_page_filter() {
  _has_bits_[0] &= ~0x00000002u;
  ::CStorePageFilter* temp = store_page_filter_;
  store_page_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForApps_Request::unsafe_arena_release_store_page_filter() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
  _has_bits_[0] &= ~0x00000002u;
  ::CStorePageFilter* temp = store_page_filter_;
  store_page_filter_ = nullptr;
  return temp;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForApps_Request::_internal_mutable_store_page_filter() {
  _has_bits_[0] |= 0x00000002u;
  if (store_page_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStorePageFilter>(GetArenaForAllocation());
    store_page_filter_ = p;
  }
  return store_page_filter_;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForApps_Request::mutable_store_page_filter() {
  ::CStorePageFilter* _msg = _internal_mutable_store_page_filter();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
  return _msg;
}
inline void CStoreBrowse_GetDLCForApps_Request::set_allocated_store_page_filter(::CStorePageFilter* store_page_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter_);
  }
  if (store_page_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter));
    if (message_arena != submessage_arena) {
      store_page_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_page_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  store_page_filter_ = store_page_filter;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetDLCForApps_Request.store_page_filter)
}

// repeated .StoreItemID appids = 3 [(.description) = "Apps for which we want DLC information."];
inline int CStoreBrowse_GetDLCForApps_Request::_internal_appids_size() const {
  return appids_.size();
}
inline int CStoreBrowse_GetDLCForApps_Request::appids_size() const {
  return _internal_appids_size();
}
inline void CStoreBrowse_GetDLCForApps_Request::clear_appids() {
  appids_.Clear();
}
inline ::StoreItemID* CStoreBrowse_GetDLCForApps_Request::mutable_appids(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForApps_Request.appids)
  return appids_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >*
CStoreBrowse_GetDLCForApps_Request::mutable_appids() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForApps_Request.appids)
  return &appids_;
}
inline const ::StoreItemID& CStoreBrowse_GetDLCForApps_Request::_internal_appids(int index) const {
  return appids_.Get(index);
}
inline const ::StoreItemID& CStoreBrowse_GetDLCForApps_Request::appids(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Request.appids)
  return _internal_appids(index);
}
inline ::StoreItemID* CStoreBrowse_GetDLCForApps_Request::_internal_add_appids() {
  return appids_.Add();
}
inline ::StoreItemID* CStoreBrowse_GetDLCForApps_Request::add_appids() {
  ::StoreItemID* _add = _internal_add_appids();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForApps_Request.appids)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::StoreItemID >&
CStoreBrowse_GetDLCForApps_Request::appids() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForApps_Request.appids)
  return appids_;
}

// optional uint64 steamid = 4 [(.description) = "If specified, we want DLC information for all apps owned by this user."];
inline bool CStoreBrowse_GetDLCForApps_Request::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Request::has_steamid() const {
  return _internal_has_steamid();
}
inline void CStoreBrowse_GetDLCForApps_Request::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CStoreBrowse_GetDLCForApps_Request::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CStoreBrowse_GetDLCForApps_Request::steamid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Request.steamid)
  return _internal_steamid();
}
inline void CStoreBrowse_GetDLCForApps_Request::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Request::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Request.steamid)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForApps_Response_DLCData

// optional uint32 appid = 1;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_appid() const {
  return _internal_has_appid();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_appid() const {
  return appid_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::appid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.appid)
  return _internal_appid();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.appid)
}

// optional uint32 parentappid = 2;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_parentappid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_parentappid() const {
  return _internal_has_parentappid();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_parentappid() {
  parentappid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_parentappid() const {
  return parentappid_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::parentappid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.parentappid)
  return _internal_parentappid();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_parentappid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  parentappid_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_parentappid(uint32_t value) {
  _internal_set_parentappid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.parentappid)
}

// optional uint32 release_date = 3;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_release_date() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_release_date() const {
  return _internal_has_release_date();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_release_date() {
  release_date_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_release_date() const {
  return release_date_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::release_date() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.release_date)
  return _internal_release_date();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_release_date(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  release_date_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_release_date(uint32_t value) {
  _internal_set_release_date(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.release_date)
}

// optional bool coming_soon = 4;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_coming_soon() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_coming_soon() const {
  return _internal_has_coming_soon();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_coming_soon() {
  coming_soon_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_coming_soon() const {
  return coming_soon_;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::coming_soon() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.coming_soon)
  return _internal_coming_soon();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_coming_soon(bool value) {
  _has_bits_[0] |= 0x00000008u;
  coming_soon_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_coming_soon(bool value) {
  _internal_set_coming_soon(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.coming_soon)
}

// optional int64 price = 5;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_price() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_price() const {
  return _internal_has_price();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_price() {
  price_ = int64_t{0};
  _has_bits_[0] &= ~0x00000020u;
}
inline int64_t CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_price() const {
  return price_;
}
inline int64_t CStoreBrowse_GetDLCForApps_Response_DLCData::price() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.price)
  return _internal_price();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_price(int64_t value) {
  _has_bits_[0] |= 0x00000020u;
  price_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_price(int64_t value) {
  _internal_set_price(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.price)
}

// optional uint32 discount = 6;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_discount() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_discount() const {
  return _internal_has_discount();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_discount() {
  discount_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_discount() const {
  return discount_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_DLCData::discount() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.discount)
  return _internal_discount();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_discount(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  discount_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_discount(uint32_t value) {
  _internal_set_discount(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.discount)
}

// optional bool free = 7;
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_has_free() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::has_free() const {
  return _internal_has_free();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::clear_free() {
  free_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_free() const {
  return free_;
}
inline bool CStoreBrowse_GetDLCForApps_Response_DLCData::free() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.DLCData.free)
  return _internal_free();
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::_internal_set_free(bool value) {
  _has_bits_[0] |= 0x00000010u;
  free_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_DLCData::set_free(bool value) {
  _internal_set_free(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.DLCData.free)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp

// optional uint32 appid = 1;
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::has_appid() const {
  return _internal_has_appid();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_appid() const {
  return appid_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::appid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.appid)
  return _internal_appid();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.appid)
}

// optional uint32 playtime = 2 [(.description) = "Total time played over all time."];
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_has_playtime() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::has_playtime() const {
  return _internal_has_playtime();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::clear_playtime() {
  playtime_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_playtime() const {
  return playtime_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::playtime() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.playtime)
  return _internal_playtime();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_set_playtime(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  playtime_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::set_playtime(uint32_t value) {
  _internal_set_playtime(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.playtime)
}

// optional uint32 last_played = 3 [(.description) = "Time last played on any platform."];
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_has_last_played() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::has_last_played() const {
  return _internal_has_last_played();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::clear_last_played() {
  last_played_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_last_played() const {
  return last_played_;
}
inline uint32_t CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::last_played() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.last_played)
  return _internal_last_played();
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::_internal_set_last_played(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  last_played_ = value;
}
inline void CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp::set_last_played(uint32_t value) {
  _internal_set_last_played(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp.last_played)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForApps_Response

// repeated .CStoreBrowse_GetDLCForApps_Response.DLCData dlc_data = 1;
inline int CStoreBrowse_GetDLCForApps_Response::_internal_dlc_data_size() const {
  return dlc_data_.size();
}
inline int CStoreBrowse_GetDLCForApps_Response::dlc_data_size() const {
  return _internal_dlc_data_size();
}
inline void CStoreBrowse_GetDLCForApps_Response::clear_dlc_data() {
  dlc_data_.Clear();
}
inline ::CStoreBrowse_GetDLCForApps_Response_DLCData* CStoreBrowse_GetDLCForApps_Response::mutable_dlc_data(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForApps_Response.dlc_data)
  return dlc_data_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_DLCData >*
CStoreBrowse_GetDLCForApps_Response::mutable_dlc_data() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForApps_Response.dlc_data)
  return &dlc_data_;
}
inline const ::CStoreBrowse_GetDLCForApps_Response_DLCData& CStoreBrowse_GetDLCForApps_Response::_internal_dlc_data(int index) const {
  return dlc_data_.Get(index);
}
inline const ::CStoreBrowse_GetDLCForApps_Response_DLCData& CStoreBrowse_GetDLCForApps_Response::dlc_data(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.dlc_data)
  return _internal_dlc_data(index);
}
inline ::CStoreBrowse_GetDLCForApps_Response_DLCData* CStoreBrowse_GetDLCForApps_Response::_internal_add_dlc_data() {
  return dlc_data_.Add();
}
inline ::CStoreBrowse_GetDLCForApps_Response_DLCData* CStoreBrowse_GetDLCForApps_Response::add_dlc_data() {
  ::CStoreBrowse_GetDLCForApps_Response_DLCData* _add = _internal_add_dlc_data();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForApps_Response.dlc_data)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_DLCData >&
CStoreBrowse_GetDLCForApps_Response::dlc_data() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForApps_Response.dlc_data)
  return dlc_data_;
}

// repeated .CStoreBrowse_GetDLCForApps_Response.PlaytimeForApp playtime = 2;
inline int CStoreBrowse_GetDLCForApps_Response::_internal_playtime_size() const {
  return playtime_.size();
}
inline int CStoreBrowse_GetDLCForApps_Response::playtime_size() const {
  return _internal_playtime_size();
}
inline void CStoreBrowse_GetDLCForApps_Response::clear_playtime() {
  playtime_.Clear();
}
inline ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* CStoreBrowse_GetDLCForApps_Response::mutable_playtime(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForApps_Response.playtime)
  return playtime_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >*
CStoreBrowse_GetDLCForApps_Response::mutable_playtime() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForApps_Response.playtime)
  return &playtime_;
}
inline const ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& CStoreBrowse_GetDLCForApps_Response::_internal_playtime(int index) const {
  return playtime_.Get(index);
}
inline const ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp& CStoreBrowse_GetDLCForApps_Response::playtime(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForApps_Response.playtime)
  return _internal_playtime(index);
}
inline ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* CStoreBrowse_GetDLCForApps_Response::_internal_add_playtime() {
  return playtime_.Add();
}
inline ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* CStoreBrowse_GetDLCForApps_Response::add_playtime() {
  ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp* _add = _internal_add_playtime();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForApps_Response.playtime)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForApps_Response_PlaytimeForApp >&
CStoreBrowse_GetDLCForApps_Response::playtime() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForApps_Response.playtime)
  return playtime_;
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForAppsSolr_Request

// optional .StoreBrowseContext context = 1;
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::_internal_has_context() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || context_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::has_context() const {
  return _internal_has_context();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::clear_context() {
  if (context_ != nullptr) context_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::StoreBrowseContext& CStoreBrowse_GetDLCForAppsSolr_Request::_internal_context() const {
  const ::StoreBrowseContext* p = context_;
  return p != nullptr ? *p : reinterpret_cast<const ::StoreBrowseContext&>(
      ::_StoreBrowseContext_default_instance_);
}
inline const ::StoreBrowseContext& CStoreBrowse_GetDLCForAppsSolr_Request::context() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Request.context)
  return _internal_context();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::unsafe_arena_set_allocated_context(
    ::StoreBrowseContext* context) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(context_);
  }
  context_ = context;
  if (context) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetDLCForAppsSolr_Request.context)
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForAppsSolr_Request::release_context() {
  _has_bits_[0] &= ~0x00000002u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForAppsSolr_Request::unsafe_arena_release_context() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetDLCForAppsSolr_Request.context)
  _has_bits_[0] &= ~0x00000002u;
  ::StoreBrowseContext* temp = context_;
  context_ = nullptr;
  return temp;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForAppsSolr_Request::_internal_mutable_context() {
  _has_bits_[0] |= 0x00000002u;
  if (context_ == nullptr) {
    auto* p = CreateMaybeMessage<::StoreBrowseContext>(GetArenaForAllocation());
    context_ = p;
  }
  return context_;
}
inline ::StoreBrowseContext* CStoreBrowse_GetDLCForAppsSolr_Request::mutable_context() {
  ::StoreBrowseContext* _msg = _internal_mutable_context();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForAppsSolr_Request.context)
  return _msg;
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::set_allocated_context(::StoreBrowseContext* context) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete context_;
  }
  if (context) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::StoreBrowseContext>::GetOwningArena(context);
    if (message_arena != submessage_arena) {
      context = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, context, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  context_ = context;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetDLCForAppsSolr_Request.context)
}

// repeated uint32 appids = 2;
inline int CStoreBrowse_GetDLCForAppsSolr_Request::_internal_appids_size() const {
  return appids_.size();
}
inline int CStoreBrowse_GetDLCForAppsSolr_Request::appids_size() const {
  return _internal_appids_size();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::clear_appids() {
  appids_.Clear();
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Request::_internal_appids(int index) const {
  return appids_.Get(index);
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Request::appids(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
  return _internal_appids(index);
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::set_appids(int index, uint32_t value) {
  appids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::_internal_add_appids(uint32_t value) {
  appids_.Add(value);
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::add_appids(uint32_t value) {
  _internal_add_appids(value);
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStoreBrowse_GetDLCForAppsSolr_Request::_internal_appids() const {
  return appids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStoreBrowse_GetDLCForAppsSolr_Request::appids() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
  return _internal_appids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStoreBrowse_GetDLCForAppsSolr_Request::_internal_mutable_appids() {
  return &appids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStoreBrowse_GetDLCForAppsSolr_Request::mutable_appids() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForAppsSolr_Request.appids)
  return _internal_mutable_appids();
}

// optional string flavor = 3;
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::_internal_has_flavor() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::has_flavor() const {
  return _internal_has_flavor();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::clear_flavor() {
  flavor_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStoreBrowse_GetDLCForAppsSolr_Request::flavor() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
  return _internal_flavor();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStoreBrowse_GetDLCForAppsSolr_Request::set_flavor(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 flavor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
}
inline std::string* CStoreBrowse_GetDLCForAppsSolr_Request::mutable_flavor() {
  std::string* _s = _internal_mutable_flavor();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
  return _s;
}
inline const std::string& CStoreBrowse_GetDLCForAppsSolr_Request::_internal_flavor() const {
  return flavor_.Get();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::_internal_set_flavor(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  flavor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetDLCForAppsSolr_Request::_internal_mutable_flavor() {
  _has_bits_[0] |= 0x00000001u;
  return flavor_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStoreBrowse_GetDLCForAppsSolr_Request::release_flavor() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
  if (!_internal_has_flavor()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = flavor_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (flavor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    flavor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::set_allocated_flavor(std::string* flavor) {
  if (flavor != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  flavor_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), flavor,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (flavor_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    flavor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetDLCForAppsSolr_Request.flavor)
}

// optional uint32 count = 4;
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::has_count() const {
  return _internal_has_count();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Request::_internal_count() const {
  return count_;
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Request::count() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Request.count)
  return _internal_count();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  count_ = value;
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForAppsSolr_Request.count)
}

// optional .CStorePageFilter store_page_filter = 5;
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::_internal_has_store_page_filter() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || store_page_filter_ != nullptr);
  return value;
}
inline bool CStoreBrowse_GetDLCForAppsSolr_Request::has_store_page_filter() const {
  return _internal_has_store_page_filter();
}
inline const ::CStorePageFilter& CStoreBrowse_GetDLCForAppsSolr_Request::_internal_store_page_filter() const {
  const ::CStorePageFilter* p = store_page_filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStorePageFilter&>(
      ::_CStorePageFilter_default_instance_);
}
inline const ::CStorePageFilter& CStoreBrowse_GetDLCForAppsSolr_Request::store_page_filter() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
  return _internal_store_page_filter();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::unsafe_arena_set_allocated_store_page_filter(
    ::CStorePageFilter* store_page_filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter_);
  }
  store_page_filter_ = store_page_filter;
  if (store_page_filter) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForAppsSolr_Request::release_store_page_filter() {
  _has_bits_[0] &= ~0x00000004u;
  ::CStorePageFilter* temp = store_page_filter_;
  store_page_filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForAppsSolr_Request::unsafe_arena_release_store_page_filter() {
  // @@protoc_insertion_point(field_release:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
  _has_bits_[0] &= ~0x00000004u;
  ::CStorePageFilter* temp = store_page_filter_;
  store_page_filter_ = nullptr;
  return temp;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForAppsSolr_Request::_internal_mutable_store_page_filter() {
  _has_bits_[0] |= 0x00000004u;
  if (store_page_filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStorePageFilter>(GetArenaForAllocation());
    store_page_filter_ = p;
  }
  return store_page_filter_;
}
inline ::CStorePageFilter* CStoreBrowse_GetDLCForAppsSolr_Request::mutable_store_page_filter() {
  ::CStorePageFilter* _msg = _internal_mutable_store_page_filter();
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
  return _msg;
}
inline void CStoreBrowse_GetDLCForAppsSolr_Request::set_allocated_store_page_filter(::CStorePageFilter* store_page_filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter_);
  }
  if (store_page_filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(store_page_filter));
    if (message_arena != submessage_arena) {
      store_page_filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_page_filter, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  store_page_filter_ = store_page_filter;
  // @@protoc_insertion_point(field_set_allocated:CStoreBrowse_GetDLCForAppsSolr_Request.store_page_filter)
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForAppsSolr_Response_DLCList

// optional uint32 parent_appid = 1;
inline bool CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_has_parent_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::has_parent_appid() const {
  return _internal_has_parent_appid();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::clear_parent_appid() {
  parent_appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_parent_appid() const {
  return parent_appid_;
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::parent_appid() const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.parent_appid)
  return _internal_parent_appid();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_set_parent_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  parent_appid_ = value;
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::set_parent_appid(uint32_t value) {
  _internal_set_parent_appid(value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.parent_appid)
}

// repeated uint32 dlc_appids = 2;
inline int CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_dlc_appids_size() const {
  return dlc_appids_.size();
}
inline int CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::dlc_appids_size() const {
  return _internal_dlc_appids_size();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::clear_dlc_appids() {
  dlc_appids_.Clear();
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_dlc_appids(int index) const {
  return dlc_appids_.Get(index);
}
inline uint32_t CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::dlc_appids(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
  return _internal_dlc_appids(index);
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::set_dlc_appids(int index, uint32_t value) {
  dlc_appids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_add_dlc_appids(uint32_t value) {
  dlc_appids_.Add(value);
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::add_dlc_appids(uint32_t value) {
  _internal_add_dlc_appids(value);
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_dlc_appids() const {
  return dlc_appids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::dlc_appids() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
  return _internal_dlc_appids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::_internal_mutable_dlc_appids() {
  return &dlc_appids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStoreBrowse_GetDLCForAppsSolr_Response_DLCList::mutable_dlc_appids() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForAppsSolr_Response.DLCList.dlc_appids)
  return _internal_mutable_dlc_appids();
}

// -------------------------------------------------------------------

// CStoreBrowse_GetDLCForAppsSolr_Response

// repeated .CStoreBrowse_GetDLCForAppsSolr_Response.DLCList dlc_lists = 1;
inline int CStoreBrowse_GetDLCForAppsSolr_Response::_internal_dlc_lists_size() const {
  return dlc_lists_.size();
}
inline int CStoreBrowse_GetDLCForAppsSolr_Response::dlc_lists_size() const {
  return _internal_dlc_lists_size();
}
inline void CStoreBrowse_GetDLCForAppsSolr_Response::clear_dlc_lists() {
  dlc_lists_.Clear();
}
inline ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* CStoreBrowse_GetDLCForAppsSolr_Response::mutable_dlc_lists(int index) {
  // @@protoc_insertion_point(field_mutable:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
  return dlc_lists_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >*
CStoreBrowse_GetDLCForAppsSolr_Response::mutable_dlc_lists() {
  // @@protoc_insertion_point(field_mutable_list:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
  return &dlc_lists_;
}
inline const ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& CStoreBrowse_GetDLCForAppsSolr_Response::_internal_dlc_lists(int index) const {
  return dlc_lists_.Get(index);
}
inline const ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList& CStoreBrowse_GetDLCForAppsSolr_Response::dlc_lists(int index) const {
  // @@protoc_insertion_point(field_get:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
  return _internal_dlc_lists(index);
}
inline ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* CStoreBrowse_GetDLCForAppsSolr_Response::_internal_add_dlc_lists() {
  return dlc_lists_.Add();
}
inline ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* CStoreBrowse_GetDLCForAppsSolr_Response::add_dlc_lists() {
  ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList* _add = _internal_add_dlc_lists();
  // @@protoc_insertion_point(field_add:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStoreBrowse_GetDLCForAppsSolr_Response_DLCList >&
CStoreBrowse_GetDLCForAppsSolr_Response::dlc_lists() const {
  // @@protoc_insertion_point(field_list:CStoreBrowse_GetDLCForAppsSolr_Response.dlc_lists)
  return dlc_lists_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EStoreItemType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStoreItemType>() {
  return ::EStoreItemType_descriptor();
}
template <> struct is_proto_enum< ::EStoreAppType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStoreAppType>() {
  return ::EStoreAppType_descriptor();
}
template <> struct is_proto_enum< ::EUserReviewScore> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EUserReviewScore>() {
  return ::EUserReviewScore_descriptor();
}
template <> struct is_proto_enum< ::EStoreCategoryType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStoreCategoryType>() {
  return ::EStoreCategoryType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fstorebrowse_2esteamclient_2eproto
