// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_client_objects.proto

#include "steammessages_client_objects.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr SteamMessagesClientIClientForcedEnumDependencies::SteamMessagesClientIClientForcedEnumDependencies(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : a_(0)

  , b_(0)

  , c_(0)

  , d_(0)
{}
struct SteamMessagesClientIClientForcedEnumDependenciesDefaultTypeInternal {
  constexpr SteamMessagesClientIClientForcedEnumDependenciesDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~SteamMessagesClientIClientForcedEnumDependenciesDefaultTypeInternal() {}
  union {
    SteamMessagesClientIClientForcedEnumDependencies _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT SteamMessagesClientIClientForcedEnumDependenciesDefaultTypeInternal _SteamMessagesClientIClientForcedEnumDependencies_default_instance_;
constexpr CMsgNetworkDeviceIP4Address::CMsgNetworkDeviceIP4Address(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(0)
  , netmask_(0){}
struct CMsgNetworkDeviceIP4AddressDefaultTypeInternal {
  constexpr CMsgNetworkDeviceIP4AddressDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceIP4AddressDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceIP4Address _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceIP4AddressDefaultTypeInternal _CMsgNetworkDeviceIP4Address_default_instance_;
constexpr CMsgNetworkDeviceIP4Config::CMsgNetworkDeviceIP4Config(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : addresses_()
  , dns_ip_()
  , gateway_ip_(0)
  , is_dhcp_enabled_(false)
  , is_default_route_(false)
  , is_enabled_(false){}
struct CMsgNetworkDeviceIP4ConfigDefaultTypeInternal {
  constexpr CMsgNetworkDeviceIP4ConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceIP4ConfigDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceIP4Config _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceIP4ConfigDefaultTypeInternal _CMsgNetworkDeviceIP4Config_default_instance_;
constexpr CMsgNetworkDeviceIP6Address::CMsgNetworkDeviceIP6Address(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgNetworkDeviceIP6AddressDefaultTypeInternal {
  constexpr CMsgNetworkDeviceIP6AddressDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceIP6AddressDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceIP6Address _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceIP6AddressDefaultTypeInternal _CMsgNetworkDeviceIP6Address_default_instance_;
constexpr CMsgNetworkDeviceIP6Config::CMsgNetworkDeviceIP6Config(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : addresses_()
  , dns_ip_()
  , gateway_ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_dhcp_enabled_(false)
  , is_default_route_(false)
  , is_enabled_(false){}
struct CMsgNetworkDeviceIP6ConfigDefaultTypeInternal {
  constexpr CMsgNetworkDeviceIP6ConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceIP6ConfigDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceIP6Config _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceIP6ConfigDefaultTypeInternal _CMsgNetworkDeviceIP6Config_default_instance_;
constexpr CMsgNetworkDevicesData_Device_Wired::CMsgNetworkDevicesData_Device_Wired(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : friendly_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , is_cable_present_(false)
  , speed_mbit_(0u){}
struct CMsgNetworkDevicesData_Device_WiredDefaultTypeInternal {
  constexpr CMsgNetworkDevicesData_Device_WiredDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDevicesData_Device_WiredDefaultTypeInternal() {}
  union {
    CMsgNetworkDevicesData_Device_Wired _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDevicesData_Device_WiredDefaultTypeInternal _CMsgNetworkDevicesData_Device_Wired_default_instance_;
constexpr CMsgNetworkDevicesData_Device_Wireless_AP::CMsgNetworkDevicesData_Device_Wireless_AP(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , user_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0u)
  , estrength_(0)
  , is_active_(false)
  , is_autoconnect_(false)
  , esecurity_(0)
  , strength_raw_(0){}
struct CMsgNetworkDevicesData_Device_Wireless_APDefaultTypeInternal {
  constexpr CMsgNetworkDevicesData_Device_Wireless_APDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDevicesData_Device_Wireless_APDefaultTypeInternal() {}
  union {
    CMsgNetworkDevicesData_Device_Wireless_AP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDevicesData_Device_Wireless_APDefaultTypeInternal _CMsgNetworkDevicesData_Device_Wireless_AP_default_instance_;
constexpr CMsgNetworkDevicesData_Device_Wireless::CMsgNetworkDevicesData_Device_Wireless(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : aps_()
  , esecurity_supported_(0){}
struct CMsgNetworkDevicesData_Device_WirelessDefaultTypeInternal {
  constexpr CMsgNetworkDevicesData_Device_WirelessDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDevicesData_Device_WirelessDefaultTypeInternal() {}
  union {
    CMsgNetworkDevicesData_Device_Wireless _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDevicesData_Device_WirelessDefaultTypeInternal _CMsgNetworkDevicesData_Device_Wireless_default_instance_;
constexpr CMsgNetworkDevicesData_Device::CMsgNetworkDevicesData_Device(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , vendor_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , product_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip4_(nullptr)
  , ip6_(nullptr)
  , wired_(nullptr)
  , wireless_(nullptr)
  , id_(0u)
  , etype_(0)
  , estate_(0){}
struct CMsgNetworkDevicesData_DeviceDefaultTypeInternal {
  constexpr CMsgNetworkDevicesData_DeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDevicesData_DeviceDefaultTypeInternal() {}
  union {
    CMsgNetworkDevicesData_Device _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDevicesData_DeviceDefaultTypeInternal _CMsgNetworkDevicesData_Device_default_instance_;
constexpr CMsgNetworkDevicesData::CMsgNetworkDevicesData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : devices_()
  , is_wifi_enabled_(false)
  , is_wifi_scanning_enabled_(false){}
struct CMsgNetworkDevicesDataDefaultTypeInternal {
  constexpr CMsgNetworkDevicesDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDevicesDataDefaultTypeInternal() {}
  union {
    CMsgNetworkDevicesData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDevicesDataDefaultTypeInternal _CMsgNetworkDevicesData_default_instance_;
constexpr CMsgNetworkDeviceConnect_KnownAP::CMsgNetworkDeviceConnect_KnownAP(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ap_id_(0u){}
struct CMsgNetworkDeviceConnect_KnownAPDefaultTypeInternal {
  constexpr CMsgNetworkDeviceConnect_KnownAPDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceConnect_KnownAPDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceConnect_KnownAP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceConnect_KnownAPDefaultTypeInternal _CMsgNetworkDeviceConnect_KnownAP_default_instance_;
constexpr CMsgNetworkDeviceConnect_CustomAP::CMsgNetworkDeviceConnect_CustomAP(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ssid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , esecurity_(0){}
struct CMsgNetworkDeviceConnect_CustomAPDefaultTypeInternal {
  constexpr CMsgNetworkDeviceConnect_CustomAPDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceConnect_CustomAPDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceConnect_CustomAP _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceConnect_CustomAPDefaultTypeInternal _CMsgNetworkDeviceConnect_CustomAP_default_instance_;
constexpr CMsgNetworkDeviceConnect_Credentials::CMsgNetworkDeviceConnect_Credentials(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : username_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgNetworkDeviceConnect_CredentialsDefaultTypeInternal {
  constexpr CMsgNetworkDeviceConnect_CredentialsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceConnect_CredentialsDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceConnect_Credentials _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceConnect_CredentialsDefaultTypeInternal _CMsgNetworkDeviceConnect_Credentials_default_instance_;
constexpr CMsgNetworkDeviceConnect::CMsgNetworkDeviceConnect(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : credentials_(nullptr)
  , ip4_(nullptr)
  , ip6_(nullptr)
  , device_id_(0u)
  , _oneof_case_{}{}
struct CMsgNetworkDeviceConnectDefaultTypeInternal {
  constexpr CMsgNetworkDeviceConnectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgNetworkDeviceConnectDefaultTypeInternal() {}
  union {
    CMsgNetworkDeviceConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgNetworkDeviceConnectDefaultTypeInternal _CMsgNetworkDeviceConnect_default_instance_;
constexpr CMsgStorageDevicesData_Drive::CMsgStorageDevicesData_Drive(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : model_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , vendor_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , serial_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0u)
  , is_ejectable_(false)
  , size_bytes_(uint64_t{0u})
  , media_type_(0)
{}
struct CMsgStorageDevicesData_DriveDefaultTypeInternal {
  constexpr CMsgStorageDevicesData_DriveDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgStorageDevicesData_DriveDefaultTypeInternal() {}
  union {
    CMsgStorageDevicesData_Drive _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgStorageDevicesData_DriveDefaultTypeInternal _CMsgStorageDevicesData_Drive_default_instance_;
constexpr CMsgStorageDevicesData_BlockDevice::CMsgStorageDevicesData_BlockDevice(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , friendly_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , label_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , mount_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0u)
  , drive_id_(0u)
  , size_bytes_(uint64_t{0u})
  , is_formattable_(false)
  , is_read_only_(false)
  , is_root_device_(false)
  , content_type_(0)

  , filesystem_type_(0)
{}
struct CMsgStorageDevicesData_BlockDeviceDefaultTypeInternal {
  constexpr CMsgStorageDevicesData_BlockDeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgStorageDevicesData_BlockDeviceDefaultTypeInternal() {}
  union {
    CMsgStorageDevicesData_BlockDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgStorageDevicesData_BlockDeviceDefaultTypeInternal _CMsgStorageDevicesData_BlockDevice_default_instance_;
constexpr CMsgStorageDevicesData::CMsgStorageDevicesData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : drives_()
  , block_devices_()
  , is_unmount_supported_(false)
  , is_trim_supported_(false)
  , is_trim_running_(false){}
struct CMsgStorageDevicesDataDefaultTypeInternal {
  constexpr CMsgStorageDevicesDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgStorageDevicesDataDefaultTypeInternal() {}
  union {
    CMsgStorageDevicesData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgStorageDevicesDataDefaultTypeInternal _CMsgStorageDevicesData_default_instance_;
constexpr CCloud_PendingRemoteOperation::CCloud_PendingRemoteOperation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : machine_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , operation_(0)

  , time_last_updated_(0u)
  , client_id_(uint64_t{0u}){}
struct CCloud_PendingRemoteOperationDefaultTypeInternal {
  constexpr CCloud_PendingRemoteOperationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloud_PendingRemoteOperationDefaultTypeInternal() {}
  union {
    CCloud_PendingRemoteOperation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloud_PendingRemoteOperationDefaultTypeInternal _CCloud_PendingRemoteOperation_default_instance_;
constexpr CMsgCloudPendingRemoteOperations::CMsgCloudPendingRemoteOperations(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : operations_(){}
struct CMsgCloudPendingRemoteOperationsDefaultTypeInternal {
  constexpr CMsgCloudPendingRemoteOperationsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgCloudPendingRemoteOperationsDefaultTypeInternal() {}
  union {
    CMsgCloudPendingRemoteOperations _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgCloudPendingRemoteOperationsDefaultTypeInternal _CMsgCloudPendingRemoteOperations_default_instance_;
constexpr CMsgBluetoothDevicesData_Adapter::CMsgBluetoothDevicesData_Adapter(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0u)
  , is_enabled_(false)
  , is_discovering_(false){}
struct CMsgBluetoothDevicesData_AdapterDefaultTypeInternal {
  constexpr CMsgBluetoothDevicesData_AdapterDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgBluetoothDevicesData_AdapterDefaultTypeInternal() {}
  union {
    CMsgBluetoothDevicesData_Adapter _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgBluetoothDevicesData_AdapterDefaultTypeInternal _CMsgBluetoothDevicesData_Adapter_default_instance_;
constexpr CMsgBluetoothDevicesData_Device::CMsgBluetoothDevicesData_Device(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mac_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0u)
  , adapter_id_(0u)
  , etype_(0)

  , is_connected_(false)
  , is_paired_(false)
  , strength_raw_(0){}
struct CMsgBluetoothDevicesData_DeviceDefaultTypeInternal {
  constexpr CMsgBluetoothDevicesData_DeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgBluetoothDevicesData_DeviceDefaultTypeInternal() {}
  union {
    CMsgBluetoothDevicesData_Device _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgBluetoothDevicesData_DeviceDefaultTypeInternal _CMsgBluetoothDevicesData_Device_default_instance_;
constexpr CMsgBluetoothDevicesData_Manager::CMsgBluetoothDevicesData_Manager(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : is_bluetooth_enabled_(false){}
struct CMsgBluetoothDevicesData_ManagerDefaultTypeInternal {
  constexpr CMsgBluetoothDevicesData_ManagerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgBluetoothDevicesData_ManagerDefaultTypeInternal() {}
  union {
    CMsgBluetoothDevicesData_Manager _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgBluetoothDevicesData_ManagerDefaultTypeInternal _CMsgBluetoothDevicesData_Manager_default_instance_;
constexpr CMsgBluetoothDevicesData::CMsgBluetoothDevicesData(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : adapters_()
  , devices_()
  , manager_(nullptr){}
struct CMsgBluetoothDevicesDataDefaultTypeInternal {
  constexpr CMsgBluetoothDevicesDataDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgBluetoothDevicesDataDefaultTypeInternal() {}
  union {
    CMsgBluetoothDevicesData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgBluetoothDevicesDataDefaultTypeInternal _CMsgBluetoothDevicesData_default_instance_;
constexpr CMsgSystemPerfDiagnosticEntry::CMsgSystemPerfDiagnosticEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgSystemPerfDiagnosticEntryDefaultTypeInternal {
  constexpr CMsgSystemPerfDiagnosticEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfDiagnosticEntryDefaultTypeInternal() {}
  union {
    CMsgSystemPerfDiagnosticEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfDiagnosticEntryDefaultTypeInternal _CMsgSystemPerfDiagnosticEntry_default_instance_;
constexpr CMsgSystemPerfNetworkInterface::CMsgSystemPerfNetworkInterface(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timestamp_(0)
  , tx_bytes_total_(int64_t{0})
  , rx_bytes_total_(int64_t{0})
  , tx_bytes_per_sec_(0)
  , rx_bytes_per_sec_(0){}
struct CMsgSystemPerfNetworkInterfaceDefaultTypeInternal {
  constexpr CMsgSystemPerfNetworkInterfaceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfNetworkInterfaceDefaultTypeInternal() {}
  union {
    CMsgSystemPerfNetworkInterface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfNetworkInterfaceDefaultTypeInternal _CMsgSystemPerfNetworkInterface_default_instance_;
constexpr CMsgSystemPerfDiagnosticInfo::CMsgSystemPerfDiagnosticInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_()
  , interfaces_()
  , battery_temp_c_(0){}
struct CMsgSystemPerfDiagnosticInfoDefaultTypeInternal {
  constexpr CMsgSystemPerfDiagnosticInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfDiagnosticInfoDefaultTypeInternal() {}
  union {
    CMsgSystemPerfDiagnosticInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfDiagnosticInfoDefaultTypeInternal _CMsgSystemPerfDiagnosticInfo_default_instance_;
constexpr CMsgSystemPerfLimits::CMsgSystemPerfLimits(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gpu_performance_levels_available_()
  , fps_limit_options_()
  , fps_limit_options_external_()
  , split_scaling_filters_available_()
  , split_scaling_scalers_available_()
  , cpu_governor_manual_min_mhz_(0)
  , cpu_governor_manual_max_mhz_(0)
  , fsr_sharpness_min_(0)
  , fsr_sharpness_max_(0)
  , gpu_performance_manual_min_mhz_(0)
  , gpu_performance_manual_max_mhz_(0)
  , perf_overlay_is_standalone_(false)
  , is_dynamic_vrs_available_(false)
  , is_manual_display_refresh_rate_available_(false)
  , is_nis_supported_(false)
  , display_refresh_manual_hz_min_(0)
  , display_refresh_manual_hz_max_(0)
  , tdp_limit_min_(0)
  , tdp_limit_max_(0)
  , nis_sharpness_min_(0)
  , nis_sharpness_max_(0)
  , display_external_refresh_manual_hz_min_(0)
  , display_external_refresh_manual_hz_max_(0)
  , is_tearing_supported_(false)
  , is_vrr_supported_(false)
  , is_dynamic_refresh_rate_in_steam_supported_(false)
  , is_split_scaling_and_filtering_supported_(false)
  , is_hdr_supported_(false)
  , display_refresh_manual_hz_oc_max_(0){}
struct CMsgSystemPerfLimitsDefaultTypeInternal {
  constexpr CMsgSystemPerfLimitsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfLimitsDefaultTypeInternal() {}
  union {
    CMsgSystemPerfLimits _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfLimitsDefaultTypeInternal _CMsgSystemPerfLimits_default_instance_;
constexpr CMsgSystemPerfSettingsGlobal::CMsgSystemPerfSettingsGlobal(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : diagnostic_update_rate_(0)
  , system_trace_service_state_(0)

  , graphics_profiling_service_state_(0)

  , perf_overlay_service_state_(0)

  , perf_overlay_level_(0)

  , is_show_perf_overlay_over_steam_enabled_(false)
  , is_advanced_settings_enabled_(false)
  , allow_external_display_refresh_control_(false)
  , is_hdr_enabled_(false)
  , hdr_on_sdr_tonemap_operator_(0)

  , is_hdr_debug_heatmap_enabled_(false)
  , allow_experimental_hdr_(false)
  , debug_force_hdr_support_(false)
  , force_hdr_10pq_output_debug_(false)
  , sdr_to_hdr_brightness_(0)
  , is_display_oc_enabled_(false)
  , is_color_management_enabled_(false)
  , force_hdr_wide_gammut_for_sdr_(true){}
struct CMsgSystemPerfSettingsGlobalDefaultTypeInternal {
  constexpr CMsgSystemPerfSettingsGlobalDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfSettingsGlobalDefaultTypeInternal() {}
  union {
    CMsgSystemPerfSettingsGlobal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfSettingsGlobalDefaultTypeInternal _CMsgSystemPerfSettingsGlobal_default_instance_;
constexpr CMsgSystemPerfSettingsPerApp::CMsgSystemPerfSettingsPerApp(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gpu_performance_manual_mhz_(0)
  , fps_limit_(0)
  , tdp_limit_(0)
  , cpu_governor_(0)

  , cpu_governor_manual_mhz_(0)
  , is_variable_resolution_enabled_(false)
  , is_dynamic_refresh_rate_enabled_(false)
  , is_fps_limit_enabled_(false)
  , is_tdp_limit_enabled_(false)
  , scaling_filter_(0)
  , fsr_sharpness_(0)
  , display_refresh_manual_hz_(0)
  , gpu_performance_level_(0)

  , nis_sharpness_(0)
  , is_low_latency_mode_enabled_(false)
  , is_game_perf_profile_enabled_(false)
  , is_tearing_enabled_(false)
  , is_vrr_enabled_(false)
  , display_external_refresh_manual_hz_(0)
  , fps_limit_external_(0)
  , is_composite_debug_enabled_(false)
  , force_composite_(false)
  , use_dynamic_refresh_rate_in_steam_(false)
  , split_scaling_filter_(0)

  , split_scaling_scaler_(0)
{}
struct CMsgSystemPerfSettingsPerAppDefaultTypeInternal {
  constexpr CMsgSystemPerfSettingsPerAppDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfSettingsPerAppDefaultTypeInternal() {}
  union {
    CMsgSystemPerfSettingsPerApp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfSettingsPerAppDefaultTypeInternal _CMsgSystemPerfSettingsPerApp_default_instance_;
constexpr CMsgSystemPerfSettings::CMsgSystemPerfSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : global_(nullptr)
  , per_app_(nullptr){}
struct CMsgSystemPerfSettingsDefaultTypeInternal {
  constexpr CMsgSystemPerfSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfSettingsDefaultTypeInternal() {}
  union {
    CMsgSystemPerfSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfSettingsDefaultTypeInternal _CMsgSystemPerfSettings_default_instance_;
constexpr CMsgSystemPerfSettingsV1::CMsgSystemPerfSettingsV1(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : diagnostic_update_rate_(0)
  , system_trace_service_state_(0)

  , graphics_profiling_service_state_(0)

  , perf_overlay_service_state_(0)

  , perf_overlay_level_(0)

  , gpu_performance_level_(0)

  , gpu_performance_manual_mhz_(0)
  , fps_limit_(0)
  , tdp_limit_(0)
  , cpu_governor_(0)

  , cpu_governor_manual_mhz_(0)
  , is_variable_resolution_enabled_(false)
  , is_dynamic_refresh_rate_enabled_(false)
  , is_fps_limit_enabled_(false)
  , is_tdp_limit_enabled_(false)
  , scaling_filter_(0)
  , fsr_sharpness_(0)
  , is_show_perf_overlay_over_steam_enabled_(false)
  , is_low_latency_mode_enabled_(false)
  , is_game_perf_profile_enabled_(false)
  , display_refresh_manual_hz_(0){}
struct CMsgSystemPerfSettingsV1DefaultTypeInternal {
  constexpr CMsgSystemPerfSettingsV1DefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfSettingsV1DefaultTypeInternal() {}
  union {
    CMsgSystemPerfSettingsV1 _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfSettingsV1DefaultTypeInternal _CMsgSystemPerfSettingsV1_default_instance_;
constexpr CMsgSystemPerfState::CMsgSystemPerfState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : limits_(nullptr)
  , settings_(nullptr)
  , current_game_id_(uint64_t{0u})
  , active_profile_game_id_(uint64_t{0u}){}
struct CMsgSystemPerfStateDefaultTypeInternal {
  constexpr CMsgSystemPerfStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfStateDefaultTypeInternal() {}
  union {
    CMsgSystemPerfState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfStateDefaultTypeInternal _CMsgSystemPerfState_default_instance_;
constexpr CMsgSystemPerfUpdateSettings::CMsgSystemPerfUpdateSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gameid_(uint64_t{0u})
  , skip_storage_update_(false)
  , _oneof_case_{}{}
struct CMsgSystemPerfUpdateSettingsDefaultTypeInternal {
  constexpr CMsgSystemPerfUpdateSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemPerfUpdateSettingsDefaultTypeInternal() {}
  union {
    CMsgSystemPerfUpdateSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemPerfUpdateSettingsDefaultTypeInternal _CMsgSystemPerfUpdateSettings_default_instance_;
constexpr CMsgSystemDockUpdateState::CMsgSystemDockUpdateState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : version_current_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , version_available_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_(0)

  , rtime_last_checked_(0u)
  , stage_progress_(0)
  , rtime_estimated_completion_(0u)
  , old_fw_workaround_(0){}
struct CMsgSystemDockUpdateStateDefaultTypeInternal {
  constexpr CMsgSystemDockUpdateStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDockUpdateStateDefaultTypeInternal() {}
  union {
    CMsgSystemDockUpdateState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDockUpdateStateDefaultTypeInternal _CMsgSystemDockUpdateState_default_instance_;
constexpr CMsgSystemDockState::CMsgSystemDockState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : update_state_(nullptr){}
struct CMsgSystemDockStateDefaultTypeInternal {
  constexpr CMsgSystemDockStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDockStateDefaultTypeInternal() {}
  union {
    CMsgSystemDockState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDockStateDefaultTypeInternal _CMsgSystemDockState_default_instance_;
constexpr CMsgSystemDockUpdateFirmware::CMsgSystemDockUpdateFirmware(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : check_only_(false){}
struct CMsgSystemDockUpdateFirmwareDefaultTypeInternal {
  constexpr CMsgSystemDockUpdateFirmwareDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDockUpdateFirmwareDefaultTypeInternal() {}
  union {
    CMsgSystemDockUpdateFirmware _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDockUpdateFirmwareDefaultTypeInternal _CMsgSystemDockUpdateFirmware_default_instance_;
constexpr CMsgSystemAudioVolume_ChannelEntry::CMsgSystemAudioVolume_ChannelEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : echannel_(0)

  , volume_(0){}
struct CMsgSystemAudioVolume_ChannelEntryDefaultTypeInternal {
  constexpr CMsgSystemAudioVolume_ChannelEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioVolume_ChannelEntryDefaultTypeInternal() {}
  union {
    CMsgSystemAudioVolume_ChannelEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioVolume_ChannelEntryDefaultTypeInternal _CMsgSystemAudioVolume_ChannelEntry_default_instance_;
constexpr CMsgSystemAudioVolume::CMsgSystemAudioVolume(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_()
  , is_muted_(false){}
struct CMsgSystemAudioVolumeDefaultTypeInternal {
  constexpr CMsgSystemAudioVolumeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioVolumeDefaultTypeInternal() {}
  union {
    CMsgSystemAudioVolume _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioVolumeDefaultTypeInternal _CMsgSystemAudioVolume_default_instance_;
constexpr CMsgSystemAudioManagerObject::CMsgSystemAudioManagerObject(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(0u)
  , rtime_last_update_(0u){}
struct CMsgSystemAudioManagerObjectDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerObjectDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerObjectDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerObject _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerObjectDefaultTypeInternal _CMsgSystemAudioManagerObject_default_instance_;
constexpr CMsgSystemAudioManagerDevice::CMsgSystemAudioManagerDevice(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nick_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , api_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_(nullptr){}
struct CMsgSystemAudioManagerDeviceDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerDeviceDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerDeviceDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerDevice _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerDeviceDefaultTypeInternal _CMsgSystemAudioManagerDevice_default_instance_;
constexpr CMsgSystemAudioManagerNode::CMsgSystemAudioManagerNode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , nick_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_(nullptr)
  , volume_(nullptr)
  , device_id_(0u)
  , edirection_(0)
{}
struct CMsgSystemAudioManagerNodeDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerNodeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerNodeDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerNodeDefaultTypeInternal _CMsgSystemAudioManagerNode_default_instance_;
constexpr CMsgSystemAudioManagerPort::CMsgSystemAudioManagerPort(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , alias_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , base_(nullptr)
  , node_id_(0u)
  , etype_(0)

  , edirection_(0)

  , is_physical_(false)
  , is_terminal_(false)
  , is_control_(false)
  , is_monitor_(false){}
struct CMsgSystemAudioManagerPortDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerPortDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerPortDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerPort _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerPortDefaultTypeInternal _CMsgSystemAudioManagerPort_default_instance_;
constexpr CMsgSystemAudioManagerLink::CMsgSystemAudioManagerLink(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : base_(nullptr)
  , output_node_id_(0u)
  , output_port_id_(0u)
  , input_node_id_(0u)
  , input_port_id_(0u){}
struct CMsgSystemAudioManagerLinkDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerLinkDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerLinkDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerLink _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerLinkDefaultTypeInternal _CMsgSystemAudioManagerLink_default_instance_;
constexpr CMsgSystemAudioManagerStateHW::CMsgSystemAudioManagerStateHW(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : devices_()
  , nodes_()
  , ports_()
  , links_(){}
struct CMsgSystemAudioManagerStateHWDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerStateHWDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerStateHWDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerStateHW _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerStateHWDefaultTypeInternal _CMsgSystemAudioManagerStateHW_default_instance_;
constexpr CMsgSystemAudioManagerState::CMsgSystemAudioManagerState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hw_(nullptr)
  , rtime_filter_(0u)
  , counter_(0){}
struct CMsgSystemAudioManagerStateDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerStateDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerStateDefaultTypeInternal _CMsgSystemAudioManagerState_default_instance_;
constexpr CMsgSystemAudioManagerUpdateSomething::CMsgSystemAudioManagerUpdateSomething(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : counter_(0){}
struct CMsgSystemAudioManagerUpdateSomethingDefaultTypeInternal {
  constexpr CMsgSystemAudioManagerUpdateSomethingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemAudioManagerUpdateSomethingDefaultTypeInternal() {}
  union {
    CMsgSystemAudioManagerUpdateSomething _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemAudioManagerUpdateSomethingDefaultTypeInternal _CMsgSystemAudioManagerUpdateSomething_default_instance_;
constexpr CMsgSystemDisplayMode::CMsgSystemDisplayMode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : id_(0)
  , width_(0)
  , height_(0)
  , refresh_hz_(0){}
struct CMsgSystemDisplayModeDefaultTypeInternal {
  constexpr CMsgSystemDisplayModeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDisplayModeDefaultTypeInternal() {}
  union {
    CMsgSystemDisplayMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDisplayModeDefaultTypeInternal _CMsgSystemDisplayMode_default_instance_;
constexpr CMsgSystemDisplay::CMsgSystemDisplay(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : modes_()
  , name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , id_(0)
  , is_primary_(false)
  , is_enabled_(false)
  , is_internal_(false)
  , has_mode_override_(false)
  , width_mm_(0)
  , height_mm_(0)
  , current_mode_id_(0)
  , refresh_rate_min_(0)
  , refresh_rate_max_(0)
  , is_vrr_capable_(false)
  , is_vrr_enabled_(false)
  , is_hdr_capable_(false)
  , is_hdr_enabled_(false){}
struct CMsgSystemDisplayDefaultTypeInternal {
  constexpr CMsgSystemDisplayDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDisplayDefaultTypeInternal() {}
  union {
    CMsgSystemDisplay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDisplayDefaultTypeInternal _CMsgSystemDisplay_default_instance_;
constexpr CMsgSystemDisplayManagerState::CMsgSystemDisplayManagerState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : displays_()
  , is_mode_switching_supported_(false)
  , compatibility_mode_(0)
{}
struct CMsgSystemDisplayManagerStateDefaultTypeInternal {
  constexpr CMsgSystemDisplayManagerStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDisplayManagerStateDefaultTypeInternal() {}
  union {
    CMsgSystemDisplayManagerState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDisplayManagerStateDefaultTypeInternal _CMsgSystemDisplayManagerState_default_instance_;
constexpr CMsgSystemDisplayManagerSetMode::CMsgSystemDisplayManagerSetMode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : display_id_(0)
  , mode_id_(0){}
struct CMsgSystemDisplayManagerSetModeDefaultTypeInternal {
  constexpr CMsgSystemDisplayManagerSetModeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemDisplayManagerSetModeDefaultTypeInternal() {}
  union {
    CMsgSystemDisplayManagerSetMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemDisplayManagerSetModeDefaultTypeInternal _CMsgSystemDisplayManagerSetMode_default_instance_;
constexpr CMsgSystemManagerSettings::CMsgSystemManagerSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : idle_backlight_dim_battery_seconds_(0)
  , idle_backlight_dim_ac_seconds_(0)
  , idle_suspend_battery_seconds_(0)
  , idle_suspend_ac_seconds_(0)
  , idle_suspend_supressed_(false)
  , is_adaptive_brightness_available_(false)
  , display_adaptive_brightness_enabled_(false)
  , display_nightmode_enabled_(false)
  , display_nightmode_tintstrength_(0)
  , display_nightmode_maxhue_(0)
  , display_nightmode_maxsat_(0)
  , display_nightmode_uiexp_(0)
  , display_nightmode_blend_(0)
  , display_nightmode_schedule_starttime_(0)
  , display_nightmode_schedule_endtime_(0)
  , display_nightmode_reset_(false)
  , display_nightmode_schedule_enabled_(false)
  , display_diagnostics_enabled_(false)
  , is_wifi_powersave_enabled_(false)
  , als_lux_latest_(0)
  , als_lux_median_(0)
  , display_backlight_raw_(0)
  , display_brightness_adaptivemin_(0)
  , display_brightness_adaptivemax_(0)
  , fan_control_mode_(0)

  , is_fan_control_available_(false)
  , is_display_brightness_available_(false)
  , is_display_colormanagement_available_(false)
  , display_colorgamut_(0){}
struct CMsgSystemManagerSettingsDefaultTypeInternal {
  constexpr CMsgSystemManagerSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemManagerSettingsDefaultTypeInternal() {}
  union {
    CMsgSystemManagerSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemManagerSettingsDefaultTypeInternal _CMsgSystemManagerSettings_default_instance_;
constexpr CMsgSelectOSBranchParams::CMsgSelectOSBranchParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : custom_branch_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , branch_(0)
{}
struct CMsgSelectOSBranchParamsDefaultTypeInternal {
  constexpr CMsgSelectOSBranchParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSelectOSBranchParamsDefaultTypeInternal() {}
  union {
    CMsgSelectOSBranchParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSelectOSBranchParamsDefaultTypeInternal _CMsgSelectOSBranchParams_default_instance_;
constexpr CMsgSystemUpdateProgress::CMsgSystemUpdateProgress(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stage_size_bytes_(int64_t{0})
  , stage_progress_(0)
  , rtime_estimated_completion_(0u){}
struct CMsgSystemUpdateProgressDefaultTypeInternal {
  constexpr CMsgSystemUpdateProgressDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemUpdateProgressDefaultTypeInternal() {}
  union {
    CMsgSystemUpdateProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemUpdateProgressDefaultTypeInternal _CMsgSystemUpdateProgress_default_instance_;
constexpr CMsgSystemUpdateCheckResult::CMsgSystemUpdateCheckResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : version_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , auto_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)

  , rtime_checked_(0u)
  , available_(false)
  , eresult_(2u){}
struct CMsgSystemUpdateCheckResultDefaultTypeInternal {
  constexpr CMsgSystemUpdateCheckResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemUpdateCheckResultDefaultTypeInternal() {}
  union {
    CMsgSystemUpdateCheckResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemUpdateCheckResultDefaultTypeInternal _CMsgSystemUpdateCheckResult_default_instance_;
constexpr CMsgSystemUpdateApplyParams::CMsgSystemUpdateApplyParams(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : apply_types_(){}
struct CMsgSystemUpdateApplyParamsDefaultTypeInternal {
  constexpr CMsgSystemUpdateApplyParamsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemUpdateApplyParamsDefaultTypeInternal() {}
  union {
    CMsgSystemUpdateApplyParams _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemUpdateApplyParamsDefaultTypeInternal _CMsgSystemUpdateApplyParams_default_instance_;
constexpr CMsgSystemUpdateApplyResult::CMsgSystemUpdateApplyResult(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : type_(0)

  , requires_client_restart_(false)
  , requires_system_restart_(false)
  , eresult_(2u){}
struct CMsgSystemUpdateApplyResultDefaultTypeInternal {
  constexpr CMsgSystemUpdateApplyResultDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemUpdateApplyResultDefaultTypeInternal() {}
  union {
    CMsgSystemUpdateApplyResult _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemUpdateApplyResultDefaultTypeInternal _CMsgSystemUpdateApplyResult_default_instance_;
constexpr CMsgSystemUpdateState::CMsgSystemUpdateState(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : update_check_results_()
  , update_apply_results_()
  , progress_(nullptr)
  , state_(0)

  , supports_os_updates_(false){}
struct CMsgSystemUpdateStateDefaultTypeInternal {
  constexpr CMsgSystemUpdateStateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgSystemUpdateStateDefaultTypeInternal() {}
  union {
    CMsgSystemUpdateState _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgSystemUpdateStateDefaultTypeInternal _CMsgSystemUpdateState_default_instance_;
constexpr CMsgAchievementChange::CMsgAchievementChange(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u){}
struct CMsgAchievementChangeDefaultTypeInternal {
  constexpr CMsgAchievementChangeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgAchievementChangeDefaultTypeInternal() {}
  union {
    CMsgAchievementChange _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgAchievementChangeDefaultTypeInternal _CMsgAchievementChange_default_instance_;
constexpr CMsgCellList_Cell::CMsgCellList_Cell(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : loc_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cell_id_(0u){}
struct CMsgCellList_CellDefaultTypeInternal {
  constexpr CMsgCellList_CellDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgCellList_CellDefaultTypeInternal() {}
  union {
    CMsgCellList_Cell _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgCellList_CellDefaultTypeInternal _CMsgCellList_Cell_default_instance_;
constexpr CMsgCellList::CMsgCellList(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cells_(){}
struct CMsgCellListDefaultTypeInternal {
  constexpr CMsgCellListDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgCellListDefaultTypeInternal() {}
  union {
    CMsgCellList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgCellListDefaultTypeInternal _CMsgCellList_default_instance_;
constexpr CMsgShortcutInfo::CMsgShortcutInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : tags_()
  , exe_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , start_dir_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , icon_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , args_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , app_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , flatpak_appid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , devkit_gameid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , override_appid_(0u)
  , is_remote_(false)
  , is_hidden_(false)
  , is_temporary_(false)
  , is_openvr_(false)
  , allow_desktop_config_(false)
  , allow_overlay_(false)
  , is_devkit_shortcut_(false)
  , rt_last_played_time_(0u){}
struct CMsgShortcutInfoDefaultTypeInternal {
  constexpr CMsgShortcutInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgShortcutInfoDefaultTypeInternal() {}
  union {
    CMsgShortcutInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgShortcutInfoDefaultTypeInternal _CMsgShortcutInfo_default_instance_;
constexpr CMsgShortcutAppIds::CMsgShortcutAppIds(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appids_(){}
struct CMsgShortcutAppIdsDefaultTypeInternal {
  constexpr CMsgShortcutAppIdsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgShortcutAppIdsDefaultTypeInternal() {}
  union {
    CMsgShortcutAppIds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgShortcutAppIdsDefaultTypeInternal _CMsgShortcutAppIds_default_instance_;
constexpr CMsgMonitorInfo_MonitorInfo::CMsgMonitorInfo_MonitorInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : monitor_device_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , monitor_display_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgMonitorInfo_MonitorInfoDefaultTypeInternal {
  constexpr CMsgMonitorInfo_MonitorInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgMonitorInfo_MonitorInfoDefaultTypeInternal() {}
  union {
    CMsgMonitorInfo_MonitorInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgMonitorInfo_MonitorInfoDefaultTypeInternal _CMsgMonitorInfo_MonitorInfo_default_instance_;
constexpr CMsgMonitorInfo::CMsgMonitorInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : monitors_()
  , selected_display_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgMonitorInfoDefaultTypeInternal {
  constexpr CMsgMonitorInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgMonitorInfoDefaultTypeInternal() {}
  union {
    CMsgMonitorInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgMonitorInfoDefaultTypeInternal _CMsgMonitorInfo_default_instance_;
constexpr CMsgGenerateSystemReportReply::CMsgGenerateSystemReportReply(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : report_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CMsgGenerateSystemReportReplyDefaultTypeInternal {
  constexpr CMsgGenerateSystemReportReplyDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgGenerateSystemReportReplyDefaultTypeInternal() {}
  union {
    CMsgGenerateSystemReportReply _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgGenerateSystemReportReplyDefaultTypeInternal _CMsgGenerateSystemReportReply_default_instance_;
constexpr CMsgWebUITransportInfo::CMsgWebUITransportInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : auth_key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , port_(0u){}
struct CMsgWebUITransportInfoDefaultTypeInternal {
  constexpr CMsgWebUITransportInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CMsgWebUITransportInfoDefaultTypeInternal() {}
  union {
    CMsgWebUITransportInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CMsgWebUITransportInfoDefaultTypeInternal _CMsgWebUITransportInfo_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fclient_5fobjects_2eproto[66];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_steammessages_5fclient_5fobjects_2eproto[2];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_steammessages_5fclient_5fobjects_2eproto = nullptr;

const uint32_t TableStruct_steammessages_5fclient_5fobjects_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, a_),
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, b_),
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, c_),
  PROTOBUF_FIELD_OFFSET(::SteamMessagesClientIClientForcedEnumDependencies, d_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Address, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Address, ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Address, netmask_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, dns_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, gateway_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, is_dhcp_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, is_default_route_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP4Config, is_enabled_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Address, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Address, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Address, ip_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, addresses_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, dns_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, gateway_ip_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, is_dhcp_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, is_default_route_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceIP6Config, is_enabled_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wired, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wired, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wired, is_cable_present_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wired, speed_mbit_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wired, friendly_name_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, estrength_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, ssid_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, is_active_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, is_autoconnect_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, esecurity_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, user_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, password_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless_AP, strength_raw_),
  3,
  4,
  0,
  5,
  6,
  7,
  1,
  2,
  8,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless, aps_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device_Wireless, esecurity_supported_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, etype_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, estate_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, mac_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, vendor_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, product_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, ip4_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, ip6_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, wired_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData_Device, wireless_),
  7,
  8,
  9,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData, devices_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData, is_wifi_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDevicesData, is_wifi_scanning_enabled_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_KnownAP, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_KnownAP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_KnownAP, ap_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_CustomAP, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_CustomAP, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_CustomAP, ssid_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_CustomAP, esecurity_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_Credentials, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_Credentials, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_Credentials, username_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect_Credentials, password_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, device_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, credentials_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, ip4_),
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, ip6_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CMsgNetworkDeviceConnect, ap_info_),
  3,
  0,
  1,
  2,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, model_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, vendor_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, serial_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, is_ejectable_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, size_bytes_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_Drive, media_type_),
  3,
  0,
  1,
  2,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, drive_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, path_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, friendly_path_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, label_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, size_bytes_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, is_formattable_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, is_read_only_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, is_root_device_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, content_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, filesystem_type_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData_BlockDevice, mount_path_),
  4,
  5,
  0,
  1,
  2,
  6,
  7,
  8,
  9,
  10,
  11,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, drives_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, block_devices_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, is_unmount_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, is_trim_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgStorageDevicesData, is_trim_running_),
  ~0u,
  ~0u,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, operation_),
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, machine_name_),
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, client_id_),
  PROTOBUF_FIELD_OFFSET(::CCloud_PendingRemoteOperation, time_last_updated_),
  1,
  0,
  3,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgCloudPendingRemoteOperations, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCloudPendingRemoteOperations, operations_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, mac_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, is_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Adapter, is_discovering_),
  2,
  0,
  1,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, adapter_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, etype_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, mac_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, is_connected_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, is_paired_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Device, strength_raw_),
  2,
  3,
  4,
  0,
  1,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Manager, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Manager, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData_Manager, is_bluetooth_enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData, adapters_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData, devices_),
  PROTOBUF_FIELD_OFFSET(::CMsgBluetoothDevicesData, manager_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticEntry, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticEntry, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, timestamp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, tx_bytes_total_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, rx_bytes_total_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, tx_bytes_per_sec_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfNetworkInterface, rx_bytes_per_sec_),
  0,
  1,
  2,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticInfo, entries_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticInfo, interfaces_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfDiagnosticInfo, battery_temp_c_),
  ~0u,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, cpu_governor_manual_min_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, cpu_governor_manual_max_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, fsr_sharpness_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, fsr_sharpness_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, gpu_performance_manual_min_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, gpu_performance_manual_max_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, perf_overlay_is_standalone_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_dynamic_vrs_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_manual_display_refresh_rate_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, gpu_performance_levels_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, display_refresh_manual_hz_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, display_refresh_manual_hz_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, fps_limit_options_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, tdp_limit_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, tdp_limit_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_nis_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, nis_sharpness_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, nis_sharpness_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, display_external_refresh_manual_hz_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, display_external_refresh_manual_hz_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, fps_limit_options_external_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_tearing_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_vrr_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_dynamic_refresh_rate_in_steam_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_split_scaling_and_filtering_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, split_scaling_filters_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, split_scaling_scalers_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, is_hdr_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfLimits, display_refresh_manual_hz_oc_max_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,
  10,
  11,
  ~0u,
  12,
  13,
  9,
  14,
  15,
  16,
  17,
  ~0u,
  18,
  19,
  20,
  21,
  ~0u,
  ~0u,
  22,
  23,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, diagnostic_update_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, system_trace_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, graphics_profiling_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, perf_overlay_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, perf_overlay_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_show_perf_overlay_over_steam_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_advanced_settings_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, allow_external_display_refresh_control_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_hdr_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, hdr_on_sdr_tonemap_operator_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_hdr_debug_heatmap_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, force_hdr_wide_gammut_for_sdr_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, allow_experimental_hdr_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, sdr_to_hdr_brightness_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, debug_force_hdr_support_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, force_hdr_10pq_output_debug_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_display_oc_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsGlobal, is_color_management_enabled_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  17,
  11,
  14,
  12,
  13,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, gpu_performance_manual_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, fps_limit_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_variable_resolution_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_dynamic_refresh_rate_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, tdp_limit_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, cpu_governor_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, cpu_governor_manual_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, scaling_filter_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, fsr_sharpness_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_fps_limit_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_tdp_limit_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_low_latency_mode_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, display_refresh_manual_hz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_game_perf_profile_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, gpu_performance_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, nis_sharpness_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, display_external_refresh_manual_hz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, fps_limit_external_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_tearing_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_vrr_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, is_composite_debug_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, force_composite_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, use_dynamic_refresh_rate_in_steam_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, split_scaling_filter_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsPerApp, split_scaling_scaler_),
  0,
  1,
  5,
  6,
  2,
  3,
  4,
  9,
  10,
  7,
  8,
  14,
  11,
  15,
  12,
  13,
  18,
  19,
  16,
  17,
  20,
  21,
  22,
  23,
  24,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettings, global_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettings, per_app_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, diagnostic_update_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, system_trace_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, graphics_profiling_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, perf_overlay_service_state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, perf_overlay_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, gpu_performance_level_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, gpu_performance_manual_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, fps_limit_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_variable_resolution_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_dynamic_refresh_rate_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, tdp_limit_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, cpu_governor_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, cpu_governor_manual_mhz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, scaling_filter_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, fsr_sharpness_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_fps_limit_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_tdp_limit_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_show_perf_overlay_over_steam_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_low_latency_mode_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, display_refresh_manual_hz_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfSettingsV1, is_game_perf_profile_enabled_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  11,
  12,
  8,
  9,
  10,
  15,
  16,
  13,
  14,
  17,
  18,
  20,
  19,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, limits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, settings_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, current_game_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfState, active_profile_game_id_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, gameid_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, skip_storage_update_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemPerfUpdateSettings, update_),
  0,
  1,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, rtime_last_checked_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, version_current_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, version_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, stage_progress_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, rtime_estimated_completion_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateState, old_fw_workaround_),
  2,
  3,
  0,
  1,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockState, update_state_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateFirmware, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateFirmware, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDockUpdateFirmware, check_only_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume_ChannelEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume_ChannelEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume_ChannelEntry, echannel_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume_ChannelEntry, volume_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume, entries_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioVolume, is_muted_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerObject, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerObject, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerObject, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerObject, rtime_last_update_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, nick_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, description_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerDevice, api_),
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, device_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, nick_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, description_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, edirection_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerNode, volume_),
  3,
  5,
  0,
  1,
  2,
  6,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, alias_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, etype_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, edirection_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, is_physical_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, is_terminal_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, is_control_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerPort, is_monitor_),
  2,
  3,
  0,
  1,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, base_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, output_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, output_port_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, input_node_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerLink, input_port_id_),
  0,
  1,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerStateHW, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerStateHW, devices_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerStateHW, nodes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerStateHW, ports_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerStateHW, links_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerState, rtime_filter_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerState, counter_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerState, hw_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerUpdateSomething, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerUpdateSomething, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemAudioManagerUpdateSomething, counter_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, width_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, height_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayMode, refresh_hz_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, name_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, description_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_primary_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_internal_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, has_mode_override_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, width_mm_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, height_mm_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, current_mode_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, modes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, refresh_rate_min_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, refresh_rate_max_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_vrr_capable_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_vrr_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_hdr_capable_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplay, is_hdr_enabled_),
  2,
  0,
  1,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  10,
  11,
  12,
  13,
  14,
  15,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerState, displays_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerState, is_mode_switching_supported_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerState, compatibility_mode_),
  ~0u,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerSetMode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerSetMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerSetMode, display_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemDisplayManagerSetMode, mode_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, idle_backlight_dim_battery_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, idle_backlight_dim_ac_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, idle_suspend_battery_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, idle_suspend_ac_seconds_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, idle_suspend_supressed_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, is_adaptive_brightness_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_adaptive_brightness_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_tintstrength_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_maxhue_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_maxsat_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_uiexp_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_blend_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_reset_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_schedule_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_schedule_starttime_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_nightmode_schedule_endtime_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_diagnostics_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, als_lux_latest_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, als_lux_median_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_backlight_raw_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_brightness_adaptivemin_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_brightness_adaptivemax_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, is_wifi_powersave_enabled_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, is_fan_control_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, fan_control_mode_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, is_display_brightness_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, is_display_colormanagement_available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemManagerSettings, display_colorgamut_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  15,
  16,
  13,
  14,
  17,
  19,
  20,
  21,
  22,
  23,
  18,
  25,
  24,
  26,
  27,
  28,
  PROTOBUF_FIELD_OFFSET(::CMsgSelectOSBranchParams, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSelectOSBranchParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSelectOSBranchParams, branch_),
  PROTOBUF_FIELD_OFFSET(::CMsgSelectOSBranchParams, custom_branch_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateProgress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateProgress, stage_progress_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateProgress, stage_size_bytes_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateProgress, rtime_estimated_completion_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, eresult_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, rtime_checked_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, available_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, version_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateCheckResult, auto_message_),
  2,
  5,
  3,
  4,
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyParams, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyParams, apply_types_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, type_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, eresult_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, requires_client_restart_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateApplyResult, requires_system_restart_),
  0,
  3,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, state_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, progress_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, update_check_results_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, update_apply_results_),
  PROTOBUF_FIELD_OFFSET(::CMsgSystemUpdateState, supports_os_updates_),
  1,
  0,
  ~0u,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgAchievementChange, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgAchievementChange, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgAchievementChange, appid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgCellList_Cell, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgCellList_Cell, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCellList_Cell, cell_id_),
  PROTOBUF_FIELD_OFFSET(::CMsgCellList_Cell, loc_name_),
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgCellList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgCellList, cells_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, appid_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, exe_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, start_dir_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, icon_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, path_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, args_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, app_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, override_appid_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, flatpak_appid_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, tags_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, is_remote_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, is_hidden_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, is_temporary_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, is_openvr_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, allow_desktop_config_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, allow_overlay_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, rt_last_played_time_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, is_devkit_shortcut_),
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutInfo, devkit_gameid_),
  8,
  0,
  1,
  2,
  3,
  4,
  5,
  9,
  6,
  ~0u,
  10,
  11,
  12,
  13,
  14,
  15,
  17,
  16,
  7,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutAppIds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgShortcutAppIds, appids_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo_MonitorInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo_MonitorInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo_MonitorInfo, monitor_device_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo_MonitorInfo, monitor_display_name_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo, selected_display_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgMonitorInfo, monitors_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CMsgGenerateSystemReportReply, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgGenerateSystemReportReply, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgGenerateSystemReportReply, report_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgWebUITransportInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgWebUITransportInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgWebUITransportInfo, port_),
  PROTOBUF_FIELD_OFFSET(::CMsgWebUITransportInfo, auth_key_),
  1,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 10, -1, sizeof(::SteamMessagesClientIClientForcedEnumDependencies)},
  { 14, 22, -1, sizeof(::CMsgNetworkDeviceIP4Address)},
  { 24, 36, -1, sizeof(::CMsgNetworkDeviceIP4Config)},
  { 42, 49, -1, sizeof(::CMsgNetworkDeviceIP6Address)},
  { 50, 62, -1, sizeof(::CMsgNetworkDeviceIP6Config)},
  { 68, 77, -1, sizeof(::CMsgNetworkDevicesData_Device_Wired)},
  { 80, 95, -1, sizeof(::CMsgNetworkDevicesData_Device_Wireless_AP)},
  { 104, 112, -1, sizeof(::CMsgNetworkDevicesData_Device_Wireless)},
  { 114, 130, -1, sizeof(::CMsgNetworkDevicesData_Device)},
  { 140, 149, -1, sizeof(::CMsgNetworkDevicesData)},
  { 152, 159, -1, sizeof(::CMsgNetworkDeviceConnect_KnownAP)},
  { 160, 168, -1, sizeof(::CMsgNetworkDeviceConnect_CustomAP)},
  { 170, 178, -1, sizeof(::CMsgNetworkDeviceConnect_Credentials)},
  { 180, 193, -1, sizeof(::CMsgNetworkDeviceConnect)},
  { 199, 212, -1, sizeof(::CMsgStorageDevicesData_Drive)},
  { 219, 237, -1, sizeof(::CMsgStorageDevicesData_BlockDevice)},
  { 249, 260, -1, sizeof(::CMsgStorageDevicesData)},
  { 265, 275, -1, sizeof(::CCloud_PendingRemoteOperation)},
  { 279, -1, -1, sizeof(::CMsgCloudPendingRemoteOperations)},
  { 286, 297, -1, sizeof(::CMsgBluetoothDevicesData_Adapter)},
  { 302, 316, -1, sizeof(::CMsgBluetoothDevicesData_Device)},
  { 324, 331, -1, sizeof(::CMsgBluetoothDevicesData_Manager)},
  { 332, 341, -1, sizeof(::CMsgBluetoothDevicesData)},
  { 344, 352, -1, sizeof(::CMsgSystemPerfDiagnosticEntry)},
  { 354, 366, -1, sizeof(::CMsgSystemPerfNetworkInterface)},
  { 372, 381, -1, sizeof(::CMsgSystemPerfDiagnosticInfo)},
  { 384, 419, -1, sizeof(::CMsgSystemPerfLimits)},
  { 448, 472, -1, sizeof(::CMsgSystemPerfSettingsGlobal)},
  { 490, 521, -1, sizeof(::CMsgSystemPerfSettingsPerApp)},
  { 546, 554, -1, sizeof(::CMsgSystemPerfSettings)},
  { 556, 583, -1, sizeof(::CMsgSystemPerfSettingsV1)},
  { 604, 614, -1, sizeof(::CMsgSystemPerfState)},
  { 618, 629, -1, sizeof(::CMsgSystemPerfUpdateSettings)},
  { 633, 646, -1, sizeof(::CMsgSystemDockUpdateState)},
  { 653, 660, -1, sizeof(::CMsgSystemDockState)},
  { 661, 668, -1, sizeof(::CMsgSystemDockUpdateFirmware)},
  { 669, 677, -1, sizeof(::CMsgSystemAudioVolume_ChannelEntry)},
  { 679, 687, -1, sizeof(::CMsgSystemAudioVolume)},
  { 689, 697, -1, sizeof(::CMsgSystemAudioManagerObject)},
  { 699, 710, -1, sizeof(::CMsgSystemAudioManagerDevice)},
  { 715, 728, -1, sizeof(::CMsgSystemAudioManagerNode)},
  { 735, 751, -1, sizeof(::CMsgSystemAudioManagerPort)},
  { 761, 772, -1, sizeof(::CMsgSystemAudioManagerLink)},
  { 777, -1, -1, sizeof(::CMsgSystemAudioManagerStateHW)},
  { 787, 796, -1, sizeof(::CMsgSystemAudioManagerState)},
  { 799, 806, -1, sizeof(::CMsgSystemAudioManagerUpdateSomething)},
  { 807, 817, -1, sizeof(::CMsgSystemDisplayMode)},
  { 821, 844, -1, sizeof(::CMsgSystemDisplay)},
  { 861, 870, -1, sizeof(::CMsgSystemDisplayManagerState)},
  { 873, 881, -1, sizeof(::CMsgSystemDisplayManagerSetMode)},
  { 883, 918, -1, sizeof(::CMsgSystemManagerSettings)},
  { 947, 955, -1, sizeof(::CMsgSelectOSBranchParams)},
  { 957, 966, -1, sizeof(::CMsgSystemUpdateProgress)},
  { 969, 981, -1, sizeof(::CMsgSystemUpdateCheckResult)},
  { 987, -1, -1, sizeof(::CMsgSystemUpdateApplyParams)},
  { 994, 1004, -1, sizeof(::CMsgSystemUpdateApplyResult)},
  { 1008, 1019, -1, sizeof(::CMsgSystemUpdateState)},
  { 1024, 1031, -1, sizeof(::CMsgAchievementChange)},
  { 1032, 1040, -1, sizeof(::CMsgCellList_Cell)},
  { 1042, -1, -1, sizeof(::CMsgCellList)},
  { 1049, 1074, -1, sizeof(::CMsgShortcutInfo)},
  { 1093, -1, -1, sizeof(::CMsgShortcutAppIds)},
  { 1100, 1108, -1, sizeof(::CMsgMonitorInfo_MonitorInfo)},
  { 1110, 1118, -1, sizeof(::CMsgMonitorInfo)},
  { 1120, 1127, -1, sizeof(::CMsgGenerateSystemReportReply)},
  { 1128, 1136, -1, sizeof(::CMsgWebUITransportInfo)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_SteamMessagesClientIClientForcedEnumDependencies_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceIP4Address_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceIP4Config_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceIP6Address_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceIP6Config_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDevicesData_Device_Wired_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDevicesData_Device_Wireless_AP_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDevicesData_Device_Wireless_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDevicesData_Device_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDevicesData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceConnect_KnownAP_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceConnect_CustomAP_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceConnect_Credentials_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgNetworkDeviceConnect_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgStorageDevicesData_Drive_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgStorageDevicesData_BlockDevice_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgStorageDevicesData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloud_PendingRemoteOperation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgCloudPendingRemoteOperations_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgBluetoothDevicesData_Adapter_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgBluetoothDevicesData_Device_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgBluetoothDevicesData_Manager_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgBluetoothDevicesData_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfDiagnosticEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfNetworkInterface_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfDiagnosticInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfLimits_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfSettingsGlobal_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfSettingsPerApp_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfSettings_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfSettingsV1_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemPerfUpdateSettings_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDockUpdateState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDockState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDockUpdateFirmware_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioVolume_ChannelEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioVolume_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerObject_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerDevice_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerNode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerPort_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerLink_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerStateHW_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemAudioManagerUpdateSomething_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDisplayMode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDisplay_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDisplayManagerState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemDisplayManagerSetMode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemManagerSettings_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSelectOSBranchParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemUpdateProgress_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemUpdateCheckResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemUpdateApplyParams_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemUpdateApplyResult_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgSystemUpdateState_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgAchievementChange_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgCellList_Cell_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgCellList_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgShortcutInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgShortcutAppIds_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgMonitorInfo_MonitorInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgMonitorInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgGenerateSystemReportReply_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CMsgWebUITransportInfo_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fclient_5fobjects_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\"steammessages_client_objects.proto\032\013en"
  "ums.proto\"\313\002\n0SteamMessagesClientIClient"
  "ForcedEnumDependencies\022\?\n\001a\030\001 \001(\0162\025.EBlu"
  "etoothDeviceType:\035k_BluetoothDeviceType_"
  "Invalid\022H\n\001b\030\002 \001(\0162\031.EStorageBlockConten"
  "tType:\"k_EStorageBlockContentType_Invali"
  "d\022N\n\001c\030\003 \001(\0162\034.EStorageBlockFileSystemTy"
  "pe:%k_EStorageBlockFileSystemType_Invali"
  "d\022<\n\001d\030\004 \001(\0162\023.ESDCardFormatStage:\034k_ESD"
  "CardFormatStage_Invalid\"=\n\033CMsgNetworkDe"
  "viceIP4Address\022\r\n\002ip\030\001 \001(\005:\0010\022\017\n\007netmask"
  "\030\002 \001(\005\"\277\001\n\032CMsgNetworkDeviceIP4Config\022/\n"
  "\taddresses\030\001 \003(\0132\034.CMsgNetworkDeviceIP4A"
  "ddress\022\016\n\006dns_ip\030\002 \003(\005\022\022\n\ngateway_ip\030\003 \001"
  "(\005\022\027\n\017is_dhcp_enabled\030\004 \001(\010\022\030\n\020is_defaul"
  "t_route\030\005 \001(\010\022\031\n\nis_enabled\030\006 \001(\010:\005false"
  "\")\n\033CMsgNetworkDeviceIP6Address\022\n\n\002ip\030\001 "
  "\001(\t\"\277\001\n\032CMsgNetworkDeviceIP6Config\022/\n\tad"
  "dresses\030\001 \003(\0132\034.CMsgNetworkDeviceIP6Addr"
  "ess\022\016\n\006dns_ip\030\002 \003(\t\022\022\n\ngateway_ip\030\003 \001(\t\022"
  "\027\n\017is_dhcp_enabled\030\004 \001(\010\022\030\n\020is_default_r"
  "oute\030\005 \001(\010\022\031\n\nis_enabled\030\006 \001(\010:\005false\"\227\006"
  "\n\026CMsgNetworkDevicesData\022/\n\007devices\030\001 \003("
  "\0132\036.CMsgNetworkDevicesData.Device\022\027\n\017is_"
  "wifi_enabled\030\002 \001(\010\022 \n\030is_wifi_scanning_e"
  "nabled\030\003 \001(\010\032\220\005\n\006Device\022\r\n\002id\030\001 \001(\r:\0010\022\r"
  "\n\005etype\030\002 \001(\005\022\016\n\006estate\030\003 \001(\005\022\013\n\003mac\030\004 \001"
  "(\t\022\016\n\006vendor\030\005 \001(\t\022\017\n\007product\030\006 \001(\t\022(\n\003i"
  "p4\030\007 \001(\0132\033.CMsgNetworkDeviceIP4Config\022(\n"
  "\003ip6\030\010 \001(\0132\033.CMsgNetworkDeviceIP6Config\022"
  "3\n\005wired\030\t \001(\0132$.CMsgNetworkDevicesData."
  "Device.Wired\0229\n\010wireless\030\n \001(\0132\'.CMsgNet"
  "workDevicesData.Device.Wireless\032S\n\005Wired"
  "\022\037\n\020is_cable_present\030\001 \001(\010:\005false\022\022\n\nspe"
  "ed_mbit\030\002 \001(\r\022\025\n\rfriendly_name\030\003 \001(\t\032\220\002\n"
  "\010Wireless\0227\n\003aps\030\001 \003(\0132*.CMsgNetworkDevi"
  "cesData.Device.Wireless.AP\022\033\n\023esecurity_"
  "supported\030\002 \001(\005\032\255\001\n\002AP\022\r\n\002id\030\001 \001(\r:\0010\022\021\n"
  "\testrength\030\002 \001(\005\022\014\n\004ssid\030\003 \001(\t\022\021\n\tis_act"
  "ive\030\004 \001(\010\022\026\n\016is_autoconnect\030\005 \001(\010\022\021\n\tese"
  "curity\030\006 \001(\005\022\021\n\tuser_name\030\007 \001(\t\022\020\n\010passw"
  "ord\030\010 \001(\t\022\024\n\014strength_raw\030\t \001(\005\"\265\003\n\030CMsg"
  "NetworkDeviceConnect\022\024\n\tdevice_id\030\001 \001(\r:"
  "\0010\022:\n\013credentials\030\004 \001(\0132%.CMsgNetworkDev"
  "iceConnect.Credentials\022(\n\003ip4\030\005 \001(\0132\033.CM"
  "sgNetworkDeviceIP4Config\022(\n\003ip6\030\006 \001(\0132\033."
  "CMsgNetworkDeviceIP6Config\0225\n\010ap_known\030\002"
  " \001(\0132!.CMsgNetworkDeviceConnect.KnownAPH"
  "\000\0227\n\tap_custom\030\003 \001(\0132\".CMsgNetworkDevice"
  "Connect.CustomAPH\000\032\030\n\007KnownAP\022\r\n\005ap_id\030\001"
  " \001(\r\032+\n\010CustomAP\022\014\n\004ssid\030\001 \001(\t\022\021\n\tesecur"
  "ity\030\002 \001(\005\0321\n\013Credentials\022\020\n\010username\030\001 \001"
  "(\t\022\020\n\010password\030\002 \001(\tB\t\n\007ap_info\"\237\006\n\026CMsg"
  "StorageDevicesData\022-\n\006drives\030\001 \003(\0132\035.CMs"
  "gStorageDevicesData.Drive\022:\n\rblock_devic"
  "es\030\002 \003(\0132#.CMsgStorageDevicesData.BlockD"
  "evice\022\034\n\024is_unmount_supported\030\003 \001(\010\022\031\n\021i"
  "s_trim_supported\030\004 \001(\010\022\027\n\017is_trim_runnin"
  "g\030\005 \001(\010\032\276\001\n\005Drive\022\r\n\002id\030\001 \001(\r:\0010\022\r\n\005mode"
  "l\030\002 \001(\t\022\016\n\006vendor\030\003 \001(\t\022\016\n\006serial\030\004 \001(\t\022"
  "\024\n\014is_ejectable\030\005 \001(\010\022\022\n\nsize_bytes\030\006 \001("
  "\004\022M\n\nmedia_type\030\007 \001(\0162\027.EStorageDriveMed"
  "iaType: k_EStorageDriveMediaType_Invalid"
  "\032\206\003\n\013BlockDevice\022\r\n\002id\030\001 \001(\r:\0010\022\023\n\010drive"
  "_id\030\002 \001(\r:\0010\022\014\n\004path\030\003 \001(\t\022\025\n\rfriendly_p"
  "ath\030\004 \001(\t\022\r\n\005label\030\005 \001(\t\022\022\n\nsize_bytes\030\006"
  " \001(\004\022\026\n\016is_formattable\030\007 \001(\010\022\024\n\014is_read_"
  "only\030\010 \001(\010\022\026\n\016is_root_device\030\t \001(\010\022S\n\014co"
  "ntent_type\030\n \001(\0162\031.EStorageBlockContentT"
  "ype:\"k_EStorageBlockContentType_Invalid\022"
  "\\\n\017filesystem_type\030\013 \001(\0162\034.EStorageBlock"
  "FileSystemType:%k_EStorageBlockFileSyste"
  "mType_Invalid\022\022\n\nmount_path\030\014 \001(\t\"\271\001\n\035CC"
  "loud_PendingRemoteOperation\022T\n\toperation"
  "\030\001 \001(\0162\035.ECloudPendingRemoteOperation:\"k"
  "_ECloudPendingRemoteOperationNone\022\024\n\014mac"
  "hine_name\030\002 \001(\t\022\021\n\tclient_id\030\003 \001(\004\022\031\n\021ti"
  "me_last_updated\030\004 \001(\r\"V\n CMsgCloudPendin"
  "gRemoteOperations\0222\n\noperations\030\001 \003(\0132\036."
  "CCloud_PendingRemoteOperation\"\220\004\n\030CMsgBl"
  "uetoothDevicesData\0223\n\010adapters\030\001 \003(\0132!.C"
  "MsgBluetoothDevicesData.Adapter\0221\n\007devic"
  "es\030\002 \003(\0132 .CMsgBluetoothDevicesData.Devi"
  "ce\0222\n\007manager\030\003 \001(\0132!.CMsgBluetoothDevic"
  "esData.Manager\032_\n\007Adapter\022\r\n\002id\030\001 \001(\r:\0010"
  "\022\013\n\003mac\030\002 \001(\t\022\014\n\004name\030\003 \001(\t\022\022\n\nis_enable"
  "d\030\004 \001(\010\022\026\n\016is_discovering\030\005 \001(\010\032\315\001\n\006Devi"
  "ce\022\r\n\002id\030\001 \001(\r:\0010\022\025\n\nadapter_id\030\002 \001(\r:\0010"
  "\022C\n\005etype\030\003 \001(\0162\025.EBluetoothDeviceType:\035"
  "k_BluetoothDeviceType_Invalid\022\013\n\003mac\030\004 \001"
  "(\t\022\014\n\004name\030\005 \001(\t\022\024\n\014is_connected\030\006 \001(\010\022\021"
  "\n\tis_paired\030\007 \001(\010\022\024\n\014strength_raw\030\010 \001(\005\032"
  "\'\n\007Manager\022\034\n\024is_bluetooth_enabled\030\001 \001(\010"
  "\"<\n\035CMsgSystemPerfDiagnosticEntry\022\014\n\004nam"
  "e\030\001 \001(\t\022\r\n\005value\030\002 \001(\t\"\245\001\n\036CMsgSystemPer"
  "fNetworkInterface\022\014\n\004name\030\001 \001(\t\022\021\n\ttimes"
  "tamp\030\002 \001(\001\022\026\n\016tx_bytes_total\030\003 \001(\003\022\026\n\016rx"
  "_bytes_total\030\004 \001(\003\022\030\n\020tx_bytes_per_sec\030\005"
  " \001(\005\022\030\n\020rx_bytes_per_sec\030\006 \001(\005\"\234\001\n\034CMsgS"
  "ystemPerfDiagnosticInfo\022/\n\007entries\030\001 \003(\013"
  "2\036.CMsgSystemPerfDiagnosticEntry\0223\n\ninte"
  "rfaces\030\002 \003(\0132\037.CMsgSystemPerfNetworkInte"
  "rface\022\026\n\016battery_temp_c\030\003 \001(\002\"\352\010\n\024CMsgSy"
  "stemPerfLimits\022#\n\033cpu_governor_manual_mi"
  "n_mhz\030\001 \001(\005\022#\n\033cpu_governor_manual_max_m"
  "hz\030\002 \001(\005\022\031\n\021fsr_sharpness_min\030\003 \001(\005\022\031\n\021f"
  "sr_sharpness_max\030\004 \001(\005\022&\n\036gpu_performanc"
  "e_manual_min_mhz\030\005 \001(\005\022&\n\036gpu_performanc"
  "e_manual_max_mhz\030\006 \001(\005\022\"\n\032perf_overlay_i"
  "s_standalone\030\007 \001(\010\022 \n\030is_dynamic_vrs_ava"
  "ilable\030\010 \001(\010\0220\n(is_manual_display_refres"
  "h_rate_available\030\t \001(\010\022\?\n gpu_performanc"
  "e_levels_available\030\n \003(\0162\025.EGPUPerforman"
  "ceLevel\022%\n\035display_refresh_manual_hz_min"
  "\030\013 \001(\005\022%\n\035display_refresh_manual_hz_max\030"
  "\014 \001(\005\022\031\n\021fps_limit_options\030\r \003(\005\022\025\n\rtdp_"
  "limit_min\030\016 \001(\005\022\025\n\rtdp_limit_max\030\017 \001(\005\022\030"
  "\n\020is_nis_supported\030\020 \001(\010\022\031\n\021nis_sharpnes"
  "s_min\030\021 \001(\005\022\031\n\021nis_sharpness_max\030\022 \001(\005\022."
  "\n&display_external_refresh_manual_hz_min"
  "\030\023 \001(\005\022.\n&display_external_refresh_manua"
  "l_hz_max\030\024 \001(\005\022\"\n\032fps_limit_options_exte"
  "rnal\030\025 \003(\005\022\034\n\024is_tearing_supported\030\026 \001(\010"
  "\022\030\n\020is_vrr_supported\030\027 \001(\010\0222\n*is_dynamic"
  "_refresh_rate_in_steam_supported\030\030 \001(\010\0220"
  "\n(is_split_scaling_and_filtering_support"
  "ed\030\031 \001(\010\022=\n\037split_scaling_filters_availa"
  "ble\030\032 \003(\0162\024.ESplitScalingFilter\022=\n\037split"
  "_scaling_scalers_available\030\033 \003(\0162\024.ESpli"
  "tScalingScaler\022\030\n\020is_hdr_supported\030\034 \001(\010"
  "\022(\n display_refresh_manual_hz_oc_max\030\035 \001"
  "(\005\"\314\007\n\034CMsgSystemPerfSettingsGlobal\022\036\n\026d"
  "iagnostic_update_rate\030\001 \001(\002\022[\n\032system_tr"
  "ace_service_state\030\002 \001(\0162\024.ESystemService"
  "State:!k_ESystemServiceState_Unavailable"
  "\022a\n graphics_profiling_service_state\030\003 \001"
  "(\0162\024.ESystemServiceState:!k_ESystemServi"
  "ceState_Unavailable\022[\n\032perf_overlay_serv"
  "ice_state\030\004 \001(\0162\024.ESystemServiceState:!k"
  "_ESystemServiceState_Unavailable\022Z\n\022perf"
  "_overlay_level\030\005 \001(\0162\032.EGraphicsPerfOver"
  "layLevel:\"k_EGraphicsPerfOverlayLevel_Hi"
  "dden\022/\n\'is_show_perf_overlay_over_steam_"
  "enabled\030\006 \001(\010\022$\n\034is_advanced_settings_en"
  "abled\030\007 \001(\010\022.\n&allow_external_display_re"
  "fresh_control\030\010 \001(\010\022\026\n\016is_hdr_enabled\030\t "
  "\001(\010\022X\n\033hdr_on_sdr_tonemap_operator\030\014 \001(\016"
  "2\024.EHDRToneMapOperator:\035k_EHDRToneMapOpe"
  "rator_Invalid\022$\n\034is_hdr_debug_heatmap_en"
  "abled\030\r \001(\010\022+\n\035force_hdr_wide_gammut_for"
  "_sdr\030\017 \001(\010:\004true\022\036\n\026allow_experimental_h"
  "dr\030\020 \001(\010\022\035\n\025sdr_to_hdr_brightness\030\021 \001(\002\022"
  "\037\n\027debug_force_hdr_support\030\022 \001(\010\022#\n\033forc"
  "e_hdr_10pq_output_debug\030\023 \001(\010\022\035\n\025is_disp"
  "lay_oc_enabled\030\024 \001(\010\022#\n\033is_color_managem"
  "ent_enabled\030\025 \001(\010\"\347\007\n\034CMsgSystemPerfSett"
  "ingsPerApp\022\"\n\032gpu_performance_manual_mhz"
  "\030\001 \001(\005\022\021\n\tfps_limit\030\002 \001(\005\022&\n\036is_variable"
  "_resolution_enabled\030\003 \001(\010\022\'\n\037is_dynamic_"
  "refresh_rate_enabled\030\004 \001(\010\022\021\n\ttdp_limit\030"
  "\005 \001(\005\022;\n\014cpu_governor\030\006 \001(\0162\r.ECPUGovern"
  "or:\026k_ECPUGovernor_Invalid\022\037\n\027cpu_govern"
  "or_manual_mhz\030\007 \001(\005\022\026\n\016scaling_filter\030\010 "
  "\001(\005\022\025\n\rfsr_sharpness\030\t \001(\005\022\034\n\024is_fps_lim"
  "it_enabled\030\n \001(\010\022\034\n\024is_tdp_limit_enabled"
  "\030\013 \001(\010\022#\n\033is_low_latency_mode_enabled\030\014 "
  "\001(\010\022!\n\031display_refresh_manual_hz\030\r \001(\005\022$"
  "\n\034is_game_perf_profile_enabled\030\016 \001(\010\022T\n\025"
  "gpu_performance_level\030\017 \001(\0162\025.EGPUPerfor"
  "manceLevel:\036k_EGPUPerformanceLevel_Inval"
  "id\022\025\n\rnis_sharpness\030\020 \001(\005\022*\n\"display_ext"
  "ernal_refresh_manual_hz\030\021 \001(\005\022\032\n\022fps_lim"
  "it_external\030\022 \001(\005\022\032\n\022is_tearing_enabled\030"
  "\023 \001(\010\022\026\n\016is_vrr_enabled\030\024 \001(\010\022\"\n\032is_comp"
  "osite_debug_enabled\030\025 \001(\010\022\027\n\017force_compo"
  "site\030\026 \001(\010\022)\n!use_dynamic_refresh_rate_i"
  "n_steam\030\027 \001(\010\022Q\n\024split_scaling_filter\030\030 "
  "\001(\0162\024.ESplitScalingFilter:\035k_ESplitScali"
  "ngFilter_Invalid\022Q\n\024split_scaling_scaler"
  "\030\031 \001(\0162\024.ESplitScalingScaler:\035k_ESplitSc"
  "alingScaler_Invalid\"w\n\026CMsgSystemPerfSet"
  "tings\022-\n\006global\030\001 \001(\0132\035.CMsgSystemPerfSe"
  "ttingsGlobal\022.\n\007per_app\030\002 \001(\0132\035.CMsgSyst"
  "emPerfSettingsPerApp\"\214\010\n\030CMsgSystemPerfS"
  "ettingsV1\022\036\n\026diagnostic_update_rate\030\001 \001("
  "\002\022[\n\032system_trace_service_state\030\002 \001(\0162\024."
  "ESystemServiceState:!k_ESystemServiceSta"
  "te_Unavailable\022a\n graphics_profiling_ser"
  "vice_state\030\003 \001(\0162\024.ESystemServiceState:!"
  "k_ESystemServiceState_Unavailable\022[\n\032per"
  "f_overlay_service_state\030\004 \001(\0162\024.ESystemS"
  "erviceState:!k_ESystemServiceState_Unava"
  "ilable\022Z\n\022perf_overlay_level\030\005 \001(\0162\032.EGr"
  "aphicsPerfOverlayLevel:\"k_EGraphicsPerfO"
  "verlayLevel_Hidden\022T\n\025gpu_performance_le"
  "vel\030\006 \001(\0162\025.EGPUPerformanceLevel:\036k_EGPU"
  "PerformanceLevel_Invalid\022\"\n\032gpu_performa"
  "nce_manual_mhz\030\007 \001(\005\022\021\n\tfps_limit\030\010 \001(\005\022"
  "&\n\036is_variable_resolution_enabled\030\t \001(\010\022"
  "\'\n\037is_dynamic_refresh_rate_enabled\030\n \001(\010"
  "\022\021\n\ttdp_limit\030\013 \001(\005\022;\n\014cpu_governor\030\014 \001("
  "\0162\r.ECPUGovernor:\026k_ECPUGovernor_Invalid"
  "\022\037\n\027cpu_governor_manual_mhz\030\r \001(\005\022\026\n\016sca"
  "ling_filter\030\016 \001(\005\022\025\n\rfsr_sharpness\030\017 \001(\005"
  "\022\034\n\024is_fps_limit_enabled\030\020 \001(\010\022\034\n\024is_tdp"
  "_limit_enabled\030\021 \001(\010\022/\n\'is_show_perf_ove"
  "rlay_over_steam_enabled\030\022 \001(\010\022#\n\033is_low_"
  "latency_mode_enabled\030\023 \001(\010\022!\n\031display_re"
  "fresh_manual_hz\030\024 \001(\005\022$\n\034is_game_perf_pr"
  "ofile_enabled\030\025 \001(\010\"\240\001\n\023CMsgSystemPerfSt"
  "ate\022%\n\006limits\030\001 \001(\0132\025.CMsgSystemPerfLimi"
  "ts\022)\n\010settings\030\002 \001(\0132\027.CMsgSystemPerfSet"
  "tings\022\027\n\017current_game_id\030\003 \001(\004\022\036\n\026active"
  "_profile_game_id\030\004 \001(\004\"\244\001\n\034CMsgSystemPer"
  "fUpdateSettings\022\016\n\006gameid\030\001 \001(\004\022\033\n\023skip_"
  "storage_update\030\004 \001(\010\022\032\n\020reset_to_default"
  "\030\002 \001(\010H\000\0221\n\016settings_delta\030\003 \001(\0132\027.CMsgS"
  "ystemPerfSettingsH\000B\010\n\006update\"\372\001\n\031CMsgSy"
  "stemDockUpdateState\0226\n\005state\030\001 \001(\0162\016.EUp"
  "daterState:\027k_EUpdaterState_Invalid\022\032\n\022r"
  "time_last_checked\030\002 \001(\007\022\027\n\017version_curre"
  "nt\030\003 \001(\t\022\031\n\021version_available\030\004 \001(\t\022\026\n\016s"
  "tage_progress\030\005 \001(\002\022\"\n\032rtime_estimated_c"
  "ompletion\030\006 \001(\007\022\031\n\021old_fw_workaround\030\007 \001"
  "(\005\"G\n\023CMsgSystemDockState\0220\n\014update_stat"
  "e\030\001 \001(\0132\032.CMsgSystemDockUpdateState\"2\n\034C"
  "MsgSystemDockUpdateFirmware\022\022\n\ncheck_onl"
  "y\030\001 \001(\010\"\305\001\n\025CMsgSystemAudioVolume\0224\n\007ent"
  "ries\030\001 \003(\0132#.CMsgSystemAudioVolume.Chann"
  "elEntry\022\020\n\010is_muted\030\002 \001(\010\032d\n\014ChannelEntr"
  "y\022D\n\010echannel\030\001 \001(\0162\024.ESystemAudioChanne"
  "l:\034k_SystemAudioChannel_Invalid\022\016\n\006volum"
  "e\030\002 \001(\002\"E\n\034CMsgSystemAudioManagerObject\022"
  "\n\n\002id\030\001 \001(\r\022\031\n\021rtime_last_update\030\002 \001(\007\"\211"
  "\001\n\034CMsgSystemAudioManagerDevice\022+\n\004base\030"
  "\001 \001(\0132\035.CMsgSystemAudioManagerObject\022\014\n\004"
  "name\030\002 \001(\t\022\014\n\004nick\030\003 \001(\t\022\023\n\013description\030"
  "\004 \001(\t\022\013\n\003api\030\005 \001(\t\"\201\002\n\032CMsgSystemAudioMa"
  "nagerNode\022+\n\004base\030\001 \001(\0132\035.CMsgSystemAudi"
  "oManagerObject\022\021\n\tdevice_id\030\002 \001(\r\022\014\n\004nam"
  "e\030\003 \001(\t\022\014\n\004nick\030\004 \001(\t\022\023\n\013description\030\005 \001"
  "(\t\022J\n\nedirection\030\006 \001(\0162\026.ESystemAudioDir"
  "ection:\036k_SystemAudioDirection_Invalid\022&"
  "\n\006volume\030\007 \001(\0132\026.CMsgSystemAudioVolume\"\342"
  "\002\n\032CMsgSystemAudioManagerPort\022+\n\004base\030\001 "
  "\001(\0132\035.CMsgSystemAudioManagerObject\022\017\n\007no"
  "de_id\030\003 \001(\r\022\014\n\004name\030\004 \001(\t\022\r\n\005alias\030\005 \001(\t"
  "\022C\n\005etype\030\006 \001(\0162\025.ESystemAudioPortType:\035"
  "k_SystemAudioPortType_Invalid\022R\n\nedirect"
  "ion\030\007 \001(\0162\032.ESystemAudioPortDirection:\"k"
  "_SystemAudioPortDirection_Invalid\022\023\n\013is_"
  "physical\030\010 \001(\010\022\023\n\013is_terminal\030\t \001(\010\022\022\n\ni"
  "s_control\030\n \001(\010\022\022\n\nis_monitor\030\013 \001(\010\"\247\001\n\032"
  "CMsgSystemAudioManagerLink\022+\n\004base\030\001 \001(\013"
  "2\035.CMsgSystemAudioManagerObject\022\026\n\016outpu"
  "t_node_id\030\002 \001(\r\022\026\n\016output_port_id\030\003 \001(\r\022"
  "\025\n\rinput_node_id\030\004 \001(\r\022\025\n\rinput_port_id\030"
  "\005 \001(\r\"\323\001\n\035CMsgSystemAudioManagerStateHW\022"
  ".\n\007devices\030\001 \003(\0132\035.CMsgSystemAudioManage"
  "rDevice\022*\n\005nodes\030\002 \003(\0132\033.CMsgSystemAudio"
  "ManagerNode\022*\n\005ports\030\003 \003(\0132\033.CMsgSystemA"
  "udioManagerPort\022*\n\005links\030\004 \003(\0132\033.CMsgSys"
  "temAudioManagerLink\"p\n\033CMsgSystemAudioMa"
  "nagerState\022\024\n\014rtime_filter\030\001 \001(\007\022\017\n\007coun"
  "ter\030\002 \001(\005\022*\n\002hw\030\003 \001(\0132\036.CMsgSystemAudioM"
  "anagerStateHW\"8\n%CMsgSystemAudioManagerU"
  "pdateSomething\022\017\n\007counter\030\001 \001(\005\"V\n\025CMsgS"
  "ystemDisplayMode\022\n\n\002id\030\001 \001(\005\022\r\n\005width\030\002 "
  "\001(\005\022\016\n\006height\030\003 \001(\005\022\022\n\nrefresh_hz\030\004 \001(\005\""
  "\223\003\n\021CMsgSystemDisplay\022\n\n\002id\030\001 \001(\005\022\014\n\004nam"
  "e\030\002 \001(\t\022\023\n\013description\030\003 \001(\t\022\022\n\nis_prima"
  "ry\030\004 \001(\010\022\022\n\nis_enabled\030\005 \001(\010\022\023\n\013is_inter"
  "nal\030\006 \001(\010\022\031\n\021has_mode_override\030\007 \001(\010\022\020\n\010"
  "width_mm\030\010 \001(\005\022\021\n\theight_mm\030\t \001(\005\022\027\n\017cur"
  "rent_mode_id\030\n \001(\005\022%\n\005modes\030\013 \003(\0132\026.CMsg"
  "SystemDisplayMode\022\030\n\020refresh_rate_min\030\014 "
  "\001(\005\022\030\n\020refresh_rate_max\030\r \001(\005\022\026\n\016is_vrr_"
  "capable\030\016 \001(\010\022\026\n\016is_vrr_enabled\030\017 \001(\010\022\026\n"
  "\016is_hdr_capable\030\020 \001(\010\022\026\n\016is_hdr_enabled\030"
  "\021 \001(\010\"\323\001\n\035CMsgSystemDisplayManagerState\022"
  "$\n\010displays\030\001 \003(\0132\022.CMsgSystemDisplay\022#\n"
  "\033is_mode_switching_supported\030\002 \001(\010\022g\n\022co"
  "mpatibility_mode\030\003 \001(\0162 .ESystemDisplayC"
  "ompatibilityMode:)k_ESystemDisplayCompat"
  "ibilityMode_Invalid\"F\n\037CMsgSystemDisplay"
  "ManagerSetMode\022\022\n\ndisplay_id\030\001 \001(\005\022\017\n\007mo"
  "de_id\030\002 \001(\005\"\362\010\n\031CMsgSystemManagerSetting"
  "s\022*\n\"idle_backlight_dim_battery_seconds\030"
  "\001 \001(\002\022%\n\035idle_backlight_dim_ac_seconds\030\002"
  " \001(\002\022$\n\034idle_suspend_battery_seconds\030\003 \001"
  "(\002\022\037\n\027idle_suspend_ac_seconds\030\004 \001(\002\022\036\n\026i"
  "dle_suspend_supressed\030\005 \001(\010\022(\n is_adapti"
  "ve_brightness_available\030\006 \001(\010\022+\n#display"
  "_adaptive_brightness_enabled\030\007 \001(\010\022!\n\031di"
  "splay_nightmode_enabled\030\n \001(\010\022&\n\036display"
  "_nightmode_tintstrength\030\013 \001(\002\022 \n\030display"
  "_nightmode_maxhue\030\014 \001(\002\022 \n\030display_night"
  "mode_maxsat\030\r \001(\002\022\037\n\027display_nightmode_u"
  "iexp\030\016 \001(\002\022\037\n\027display_nightmode_blend\030\017 "
  "\001(\002\022\037\n\027display_nightmode_reset\030\020 \001(\010\022*\n\""
  "display_nightmode_schedule_enabled\030\021 \001(\010"
  "\022,\n$display_nightmode_schedule_starttime"
  "\030\022 \001(\002\022*\n\"display_nightmode_schedule_end"
  "time\030\023 \001(\002\022#\n\033display_diagnostics_enable"
  "d\030\024 \001(\010\022\026\n\016als_lux_latest\030\025 \001(\002\022\026\n\016als_l"
  "ux_median\030\026 \001(\002\022\035\n\025display_backlight_raw"
  "\030\027 \001(\002\022&\n\036display_brightness_adaptivemin"
  "\030\030 \001(\002\022&\n\036display_brightness_adaptivemax"
  "\030\031 \001(\002\022!\n\031is_wifi_powersave_enabled\030\032 \001("
  "\010\022 \n\030is_fan_control_available\030\033 \001(\010\022P\n\020f"
  "an_control_mode\030\034 \001(\0162\026.ESystemFanContro"
  "lMode:\036k_SystemFanControlMode_Invalid\022\'\n"
  "\037is_display_brightness_available\030\035 \001(\010\022,"
  "\n$is_display_colormanagement_available\030\037"
  " \001(\010\022\032\n\022display_colorgamut\030  \001(\002\"b\n\030CMsg"
  "SelectOSBranchParams\022/\n\006branch\030\001 \001(\0162\n.E"
  "OSBranch:\023k_EOSBranch_Unknown\022\025\n\rcustom_"
  "branch\030\002 \001(\t\"p\n\030CMsgSystemUpdateProgress"
  "\022\026\n\016stage_progress\030\001 \001(\002\022\030\n\020stage_size_b"
  "ytes\030\002 \001(\003\022\"\n\032rtime_estimated_completion"
  "\030\003 \001(\007\"\267\001\n\033CMsgSystemUpdateCheckResult\0223"
  "\n\004type\030\001 \001(\0162\r.EUpdaterType:\026k_EUpdaterT"
  "ype_Invalid\022\022\n\007eresult\030\002 \001(\r:\0012\022\025\n\rrtime"
  "_checked\030\003 \001(\007\022\021\n\tavailable\030\004 \001(\010\022\017\n\007ver"
  "sion\030\005 \001(\t\022\024\n\014auto_message\030\006 \001(\t\"A\n\033CMsg"
  "SystemUpdateApplyParams\022\"\n\013apply_types\030\001"
  " \003(\0162\r.EUpdaterType\"\266\001\n\033CMsgSystemUpdate"
  "ApplyResult\0223\n\004type\030\001 \001(\0162\r.EUpdaterType"
  ":\026k_EUpdaterType_Invalid\022\022\n\007eresult\030\002 \001("
  "\r:\0012\022&\n\027requires_client_restart\030\003 \001(\010:\005f"
  "alse\022&\n\027requires_system_restart\030\004 \001(\010:\005f"
  "alse\"\221\002\n\025CMsgSystemUpdateState\0226\n\005state\030"
  "\001 \001(\0162\016.EUpdaterState:\027k_EUpdaterState_I"
  "nvalid\022+\n\010progress\030\002 \001(\0132\031.CMsgSystemUpd"
  "ateProgress\022:\n\024update_check_results\030\003 \003("
  "\0132\034.CMsgSystemUpdateCheckResult\022:\n\024updat"
  "e_apply_results\030\004 \003(\0132\034.CMsgSystemUpdate"
  "ApplyResult\022\033\n\023supports_os_updates\030\005 \001(\010"
  "\"&\n\025CMsgAchievementChange\022\r\n\005appid\030\001 \001(\r"
  "\"\\\n\014CMsgCellList\022!\n\005cells\030\001 \003(\0132\022.CMsgCe"
  "llList.Cell\032)\n\004Cell\022\017\n\007cell_id\030\001 \001(\r\022\020\n\010"
  "loc_name\030\002 \001(\t\"\216\003\n\020CMsgShortcutInfo\022\r\n\005a"
  "ppid\030\001 \001(\r\022\013\n\003exe\030\002 \001(\t\022\021\n\tstart_dir\030\003 \001"
  "(\t\022\014\n\004icon\030\004 \001(\t\022\014\n\004path\030\005 \001(\t\022\014\n\004args\030\006"
  " \001(\t\022\020\n\010app_name\030\007 \001(\t\022\026\n\016override_appid"
  "\030\010 \001(\r\022\025\n\rflatpak_appid\030\t \001(\t\022\014\n\004tags\030\n "
  "\003(\t\022\021\n\tis_remote\030\013 \001(\010\022\021\n\tis_hidden\030\014 \001("
  "\010\022\024\n\014is_temporary\030\r \001(\010\022\021\n\tis_openvr\030\016 \001"
  "(\010\022\034\n\024allow_desktop_config\030\017 \001(\010\022\025\n\rallo"
  "w_overlay\030\020 \001(\010\022\033\n\023rt_last_played_time\030\021"
  " \001(\r\022\032\n\022is_devkit_shortcut\030\022 \001(\010\022\025\n\rdevk"
  "it_gameid\030\023 \001(\t\"$\n\022CMsgShortcutAppIds\022\016\n"
  "\006appids\030\001 \003(\r\"\252\001\n\017CMsgMonitorInfo\022\035\n\025sel"
  "ected_display_name\030\001 \002(\t\022.\n\010monitors\030\002 \003"
  "(\0132\034.CMsgMonitorInfo.MonitorInfo\032H\n\013Moni"
  "torInfo\022\033\n\023monitor_device_name\030\001 \002(\t\022\034\n\024"
  "monitor_display_name\030\002 \002(\t\"2\n\035CMsgGenera"
  "teSystemReportReply\022\021\n\treport_id\030\001 \001(\t\"8"
  "\n\026CMsgWebUITransportInfo\022\014\n\004port\030\001 \001(\r\022\020"
  "\n\010auth_key\030\002 \001(\t*\226\002\n\034ECloudPendingRemote"
  "Operation\022&\n\"k_ECloudPendingRemoteOperat"
  "ionNone\020\000\0222\n.k_ECloudPendingRemoteOperat"
  "ionAppSessionActive\020\001\0222\n.k_ECloudPending"
  "RemoteOperationUploadInProgress\020\002\022/\n+k_E"
  "CloudPendingRemoteOperationUploadPending"
  "\020\003\0225\n1k_ECloudPendingRemoteOperationAppS"
  "essionSuspended\020\004*\237\014\n\030ESteamDeckKeyboard"
  "Layout\022%\n!k_ESteamDeckKeyboardLayout_QWE"
  "RTY\020\000\022(\n$k_ESteamDeckKeyboardLayout_Bulg"
  "arian\020\001\0221\n-k_ESteamDeckKeyboardLayout_Ch"
  "inese_Simplified\020\002\0222\n.k_ESteamDeckKeyboa"
  "rdLayout_Chinese_Traditional\020\003\022$\n k_ESte"
  "amDeckKeyboardLayout_Czech\020\004\022%\n!k_ESteam"
  "DeckKeyboardLayout_Danish\020\005\022&\n\"k_ESteamD"
  "eckKeyboardLayout_Finnish\020\006\022%\n!k_ESteamD"
  "eckKeyboardLayout_French\020\007\022%\n!k_ESteamDe"
  "ckKeyboardLayout_German\020\010\022$\n k_ESteamDec"
  "kKeyboardLayout_Greek\020\t\022(\n$k_ESteamDeckK"
  "eyboardLayout_Hungarian\020\n\022&\n\"k_ESteamDec"
  "kKeyboardLayout_Italian\020\013\022\'\n#k_ESteamDec"
  "kKeyboardLayout_Japanese\020\014\022%\n!k_ESteamDe"
  "ckKeyboardLayout_Korean\020\r\022(\n$k_ESteamDec"
  "kKeyboardLayout_Norwegian\020\016\022%\n!k_ESteamD"
  "eckKeyboardLayout_Polish\020\017\022)\n%k_ESteamDe"
  "ckKeyboardLayout_Portuguese\020\020\022\'\n#k_EStea"
  "mDeckKeyboardLayout_Romanian\020\021\022&\n\"k_ESte"
  "amDeckKeyboardLayout_Russian\020\022\022&\n\"k_ESte"
  "amDeckKeyboardLayout_Spanish\020\023\022&\n\"k_ESte"
  "amDeckKeyboardLayout_Swedish\020\024\022#\n\037k_ESte"
  "amDeckKeyboardLayout_Thai\020\025\022(\n$k_ESteamD"
  "eckKeyboardLayout_Turkish_F\020\026\022(\n$k_EStea"
  "mDeckKeyboardLayout_Turkish_Q\020\027\022(\n$k_ESt"
  "eamDeckKeyboardLayout_Ukrainian\020\030\022)\n%k_E"
  "SteamDeckKeyboardLayout_Vietnamese\020\031\0223\n/"
  "k_ESteamDeckKeyboardLayout_QWERTY_Intern"
  "ational\020\032\022%\n!k_ESteamDeckKeyboardLayout_"
  "Dvorak\020\033\022&\n\"k_ESteamDeckKeyboardLayout_C"
  "olemak\020\034\022=\n9k_ESteamDeckKeyboardLayout_B"
  "ulgarian_Phonetic_Traditional\020\035\0221\n-k_ESt"
  "eamDeckKeyboardLayout_Bulgarian_Phonetic"
  "\020\036\022;\n7k_ESteamDeckKeyboardLayout_Chinese"
  "_Traditional_Bopomofo\020\037\022:\n6k_ESteamDeckK"
  "eyboardLayout_Chinese_Traditional_Cangji"
  "e\020 \022,\n(k_ESteamDeckKeyboardLayout_Japane"
  "se_Kana\020!\0228\n4k_ESteamDeckKeyboardLayout_"
  "Chinese_Traditional_Quick\020\"B\005H\001\200\001\000"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fclient_5fobjects_2eproto_deps[1] = {
  &::descriptor_table_enums_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fclient_5fobjects_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fclient_5fobjects_2eproto = {
  false, false, 16234, descriptor_table_protodef_steammessages_5fclient_5fobjects_2eproto, "steammessages_client_objects.proto", 
  &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once, descriptor_table_steammessages_5fclient_5fobjects_2eproto_deps, 1, 66,
  schemas, file_default_instances, TableStruct_steammessages_5fclient_5fobjects_2eproto::offsets,
  file_level_metadata_steammessages_5fclient_5fobjects_2eproto, file_level_enum_descriptors_steammessages_5fclient_5fobjects_2eproto, file_level_service_descriptors_steammessages_5fclient_5fobjects_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter() {
  return &descriptor_table_steammessages_5fclient_5fobjects_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fclient_5fobjects_2eproto(&descriptor_table_steammessages_5fclient_5fobjects_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ECloudPendingRemoteOperation_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fclient_5fobjects_2eproto);
  return file_level_enum_descriptors_steammessages_5fclient_5fobjects_2eproto[0];
}
bool ECloudPendingRemoteOperation_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESteamDeckKeyboardLayout_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fclient_5fobjects_2eproto);
  return file_level_enum_descriptors_steammessages_5fclient_5fobjects_2eproto[1];
}
bool ESteamDeckKeyboardLayout_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class SteamMessagesClientIClientForcedEnumDependencies::_Internal {
 public:
  using HasBits = decltype(std::declval<SteamMessagesClientIClientForcedEnumDependencies>()._has_bits_);
  static void set_has_a(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_b(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_c(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_d(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

SteamMessagesClientIClientForcedEnumDependencies::SteamMessagesClientIClientForcedEnumDependencies(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:SteamMessagesClientIClientForcedEnumDependencies)
}
SteamMessagesClientIClientForcedEnumDependencies::SteamMessagesClientIClientForcedEnumDependencies(const SteamMessagesClientIClientForcedEnumDependencies& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&a_, &from.a_,
    static_cast<size_t>(reinterpret_cast<char*>(&d_) -
    reinterpret_cast<char*>(&a_)) + sizeof(d_));
  // @@protoc_insertion_point(copy_constructor:SteamMessagesClientIClientForcedEnumDependencies)
}

inline void SteamMessagesClientIClientForcedEnumDependencies::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&a_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&d_) -
    reinterpret_cast<char*>(&a_)) + sizeof(d_));
}

SteamMessagesClientIClientForcedEnumDependencies::~SteamMessagesClientIClientForcedEnumDependencies() {
  // @@protoc_insertion_point(destructor:SteamMessagesClientIClientForcedEnumDependencies)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void SteamMessagesClientIClientForcedEnumDependencies::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void SteamMessagesClientIClientForcedEnumDependencies::ArenaDtor(void* object) {
  SteamMessagesClientIClientForcedEnumDependencies* _this = reinterpret_cast< SteamMessagesClientIClientForcedEnumDependencies* >(object);
  (void)_this;
}
void SteamMessagesClientIClientForcedEnumDependencies::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void SteamMessagesClientIClientForcedEnumDependencies::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void SteamMessagesClientIClientForcedEnumDependencies::Clear() {
// @@protoc_insertion_point(message_clear_start:SteamMessagesClientIClientForcedEnumDependencies)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&a_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&d_) -
        reinterpret_cast<char*>(&a_)) + sizeof(d_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SteamMessagesClientIClientForcedEnumDependencies::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EBluetoothDeviceType a = 1 [default = k_BluetoothDeviceType_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EBluetoothDeviceType_IsValid(val))) {
            _internal_set_a(static_cast<::EBluetoothDeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EStorageBlockContentType b = 2 [default = k_EStorageBlockContentType_Invalid];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStorageBlockContentType_IsValid(val))) {
            _internal_set_b(static_cast<::EStorageBlockContentType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EStorageBlockFileSystemType c = 3 [default = k_EStorageBlockFileSystemType_Invalid];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStorageBlockFileSystemType_IsValid(val))) {
            _internal_set_c(static_cast<::EStorageBlockFileSystemType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESDCardFormatStage d = 4 [default = k_ESDCardFormatStage_Invalid];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESDCardFormatStage_IsValid(val))) {
            _internal_set_d(static_cast<::ESDCardFormatStage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SteamMessagesClientIClientForcedEnumDependencies::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:SteamMessagesClientIClientForcedEnumDependencies)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EBluetoothDeviceType a = 1 [default = k_BluetoothDeviceType_Invalid];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_a(), target);
  }

  // optional .EStorageBlockContentType b = 2 [default = k_EStorageBlockContentType_Invalid];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_b(), target);
  }

  // optional .EStorageBlockFileSystemType c = 3 [default = k_EStorageBlockFileSystemType_Invalid];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_c(), target);
  }

  // optional .ESDCardFormatStage d = 4 [default = k_ESDCardFormatStage_Invalid];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_d(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:SteamMessagesClientIClientForcedEnumDependencies)
  return target;
}

size_t SteamMessagesClientIClientForcedEnumDependencies::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:SteamMessagesClientIClientForcedEnumDependencies)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .EBluetoothDeviceType a = 1 [default = k_BluetoothDeviceType_Invalid];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_a());
    }

    // optional .EStorageBlockContentType b = 2 [default = k_EStorageBlockContentType_Invalid];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_b());
    }

    // optional .EStorageBlockFileSystemType c = 3 [default = k_EStorageBlockFileSystemType_Invalid];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_c());
    }

    // optional .ESDCardFormatStage d = 4 [default = k_ESDCardFormatStage_Invalid];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_d());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SteamMessagesClientIClientForcedEnumDependencies::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    SteamMessagesClientIClientForcedEnumDependencies::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SteamMessagesClientIClientForcedEnumDependencies::GetClassData() const { return &_class_data_; }

void SteamMessagesClientIClientForcedEnumDependencies::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<SteamMessagesClientIClientForcedEnumDependencies *>(to)->MergeFrom(
      static_cast<const SteamMessagesClientIClientForcedEnumDependencies &>(from));
}


void SteamMessagesClientIClientForcedEnumDependencies::MergeFrom(const SteamMessagesClientIClientForcedEnumDependencies& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:SteamMessagesClientIClientForcedEnumDependencies)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      a_ = from.a_;
    }
    if (cached_has_bits & 0x00000002u) {
      b_ = from.b_;
    }
    if (cached_has_bits & 0x00000004u) {
      c_ = from.c_;
    }
    if (cached_has_bits & 0x00000008u) {
      d_ = from.d_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SteamMessagesClientIClientForcedEnumDependencies::CopyFrom(const SteamMessagesClientIClientForcedEnumDependencies& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:SteamMessagesClientIClientForcedEnumDependencies)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SteamMessagesClientIClientForcedEnumDependencies::IsInitialized() const {
  return true;
}

void SteamMessagesClientIClientForcedEnumDependencies::InternalSwap(SteamMessagesClientIClientForcedEnumDependencies* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SteamMessagesClientIClientForcedEnumDependencies, d_)
      + sizeof(SteamMessagesClientIClientForcedEnumDependencies::d_)
      - PROTOBUF_FIELD_OFFSET(SteamMessagesClientIClientForcedEnumDependencies, a_)>(
          reinterpret_cast<char*>(&a_),
          reinterpret_cast<char*>(&other->a_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SteamMessagesClientIClientForcedEnumDependencies::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[0]);
}

// ===================================================================

class CMsgNetworkDeviceIP4Address::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceIP4Address>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_netmask(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgNetworkDeviceIP4Address::CMsgNetworkDeviceIP4Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceIP4Address)
}
CMsgNetworkDeviceIP4Address::CMsgNetworkDeviceIP4Address(const CMsgNetworkDeviceIP4Address& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&ip_, &from.ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&netmask_) -
    reinterpret_cast<char*>(&ip_)) + sizeof(netmask_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceIP4Address)
}

inline void CMsgNetworkDeviceIP4Address::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&netmask_) -
    reinterpret_cast<char*>(&ip_)) + sizeof(netmask_));
}

CMsgNetworkDeviceIP4Address::~CMsgNetworkDeviceIP4Address() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceIP4Address)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceIP4Address::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgNetworkDeviceIP4Address::ArenaDtor(void* object) {
  CMsgNetworkDeviceIP4Address* _this = reinterpret_cast< CMsgNetworkDeviceIP4Address* >(object);
  (void)_this;
}
void CMsgNetworkDeviceIP4Address::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceIP4Address::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceIP4Address::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceIP4Address)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&netmask_) -
        reinterpret_cast<char*>(&ip_)) + sizeof(netmask_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceIP4Address::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 ip = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ip(&has_bits);
          ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 netmask = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_netmask(&has_bits);
          netmask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceIP4Address::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceIP4Address)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 ip = 1 [default = 0];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_ip(), target);
  }

  // optional int32 netmask = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_netmask(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceIP4Address)
  return target;
}

size_t CMsgNetworkDeviceIP4Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceIP4Address)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 ip = 1 [default = 0];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_ip());
    }

    // optional int32 netmask = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_netmask());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceIP4Address::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceIP4Address::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceIP4Address::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceIP4Address::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceIP4Address *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceIP4Address &>(from));
}


void CMsgNetworkDeviceIP4Address::MergeFrom(const CMsgNetworkDeviceIP4Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceIP4Address)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ip_ = from.ip_;
    }
    if (cached_has_bits & 0x00000002u) {
      netmask_ = from.netmask_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceIP4Address::CopyFrom(const CMsgNetworkDeviceIP4Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceIP4Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceIP4Address::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceIP4Address::InternalSwap(CMsgNetworkDeviceIP4Address* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP4Address, netmask_)
      + sizeof(CMsgNetworkDeviceIP4Address::netmask_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP4Address, ip_)>(
          reinterpret_cast<char*>(&ip_),
          reinterpret_cast<char*>(&other->ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceIP4Address::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[1]);
}

// ===================================================================

class CMsgNetworkDeviceIP4Config::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceIP4Config>()._has_bits_);
  static void set_has_gateway_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_dhcp_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_default_route(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgNetworkDeviceIP4Config::CMsgNetworkDeviceIP4Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  addresses_(arena),
  dns_ip_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceIP4Config)
}
CMsgNetworkDeviceIP4Config::CMsgNetworkDeviceIP4Config(const CMsgNetworkDeviceIP4Config& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      addresses_(from.addresses_),
      dns_ip_(from.dns_ip_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&gateway_ip_, &from.gateway_ip_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&gateway_ip_)) + sizeof(is_enabled_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceIP4Config)
}

inline void CMsgNetworkDeviceIP4Config::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gateway_ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&gateway_ip_)) + sizeof(is_enabled_));
}

CMsgNetworkDeviceIP4Config::~CMsgNetworkDeviceIP4Config() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceIP4Config)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceIP4Config::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgNetworkDeviceIP4Config::ArenaDtor(void* object) {
  CMsgNetworkDeviceIP4Config* _this = reinterpret_cast< CMsgNetworkDeviceIP4Config* >(object);
  (void)_this;
}
void CMsgNetworkDeviceIP4Config::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceIP4Config::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceIP4Config::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceIP4Config)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addresses_.Clear();
  dns_ip_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&gateway_ip_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_enabled_) -
        reinterpret_cast<char*>(&gateway_ip_)) + sizeof(is_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceIP4Config::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgNetworkDeviceIP4Address addresses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dns_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dns_ip(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dns_ip(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gateway_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gateway_ip(&has_bits);
          gateway_ip_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dhcp_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_dhcp_enabled(&has_bits);
          is_dhcp_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_default_route = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_default_route(&has_bits);
          is_default_route_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_enabled(&has_bits);
          is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceIP4Config::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceIP4Config)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgNetworkDeviceIP4Address addresses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_addresses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_addresses(i), target, stream);
  }

  // repeated int32 dns_ip = 2;
  for (int i = 0, n = this->_internal_dns_ip_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_dns_ip(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 gateway_ip = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_gateway_ip(), target);
  }

  // optional bool is_dhcp_enabled = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_dhcp_enabled(), target);
  }

  // optional bool is_default_route = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_default_route(), target);
  }

  // optional bool is_enabled = 6 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceIP4Config)
  return target;
}

size_t CMsgNetworkDeviceIP4Config::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceIP4Config)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgNetworkDeviceIP4Address addresses = 1;
  total_size += 1UL * this->_internal_addresses_size();
  for (const auto& msg : this->addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 dns_ip = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->dns_ip_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_dns_ip_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 gateway_ip = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_gateway_ip());
    }

    // optional bool is_dhcp_enabled = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_default_route = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_enabled = 6 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceIP4Config::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceIP4Config::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceIP4Config::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceIP4Config::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceIP4Config *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceIP4Config &>(from));
}


void CMsgNetworkDeviceIP4Config::MergeFrom(const CMsgNetworkDeviceIP4Config& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceIP4Config)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  addresses_.MergeFrom(from.addresses_);
  dns_ip_.MergeFrom(from.dns_ip_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      gateway_ip_ = from.gateway_ip_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_dhcp_enabled_ = from.is_dhcp_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_default_route_ = from.is_default_route_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_enabled_ = from.is_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceIP4Config::CopyFrom(const CMsgNetworkDeviceIP4Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceIP4Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceIP4Config::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceIP4Config::InternalSwap(CMsgNetworkDeviceIP4Config* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addresses_.InternalSwap(&other->addresses_);
  dns_ip_.InternalSwap(&other->dns_ip_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP4Config, is_enabled_)
      + sizeof(CMsgNetworkDeviceIP4Config::is_enabled_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP4Config, gateway_ip_)>(
          reinterpret_cast<char*>(&gateway_ip_),
          reinterpret_cast<char*>(&other->gateway_ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceIP4Config::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[2]);
}

// ===================================================================

class CMsgNetworkDeviceIP6Address::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceIP6Address>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNetworkDeviceIP6Address::CMsgNetworkDeviceIP6Address(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceIP6Address)
}
CMsgNetworkDeviceIP6Address::CMsgNetworkDeviceIP6Address(const CMsgNetworkDeviceIP6Address& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceIP6Address)
}

inline void CMsgNetworkDeviceIP6Address::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgNetworkDeviceIP6Address::~CMsgNetworkDeviceIP6Address() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceIP6Address)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceIP6Address::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDeviceIP6Address::ArenaDtor(void* object) {
  CMsgNetworkDeviceIP6Address* _this = reinterpret_cast< CMsgNetworkDeviceIP6Address* >(object);
  (void)_this;
}
void CMsgNetworkDeviceIP6Address::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceIP6Address::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceIP6Address::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceIP6Address)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceIP6Address::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ip = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceIP6Address.ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceIP6Address::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceIP6Address)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ip = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceIP6Address.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceIP6Address)
  return target;
}

size_t CMsgNetworkDeviceIP6Address::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceIP6Address)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string ip = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceIP6Address::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceIP6Address::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceIP6Address::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceIP6Address::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceIP6Address *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceIP6Address &>(from));
}


void CMsgNetworkDeviceIP6Address::MergeFrom(const CMsgNetworkDeviceIP6Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceIP6Address)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ip()) {
    _internal_set_ip(from._internal_ip());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceIP6Address::CopyFrom(const CMsgNetworkDeviceIP6Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceIP6Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceIP6Address::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceIP6Address::InternalSwap(CMsgNetworkDeviceIP6Address* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceIP6Address::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[3]);
}

// ===================================================================

class CMsgNetworkDeviceIP6Config::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceIP6Config>()._has_bits_);
  static void set_has_gateway_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_dhcp_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_default_route(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgNetworkDeviceIP6Config::CMsgNetworkDeviceIP6Config(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  addresses_(arena),
  dns_ip_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceIP6Config)
}
CMsgNetworkDeviceIP6Config::CMsgNetworkDeviceIP6Config(const CMsgNetworkDeviceIP6Config& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      addresses_(from.addresses_),
      dns_ip_(from.dns_ip_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  gateway_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gateway_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gateway_ip()) {
    gateway_ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_gateway_ip(), 
      GetArenaForAllocation());
  }
  ::memcpy(&is_dhcp_enabled_, &from.is_dhcp_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&is_dhcp_enabled_)) + sizeof(is_enabled_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceIP6Config)
}

inline void CMsgNetworkDeviceIP6Config::SharedCtor() {
gateway_ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gateway_ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_dhcp_enabled_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_enabled_) -
    reinterpret_cast<char*>(&is_dhcp_enabled_)) + sizeof(is_enabled_));
}

CMsgNetworkDeviceIP6Config::~CMsgNetworkDeviceIP6Config() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceIP6Config)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceIP6Config::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  gateway_ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDeviceIP6Config::ArenaDtor(void* object) {
  CMsgNetworkDeviceIP6Config* _this = reinterpret_cast< CMsgNetworkDeviceIP6Config* >(object);
  (void)_this;
}
void CMsgNetworkDeviceIP6Config::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceIP6Config::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceIP6Config::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceIP6Config)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  addresses_.Clear();
  dns_ip_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    gateway_ip_.ClearNonDefaultToEmpty();
  }
  ::memset(&is_dhcp_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_enabled_) -
      reinterpret_cast<char*>(&is_dhcp_enabled_)) + sizeof(is_enabled_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceIP6Config::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgNetworkDeviceIP6Address addresses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_addresses(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string dns_ip = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dns_ip();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceIP6Config.dns_ip");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string gateway_ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_gateway_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceIP6Config.gateway_ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dhcp_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_dhcp_enabled(&has_bits);
          is_dhcp_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_default_route = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_default_route(&has_bits);
          is_default_route_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 6 [default = false];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_enabled(&has_bits);
          is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceIP6Config::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceIP6Config)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgNetworkDeviceIP6Address addresses = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_addresses_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_addresses(i), target, stream);
  }

  // repeated string dns_ip = 2;
  for (int i = 0, n = this->_internal_dns_ip_size(); i < n; i++) {
    const auto& s = this->_internal_dns_ip(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceIP6Config.dns_ip");
    target = stream->WriteString(2, s, target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string gateway_ip = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_gateway_ip().data(), static_cast<int>(this->_internal_gateway_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceIP6Config.gateway_ip");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_gateway_ip(), target);
  }

  // optional bool is_dhcp_enabled = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_dhcp_enabled(), target);
  }

  // optional bool is_default_route = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_default_route(), target);
  }

  // optional bool is_enabled = 6 [default = false];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceIP6Config)
  return target;
}

size_t CMsgNetworkDeviceIP6Config::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceIP6Config)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgNetworkDeviceIP6Address addresses = 1;
  total_size += 1UL * this->_internal_addresses_size();
  for (const auto& msg : this->addresses_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string dns_ip = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(dns_ip_.size());
  for (int i = 0, n = dns_ip_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      dns_ip_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string gateway_ip = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_gateway_ip());
    }

    // optional bool is_dhcp_enabled = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_default_route = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool is_enabled = 6 [default = false];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceIP6Config::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceIP6Config::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceIP6Config::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceIP6Config::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceIP6Config *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceIP6Config &>(from));
}


void CMsgNetworkDeviceIP6Config::MergeFrom(const CMsgNetworkDeviceIP6Config& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceIP6Config)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  addresses_.MergeFrom(from.addresses_);
  dns_ip_.MergeFrom(from.dns_ip_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_gateway_ip(from._internal_gateway_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      is_dhcp_enabled_ = from.is_dhcp_enabled_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_default_route_ = from.is_default_route_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_enabled_ = from.is_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceIP6Config::CopyFrom(const CMsgNetworkDeviceIP6Config& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceIP6Config)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceIP6Config::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceIP6Config::InternalSwap(CMsgNetworkDeviceIP6Config* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  addresses_.InternalSwap(&other->addresses_);
  dns_ip_.InternalSwap(&other->dns_ip_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &gateway_ip_, lhs_arena,
      &other->gateway_ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP6Config, is_enabled_)
      + sizeof(CMsgNetworkDeviceIP6Config::is_enabled_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceIP6Config, is_dhcp_enabled_)>(
          reinterpret_cast<char*>(&is_dhcp_enabled_),
          reinterpret_cast<char*>(&other->is_dhcp_enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceIP6Config::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[4]);
}

// ===================================================================

class CMsgNetworkDevicesData_Device_Wired::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDevicesData_Device_Wired>()._has_bits_);
  static void set_has_is_cable_present(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_speed_mbit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNetworkDevicesData_Device_Wired::CMsgNetworkDevicesData_Device_Wired(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDevicesData.Device.Wired)
}
CMsgNetworkDevicesData_Device_Wired::CMsgNetworkDevicesData_Device_Wired(const CMsgNetworkDevicesData_Device_Wired& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friendly_name()) {
    friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_friendly_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&is_cable_present_, &from.is_cable_present_,
    static_cast<size_t>(reinterpret_cast<char*>(&speed_mbit_) -
    reinterpret_cast<char*>(&is_cable_present_)) + sizeof(speed_mbit_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDevicesData.Device.Wired)
}

inline void CMsgNetworkDevicesData_Device_Wired::SharedCtor() {
friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_cable_present_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&speed_mbit_) -
    reinterpret_cast<char*>(&is_cable_present_)) + sizeof(speed_mbit_));
}

CMsgNetworkDevicesData_Device_Wired::~CMsgNetworkDevicesData_Device_Wired() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDevicesData.Device.Wired)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDevicesData_Device_Wired::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDevicesData_Device_Wired::ArenaDtor(void* object) {
  CMsgNetworkDevicesData_Device_Wired* _this = reinterpret_cast< CMsgNetworkDevicesData_Device_Wired* >(object);
  (void)_this;
}
void CMsgNetworkDevicesData_Device_Wired::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDevicesData_Device_Wired::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDevicesData_Device_Wired::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDevicesData.Device.Wired)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    friendly_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&is_cable_present_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&speed_mbit_) -
        reinterpret_cast<char*>(&is_cable_present_)) + sizeof(speed_mbit_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDevicesData_Device_Wired::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_cable_present = 1 [default = false];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_cable_present(&has_bits);
          is_cable_present_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 speed_mbit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_speed_mbit(&has_bits);
          speed_mbit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string friendly_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.Wired.friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDevicesData_Device_Wired::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDevicesData.Device.Wired)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_cable_present = 1 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_cable_present(), target);
  }

  // optional uint32 speed_mbit = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_speed_mbit(), target);
  }

  // optional string friendly_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_name().data(), static_cast<int>(this->_internal_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.Wired.friendly_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_friendly_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDevicesData.Device.Wired)
  return target;
}

size_t CMsgNetworkDevicesData_Device_Wired::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDevicesData.Device.Wired)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string friendly_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_name());
    }

    // optional bool is_cable_present = 1 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional uint32 speed_mbit = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_speed_mbit());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDevicesData_Device_Wired::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDevicesData_Device_Wired::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDevicesData_Device_Wired::GetClassData() const { return &_class_data_; }

void CMsgNetworkDevicesData_Device_Wired::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDevicesData_Device_Wired *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDevicesData_Device_Wired &>(from));
}


void CMsgNetworkDevicesData_Device_Wired::MergeFrom(const CMsgNetworkDevicesData_Device_Wired& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDevicesData.Device.Wired)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_friendly_name(from._internal_friendly_name());
    }
    if (cached_has_bits & 0x00000002u) {
      is_cable_present_ = from.is_cable_present_;
    }
    if (cached_has_bits & 0x00000004u) {
      speed_mbit_ = from.speed_mbit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDevicesData_Device_Wired::CopyFrom(const CMsgNetworkDevicesData_Device_Wired& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDevicesData.Device.Wired)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDevicesData_Device_Wired::IsInitialized() const {
  return true;
}

void CMsgNetworkDevicesData_Device_Wired::InternalSwap(CMsgNetworkDevicesData_Device_Wired* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &friendly_name_, lhs_arena,
      &other->friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device_Wired, speed_mbit_)
      + sizeof(CMsgNetworkDevicesData_Device_Wired::speed_mbit_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device_Wired, is_cable_present_)>(
          reinterpret_cast<char*>(&is_cable_present_),
          reinterpret_cast<char*>(&other->is_cable_present_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDevicesData_Device_Wired::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[5]);
}

// ===================================================================

class CMsgNetworkDevicesData_Device_Wireless_AP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDevicesData_Device_Wireless_AP>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_estrength(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_active(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_autoconnect(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_esecurity(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_user_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_strength_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CMsgNetworkDevicesData_Device_Wireless_AP::CMsgNetworkDevicesData_Device_Wireless_AP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDevicesData.Device.Wireless.AP)
}
CMsgNetworkDevicesData_Device_Wireless_AP::CMsgNetworkDevicesData_Device_Wireless_AP(const CMsgNetworkDevicesData_Device_Wireless_AP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_user_name()) {
    user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_user_name(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&strength_raw_) -
    reinterpret_cast<char*>(&id_)) + sizeof(strength_raw_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDevicesData.Device.Wireless.AP)
}

inline void CMsgNetworkDevicesData_Device_Wireless_AP::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
user_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  user_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&strength_raw_) -
    reinterpret_cast<char*>(&id_)) + sizeof(strength_raw_));
}

CMsgNetworkDevicesData_Device_Wireless_AP::~CMsgNetworkDevicesData_Device_Wireless_AP() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDevicesData.Device.Wireless.AP)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDevicesData_Device_Wireless_AP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  user_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDevicesData_Device_Wireless_AP::ArenaDtor(void* object) {
  CMsgNetworkDevicesData_Device_Wireless_AP* _this = reinterpret_cast< CMsgNetworkDevicesData_Device_Wireless_AP* >(object);
  (void)_this;
}
void CMsgNetworkDevicesData_Device_Wireless_AP::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDevicesData_Device_Wireless_AP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDevicesData_Device_Wireless_AP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDevicesData.Device.Wireless.AP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      ssid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      user_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      password_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&esecurity_) -
        reinterpret_cast<char*>(&id_)) + sizeof(esecurity_));
  }
  strength_raw_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDevicesData_Device_Wireless_AP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 estrength = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_estrength(&has_bits);
          estrength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ssid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.Wireless.AP.ssid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_active = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_active(&has_bits);
          is_active_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_autoconnect = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_autoconnect(&has_bits);
          is_autoconnect_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 esecurity = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_esecurity(&has_bits);
          esecurity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string user_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_user_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.Wireless.AP.user_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.Wireless.AP.password");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 strength_raw = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_strength_raw(&has_bits);
          strength_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDevicesData_Device_Wireless_AP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDevicesData.Device.Wireless.AP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional int32 estrength = 2;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_estrength(), target);
  }

  // optional string ssid = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ssid().data(), static_cast<int>(this->_internal_ssid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.Wireless.AP.ssid");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ssid(), target);
  }

  // optional bool is_active = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_active(), target);
  }

  // optional bool is_autoconnect = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_autoconnect(), target);
  }

  // optional int32 esecurity = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_esecurity(), target);
  }

  // optional string user_name = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_user_name().data(), static_cast<int>(this->_internal_user_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.Wireless.AP.user_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_user_name(), target);
  }

  // optional string password = 8;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.Wireless.AP.password");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_password(), target);
  }

  // optional int32 strength_raw = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_strength_raw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDevicesData.Device.Wireless.AP)
  return target;
}

size_t CMsgNetworkDevicesData_Device_Wireless_AP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDevicesData.Device.Wireless.AP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string ssid = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional string user_name = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_user_name());
    }

    // optional string password = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional int32 estrength = 2;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_estrength());
    }

    // optional bool is_active = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_autoconnect = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 esecurity = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_esecurity());
    }

  }
  // optional int32 strength_raw = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_strength_raw());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDevicesData_Device_Wireless_AP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDevicesData_Device_Wireless_AP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDevicesData_Device_Wireless_AP::GetClassData() const { return &_class_data_; }

void CMsgNetworkDevicesData_Device_Wireless_AP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDevicesData_Device_Wireless_AP *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDevicesData_Device_Wireless_AP &>(from));
}


void CMsgNetworkDevicesData_Device_Wireless_AP::MergeFrom(const CMsgNetworkDevicesData_Device_Wireless_AP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDevicesData.Device.Wireless.AP)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_user_name(from._internal_user_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_password(from._internal_password());
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      estrength_ = from.estrength_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_active_ = from.is_active_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_autoconnect_ = from.is_autoconnect_;
    }
    if (cached_has_bits & 0x00000080u) {
      esecurity_ = from.esecurity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_strength_raw(from._internal_strength_raw());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDevicesData_Device_Wireless_AP::CopyFrom(const CMsgNetworkDevicesData_Device_Wireless_AP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDevicesData.Device.Wireless.AP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDevicesData_Device_Wireless_AP::IsInitialized() const {
  return true;
}

void CMsgNetworkDevicesData_Device_Wireless_AP::InternalSwap(CMsgNetworkDevicesData_Device_Wireless_AP* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &user_name_, lhs_arena,
      &other->user_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device_Wireless_AP, strength_raw_)
      + sizeof(CMsgNetworkDevicesData_Device_Wireless_AP::strength_raw_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device_Wireless_AP, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDevicesData_Device_Wireless_AP::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[6]);
}

// ===================================================================

class CMsgNetworkDevicesData_Device_Wireless::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDevicesData_Device_Wireless>()._has_bits_);
  static void set_has_esecurity_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNetworkDevicesData_Device_Wireless::CMsgNetworkDevicesData_Device_Wireless(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  aps_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDevicesData.Device.Wireless)
}
CMsgNetworkDevicesData_Device_Wireless::CMsgNetworkDevicesData_Device_Wireless(const CMsgNetworkDevicesData_Device_Wireless& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      aps_(from.aps_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  esecurity_supported_ = from.esecurity_supported_;
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDevicesData.Device.Wireless)
}

inline void CMsgNetworkDevicesData_Device_Wireless::SharedCtor() {
esecurity_supported_ = 0;
}

CMsgNetworkDevicesData_Device_Wireless::~CMsgNetworkDevicesData_Device_Wireless() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDevicesData.Device.Wireless)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDevicesData_Device_Wireless::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgNetworkDevicesData_Device_Wireless::ArenaDtor(void* object) {
  CMsgNetworkDevicesData_Device_Wireless* _this = reinterpret_cast< CMsgNetworkDevicesData_Device_Wireless* >(object);
  (void)_this;
}
void CMsgNetworkDevicesData_Device_Wireless::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDevicesData_Device_Wireless::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDevicesData_Device_Wireless::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDevicesData.Device.Wireless)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  aps_.Clear();
  esecurity_supported_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDevicesData_Device_Wireless::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgNetworkDevicesData.Device.Wireless.AP aps = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_aps(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 esecurity_supported = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_esecurity_supported(&has_bits);
          esecurity_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDevicesData_Device_Wireless::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDevicesData.Device.Wireless)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgNetworkDevicesData.Device.Wireless.AP aps = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_aps_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_aps(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 esecurity_supported = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_esecurity_supported(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDevicesData.Device.Wireless)
  return target;
}

size_t CMsgNetworkDevicesData_Device_Wireless::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDevicesData.Device.Wireless)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgNetworkDevicesData.Device.Wireless.AP aps = 1;
  total_size += 1UL * this->_internal_aps_size();
  for (const auto& msg : this->aps_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 esecurity_supported = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_esecurity_supported());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDevicesData_Device_Wireless::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDevicesData_Device_Wireless::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDevicesData_Device_Wireless::GetClassData() const { return &_class_data_; }

void CMsgNetworkDevicesData_Device_Wireless::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDevicesData_Device_Wireless *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDevicesData_Device_Wireless &>(from));
}


void CMsgNetworkDevicesData_Device_Wireless::MergeFrom(const CMsgNetworkDevicesData_Device_Wireless& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDevicesData.Device.Wireless)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  aps_.MergeFrom(from.aps_);
  if (from._internal_has_esecurity_supported()) {
    _internal_set_esecurity_supported(from._internal_esecurity_supported());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDevicesData_Device_Wireless::CopyFrom(const CMsgNetworkDevicesData_Device_Wireless& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDevicesData.Device.Wireless)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDevicesData_Device_Wireless::IsInitialized() const {
  return true;
}

void CMsgNetworkDevicesData_Device_Wireless::InternalSwap(CMsgNetworkDevicesData_Device_Wireless* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  aps_.InternalSwap(&other->aps_);
  swap(esecurity_supported_, other->esecurity_supported_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDevicesData_Device_Wireless::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[7]);
}

// ===================================================================

class CMsgNetworkDevicesData_Device::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDevicesData_Device>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_etype(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_estate(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_product(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgNetworkDeviceIP4Config& ip4(const CMsgNetworkDevicesData_Device* msg);
  static void set_has_ip4(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgNetworkDeviceIP6Config& ip6(const CMsgNetworkDevicesData_Device* msg);
  static void set_has_ip6(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgNetworkDevicesData_Device_Wired& wired(const CMsgNetworkDevicesData_Device* msg);
  static void set_has_wired(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CMsgNetworkDevicesData_Device_Wireless& wireless(const CMsgNetworkDevicesData_Device* msg);
  static void set_has_wireless(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::CMsgNetworkDeviceIP4Config&
CMsgNetworkDevicesData_Device::_Internal::ip4(const CMsgNetworkDevicesData_Device* msg) {
  return *msg->ip4_;
}
const ::CMsgNetworkDeviceIP6Config&
CMsgNetworkDevicesData_Device::_Internal::ip6(const CMsgNetworkDevicesData_Device* msg) {
  return *msg->ip6_;
}
const ::CMsgNetworkDevicesData_Device_Wired&
CMsgNetworkDevicesData_Device::_Internal::wired(const CMsgNetworkDevicesData_Device* msg) {
  return *msg->wired_;
}
const ::CMsgNetworkDevicesData_Device_Wireless&
CMsgNetworkDevicesData_Device::_Internal::wireless(const CMsgNetworkDevicesData_Device* msg) {
  return *msg->wireless_;
}
CMsgNetworkDevicesData_Device::CMsgNetworkDevicesData_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDevicesData.Device)
}
CMsgNetworkDevicesData_Device::CMsgNetworkDevicesData_Device(const CMsgNetworkDevicesData_Device& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac()) {
    mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac(), 
      GetArenaForAllocation());
  }
  vendor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor()) {
    vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_vendor(), 
      GetArenaForAllocation());
  }
  product_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_product()) {
    product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_product(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_ip4()) {
    ip4_ = new ::CMsgNetworkDeviceIP4Config(*from.ip4_);
  } else {
    ip4_ = nullptr;
  }
  if (from._internal_has_ip6()) {
    ip6_ = new ::CMsgNetworkDeviceIP6Config(*from.ip6_);
  } else {
    ip6_ = nullptr;
  }
  if (from._internal_has_wired()) {
    wired_ = new ::CMsgNetworkDevicesData_Device_Wired(*from.wired_);
  } else {
    wired_ = nullptr;
  }
  if (from._internal_has_wireless()) {
    wireless_ = new ::CMsgNetworkDevicesData_Device_Wireless(*from.wireless_);
  } else {
    wireless_ = nullptr;
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&estate_) -
    reinterpret_cast<char*>(&id_)) + sizeof(estate_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDevicesData.Device)
}

inline void CMsgNetworkDevicesData_Device::SharedCtor() {
mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
vendor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
product_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip4_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&estate_) -
    reinterpret_cast<char*>(&ip4_)) + sizeof(estate_));
}

CMsgNetworkDevicesData_Device::~CMsgNetworkDevicesData_Device() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDevicesData.Device)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDevicesData_Device::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mac_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  vendor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  product_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete ip4_;
  if (this != internal_default_instance()) delete ip6_;
  if (this != internal_default_instance()) delete wired_;
  if (this != internal_default_instance()) delete wireless_;
}

void CMsgNetworkDevicesData_Device::ArenaDtor(void* object) {
  CMsgNetworkDevicesData_Device* _this = reinterpret_cast< CMsgNetworkDevicesData_Device* >(object);
  (void)_this;
}
void CMsgNetworkDevicesData_Device::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDevicesData_Device::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDevicesData_Device::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDevicesData.Device)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      mac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      vendor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      product_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(ip4_ != nullptr);
      ip4_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(ip6_ != nullptr);
      ip6_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(wired_ != nullptr);
      wired_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(wireless_ != nullptr);
      wireless_->Clear();
    }
  }
  id_ = 0u;
  if (cached_has_bits & 0x00000300u) {
    ::memset(&etype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&estate_) -
        reinterpret_cast<char*>(&etype_)) + sizeof(estate_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDevicesData_Device::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 etype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_etype(&has_bits);
          etype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 estate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_estate(&has_bits);
          estate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mac();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.mac");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vendor = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_vendor();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.vendor");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string product = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_product();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDevicesData.Device.product");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDeviceIP4Config ip4 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip4(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDeviceIP6Config ip6 = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip6(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDevicesData.Device.Wired wired = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_wired(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDevicesData.Device.Wireless wireless = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_wireless(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDevicesData_Device::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDevicesData.Device)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional int32 etype = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_etype(), target);
  }

  // optional int32 estate = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_estate(), target);
  }

  // optional string mac = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.mac");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_mac(), target);
  }

  // optional string vendor = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vendor().data(), static_cast<int>(this->_internal_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.vendor");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_vendor(), target);
  }

  // optional string product = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_product().data(), static_cast<int>(this->_internal_product().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDevicesData.Device.product");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_product(), target);
  }

  // optional .CMsgNetworkDeviceIP4Config ip4 = 7;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::ip4(this), target, stream);
  }

  // optional .CMsgNetworkDeviceIP6Config ip6 = 8;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        8, _Internal::ip6(this), target, stream);
  }

  // optional .CMsgNetworkDevicesData.Device.Wired wired = 9;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::wired(this), target, stream);
  }

  // optional .CMsgNetworkDevicesData.Device.Wireless wireless = 10;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::wireless(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDevicesData.Device)
  return target;
}

size_t CMsgNetworkDevicesData_Device::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDevicesData.Device)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string mac = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac());
    }

    // optional string vendor = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor());
    }

    // optional string product = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_product());
    }

    // optional .CMsgNetworkDeviceIP4Config ip4 = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip4_);
    }

    // optional .CMsgNetworkDeviceIP6Config ip6 = 8;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip6_);
    }

    // optional .CMsgNetworkDevicesData.Device.Wired wired = 9;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wired_);
    }

    // optional .CMsgNetworkDevicesData.Device.Wireless wireless = 10;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *wireless_);
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional int32 etype = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_etype());
    }

    // optional int32 estate = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_estate());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDevicesData_Device::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDevicesData_Device::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDevicesData_Device::GetClassData() const { return &_class_data_; }

void CMsgNetworkDevicesData_Device::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDevicesData_Device *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDevicesData_Device &>(from));
}


void CMsgNetworkDevicesData_Device::MergeFrom(const CMsgNetworkDevicesData_Device& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDevicesData.Device)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_mac(from._internal_mac());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_vendor(from._internal_vendor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_product(from._internal_product());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_ip4()->::CMsgNetworkDeviceIP4Config::MergeFrom(from._internal_ip4());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_ip6()->::CMsgNetworkDeviceIP6Config::MergeFrom(from._internal_ip6());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_wired()->::CMsgNetworkDevicesData_Device_Wired::MergeFrom(from._internal_wired());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_mutable_wireless()->::CMsgNetworkDevicesData_Device_Wireless::MergeFrom(from._internal_wireless());
    }
    if (cached_has_bits & 0x00000080u) {
      id_ = from.id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      etype_ = from.etype_;
    }
    if (cached_has_bits & 0x00000200u) {
      estate_ = from.estate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDevicesData_Device::CopyFrom(const CMsgNetworkDevicesData_Device& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDevicesData.Device)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDevicesData_Device::IsInitialized() const {
  return true;
}

void CMsgNetworkDevicesData_Device::InternalSwap(CMsgNetworkDevicesData_Device* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_, lhs_arena,
      &other->mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &vendor_, lhs_arena,
      &other->vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &product_, lhs_arena,
      &other->product_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device, estate_)
      + sizeof(CMsgNetworkDevicesData_Device::estate_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData_Device, ip4_)>(
          reinterpret_cast<char*>(&ip4_),
          reinterpret_cast<char*>(&other->ip4_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDevicesData_Device::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[8]);
}

// ===================================================================

class CMsgNetworkDevicesData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDevicesData>()._has_bits_);
  static void set_has_is_wifi_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_wifi_scanning_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgNetworkDevicesData::CMsgNetworkDevicesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  devices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDevicesData)
}
CMsgNetworkDevicesData::CMsgNetworkDevicesData(const CMsgNetworkDevicesData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      devices_(from.devices_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&is_wifi_enabled_, &from.is_wifi_enabled_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_wifi_scanning_enabled_) -
    reinterpret_cast<char*>(&is_wifi_enabled_)) + sizeof(is_wifi_scanning_enabled_));
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDevicesData)
}

inline void CMsgNetworkDevicesData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_wifi_enabled_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_wifi_scanning_enabled_) -
    reinterpret_cast<char*>(&is_wifi_enabled_)) + sizeof(is_wifi_scanning_enabled_));
}

CMsgNetworkDevicesData::~CMsgNetworkDevicesData() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDevicesData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDevicesData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgNetworkDevicesData::ArenaDtor(void* object) {
  CMsgNetworkDevicesData* _this = reinterpret_cast< CMsgNetworkDevicesData* >(object);
  (void)_this;
}
void CMsgNetworkDevicesData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDevicesData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDevicesData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDevicesData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  devices_.Clear();
  ::memset(&is_wifi_enabled_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_wifi_scanning_enabled_) -
      reinterpret_cast<char*>(&is_wifi_enabled_)) + sizeof(is_wifi_scanning_enabled_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDevicesData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgNetworkDevicesData.Device devices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_wifi_enabled = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_wifi_enabled(&has_bits);
          is_wifi_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_wifi_scanning_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_wifi_scanning_enabled(&has_bits);
          is_wifi_scanning_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDevicesData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDevicesData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgNetworkDevicesData.Device devices = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_devices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_devices(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_wifi_enabled = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_wifi_enabled(), target);
  }

  // optional bool is_wifi_scanning_enabled = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_wifi_scanning_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDevicesData)
  return target;
}

size_t CMsgNetworkDevicesData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDevicesData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgNetworkDevicesData.Device devices = 1;
  total_size += 1UL * this->_internal_devices_size();
  for (const auto& msg : this->devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool is_wifi_enabled = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool is_wifi_scanning_enabled = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDevicesData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDevicesData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDevicesData::GetClassData() const { return &_class_data_; }

void CMsgNetworkDevicesData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDevicesData *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDevicesData &>(from));
}


void CMsgNetworkDevicesData::MergeFrom(const CMsgNetworkDevicesData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDevicesData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  devices_.MergeFrom(from.devices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      is_wifi_enabled_ = from.is_wifi_enabled_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_wifi_scanning_enabled_ = from.is_wifi_scanning_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDevicesData::CopyFrom(const CMsgNetworkDevicesData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDevicesData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDevicesData::IsInitialized() const {
  return true;
}

void CMsgNetworkDevicesData::InternalSwap(CMsgNetworkDevicesData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  devices_.InternalSwap(&other->devices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData, is_wifi_scanning_enabled_)
      + sizeof(CMsgNetworkDevicesData::is_wifi_scanning_enabled_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDevicesData, is_wifi_enabled_)>(
          reinterpret_cast<char*>(&is_wifi_enabled_),
          reinterpret_cast<char*>(&other->is_wifi_enabled_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDevicesData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[9]);
}

// ===================================================================

class CMsgNetworkDeviceConnect_KnownAP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceConnect_KnownAP>()._has_bits_);
  static void set_has_ap_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgNetworkDeviceConnect_KnownAP::CMsgNetworkDeviceConnect_KnownAP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceConnect.KnownAP)
}
CMsgNetworkDeviceConnect_KnownAP::CMsgNetworkDeviceConnect_KnownAP(const CMsgNetworkDeviceConnect_KnownAP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ap_id_ = from.ap_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceConnect.KnownAP)
}

inline void CMsgNetworkDeviceConnect_KnownAP::SharedCtor() {
ap_id_ = 0u;
}

CMsgNetworkDeviceConnect_KnownAP::~CMsgNetworkDeviceConnect_KnownAP() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceConnect.KnownAP)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceConnect_KnownAP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgNetworkDeviceConnect_KnownAP::ArenaDtor(void* object) {
  CMsgNetworkDeviceConnect_KnownAP* _this = reinterpret_cast< CMsgNetworkDeviceConnect_KnownAP* >(object);
  (void)_this;
}
void CMsgNetworkDeviceConnect_KnownAP::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceConnect_KnownAP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceConnect_KnownAP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceConnect.KnownAP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ap_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceConnect_KnownAP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 ap_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_ap_id(&has_bits);
          ap_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceConnect_KnownAP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceConnect.KnownAP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 ap_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_ap_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceConnect.KnownAP)
  return target;
}

size_t CMsgNetworkDeviceConnect_KnownAP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceConnect.KnownAP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 ap_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_ap_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceConnect_KnownAP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceConnect_KnownAP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceConnect_KnownAP::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceConnect_KnownAP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceConnect_KnownAP *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceConnect_KnownAP &>(from));
}


void CMsgNetworkDeviceConnect_KnownAP::MergeFrom(const CMsgNetworkDeviceConnect_KnownAP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceConnect.KnownAP)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_ap_id()) {
    _internal_set_ap_id(from._internal_ap_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceConnect_KnownAP::CopyFrom(const CMsgNetworkDeviceConnect_KnownAP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceConnect.KnownAP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceConnect_KnownAP::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceConnect_KnownAP::InternalSwap(CMsgNetworkDeviceConnect_KnownAP* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(ap_id_, other->ap_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceConnect_KnownAP::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[10]);
}

// ===================================================================

class CMsgNetworkDeviceConnect_CustomAP::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceConnect_CustomAP>()._has_bits_);
  static void set_has_ssid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_esecurity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgNetworkDeviceConnect_CustomAP::CMsgNetworkDeviceConnect_CustomAP(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceConnect.CustomAP)
}
CMsgNetworkDeviceConnect_CustomAP::CMsgNetworkDeviceConnect_CustomAP(const CMsgNetworkDeviceConnect_CustomAP& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ssid()) {
    ssid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ssid(), 
      GetArenaForAllocation());
  }
  esecurity_ = from.esecurity_;
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceConnect.CustomAP)
}

inline void CMsgNetworkDeviceConnect_CustomAP::SharedCtor() {
ssid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ssid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
esecurity_ = 0;
}

CMsgNetworkDeviceConnect_CustomAP::~CMsgNetworkDeviceConnect_CustomAP() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceConnect.CustomAP)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceConnect_CustomAP::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ssid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDeviceConnect_CustomAP::ArenaDtor(void* object) {
  CMsgNetworkDeviceConnect_CustomAP* _this = reinterpret_cast< CMsgNetworkDeviceConnect_CustomAP* >(object);
  (void)_this;
}
void CMsgNetworkDeviceConnect_CustomAP::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceConnect_CustomAP::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceConnect_CustomAP::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceConnect.CustomAP)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ssid_.ClearNonDefaultToEmpty();
  }
  esecurity_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceConnect_CustomAP::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ssid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ssid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceConnect.CustomAP.ssid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 esecurity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_esecurity(&has_bits);
          esecurity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceConnect_CustomAP::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceConnect.CustomAP)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ssid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ssid().data(), static_cast<int>(this->_internal_ssid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceConnect.CustomAP.ssid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ssid(), target);
  }

  // optional int32 esecurity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_esecurity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceConnect.CustomAP)
  return target;
}

size_t CMsgNetworkDeviceConnect_CustomAP::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceConnect.CustomAP)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string ssid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ssid());
    }

    // optional int32 esecurity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_esecurity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceConnect_CustomAP::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceConnect_CustomAP::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceConnect_CustomAP::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceConnect_CustomAP::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceConnect_CustomAP *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceConnect_CustomAP &>(from));
}


void CMsgNetworkDeviceConnect_CustomAP::MergeFrom(const CMsgNetworkDeviceConnect_CustomAP& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceConnect.CustomAP)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ssid(from._internal_ssid());
    }
    if (cached_has_bits & 0x00000002u) {
      esecurity_ = from.esecurity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceConnect_CustomAP::CopyFrom(const CMsgNetworkDeviceConnect_CustomAP& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceConnect.CustomAP)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceConnect_CustomAP::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceConnect_CustomAP::InternalSwap(CMsgNetworkDeviceConnect_CustomAP* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ssid_, lhs_arena,
      &other->ssid_, rhs_arena
  );
  swap(esecurity_, other->esecurity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceConnect_CustomAP::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[11]);
}

// ===================================================================

class CMsgNetworkDeviceConnect_Credentials::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceConnect_Credentials>()._has_bits_);
  static void set_has_username(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_password(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgNetworkDeviceConnect_Credentials::CMsgNetworkDeviceConnect_Credentials(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceConnect.Credentials)
}
CMsgNetworkDeviceConnect_Credentials::CMsgNetworkDeviceConnect_Credentials(const CMsgNetworkDeviceConnect_Credentials& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_username()) {
    username_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_username(), 
      GetArenaForAllocation());
  }
  password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_password()) {
    password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_password(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceConnect.Credentials)
}

inline void CMsgNetworkDeviceConnect_Credentials::SharedCtor() {
username_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgNetworkDeviceConnect_Credentials::~CMsgNetworkDeviceConnect_Credentials() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceConnect.Credentials)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceConnect_Credentials::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  username_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgNetworkDeviceConnect_Credentials::ArenaDtor(void* object) {
  CMsgNetworkDeviceConnect_Credentials* _this = reinterpret_cast< CMsgNetworkDeviceConnect_Credentials* >(object);
  (void)_this;
}
void CMsgNetworkDeviceConnect_Credentials::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceConnect_Credentials::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceConnect_Credentials::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceConnect.Credentials)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      username_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      password_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceConnect_Credentials::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string username = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_username();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceConnect.Credentials.username");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string password = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgNetworkDeviceConnect.Credentials.password");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceConnect_Credentials::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceConnect.Credentials)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string username = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceConnect.Credentials.username");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_username(), target);
  }

  // optional string password = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_password().data(), static_cast<int>(this->_internal_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgNetworkDeviceConnect.Credentials.password");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_password(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceConnect.Credentials)
  return target;
}

size_t CMsgNetworkDeviceConnect_Credentials::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceConnect.Credentials)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string username = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_username());
    }

    // optional string password = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_password());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceConnect_Credentials::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceConnect_Credentials::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceConnect_Credentials::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceConnect_Credentials::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceConnect_Credentials *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceConnect_Credentials &>(from));
}


void CMsgNetworkDeviceConnect_Credentials::MergeFrom(const CMsgNetworkDeviceConnect_Credentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceConnect.Credentials)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_username(from._internal_username());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_password(from._internal_password());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceConnect_Credentials::CopyFrom(const CMsgNetworkDeviceConnect_Credentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceConnect.Credentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceConnect_Credentials::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceConnect_Credentials::InternalSwap(CMsgNetworkDeviceConnect_Credentials* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &password_, lhs_arena,
      &other->password_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceConnect_Credentials::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[12]);
}

// ===================================================================

class CMsgNetworkDeviceConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgNetworkDeviceConnect>()._has_bits_);
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgNetworkDeviceConnect_Credentials& credentials(const CMsgNetworkDeviceConnect* msg);
  static void set_has_credentials(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgNetworkDeviceIP4Config& ip4(const CMsgNetworkDeviceConnect* msg);
  static void set_has_ip4(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgNetworkDeviceIP6Config& ip6(const CMsgNetworkDeviceConnect* msg);
  static void set_has_ip6(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgNetworkDeviceConnect_KnownAP& ap_known(const CMsgNetworkDeviceConnect* msg);
  static const ::CMsgNetworkDeviceConnect_CustomAP& ap_custom(const CMsgNetworkDeviceConnect* msg);
};

const ::CMsgNetworkDeviceConnect_Credentials&
CMsgNetworkDeviceConnect::_Internal::credentials(const CMsgNetworkDeviceConnect* msg) {
  return *msg->credentials_;
}
const ::CMsgNetworkDeviceIP4Config&
CMsgNetworkDeviceConnect::_Internal::ip4(const CMsgNetworkDeviceConnect* msg) {
  return *msg->ip4_;
}
const ::CMsgNetworkDeviceIP6Config&
CMsgNetworkDeviceConnect::_Internal::ip6(const CMsgNetworkDeviceConnect* msg) {
  return *msg->ip6_;
}
const ::CMsgNetworkDeviceConnect_KnownAP&
CMsgNetworkDeviceConnect::_Internal::ap_known(const CMsgNetworkDeviceConnect* msg) {
  return *msg->ap_info_.ap_known_;
}
const ::CMsgNetworkDeviceConnect_CustomAP&
CMsgNetworkDeviceConnect::_Internal::ap_custom(const CMsgNetworkDeviceConnect* msg) {
  return *msg->ap_info_.ap_custom_;
}
void CMsgNetworkDeviceConnect::set_allocated_ap_known(::CMsgNetworkDeviceConnect_KnownAP* ap_known) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ap_info();
  if (ap_known) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CMsgNetworkDeviceConnect_KnownAP>::GetOwningArena(ap_known);
    if (message_arena != submessage_arena) {
      ap_known = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ap_known, submessage_arena);
    }
    set_has_ap_known();
    ap_info_.ap_known_ = ap_known;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetworkDeviceConnect.ap_known)
}
void CMsgNetworkDeviceConnect::set_allocated_ap_custom(::CMsgNetworkDeviceConnect_CustomAP* ap_custom) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_ap_info();
  if (ap_custom) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CMsgNetworkDeviceConnect_CustomAP>::GetOwningArena(ap_custom);
    if (message_arena != submessage_arena) {
      ap_custom = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ap_custom, submessage_arena);
    }
    set_has_ap_custom();
    ap_info_.ap_custom_ = ap_custom;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgNetworkDeviceConnect.ap_custom)
}
CMsgNetworkDeviceConnect::CMsgNetworkDeviceConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgNetworkDeviceConnect)
}
CMsgNetworkDeviceConnect::CMsgNetworkDeviceConnect(const CMsgNetworkDeviceConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_credentials()) {
    credentials_ = new ::CMsgNetworkDeviceConnect_Credentials(*from.credentials_);
  } else {
    credentials_ = nullptr;
  }
  if (from._internal_has_ip4()) {
    ip4_ = new ::CMsgNetworkDeviceIP4Config(*from.ip4_);
  } else {
    ip4_ = nullptr;
  }
  if (from._internal_has_ip6()) {
    ip6_ = new ::CMsgNetworkDeviceIP6Config(*from.ip6_);
  } else {
    ip6_ = nullptr;
  }
  device_id_ = from.device_id_;
  clear_has_ap_info();
  switch (from.ap_info_case()) {
    case kApKnown: {
      _internal_mutable_ap_known()->::CMsgNetworkDeviceConnect_KnownAP::MergeFrom(from._internal_ap_known());
      break;
    }
    case kApCustom: {
      _internal_mutable_ap_custom()->::CMsgNetworkDeviceConnect_CustomAP::MergeFrom(from._internal_ap_custom());
      break;
    }
    case AP_INFO_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CMsgNetworkDeviceConnect)
}

inline void CMsgNetworkDeviceConnect::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&credentials_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_id_) -
    reinterpret_cast<char*>(&credentials_)) + sizeof(device_id_));
clear_has_ap_info();
}

CMsgNetworkDeviceConnect::~CMsgNetworkDeviceConnect() {
  // @@protoc_insertion_point(destructor:CMsgNetworkDeviceConnect)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgNetworkDeviceConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete credentials_;
  if (this != internal_default_instance()) delete ip4_;
  if (this != internal_default_instance()) delete ip6_;
  if (has_ap_info()) {
    clear_ap_info();
  }
}

void CMsgNetworkDeviceConnect::ArenaDtor(void* object) {
  CMsgNetworkDeviceConnect* _this = reinterpret_cast< CMsgNetworkDeviceConnect* >(object);
  (void)_this;
}
void CMsgNetworkDeviceConnect::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgNetworkDeviceConnect::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgNetworkDeviceConnect::clear_ap_info() {
// @@protoc_insertion_point(one_of_clear_start:CMsgNetworkDeviceConnect)
  switch (ap_info_case()) {
    case kApKnown: {
      if (GetArenaForAllocation() == nullptr) {
        delete ap_info_.ap_known_;
      }
      break;
    }
    case kApCustom: {
      if (GetArenaForAllocation() == nullptr) {
        delete ap_info_.ap_custom_;
      }
      break;
    }
    case AP_INFO_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = AP_INFO_NOT_SET;
}


void CMsgNetworkDeviceConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgNetworkDeviceConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(credentials_ != nullptr);
      credentials_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(ip4_ != nullptr);
      ip4_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(ip6_ != nullptr);
      ip6_->Clear();
    }
  }
  device_id_ = 0u;
  clear_ap_info();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgNetworkDeviceConnect::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 device_id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CMsgNetworkDeviceConnect.KnownAP ap_known = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ap_known(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CMsgNetworkDeviceConnect.CustomAP ap_custom = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ap_custom(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDeviceConnect.Credentials credentials = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_credentials(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDeviceIP4Config ip4 = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip4(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgNetworkDeviceIP6Config ip6 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip6(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgNetworkDeviceConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgNetworkDeviceConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 device_id = 1 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_device_id(), target);
  }

  switch (ap_info_case()) {
    case kApKnown: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          2, _Internal::ap_known(this), target, stream);
      break;
    }
    case kApCustom: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::ap_custom(this), target, stream);
      break;
    }
    default: ;
  }
  // optional .CMsgNetworkDeviceConnect.Credentials credentials = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::credentials(this), target, stream);
  }

  // optional .CMsgNetworkDeviceIP4Config ip4 = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::ip4(this), target, stream);
  }

  // optional .CMsgNetworkDeviceIP6Config ip6 = 6;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        6, _Internal::ip6(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgNetworkDeviceConnect)
  return target;
}

size_t CMsgNetworkDeviceConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgNetworkDeviceConnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgNetworkDeviceConnect.Credentials credentials = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *credentials_);
    }

    // optional .CMsgNetworkDeviceIP4Config ip4 = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip4_);
    }

    // optional .CMsgNetworkDeviceIP6Config ip6 = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip6_);
    }

    // optional uint32 device_id = 1 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
    }

  }
  switch (ap_info_case()) {
    // .CMsgNetworkDeviceConnect.KnownAP ap_known = 2;
    case kApKnown: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ap_info_.ap_known_);
      break;
    }
    // .CMsgNetworkDeviceConnect.CustomAP ap_custom = 3;
    case kApCustom: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ap_info_.ap_custom_);
      break;
    }
    case AP_INFO_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgNetworkDeviceConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgNetworkDeviceConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgNetworkDeviceConnect::GetClassData() const { return &_class_data_; }

void CMsgNetworkDeviceConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgNetworkDeviceConnect *>(to)->MergeFrom(
      static_cast<const CMsgNetworkDeviceConnect &>(from));
}


void CMsgNetworkDeviceConnect::MergeFrom(const CMsgNetworkDeviceConnect& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgNetworkDeviceConnect)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_credentials()->::CMsgNetworkDeviceConnect_Credentials::MergeFrom(from._internal_credentials());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_ip4()->::CMsgNetworkDeviceIP4Config::MergeFrom(from._internal_ip4());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_ip6()->::CMsgNetworkDeviceIP6Config::MergeFrom(from._internal_ip6());
    }
    if (cached_has_bits & 0x00000008u) {
      device_id_ = from.device_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.ap_info_case()) {
    case kApKnown: {
      _internal_mutable_ap_known()->::CMsgNetworkDeviceConnect_KnownAP::MergeFrom(from._internal_ap_known());
      break;
    }
    case kApCustom: {
      _internal_mutable_ap_custom()->::CMsgNetworkDeviceConnect_CustomAP::MergeFrom(from._internal_ap_custom());
      break;
    }
    case AP_INFO_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgNetworkDeviceConnect::CopyFrom(const CMsgNetworkDeviceConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgNetworkDeviceConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgNetworkDeviceConnect::IsInitialized() const {
  return true;
}

void CMsgNetworkDeviceConnect::InternalSwap(CMsgNetworkDeviceConnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceConnect, device_id_)
      + sizeof(CMsgNetworkDeviceConnect::device_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgNetworkDeviceConnect, credentials_)>(
          reinterpret_cast<char*>(&credentials_),
          reinterpret_cast<char*>(&other->credentials_));
  swap(ap_info_, other->ap_info_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgNetworkDeviceConnect::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[13]);
}

// ===================================================================

class CMsgStorageDevicesData_Drive::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStorageDevicesData_Drive>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_model(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_vendor(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_serial(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_ejectable(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_media_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgStorageDevicesData_Drive::CMsgStorageDevicesData_Drive(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgStorageDevicesData.Drive)
}
CMsgStorageDevicesData_Drive::CMsgStorageDevicesData_Drive(const CMsgStorageDevicesData_Drive& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_model()) {
    model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_model(), 
      GetArenaForAllocation());
  }
  vendor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vendor()) {
    vendor_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_vendor(), 
      GetArenaForAllocation());
  }
  serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serial()) {
    serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_serial(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&media_type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(media_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgStorageDevicesData.Drive)
}

inline void CMsgStorageDevicesData_Drive::SharedCtor() {
model_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
vendor_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vendor_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
serial_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&media_type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(media_type_));
}

CMsgStorageDevicesData_Drive::~CMsgStorageDevicesData_Drive() {
  // @@protoc_insertion_point(destructor:CMsgStorageDevicesData.Drive)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgStorageDevicesData_Drive::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  model_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  vendor_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  serial_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgStorageDevicesData_Drive::ArenaDtor(void* object) {
  CMsgStorageDevicesData_Drive* _this = reinterpret_cast< CMsgStorageDevicesData_Drive* >(object);
  (void)_this;
}
void CMsgStorageDevicesData_Drive::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgStorageDevicesData_Drive::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgStorageDevicesData_Drive::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStorageDevicesData.Drive)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      model_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      vendor_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      serial_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000078u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&media_type_) -
        reinterpret_cast<char*>(&id_)) + sizeof(media_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStorageDevicesData_Drive::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string model = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_model();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.Drive.model");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vendor = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_vendor();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.Drive.vendor");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string serial = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_serial();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.Drive.serial");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ejectable = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_ejectable(&has_bits);
          is_ejectable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_size_bytes(&has_bits);
          size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStorageDriveMediaType media_type = 7 [default = k_EStorageDriveMediaType_Invalid];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStorageDriveMediaType_IsValid(val))) {
            _internal_set_media_type(static_cast<::EStorageDriveMediaType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStorageDevicesData_Drive::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStorageDevicesData.Drive)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string model = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_model().data(), static_cast<int>(this->_internal_model().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.Drive.model");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_model(), target);
  }

  // optional string vendor = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vendor().data(), static_cast<int>(this->_internal_vendor().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.Drive.vendor");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_vendor(), target);
  }

  // optional string serial = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_serial().data(), static_cast<int>(this->_internal_serial().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.Drive.serial");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_serial(), target);
  }

  // optional bool is_ejectable = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_ejectable(), target);
  }

  // optional uint64 size_bytes = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_size_bytes(), target);
  }

  // optional .EStorageDriveMediaType media_type = 7 [default = k_EStorageDriveMediaType_Invalid];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_media_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStorageDevicesData.Drive)
  return target;
}

size_t CMsgStorageDevicesData_Drive::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStorageDevicesData.Drive)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string model = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_model());
    }

    // optional string vendor = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vendor());
    }

    // optional string serial = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_serial());
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional bool is_ejectable = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint64 size_bytes = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_size_bytes());
    }

    // optional .EStorageDriveMediaType media_type = 7 [default = k_EStorageDriveMediaType_Invalid];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_media_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStorageDevicesData_Drive::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgStorageDevicesData_Drive::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStorageDevicesData_Drive::GetClassData() const { return &_class_data_; }

void CMsgStorageDevicesData_Drive::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgStorageDevicesData_Drive *>(to)->MergeFrom(
      static_cast<const CMsgStorageDevicesData_Drive &>(from));
}


void CMsgStorageDevicesData_Drive::MergeFrom(const CMsgStorageDevicesData_Drive& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgStorageDevicesData.Drive)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_model(from._internal_model());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_vendor(from._internal_vendor());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_serial(from._internal_serial());
    }
    if (cached_has_bits & 0x00000008u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_ejectable_ = from.is_ejectable_;
    }
    if (cached_has_bits & 0x00000020u) {
      size_bytes_ = from.size_bytes_;
    }
    if (cached_has_bits & 0x00000040u) {
      media_type_ = from.media_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStorageDevicesData_Drive::CopyFrom(const CMsgStorageDevicesData_Drive& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStorageDevicesData.Drive)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStorageDevicesData_Drive::IsInitialized() const {
  return true;
}

void CMsgStorageDevicesData_Drive::InternalSwap(CMsgStorageDevicesData_Drive* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &model_, lhs_arena,
      &other->model_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &vendor_, lhs_arena,
      &other->vendor_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &serial_, lhs_arena,
      &other->serial_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData_Drive, media_type_)
      + sizeof(CMsgStorageDevicesData_Drive::media_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData_Drive, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStorageDevicesData_Drive::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[14]);
}

// ===================================================================

class CMsgStorageDevicesData_BlockDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStorageDevicesData_BlockDevice>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_drive_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_friendly_path(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_label(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_formattable(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_read_only(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_root_device(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_content_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_filesystem_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_mount_path(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgStorageDevicesData_BlockDevice::CMsgStorageDevicesData_BlockDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgStorageDevicesData.BlockDevice)
}
CMsgStorageDevicesData_BlockDevice::CMsgStorageDevicesData_BlockDevice(const CMsgStorageDevicesData_BlockDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_path(), 
      GetArenaForAllocation());
  }
  friendly_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    friendly_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friendly_path()) {
    friendly_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_friendly_path(), 
      GetArenaForAllocation());
  }
  label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_label()) {
    label_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_label(), 
      GetArenaForAllocation());
  }
  mount_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mount_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mount_path()) {
    mount_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mount_path(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&filesystem_type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(filesystem_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgStorageDevicesData.BlockDevice)
}

inline void CMsgStorageDevicesData_BlockDevice::SharedCtor() {
path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
friendly_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  friendly_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
label_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  label_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
mount_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mount_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&filesystem_type_) -
    reinterpret_cast<char*>(&id_)) + sizeof(filesystem_type_));
}

CMsgStorageDevicesData_BlockDevice::~CMsgStorageDevicesData_BlockDevice() {
  // @@protoc_insertion_point(destructor:CMsgStorageDevicesData.BlockDevice)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgStorageDevicesData_BlockDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  friendly_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  label_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  mount_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgStorageDevicesData_BlockDevice::ArenaDtor(void* object) {
  CMsgStorageDevicesData_BlockDevice* _this = reinterpret_cast< CMsgStorageDevicesData_BlockDevice* >(object);
  (void)_this;
}
void CMsgStorageDevicesData_BlockDevice::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgStorageDevicesData_BlockDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgStorageDevicesData_BlockDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStorageDevicesData.BlockDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      friendly_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      label_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      mount_path_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_formattable_) -
        reinterpret_cast<char*>(&id_)) + sizeof(is_formattable_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&is_read_only_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&filesystem_type_) -
        reinterpret_cast<char*>(&is_read_only_)) + sizeof(filesystem_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStorageDevicesData_BlockDevice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 drive_id = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_drive_id(&has_bits);
          drive_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string path = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.BlockDevice.path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string friendly_path = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_friendly_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.BlockDevice.friendly_path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string label = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_label();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.BlockDevice.label");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 size_bytes = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_size_bytes(&has_bits);
          size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_formattable = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_formattable(&has_bits);
          is_formattable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_read_only = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_read_only(&has_bits);
          is_read_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_root_device = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_root_device(&has_bits);
          is_root_device_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStorageBlockContentType content_type = 10 [default = k_EStorageBlockContentType_Invalid];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStorageBlockContentType_IsValid(val))) {
            _internal_set_content_type(static_cast<::EStorageBlockContentType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EStorageBlockFileSystemType filesystem_type = 11 [default = k_EStorageBlockFileSystemType_Invalid];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStorageBlockFileSystemType_IsValid(val))) {
            _internal_set_filesystem_type(static_cast<::EStorageBlockFileSystemType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(11, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string mount_path = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_mount_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgStorageDevicesData.BlockDevice.mount_path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStorageDevicesData_BlockDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStorageDevicesData.BlockDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional uint32 drive_id = 2 [default = 0];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_drive_id(), target);
  }

  // optional string path = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.BlockDevice.path");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_path(), target);
  }

  // optional string friendly_path = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friendly_path().data(), static_cast<int>(this->_internal_friendly_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.BlockDevice.friendly_path");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_friendly_path(), target);
  }

  // optional string label = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_label().data(), static_cast<int>(this->_internal_label().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.BlockDevice.label");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_label(), target);
  }

  // optional uint64 size_bytes = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(6, this->_internal_size_bytes(), target);
  }

  // optional bool is_formattable = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_formattable(), target);
  }

  // optional bool is_read_only = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_read_only(), target);
  }

  // optional bool is_root_device = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_root_device(), target);
  }

  // optional .EStorageBlockContentType content_type = 10 [default = k_EStorageBlockContentType_Invalid];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->_internal_content_type(), target);
  }

  // optional .EStorageBlockFileSystemType filesystem_type = 11 [default = k_EStorageBlockFileSystemType_Invalid];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      11, this->_internal_filesystem_type(), target);
  }

  // optional string mount_path = 12;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mount_path().data(), static_cast<int>(this->_internal_mount_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgStorageDevicesData.BlockDevice.mount_path");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_mount_path(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStorageDevicesData.BlockDevice)
  return target;
}

size_t CMsgStorageDevicesData_BlockDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStorageDevicesData.BlockDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string path = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional string friendly_path = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friendly_path());
    }

    // optional string label = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_label());
    }

    // optional string mount_path = 12;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mount_path());
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 drive_id = 2 [default = 0];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_drive_id());
    }

    // optional uint64 size_bytes = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_size_bytes());
    }

    // optional bool is_formattable = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool is_read_only = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_root_device = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional .EStorageBlockContentType content_type = 10 [default = k_EStorageBlockContentType_Invalid];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_content_type());
    }

    // optional .EStorageBlockFileSystemType filesystem_type = 11 [default = k_EStorageBlockFileSystemType_Invalid];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_filesystem_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStorageDevicesData_BlockDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgStorageDevicesData_BlockDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStorageDevicesData_BlockDevice::GetClassData() const { return &_class_data_; }

void CMsgStorageDevicesData_BlockDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgStorageDevicesData_BlockDevice *>(to)->MergeFrom(
      static_cast<const CMsgStorageDevicesData_BlockDevice &>(from));
}


void CMsgStorageDevicesData_BlockDevice::MergeFrom(const CMsgStorageDevicesData_BlockDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgStorageDevicesData.BlockDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_friendly_path(from._internal_friendly_path());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_label(from._internal_label());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_mount_path(from._internal_mount_path());
    }
    if (cached_has_bits & 0x00000010u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000020u) {
      drive_id_ = from.drive_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      size_bytes_ = from.size_bytes_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_formattable_ = from.is_formattable_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      is_read_only_ = from.is_read_only_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_root_device_ = from.is_root_device_;
    }
    if (cached_has_bits & 0x00000400u) {
      content_type_ = from.content_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      filesystem_type_ = from.filesystem_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStorageDevicesData_BlockDevice::CopyFrom(const CMsgStorageDevicesData_BlockDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStorageDevicesData.BlockDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStorageDevicesData_BlockDevice::IsInitialized() const {
  return true;
}

void CMsgStorageDevicesData_BlockDevice::InternalSwap(CMsgStorageDevicesData_BlockDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &path_, lhs_arena,
      &other->path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &friendly_path_, lhs_arena,
      &other->friendly_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &label_, lhs_arena,
      &other->label_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mount_path_, lhs_arena,
      &other->mount_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData_BlockDevice, filesystem_type_)
      + sizeof(CMsgStorageDevicesData_BlockDevice::filesystem_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData_BlockDevice, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStorageDevicesData_BlockDevice::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[15]);
}

// ===================================================================

class CMsgStorageDevicesData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgStorageDevicesData>()._has_bits_);
  static void set_has_is_unmount_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_is_trim_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_trim_running(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgStorageDevicesData::CMsgStorageDevicesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  drives_(arena),
  block_devices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgStorageDevicesData)
}
CMsgStorageDevicesData::CMsgStorageDevicesData(const CMsgStorageDevicesData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      drives_(from.drives_),
      block_devices_(from.block_devices_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&is_unmount_supported_, &from.is_unmount_supported_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_trim_running_) -
    reinterpret_cast<char*>(&is_unmount_supported_)) + sizeof(is_trim_running_));
  // @@protoc_insertion_point(copy_constructor:CMsgStorageDevicesData)
}

inline void CMsgStorageDevicesData::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_unmount_supported_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_trim_running_) -
    reinterpret_cast<char*>(&is_unmount_supported_)) + sizeof(is_trim_running_));
}

CMsgStorageDevicesData::~CMsgStorageDevicesData() {
  // @@protoc_insertion_point(destructor:CMsgStorageDevicesData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgStorageDevicesData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgStorageDevicesData::ArenaDtor(void* object) {
  CMsgStorageDevicesData* _this = reinterpret_cast< CMsgStorageDevicesData* >(object);
  (void)_this;
}
void CMsgStorageDevicesData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgStorageDevicesData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgStorageDevicesData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgStorageDevicesData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  drives_.Clear();
  block_devices_.Clear();
  ::memset(&is_unmount_supported_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&is_trim_running_) -
      reinterpret_cast<char*>(&is_unmount_supported_)) + sizeof(is_trim_running_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgStorageDevicesData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgStorageDevicesData.Drive drives = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_drives(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgStorageDevicesData.BlockDevice block_devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_block_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_unmount_supported = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_unmount_supported(&has_bits);
          is_unmount_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_trim_supported = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_trim_supported(&has_bits);
          is_trim_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_trim_running = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_trim_running(&has_bits);
          is_trim_running_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgStorageDevicesData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgStorageDevicesData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgStorageDevicesData.Drive drives = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_drives_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_drives(i), target, stream);
  }

  // repeated .CMsgStorageDevicesData.BlockDevice block_devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_block_devices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_block_devices(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_unmount_supported = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_unmount_supported(), target);
  }

  // optional bool is_trim_supported = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_trim_supported(), target);
  }

  // optional bool is_trim_running = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_trim_running(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgStorageDevicesData)
  return target;
}

size_t CMsgStorageDevicesData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgStorageDevicesData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgStorageDevicesData.Drive drives = 1;
  total_size += 1UL * this->_internal_drives_size();
  for (const auto& msg : this->drives_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgStorageDevicesData.BlockDevice block_devices = 2;
  total_size += 1UL * this->_internal_block_devices_size();
  for (const auto& msg : this->block_devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool is_unmount_supported = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool is_trim_supported = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool is_trim_running = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgStorageDevicesData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgStorageDevicesData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgStorageDevicesData::GetClassData() const { return &_class_data_; }

void CMsgStorageDevicesData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgStorageDevicesData *>(to)->MergeFrom(
      static_cast<const CMsgStorageDevicesData &>(from));
}


void CMsgStorageDevicesData::MergeFrom(const CMsgStorageDevicesData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgStorageDevicesData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  drives_.MergeFrom(from.drives_);
  block_devices_.MergeFrom(from.block_devices_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      is_unmount_supported_ = from.is_unmount_supported_;
    }
    if (cached_has_bits & 0x00000002u) {
      is_trim_supported_ = from.is_trim_supported_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_trim_running_ = from.is_trim_running_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgStorageDevicesData::CopyFrom(const CMsgStorageDevicesData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgStorageDevicesData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgStorageDevicesData::IsInitialized() const {
  return true;
}

void CMsgStorageDevicesData::InternalSwap(CMsgStorageDevicesData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  drives_.InternalSwap(&other->drives_);
  block_devices_.InternalSwap(&other->block_devices_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData, is_trim_running_)
      + sizeof(CMsgStorageDevicesData::is_trim_running_)
      - PROTOBUF_FIELD_OFFSET(CMsgStorageDevicesData, is_unmount_supported_)>(
          reinterpret_cast<char*>(&is_unmount_supported_),
          reinterpret_cast<char*>(&other->is_unmount_supported_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgStorageDevicesData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[16]);
}

// ===================================================================

class CCloud_PendingRemoteOperation::_Internal {
 public:
  using HasBits = decltype(std::declval<CCloud_PendingRemoteOperation>()._has_bits_);
  static void set_has_operation(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_machine_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_time_last_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CCloud_PendingRemoteOperation::CCloud_PendingRemoteOperation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloud_PendingRemoteOperation)
}
CCloud_PendingRemoteOperation::CCloud_PendingRemoteOperation(const CCloud_PendingRemoteOperation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  machine_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    machine_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_name()) {
    machine_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_machine_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&operation_, &from.operation_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_id_) -
    reinterpret_cast<char*>(&operation_)) + sizeof(client_id_));
  // @@protoc_insertion_point(copy_constructor:CCloud_PendingRemoteOperation)
}

inline void CCloud_PendingRemoteOperation::SharedCtor() {
machine_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  machine_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&operation_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_id_) -
    reinterpret_cast<char*>(&operation_)) + sizeof(client_id_));
}

CCloud_PendingRemoteOperation::~CCloud_PendingRemoteOperation() {
  // @@protoc_insertion_point(destructor:CCloud_PendingRemoteOperation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloud_PendingRemoteOperation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  machine_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CCloud_PendingRemoteOperation::ArenaDtor(void* object) {
  CCloud_PendingRemoteOperation* _this = reinterpret_cast< CCloud_PendingRemoteOperation* >(object);
  (void)_this;
}
void CCloud_PendingRemoteOperation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloud_PendingRemoteOperation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloud_PendingRemoteOperation::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloud_PendingRemoteOperation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    machine_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&operation_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_id_) -
        reinterpret_cast<char*>(&operation_)) + sizeof(client_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloud_PendingRemoteOperation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ECloudPendingRemoteOperation operation = 1 [default = k_ECloudPendingRemoteOperationNone];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ECloudPendingRemoteOperation_IsValid(val))) {
            _internal_set_operation(static_cast<::ECloudPendingRemoteOperation>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string machine_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_machine_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CCloud_PendingRemoteOperation.machine_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 client_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_last_updated = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_time_last_updated(&has_bits);
          time_last_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloud_PendingRemoteOperation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloud_PendingRemoteOperation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ECloudPendingRemoteOperation operation = 1 [default = k_ECloudPendingRemoteOperationNone];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_operation(), target);
  }

  // optional string machine_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_machine_name().data(), static_cast<int>(this->_internal_machine_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCloud_PendingRemoteOperation.machine_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_machine_name(), target);
  }

  // optional uint64 client_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_client_id(), target);
  }

  // optional uint32 time_last_updated = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_time_last_updated(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloud_PendingRemoteOperation)
  return target;
}

size_t CCloud_PendingRemoteOperation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloud_PendingRemoteOperation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string machine_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_machine_name());
    }

    // optional .ECloudPendingRemoteOperation operation = 1 [default = k_ECloudPendingRemoteOperationNone];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_operation());
    }

    // optional uint32 time_last_updated = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time_last_updated());
    }

    // optional uint64 client_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloud_PendingRemoteOperation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloud_PendingRemoteOperation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloud_PendingRemoteOperation::GetClassData() const { return &_class_data_; }

void CCloud_PendingRemoteOperation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloud_PendingRemoteOperation *>(to)->MergeFrom(
      static_cast<const CCloud_PendingRemoteOperation &>(from));
}


void CCloud_PendingRemoteOperation::MergeFrom(const CCloud_PendingRemoteOperation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloud_PendingRemoteOperation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_machine_name(from._internal_machine_name());
    }
    if (cached_has_bits & 0x00000002u) {
      operation_ = from.operation_;
    }
    if (cached_has_bits & 0x00000004u) {
      time_last_updated_ = from.time_last_updated_;
    }
    if (cached_has_bits & 0x00000008u) {
      client_id_ = from.client_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloud_PendingRemoteOperation::CopyFrom(const CCloud_PendingRemoteOperation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloud_PendingRemoteOperation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloud_PendingRemoteOperation::IsInitialized() const {
  return true;
}

void CCloud_PendingRemoteOperation::InternalSwap(CCloud_PendingRemoteOperation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &machine_name_, lhs_arena,
      &other->machine_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCloud_PendingRemoteOperation, client_id_)
      + sizeof(CCloud_PendingRemoteOperation::client_id_)
      - PROTOBUF_FIELD_OFFSET(CCloud_PendingRemoteOperation, operation_)>(
          reinterpret_cast<char*>(&operation_),
          reinterpret_cast<char*>(&other->operation_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloud_PendingRemoteOperation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[17]);
}

// ===================================================================

class CMsgCloudPendingRemoteOperations::_Internal {
 public:
};

CMsgCloudPendingRemoteOperations::CMsgCloudPendingRemoteOperations(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  operations_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgCloudPendingRemoteOperations)
}
CMsgCloudPendingRemoteOperations::CMsgCloudPendingRemoteOperations(const CMsgCloudPendingRemoteOperations& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      operations_(from.operations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgCloudPendingRemoteOperations)
}

inline void CMsgCloudPendingRemoteOperations::SharedCtor() {
}

CMsgCloudPendingRemoteOperations::~CMsgCloudPendingRemoteOperations() {
  // @@protoc_insertion_point(destructor:CMsgCloudPendingRemoteOperations)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgCloudPendingRemoteOperations::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgCloudPendingRemoteOperations::ArenaDtor(void* object) {
  CMsgCloudPendingRemoteOperations* _this = reinterpret_cast< CMsgCloudPendingRemoteOperations* >(object);
  (void)_this;
}
void CMsgCloudPendingRemoteOperations::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgCloudPendingRemoteOperations::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgCloudPendingRemoteOperations::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCloudPendingRemoteOperations)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  operations_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCloudPendingRemoteOperations::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CCloud_PendingRemoteOperation operations = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_operations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCloudPendingRemoteOperations::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCloudPendingRemoteOperations)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CCloud_PendingRemoteOperation operations = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_operations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_operations(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCloudPendingRemoteOperations)
  return target;
}

size_t CMsgCloudPendingRemoteOperations::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCloudPendingRemoteOperations)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CCloud_PendingRemoteOperation operations = 1;
  total_size += 1UL * this->_internal_operations_size();
  for (const auto& msg : this->operations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCloudPendingRemoteOperations::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgCloudPendingRemoteOperations::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCloudPendingRemoteOperations::GetClassData() const { return &_class_data_; }

void CMsgCloudPendingRemoteOperations::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgCloudPendingRemoteOperations *>(to)->MergeFrom(
      static_cast<const CMsgCloudPendingRemoteOperations &>(from));
}


void CMsgCloudPendingRemoteOperations::MergeFrom(const CMsgCloudPendingRemoteOperations& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgCloudPendingRemoteOperations)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  operations_.MergeFrom(from.operations_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCloudPendingRemoteOperations::CopyFrom(const CMsgCloudPendingRemoteOperations& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCloudPendingRemoteOperations)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCloudPendingRemoteOperations::IsInitialized() const {
  return true;
}

void CMsgCloudPendingRemoteOperations::InternalSwap(CMsgCloudPendingRemoteOperations* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  operations_.InternalSwap(&other->operations_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCloudPendingRemoteOperations::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[18]);
}

// ===================================================================

class CMsgBluetoothDevicesData_Adapter::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgBluetoothDevicesData_Adapter>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_discovering(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CMsgBluetoothDevicesData_Adapter::CMsgBluetoothDevicesData_Adapter(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgBluetoothDevicesData.Adapter)
}
CMsgBluetoothDevicesData_Adapter::CMsgBluetoothDevicesData_Adapter(const CMsgBluetoothDevicesData_Adapter& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac()) {
    mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac(), 
      GetArenaForAllocation());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_discovering_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_discovering_));
  // @@protoc_insertion_point(copy_constructor:CMsgBluetoothDevicesData.Adapter)
}

inline void CMsgBluetoothDevicesData_Adapter::SharedCtor() {
mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_discovering_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_discovering_));
}

CMsgBluetoothDevicesData_Adapter::~CMsgBluetoothDevicesData_Adapter() {
  // @@protoc_insertion_point(destructor:CMsgBluetoothDevicesData.Adapter)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgBluetoothDevicesData_Adapter::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mac_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgBluetoothDevicesData_Adapter::ArenaDtor(void* object) {
  CMsgBluetoothDevicesData_Adapter* _this = reinterpret_cast< CMsgBluetoothDevicesData_Adapter* >(object);
  (void)_this;
}
void CMsgBluetoothDevicesData_Adapter::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgBluetoothDevicesData_Adapter::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgBluetoothDevicesData_Adapter::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgBluetoothDevicesData.Adapter)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_discovering_) -
        reinterpret_cast<char*>(&id_)) + sizeof(is_discovering_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgBluetoothDevicesData_Adapter::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string mac = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_mac();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgBluetoothDevicesData.Adapter.mac");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgBluetoothDevicesData.Adapter.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_enabled(&has_bits);
          is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_discovering = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_discovering(&has_bits);
          is_discovering_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgBluetoothDevicesData_Adapter::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgBluetoothDevicesData.Adapter)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string mac = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgBluetoothDevicesData.Adapter.mac");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_mac(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgBluetoothDevicesData.Adapter.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional bool is_enabled = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_enabled(), target);
  }

  // optional bool is_discovering = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_discovering(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgBluetoothDevicesData.Adapter)
  return target;
}

size_t CMsgBluetoothDevicesData_Adapter::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgBluetoothDevicesData.Adapter)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string mac = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac());
    }

    // optional string name = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional bool is_enabled = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_discovering = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgBluetoothDevicesData_Adapter::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgBluetoothDevicesData_Adapter::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgBluetoothDevicesData_Adapter::GetClassData() const { return &_class_data_; }

void CMsgBluetoothDevicesData_Adapter::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgBluetoothDevicesData_Adapter *>(to)->MergeFrom(
      static_cast<const CMsgBluetoothDevicesData_Adapter &>(from));
}


void CMsgBluetoothDevicesData_Adapter::MergeFrom(const CMsgBluetoothDevicesData_Adapter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgBluetoothDevicesData.Adapter)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_mac(from._internal_mac());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_enabled_ = from.is_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_discovering_ = from.is_discovering_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgBluetoothDevicesData_Adapter::CopyFrom(const CMsgBluetoothDevicesData_Adapter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgBluetoothDevicesData.Adapter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgBluetoothDevicesData_Adapter::IsInitialized() const {
  return true;
}

void CMsgBluetoothDevicesData_Adapter::InternalSwap(CMsgBluetoothDevicesData_Adapter* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_, lhs_arena,
      &other->mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgBluetoothDevicesData_Adapter, is_discovering_)
      + sizeof(CMsgBluetoothDevicesData_Adapter::is_discovering_)
      - PROTOBUF_FIELD_OFFSET(CMsgBluetoothDevicesData_Adapter, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgBluetoothDevicesData_Adapter::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[19]);
}

// ===================================================================

class CMsgBluetoothDevicesData_Device::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgBluetoothDevicesData_Device>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_adapter_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_etype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_mac(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_connected(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_paired(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_strength_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgBluetoothDevicesData_Device::CMsgBluetoothDevicesData_Device(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgBluetoothDevicesData.Device)
}
CMsgBluetoothDevicesData_Device::CMsgBluetoothDevicesData_Device(const CMsgBluetoothDevicesData_Device& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mac()) {
    mac_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_mac(), 
      GetArenaForAllocation());
  }
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&strength_raw_) -
    reinterpret_cast<char*>(&id_)) + sizeof(strength_raw_));
  // @@protoc_insertion_point(copy_constructor:CMsgBluetoothDevicesData.Device)
}

inline void CMsgBluetoothDevicesData_Device::SharedCtor() {
mac_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  mac_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&strength_raw_) -
    reinterpret_cast<char*>(&id_)) + sizeof(strength_raw_));
}

CMsgBluetoothDevicesData_Device::~CMsgBluetoothDevicesData_Device() {
  // @@protoc_insertion_point(destructor:CMsgBluetoothDevicesData.Device)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgBluetoothDevicesData_Device::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  mac_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgBluetoothDevicesData_Device::ArenaDtor(void* object) {
  CMsgBluetoothDevicesData_Device* _this = reinterpret_cast< CMsgBluetoothDevicesData_Device* >(object);
  (void)_this;
}
void CMsgBluetoothDevicesData_Device::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgBluetoothDevicesData_Device::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgBluetoothDevicesData_Device::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgBluetoothDevicesData.Device)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mac_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&strength_raw_) -
        reinterpret_cast<char*>(&id_)) + sizeof(strength_raw_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgBluetoothDevicesData_Device::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1 [default = 0];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 adapter_id = 2 [default = 0];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_adapter_id(&has_bits);
          adapter_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EBluetoothDeviceType etype = 3 [default = k_BluetoothDeviceType_Invalid];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EBluetoothDeviceType_IsValid(val))) {
            _internal_set_etype(static_cast<::EBluetoothDeviceType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string mac = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_mac();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgBluetoothDevicesData.Device.mac");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgBluetoothDevicesData.Device.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_connected = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_connected(&has_bits);
          is_connected_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_paired = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_paired(&has_bits);
          is_paired_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 strength_raw = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_strength_raw(&has_bits);
          strength_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgBluetoothDevicesData_Device::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgBluetoothDevicesData.Device)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional uint32 adapter_id = 2 [default = 0];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_adapter_id(), target);
  }

  // optional .EBluetoothDeviceType etype = 3 [default = k_BluetoothDeviceType_Invalid];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_etype(), target);
  }

  // optional string mac = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mac().data(), static_cast<int>(this->_internal_mac().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgBluetoothDevicesData.Device.mac");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_mac(), target);
  }

  // optional string name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgBluetoothDevicesData.Device.name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_name(), target);
  }

  // optional bool is_connected = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_connected(), target);
  }

  // optional bool is_paired = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_paired(), target);
  }

  // optional int32 strength_raw = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_strength_raw(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgBluetoothDevicesData.Device)
  return target;
}

size_t CMsgBluetoothDevicesData_Device::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgBluetoothDevicesData.Device)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string mac = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mac());
    }

    // optional string name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional uint32 id = 1 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional uint32 adapter_id = 2 [default = 0];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_adapter_id());
    }

    // optional .EBluetoothDeviceType etype = 3 [default = k_BluetoothDeviceType_Invalid];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_etype());
    }

    // optional bool is_connected = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_paired = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 strength_raw = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_strength_raw());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgBluetoothDevicesData_Device::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgBluetoothDevicesData_Device::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgBluetoothDevicesData_Device::GetClassData() const { return &_class_data_; }

void CMsgBluetoothDevicesData_Device::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgBluetoothDevicesData_Device *>(to)->MergeFrom(
      static_cast<const CMsgBluetoothDevicesData_Device &>(from));
}


void CMsgBluetoothDevicesData_Device::MergeFrom(const CMsgBluetoothDevicesData_Device& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgBluetoothDevicesData.Device)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_mac(from._internal_mac());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      adapter_id_ = from.adapter_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      etype_ = from.etype_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_connected_ = from.is_connected_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_paired_ = from.is_paired_;
    }
    if (cached_has_bits & 0x00000080u) {
      strength_raw_ = from.strength_raw_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgBluetoothDevicesData_Device::CopyFrom(const CMsgBluetoothDevicesData_Device& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgBluetoothDevicesData.Device)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgBluetoothDevicesData_Device::IsInitialized() const {
  return true;
}

void CMsgBluetoothDevicesData_Device::InternalSwap(CMsgBluetoothDevicesData_Device* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &mac_, lhs_arena,
      &other->mac_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgBluetoothDevicesData_Device, strength_raw_)
      + sizeof(CMsgBluetoothDevicesData_Device::strength_raw_)
      - PROTOBUF_FIELD_OFFSET(CMsgBluetoothDevicesData_Device, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgBluetoothDevicesData_Device::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[20]);
}

// ===================================================================

class CMsgBluetoothDevicesData_Manager::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgBluetoothDevicesData_Manager>()._has_bits_);
  static void set_has_is_bluetooth_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgBluetoothDevicesData_Manager::CMsgBluetoothDevicesData_Manager(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgBluetoothDevicesData.Manager)
}
CMsgBluetoothDevicesData_Manager::CMsgBluetoothDevicesData_Manager(const CMsgBluetoothDevicesData_Manager& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  is_bluetooth_enabled_ = from.is_bluetooth_enabled_;
  // @@protoc_insertion_point(copy_constructor:CMsgBluetoothDevicesData.Manager)
}

inline void CMsgBluetoothDevicesData_Manager::SharedCtor() {
is_bluetooth_enabled_ = false;
}

CMsgBluetoothDevicesData_Manager::~CMsgBluetoothDevicesData_Manager() {
  // @@protoc_insertion_point(destructor:CMsgBluetoothDevicesData.Manager)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgBluetoothDevicesData_Manager::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgBluetoothDevicesData_Manager::ArenaDtor(void* object) {
  CMsgBluetoothDevicesData_Manager* _this = reinterpret_cast< CMsgBluetoothDevicesData_Manager* >(object);
  (void)_this;
}
void CMsgBluetoothDevicesData_Manager::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgBluetoothDevicesData_Manager::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgBluetoothDevicesData_Manager::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgBluetoothDevicesData.Manager)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  is_bluetooth_enabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgBluetoothDevicesData_Manager::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_bluetooth_enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_bluetooth_enabled(&has_bits);
          is_bluetooth_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgBluetoothDevicesData_Manager::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgBluetoothDevicesData.Manager)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_bluetooth_enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_bluetooth_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgBluetoothDevicesData.Manager)
  return target;
}

size_t CMsgBluetoothDevicesData_Manager::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgBluetoothDevicesData.Manager)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool is_bluetooth_enabled = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgBluetoothDevicesData_Manager::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgBluetoothDevicesData_Manager::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgBluetoothDevicesData_Manager::GetClassData() const { return &_class_data_; }

void CMsgBluetoothDevicesData_Manager::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgBluetoothDevicesData_Manager *>(to)->MergeFrom(
      static_cast<const CMsgBluetoothDevicesData_Manager &>(from));
}


void CMsgBluetoothDevicesData_Manager::MergeFrom(const CMsgBluetoothDevicesData_Manager& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgBluetoothDevicesData.Manager)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_is_bluetooth_enabled()) {
    _internal_set_is_bluetooth_enabled(from._internal_is_bluetooth_enabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgBluetoothDevicesData_Manager::CopyFrom(const CMsgBluetoothDevicesData_Manager& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgBluetoothDevicesData.Manager)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgBluetoothDevicesData_Manager::IsInitialized() const {
  return true;
}

void CMsgBluetoothDevicesData_Manager::InternalSwap(CMsgBluetoothDevicesData_Manager* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(is_bluetooth_enabled_, other->is_bluetooth_enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgBluetoothDevicesData_Manager::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[21]);
}

// ===================================================================

class CMsgBluetoothDevicesData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgBluetoothDevicesData>()._has_bits_);
  static const ::CMsgBluetoothDevicesData_Manager& manager(const CMsgBluetoothDevicesData* msg);
  static void set_has_manager(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgBluetoothDevicesData_Manager&
CMsgBluetoothDevicesData::_Internal::manager(const CMsgBluetoothDevicesData* msg) {
  return *msg->manager_;
}
CMsgBluetoothDevicesData::CMsgBluetoothDevicesData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  adapters_(arena),
  devices_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgBluetoothDevicesData)
}
CMsgBluetoothDevicesData::CMsgBluetoothDevicesData(const CMsgBluetoothDevicesData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      adapters_(from.adapters_),
      devices_(from.devices_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_manager()) {
    manager_ = new ::CMsgBluetoothDevicesData_Manager(*from.manager_);
  } else {
    manager_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgBluetoothDevicesData)
}

inline void CMsgBluetoothDevicesData::SharedCtor() {
manager_ = nullptr;
}

CMsgBluetoothDevicesData::~CMsgBluetoothDevicesData() {
  // @@protoc_insertion_point(destructor:CMsgBluetoothDevicesData)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgBluetoothDevicesData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete manager_;
}

void CMsgBluetoothDevicesData::ArenaDtor(void* object) {
  CMsgBluetoothDevicesData* _this = reinterpret_cast< CMsgBluetoothDevicesData* >(object);
  (void)_this;
}
void CMsgBluetoothDevicesData::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgBluetoothDevicesData::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgBluetoothDevicesData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgBluetoothDevicesData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  adapters_.Clear();
  devices_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(manager_ != nullptr);
    manager_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgBluetoothDevicesData::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgBluetoothDevicesData.Adapter adapters = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_adapters(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgBluetoothDevicesData.Device devices = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgBluetoothDevicesData.Manager manager = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_manager(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgBluetoothDevicesData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgBluetoothDevicesData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgBluetoothDevicesData.Adapter adapters = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_adapters_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_adapters(i), target, stream);
  }

  // repeated .CMsgBluetoothDevicesData.Device devices = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_devices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_devices(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional .CMsgBluetoothDevicesData.Manager manager = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::manager(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgBluetoothDevicesData)
  return target;
}

size_t CMsgBluetoothDevicesData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgBluetoothDevicesData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgBluetoothDevicesData.Adapter adapters = 1;
  total_size += 1UL * this->_internal_adapters_size();
  for (const auto& msg : this->adapters_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgBluetoothDevicesData.Device devices = 2;
  total_size += 1UL * this->_internal_devices_size();
  for (const auto& msg : this->devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional .CMsgBluetoothDevicesData.Manager manager = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *manager_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgBluetoothDevicesData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgBluetoothDevicesData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgBluetoothDevicesData::GetClassData() const { return &_class_data_; }

void CMsgBluetoothDevicesData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgBluetoothDevicesData *>(to)->MergeFrom(
      static_cast<const CMsgBluetoothDevicesData &>(from));
}


void CMsgBluetoothDevicesData::MergeFrom(const CMsgBluetoothDevicesData& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgBluetoothDevicesData)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  adapters_.MergeFrom(from.adapters_);
  devices_.MergeFrom(from.devices_);
  if (from._internal_has_manager()) {
    _internal_mutable_manager()->::CMsgBluetoothDevicesData_Manager::MergeFrom(from._internal_manager());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgBluetoothDevicesData::CopyFrom(const CMsgBluetoothDevicesData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgBluetoothDevicesData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgBluetoothDevicesData::IsInitialized() const {
  return true;
}

void CMsgBluetoothDevicesData::InternalSwap(CMsgBluetoothDevicesData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  adapters_.InternalSwap(&other->adapters_);
  devices_.InternalSwap(&other->devices_);
  swap(manager_, other->manager_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgBluetoothDevicesData::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[22]);
}

// ===================================================================

class CMsgSystemPerfDiagnosticEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfDiagnosticEntry>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemPerfDiagnosticEntry::CMsgSystemPerfDiagnosticEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfDiagnosticEntry)
}
CMsgSystemPerfDiagnosticEntry::CMsgSystemPerfDiagnosticEntry(const CMsgSystemPerfDiagnosticEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfDiagnosticEntry)
}

inline void CMsgSystemPerfDiagnosticEntry::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgSystemPerfDiagnosticEntry::~CMsgSystemPerfDiagnosticEntry() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfDiagnosticEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfDiagnosticEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSystemPerfDiagnosticEntry::ArenaDtor(void* object) {
  CMsgSystemPerfDiagnosticEntry* _this = reinterpret_cast< CMsgSystemPerfDiagnosticEntry* >(object);
  (void)_this;
}
void CMsgSystemPerfDiagnosticEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfDiagnosticEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfDiagnosticEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfDiagnosticEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfDiagnosticEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemPerfDiagnosticEntry.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemPerfDiagnosticEntry.value");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfDiagnosticEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfDiagnosticEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemPerfDiagnosticEntry.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional string value = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemPerfDiagnosticEntry.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfDiagnosticEntry)
  return target;
}

size_t CMsgSystemPerfDiagnosticEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfDiagnosticEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfDiagnosticEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfDiagnosticEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfDiagnosticEntry::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfDiagnosticEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfDiagnosticEntry *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfDiagnosticEntry &>(from));
}


void CMsgSystemPerfDiagnosticEntry::MergeFrom(const CMsgSystemPerfDiagnosticEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfDiagnosticEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfDiagnosticEntry::CopyFrom(const CMsgSystemPerfDiagnosticEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfDiagnosticEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfDiagnosticEntry::IsInitialized() const {
  return true;
}

void CMsgSystemPerfDiagnosticEntry::InternalSwap(CMsgSystemPerfDiagnosticEntry* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfDiagnosticEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[23]);
}

// ===================================================================

class CMsgSystemPerfNetworkInterface::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfNetworkInterface>()._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tx_bytes_total(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rx_bytes_total(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tx_bytes_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_rx_bytes_per_sec(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CMsgSystemPerfNetworkInterface::CMsgSystemPerfNetworkInterface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfNetworkInterface)
}
CMsgSystemPerfNetworkInterface::CMsgSystemPerfNetworkInterface(const CMsgSystemPerfNetworkInterface& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&rx_bytes_per_sec_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(rx_bytes_per_sec_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfNetworkInterface)
}

inline void CMsgSystemPerfNetworkInterface::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&timestamp_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rx_bytes_per_sec_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(rx_bytes_per_sec_));
}

CMsgSystemPerfNetworkInterface::~CMsgSystemPerfNetworkInterface() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfNetworkInterface)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfNetworkInterface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSystemPerfNetworkInterface::ArenaDtor(void* object) {
  CMsgSystemPerfNetworkInterface* _this = reinterpret_cast< CMsgSystemPerfNetworkInterface* >(object);
  (void)_this;
}
void CMsgSystemPerfNetworkInterface::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfNetworkInterface::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfNetworkInterface::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfNetworkInterface)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rx_bytes_per_sec_) -
        reinterpret_cast<char*>(&timestamp_)) + sizeof(rx_bytes_per_sec_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfNetworkInterface::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemPerfNetworkInterface.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional double timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      // optional int64 tx_bytes_total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tx_bytes_total(&has_bits);
          tx_bytes_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 rx_bytes_total = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_rx_bytes_total(&has_bits);
          rx_bytes_total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tx_bytes_per_sec = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tx_bytes_per_sec(&has_bits);
          tx_bytes_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 rx_bytes_per_sec = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_rx_bytes_per_sec(&has_bits);
          rx_bytes_per_sec_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfNetworkInterface::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfNetworkInterface)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemPerfNetworkInterface.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional double timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteDoubleToArray(2, this->_internal_timestamp(), target);
  }

  // optional int64 tx_bytes_total = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(3, this->_internal_tx_bytes_total(), target);
  }

  // optional int64 rx_bytes_total = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(4, this->_internal_rx_bytes_total(), target);
  }

  // optional int32 tx_bytes_per_sec = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_tx_bytes_per_sec(), target);
  }

  // optional int32 rx_bytes_per_sec = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_rx_bytes_per_sec(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfNetworkInterface)
  return target;
}

size_t CMsgSystemPerfNetworkInterface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfNetworkInterface)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional double timestamp = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional int64 tx_bytes_total = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_tx_bytes_total());
    }

    // optional int64 rx_bytes_total = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_rx_bytes_total());
    }

    // optional int32 tx_bytes_per_sec = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tx_bytes_per_sec());
    }

    // optional int32 rx_bytes_per_sec = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_rx_bytes_per_sec());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfNetworkInterface::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfNetworkInterface::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfNetworkInterface::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfNetworkInterface::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfNetworkInterface *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfNetworkInterface &>(from));
}


void CMsgSystemPerfNetworkInterface::MergeFrom(const CMsgSystemPerfNetworkInterface& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfNetworkInterface)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000004u) {
      tx_bytes_total_ = from.tx_bytes_total_;
    }
    if (cached_has_bits & 0x00000008u) {
      rx_bytes_total_ = from.rx_bytes_total_;
    }
    if (cached_has_bits & 0x00000010u) {
      tx_bytes_per_sec_ = from.tx_bytes_per_sec_;
    }
    if (cached_has_bits & 0x00000020u) {
      rx_bytes_per_sec_ = from.rx_bytes_per_sec_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfNetworkInterface::CopyFrom(const CMsgSystemPerfNetworkInterface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfNetworkInterface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfNetworkInterface::IsInitialized() const {
  return true;
}

void CMsgSystemPerfNetworkInterface::InternalSwap(CMsgSystemPerfNetworkInterface* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfNetworkInterface, rx_bytes_per_sec_)
      + sizeof(CMsgSystemPerfNetworkInterface::rx_bytes_per_sec_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfNetworkInterface, timestamp_)>(
          reinterpret_cast<char*>(&timestamp_),
          reinterpret_cast<char*>(&other->timestamp_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfNetworkInterface::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[24]);
}

// ===================================================================

class CMsgSystemPerfDiagnosticInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfDiagnosticInfo>()._has_bits_);
  static void set_has_battery_temp_c(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSystemPerfDiagnosticInfo::CMsgSystemPerfDiagnosticInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena),
  interfaces_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfDiagnosticInfo)
}
CMsgSystemPerfDiagnosticInfo::CMsgSystemPerfDiagnosticInfo(const CMsgSystemPerfDiagnosticInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      entries_(from.entries_),
      interfaces_(from.interfaces_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  battery_temp_c_ = from.battery_temp_c_;
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfDiagnosticInfo)
}

inline void CMsgSystemPerfDiagnosticInfo::SharedCtor() {
battery_temp_c_ = 0;
}

CMsgSystemPerfDiagnosticInfo::~CMsgSystemPerfDiagnosticInfo() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfDiagnosticInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfDiagnosticInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemPerfDiagnosticInfo::ArenaDtor(void* object) {
  CMsgSystemPerfDiagnosticInfo* _this = reinterpret_cast< CMsgSystemPerfDiagnosticInfo* >(object);
  (void)_this;
}
void CMsgSystemPerfDiagnosticInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfDiagnosticInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfDiagnosticInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfDiagnosticInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  interfaces_.Clear();
  battery_temp_c_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfDiagnosticInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSystemPerfDiagnosticEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemPerfNetworkInterface interfaces = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_interfaces(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float battery_temp_c = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_battery_temp_c(&has_bits);
          battery_temp_c_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfDiagnosticInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfDiagnosticInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSystemPerfDiagnosticEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  // repeated .CMsgSystemPerfNetworkInterface interfaces = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_interfaces_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_interfaces(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional float battery_temp_c = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_battery_temp_c(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfDiagnosticInfo)
  return target;
}

size_t CMsgSystemPerfDiagnosticInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfDiagnosticInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemPerfDiagnosticEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSystemPerfNetworkInterface interfaces = 2;
  total_size += 1UL * this->_internal_interfaces_size();
  for (const auto& msg : this->interfaces_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional float battery_temp_c = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfDiagnosticInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfDiagnosticInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfDiagnosticInfo::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfDiagnosticInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfDiagnosticInfo *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfDiagnosticInfo &>(from));
}


void CMsgSystemPerfDiagnosticInfo::MergeFrom(const CMsgSystemPerfDiagnosticInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfDiagnosticInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  interfaces_.MergeFrom(from.interfaces_);
  if (from._internal_has_battery_temp_c()) {
    _internal_set_battery_temp_c(from._internal_battery_temp_c());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfDiagnosticInfo::CopyFrom(const CMsgSystemPerfDiagnosticInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfDiagnosticInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfDiagnosticInfo::IsInitialized() const {
  return true;
}

void CMsgSystemPerfDiagnosticInfo::InternalSwap(CMsgSystemPerfDiagnosticInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
  interfaces_.InternalSwap(&other->interfaces_);
  swap(battery_temp_c_, other->battery_temp_c_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfDiagnosticInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[25]);
}

// ===================================================================

class CMsgSystemPerfLimits::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfLimits>()._has_bits_);
  static void set_has_cpu_governor_manual_min_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_governor_manual_max_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fsr_sharpness_min(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_fsr_sharpness_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gpu_performance_manual_min_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gpu_performance_manual_max_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_perf_overlay_is_standalone(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_dynamic_vrs_available(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_manual_display_refresh_rate_available(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_display_refresh_manual_hz_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_display_refresh_manual_hz_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_tdp_limit_min(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_tdp_limit_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_nis_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_nis_sharpness_min(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_nis_sharpness_max(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_display_external_refresh_manual_hz_min(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_display_external_refresh_manual_hz_max(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_tearing_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_is_vrr_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_is_dynamic_refresh_rate_in_steam_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_is_split_scaling_and_filtering_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_is_hdr_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_display_refresh_manual_hz_oc_max(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
};

CMsgSystemPerfLimits::CMsgSystemPerfLimits(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  gpu_performance_levels_available_(arena),
  fps_limit_options_(arena),
  fps_limit_options_external_(arena),
  split_scaling_filters_available_(arena),
  split_scaling_scalers_available_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfLimits)
}
CMsgSystemPerfLimits::CMsgSystemPerfLimits(const CMsgSystemPerfLimits& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      gpu_performance_levels_available_(from.gpu_performance_levels_available_),
      fps_limit_options_(from.fps_limit_options_),
      fps_limit_options_external_(from.fps_limit_options_external_),
      split_scaling_filters_available_(from.split_scaling_filters_available_),
      split_scaling_scalers_available_(from.split_scaling_scalers_available_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&cpu_governor_manual_min_mhz_, &from.cpu_governor_manual_min_mhz_,
    static_cast<size_t>(reinterpret_cast<char*>(&display_refresh_manual_hz_oc_max_) -
    reinterpret_cast<char*>(&cpu_governor_manual_min_mhz_)) + sizeof(display_refresh_manual_hz_oc_max_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfLimits)
}

inline void CMsgSystemPerfLimits::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cpu_governor_manual_min_mhz_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&display_refresh_manual_hz_oc_max_) -
    reinterpret_cast<char*>(&cpu_governor_manual_min_mhz_)) + sizeof(display_refresh_manual_hz_oc_max_));
}

CMsgSystemPerfLimits::~CMsgSystemPerfLimits() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfLimits)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfLimits::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemPerfLimits::ArenaDtor(void* object) {
  CMsgSystemPerfLimits* _this = reinterpret_cast< CMsgSystemPerfLimits* >(object);
  (void)_this;
}
void CMsgSystemPerfLimits::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfLimits::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfLimits::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfLimits)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  gpu_performance_levels_available_.Clear();
  fps_limit_options_.Clear();
  fps_limit_options_external_.Clear();
  split_scaling_filters_available_.Clear();
  split_scaling_scalers_available_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&cpu_governor_manual_min_mhz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_dynamic_vrs_available_) -
        reinterpret_cast<char*>(&cpu_governor_manual_min_mhz_)) + sizeof(is_dynamic_vrs_available_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&is_manual_display_refresh_rate_available_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&nis_sharpness_max_) -
        reinterpret_cast<char*>(&is_manual_display_refresh_rate_available_)) + sizeof(nis_sharpness_max_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&display_external_refresh_manual_hz_min_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_refresh_manual_hz_oc_max_) -
        reinterpret_cast<char*>(&display_external_refresh_manual_hz_min_)) + sizeof(display_refresh_manual_hz_oc_max_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfLimits::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cpu_governor_manual_min_mhz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cpu_governor_manual_min_mhz(&has_bits);
          cpu_governor_manual_min_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_governor_manual_max_mhz = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cpu_governor_manual_max_mhz(&has_bits);
          cpu_governor_manual_max_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fsr_sharpness_min = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_fsr_sharpness_min(&has_bits);
          fsr_sharpness_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fsr_sharpness_max = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_fsr_sharpness_max(&has_bits);
          fsr_sharpness_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gpu_performance_manual_min_mhz = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_gpu_performance_manual_min_mhz(&has_bits);
          gpu_performance_manual_min_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 gpu_performance_manual_max_mhz = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_gpu_performance_manual_max_mhz(&has_bits);
          gpu_performance_manual_max_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool perf_overlay_is_standalone = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_perf_overlay_is_standalone(&has_bits);
          perf_overlay_is_standalone_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dynamic_vrs_available = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_dynamic_vrs_available(&has_bits);
          is_dynamic_vrs_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_manual_display_refresh_rate_available = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_manual_display_refresh_rate_available(&has_bits);
          is_manual_display_refresh_rate_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EGPUPerformanceLevel gpu_performance_levels_available = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EGPUPerformanceLevel_IsValid(val))) {
              _internal_add_gpu_performance_levels_available(static_cast<::EGPUPerformanceLevel>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<80>(ptr));
        } else if (static_cast<uint8_t>(tag) == 82) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_gpu_performance_levels_available(), ptr, ctx, ::EGPUPerformanceLevel_IsValid, &_internal_metadata_, 10);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_refresh_manual_hz_min = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_display_refresh_manual_hz_min(&has_bits);
          display_refresh_manual_hz_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_refresh_manual_hz_max = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_display_refresh_manual_hz_max(&has_bits);
          display_refresh_manual_hz_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 fps_limit_options = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fps_limit_options(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_fps_limit_options(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tdp_limit_min = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_tdp_limit_min(&has_bits);
          tdp_limit_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tdp_limit_max = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_tdp_limit_max(&has_bits);
          tdp_limit_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_nis_supported = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_nis_supported(&has_bits);
          is_nis_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nis_sharpness_min = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_nis_sharpness_min(&has_bits);
          nis_sharpness_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 nis_sharpness_max = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_nis_sharpness_max(&has_bits);
          nis_sharpness_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_external_refresh_manual_hz_min = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_display_external_refresh_manual_hz_min(&has_bits);
          display_external_refresh_manual_hz_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_external_refresh_manual_hz_max = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_display_external_refresh_manual_hz_max(&has_bits);
          display_external_refresh_manual_hz_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 fps_limit_options_external = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          ptr -= 2;
          do {
            ptr += 2;
            _internal_add_fps_limit_options_external(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<168>(ptr));
        } else if (static_cast<uint8_t>(tag) == 170) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_fps_limit_options_external(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_tearing_supported = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_is_tearing_supported(&has_bits);
          is_tearing_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vrr_supported = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_is_vrr_supported(&has_bits);
          is_vrr_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dynamic_refresh_rate_in_steam_supported = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          _Internal::set_has_is_dynamic_refresh_rate_in_steam_supported(&has_bits);
          is_dynamic_refresh_rate_in_steam_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_split_scaling_and_filtering_supported = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          _Internal::set_has_is_split_scaling_and_filtering_supported(&has_bits);
          is_split_scaling_and_filtering_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ESplitScalingFilter split_scaling_filters_available = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ESplitScalingFilter_IsValid(val))) {
              _internal_add_split_scaling_filters_available(static_cast<::ESplitScalingFilter>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(26, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<208>(ptr));
        } else if (static_cast<uint8_t>(tag) == 210) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_split_scaling_filters_available(), ptr, ctx, ::ESplitScalingFilter_IsValid, &_internal_metadata_, 26);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ESplitScalingScaler split_scaling_scalers_available = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          ptr -= 2;
          do {
            ptr += 2;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::ESplitScalingScaler_IsValid(val))) {
              _internal_add_split_scaling_scalers_available(static_cast<::ESplitScalingScaler>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(27, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<216>(ptr));
        } else if (static_cast<uint8_t>(tag) == 218) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_split_scaling_scalers_available(), ptr, ctx, ::ESplitScalingScaler_IsValid, &_internal_metadata_, 27);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hdr_supported = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_is_hdr_supported(&has_bits);
          is_hdr_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_refresh_manual_hz_oc_max = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_display_refresh_manual_hz_oc_max(&has_bits);
          display_refresh_manual_hz_oc_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfLimits::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfLimits)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 cpu_governor_manual_min_mhz = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_cpu_governor_manual_min_mhz(), target);
  }

  // optional int32 cpu_governor_manual_max_mhz = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_governor_manual_max_mhz(), target);
  }

  // optional int32 fsr_sharpness_min = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_fsr_sharpness_min(), target);
  }

  // optional int32 fsr_sharpness_max = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_fsr_sharpness_max(), target);
  }

  // optional int32 gpu_performance_manual_min_mhz = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_gpu_performance_manual_min_mhz(), target);
  }

  // optional int32 gpu_performance_manual_max_mhz = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_gpu_performance_manual_max_mhz(), target);
  }

  // optional bool perf_overlay_is_standalone = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_perf_overlay_is_standalone(), target);
  }

  // optional bool is_dynamic_vrs_available = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_dynamic_vrs_available(), target);
  }

  // optional bool is_manual_display_refresh_rate_available = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_manual_display_refresh_rate_available(), target);
  }

  // repeated .EGPUPerformanceLevel gpu_performance_levels_available = 10;
  for (int i = 0, n = this->_internal_gpu_performance_levels_available_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        10, this->_internal_gpu_performance_levels_available(i), target);
  }

  // optional int32 display_refresh_manual_hz_min = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_display_refresh_manual_hz_min(), target);
  }

  // optional int32 display_refresh_manual_hz_max = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_display_refresh_manual_hz_max(), target);
  }

  // repeated int32 fps_limit_options = 13;
  for (int i = 0, n = this->_internal_fps_limit_options_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_fps_limit_options(i), target);
  }

  // optional int32 tdp_limit_min = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_tdp_limit_min(), target);
  }

  // optional int32 tdp_limit_max = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_tdp_limit_max(), target);
  }

  // optional bool is_nis_supported = 16;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_is_nis_supported(), target);
  }

  // optional int32 nis_sharpness_min = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_nis_sharpness_min(), target);
  }

  // optional int32 nis_sharpness_max = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(18, this->_internal_nis_sharpness_max(), target);
  }

  // optional int32 display_external_refresh_manual_hz_min = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(19, this->_internal_display_external_refresh_manual_hz_min(), target);
  }

  // optional int32 display_external_refresh_manual_hz_max = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_display_external_refresh_manual_hz_max(), target);
  }

  // repeated int32 fps_limit_options_external = 21;
  for (int i = 0, n = this->_internal_fps_limit_options_external_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(21, this->_internal_fps_limit_options_external(i), target);
  }

  // optional bool is_tearing_supported = 22;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_is_tearing_supported(), target);
  }

  // optional bool is_vrr_supported = 23;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_is_vrr_supported(), target);
  }

  // optional bool is_dynamic_refresh_rate_in_steam_supported = 24;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(24, this->_internal_is_dynamic_refresh_rate_in_steam_supported(), target);
  }

  // optional bool is_split_scaling_and_filtering_supported = 25;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(25, this->_internal_is_split_scaling_and_filtering_supported(), target);
  }

  // repeated .ESplitScalingFilter split_scaling_filters_available = 26;
  for (int i = 0, n = this->_internal_split_scaling_filters_available_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        26, this->_internal_split_scaling_filters_available(i), target);
  }

  // repeated .ESplitScalingScaler split_scaling_scalers_available = 27;
  for (int i = 0, n = this->_internal_split_scaling_scalers_available_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        27, this->_internal_split_scaling_scalers_available(i), target);
  }

  // optional bool is_hdr_supported = 28;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(28, this->_internal_is_hdr_supported(), target);
  }

  // optional int32 display_refresh_manual_hz_oc_max = 29;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(29, this->_internal_display_refresh_manual_hz_oc_max(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfLimits)
  return target;
}

size_t CMsgSystemPerfLimits::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfLimits)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EGPUPerformanceLevel gpu_performance_levels_available = 10;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_gpu_performance_levels_available_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_gpu_performance_levels_available(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated int32 fps_limit_options = 13;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->fps_limit_options_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_fps_limit_options_size());
    total_size += data_size;
  }

  // repeated int32 fps_limit_options_external = 21;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      Int32Size(this->fps_limit_options_external_);
    total_size += 2 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_fps_limit_options_external_size());
    total_size += data_size;
  }

  // repeated .ESplitScalingFilter split_scaling_filters_available = 26;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_split_scaling_filters_available_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_split_scaling_filters_available(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  // repeated .ESplitScalingScaler split_scaling_scalers_available = 27;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_split_scaling_scalers_available_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_split_scaling_scalers_available(static_cast<int>(i)));
    }
    total_size += (2UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 cpu_governor_manual_min_mhz = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_governor_manual_min_mhz());
    }

    // optional int32 cpu_governor_manual_max_mhz = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_governor_manual_max_mhz());
    }

    // optional int32 fsr_sharpness_min = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fsr_sharpness_min());
    }

    // optional int32 fsr_sharpness_max = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fsr_sharpness_max());
    }

    // optional int32 gpu_performance_manual_min_mhz = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_gpu_performance_manual_min_mhz());
    }

    // optional int32 gpu_performance_manual_max_mhz = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_gpu_performance_manual_max_mhz());
    }

    // optional bool perf_overlay_is_standalone = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_dynamic_vrs_available = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_manual_display_refresh_rate_available = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_nis_supported = 16;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 + 1;
    }

    // optional int32 display_refresh_manual_hz_min = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_display_refresh_manual_hz_min());
    }

    // optional int32 display_refresh_manual_hz_max = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_display_refresh_manual_hz_max());
    }

    // optional int32 tdp_limit_min = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tdp_limit_min());
    }

    // optional int32 tdp_limit_max = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tdp_limit_max());
    }

    // optional int32 nis_sharpness_min = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_nis_sharpness_min());
    }

    // optional int32 nis_sharpness_max = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_nis_sharpness_max());
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional int32 display_external_refresh_manual_hz_min = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_display_external_refresh_manual_hz_min());
    }

    // optional int32 display_external_refresh_manual_hz_max = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_display_external_refresh_manual_hz_max());
    }

    // optional bool is_tearing_supported = 22;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool is_vrr_supported = 23;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional bool is_dynamic_refresh_rate_in_steam_supported = 24;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool is_split_scaling_and_filtering_supported = 25;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool is_hdr_supported = 28;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional int32 display_refresh_manual_hz_oc_max = 29;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_display_refresh_manual_hz_oc_max());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfLimits::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfLimits::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfLimits::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfLimits::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfLimits *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfLimits &>(from));
}


void CMsgSystemPerfLimits::MergeFrom(const CMsgSystemPerfLimits& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfLimits)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  gpu_performance_levels_available_.MergeFrom(from.gpu_performance_levels_available_);
  fps_limit_options_.MergeFrom(from.fps_limit_options_);
  fps_limit_options_external_.MergeFrom(from.fps_limit_options_external_);
  split_scaling_filters_available_.MergeFrom(from.split_scaling_filters_available_);
  split_scaling_scalers_available_.MergeFrom(from.split_scaling_scalers_available_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      cpu_governor_manual_min_mhz_ = from.cpu_governor_manual_min_mhz_;
    }
    if (cached_has_bits & 0x00000002u) {
      cpu_governor_manual_max_mhz_ = from.cpu_governor_manual_max_mhz_;
    }
    if (cached_has_bits & 0x00000004u) {
      fsr_sharpness_min_ = from.fsr_sharpness_min_;
    }
    if (cached_has_bits & 0x00000008u) {
      fsr_sharpness_max_ = from.fsr_sharpness_max_;
    }
    if (cached_has_bits & 0x00000010u) {
      gpu_performance_manual_min_mhz_ = from.gpu_performance_manual_min_mhz_;
    }
    if (cached_has_bits & 0x00000020u) {
      gpu_performance_manual_max_mhz_ = from.gpu_performance_manual_max_mhz_;
    }
    if (cached_has_bits & 0x00000040u) {
      perf_overlay_is_standalone_ = from.perf_overlay_is_standalone_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_dynamic_vrs_available_ = from.is_dynamic_vrs_available_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      is_manual_display_refresh_rate_available_ = from.is_manual_display_refresh_rate_available_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_nis_supported_ = from.is_nis_supported_;
    }
    if (cached_has_bits & 0x00000400u) {
      display_refresh_manual_hz_min_ = from.display_refresh_manual_hz_min_;
    }
    if (cached_has_bits & 0x00000800u) {
      display_refresh_manual_hz_max_ = from.display_refresh_manual_hz_max_;
    }
    if (cached_has_bits & 0x00001000u) {
      tdp_limit_min_ = from.tdp_limit_min_;
    }
    if (cached_has_bits & 0x00002000u) {
      tdp_limit_max_ = from.tdp_limit_max_;
    }
    if (cached_has_bits & 0x00004000u) {
      nis_sharpness_min_ = from.nis_sharpness_min_;
    }
    if (cached_has_bits & 0x00008000u) {
      nis_sharpness_max_ = from.nis_sharpness_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      display_external_refresh_manual_hz_min_ = from.display_external_refresh_manual_hz_min_;
    }
    if (cached_has_bits & 0x00020000u) {
      display_external_refresh_manual_hz_max_ = from.display_external_refresh_manual_hz_max_;
    }
    if (cached_has_bits & 0x00040000u) {
      is_tearing_supported_ = from.is_tearing_supported_;
    }
    if (cached_has_bits & 0x00080000u) {
      is_vrr_supported_ = from.is_vrr_supported_;
    }
    if (cached_has_bits & 0x00100000u) {
      is_dynamic_refresh_rate_in_steam_supported_ = from.is_dynamic_refresh_rate_in_steam_supported_;
    }
    if (cached_has_bits & 0x00200000u) {
      is_split_scaling_and_filtering_supported_ = from.is_split_scaling_and_filtering_supported_;
    }
    if (cached_has_bits & 0x00400000u) {
      is_hdr_supported_ = from.is_hdr_supported_;
    }
    if (cached_has_bits & 0x00800000u) {
      display_refresh_manual_hz_oc_max_ = from.display_refresh_manual_hz_oc_max_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfLimits::CopyFrom(const CMsgSystemPerfLimits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfLimits::IsInitialized() const {
  return true;
}

void CMsgSystemPerfLimits::InternalSwap(CMsgSystemPerfLimits* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  gpu_performance_levels_available_.InternalSwap(&other->gpu_performance_levels_available_);
  fps_limit_options_.InternalSwap(&other->fps_limit_options_);
  fps_limit_options_external_.InternalSwap(&other->fps_limit_options_external_);
  split_scaling_filters_available_.InternalSwap(&other->split_scaling_filters_available_);
  split_scaling_scalers_available_.InternalSwap(&other->split_scaling_scalers_available_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfLimits, display_refresh_manual_hz_oc_max_)
      + sizeof(CMsgSystemPerfLimits::display_refresh_manual_hz_oc_max_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfLimits, cpu_governor_manual_min_mhz_)>(
          reinterpret_cast<char*>(&cpu_governor_manual_min_mhz_),
          reinterpret_cast<char*>(&other->cpu_governor_manual_min_mhz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfLimits::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[26]);
}

// ===================================================================

class CMsgSystemPerfSettingsGlobal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfSettingsGlobal>()._has_bits_);
  static void set_has_diagnostic_update_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_system_trace_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_graphics_profiling_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_perf_overlay_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_perf_overlay_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_show_perf_overlay_over_steam_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_advanced_settings_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_allow_external_display_refresh_control(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_hdr_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_hdr_on_sdr_tonemap_operator(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_hdr_debug_heatmap_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_force_hdr_wide_gammut_for_sdr(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_allow_experimental_hdr(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_sdr_to_hdr_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_debug_force_hdr_support(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_force_hdr_10pq_output_debug(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_display_oc_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_is_color_management_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

CMsgSystemPerfSettingsGlobal::CMsgSystemPerfSettingsGlobal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfSettingsGlobal)
}
CMsgSystemPerfSettingsGlobal::CMsgSystemPerfSettingsGlobal(const CMsgSystemPerfSettingsGlobal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&diagnostic_update_rate_, &from.diagnostic_update_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&force_hdr_wide_gammut_for_sdr_) -
    reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(force_hdr_wide_gammut_for_sdr_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfSettingsGlobal)
}

inline void CMsgSystemPerfSettingsGlobal::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&diagnostic_update_rate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_color_management_enabled_) -
    reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(is_color_management_enabled_));
force_hdr_wide_gammut_for_sdr_ = true;
}

CMsgSystemPerfSettingsGlobal::~CMsgSystemPerfSettingsGlobal() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfSettingsGlobal)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfSettingsGlobal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemPerfSettingsGlobal::ArenaDtor(void* object) {
  CMsgSystemPerfSettingsGlobal* _this = reinterpret_cast< CMsgSystemPerfSettingsGlobal* >(object);
  (void)_this;
}
void CMsgSystemPerfSettingsGlobal::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfSettingsGlobal::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfSettingsGlobal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfSettingsGlobal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&diagnostic_update_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_external_display_refresh_control_) -
        reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(allow_external_display_refresh_control_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&is_hdr_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_display_oc_enabled_) -
        reinterpret_cast<char*>(&is_hdr_enabled_)) + sizeof(is_display_oc_enabled_));
  }
  if (cached_has_bits & 0x00030000u) {
    is_color_management_enabled_ = false;
    force_hdr_wide_gammut_for_sdr_ = true;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfSettingsGlobal::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float diagnostic_update_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_diagnostic_update_rate(&has_bits);
          diagnostic_update_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_system_trace_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_graphics_profiling_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_perf_overlay_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EGraphicsPerfOverlayLevel_IsValid(val))) {
            _internal_set_perf_overlay_level(static_cast<::EGraphicsPerfOverlayLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_show_perf_overlay_over_steam_enabled = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_show_perf_overlay_over_steam_enabled(&has_bits);
          is_show_perf_overlay_over_steam_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_advanced_settings_enabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_is_advanced_settings_enabled(&has_bits);
          is_advanced_settings_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_external_display_refresh_control = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_allow_external_display_refresh_control(&has_bits);
          allow_external_display_refresh_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hdr_enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_hdr_enabled(&has_bits);
          is_hdr_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EHDRToneMapOperator hdr_on_sdr_tonemap_operator = 12 [default = k_EHDRToneMapOperator_Invalid];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EHDRToneMapOperator_IsValid(val))) {
            _internal_set_hdr_on_sdr_tonemap_operator(static_cast<::EHDRToneMapOperator>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hdr_debug_heatmap_enabled = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_hdr_debug_heatmap_enabled(&has_bits);
          is_hdr_debug_heatmap_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_force_hdr_wide_gammut_for_sdr(&has_bits);
          force_hdr_wide_gammut_for_sdr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_experimental_hdr = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_allow_experimental_hdr(&has_bits);
          allow_experimental_hdr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float sdr_to_hdr_brightness = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 141)) {
          _Internal::set_has_sdr_to_hdr_brightness(&has_bits);
          sdr_to_hdr_brightness_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool debug_force_hdr_support = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_debug_force_hdr_support(&has_bits);
          debug_force_hdr_support_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_hdr_10pq_output_debug = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_force_hdr_10pq_output_debug(&has_bits);
          force_hdr_10pq_output_debug_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_display_oc_enabled = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_is_display_oc_enabled(&has_bits);
          is_display_oc_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_color_management_enabled = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_is_color_management_enabled(&has_bits);
          is_color_management_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfSettingsGlobal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfSettingsGlobal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float diagnostic_update_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_diagnostic_update_rate(), target);
  }

  // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_system_trace_service_state(), target);
  }

  // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_graphics_profiling_service_state(), target);
  }

  // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_perf_overlay_service_state(), target);
  }

  // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_perf_overlay_level(), target);
  }

  // optional bool is_show_perf_overlay_over_steam_enabled = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_show_perf_overlay_over_steam_enabled(), target);
  }

  // optional bool is_advanced_settings_enabled = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_is_advanced_settings_enabled(), target);
  }

  // optional bool allow_external_display_refresh_control = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_allow_external_display_refresh_control(), target);
  }

  // optional bool is_hdr_enabled = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_hdr_enabled(), target);
  }

  // optional .EHDRToneMapOperator hdr_on_sdr_tonemap_operator = 12 [default = k_EHDRToneMapOperator_Invalid];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_hdr_on_sdr_tonemap_operator(), target);
  }

  // optional bool is_hdr_debug_heatmap_enabled = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_is_hdr_debug_heatmap_enabled(), target);
  }

  // optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_force_hdr_wide_gammut_for_sdr(), target);
  }

  // optional bool allow_experimental_hdr = 16;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_allow_experimental_hdr(), target);
  }

  // optional float sdr_to_hdr_brightness = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(17, this->_internal_sdr_to_hdr_brightness(), target);
  }

  // optional bool debug_force_hdr_support = 18;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_debug_force_hdr_support(), target);
  }

  // optional bool force_hdr_10pq_output_debug = 19;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_force_hdr_10pq_output_debug(), target);
  }

  // optional bool is_display_oc_enabled = 20;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_is_display_oc_enabled(), target);
  }

  // optional bool is_color_management_enabled = 21;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_is_color_management_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfSettingsGlobal)
  return target;
}

size_t CMsgSystemPerfSettingsGlobal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfSettingsGlobal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float diagnostic_update_rate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_system_trace_service_state());
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_graphics_profiling_service_state());
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_perf_overlay_service_state());
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_perf_overlay_level());
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_advanced_settings_enabled = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool allow_external_display_refresh_control = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_hdr_enabled = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional .EHDRToneMapOperator hdr_on_sdr_tonemap_operator = 12 [default = k_EHDRToneMapOperator_Invalid];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_hdr_on_sdr_tonemap_operator());
    }

    // optional bool is_hdr_debug_heatmap_enabled = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool allow_experimental_hdr = 16;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 1;
    }

    // optional bool debug_force_hdr_support = 18;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 1;
    }

    // optional bool force_hdr_10pq_output_debug = 19;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional float sdr_to_hdr_brightness = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional bool is_display_oc_enabled = 20;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional bool is_color_management_enabled = 21;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool force_hdr_wide_gammut_for_sdr = 15 [default = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfSettingsGlobal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfSettingsGlobal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfSettingsGlobal::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfSettingsGlobal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfSettingsGlobal *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfSettingsGlobal &>(from));
}


void CMsgSystemPerfSettingsGlobal::MergeFrom(const CMsgSystemPerfSettingsGlobal& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfSettingsGlobal)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      diagnostic_update_rate_ = from.diagnostic_update_rate_;
    }
    if (cached_has_bits & 0x00000002u) {
      system_trace_service_state_ = from.system_trace_service_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      graphics_profiling_service_state_ = from.graphics_profiling_service_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      perf_overlay_service_state_ = from.perf_overlay_service_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      perf_overlay_level_ = from.perf_overlay_level_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_show_perf_overlay_over_steam_enabled_ = from.is_show_perf_overlay_over_steam_enabled_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_advanced_settings_enabled_ = from.is_advanced_settings_enabled_;
    }
    if (cached_has_bits & 0x00000080u) {
      allow_external_display_refresh_control_ = from.allow_external_display_refresh_control_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      is_hdr_enabled_ = from.is_hdr_enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      hdr_on_sdr_tonemap_operator_ = from.hdr_on_sdr_tonemap_operator_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_hdr_debug_heatmap_enabled_ = from.is_hdr_debug_heatmap_enabled_;
    }
    if (cached_has_bits & 0x00000800u) {
      allow_experimental_hdr_ = from.allow_experimental_hdr_;
    }
    if (cached_has_bits & 0x00001000u) {
      debug_force_hdr_support_ = from.debug_force_hdr_support_;
    }
    if (cached_has_bits & 0x00002000u) {
      force_hdr_10pq_output_debug_ = from.force_hdr_10pq_output_debug_;
    }
    if (cached_has_bits & 0x00004000u) {
      sdr_to_hdr_brightness_ = from.sdr_to_hdr_brightness_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_display_oc_enabled_ = from.is_display_oc_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      is_color_management_enabled_ = from.is_color_management_enabled_;
    }
    if (cached_has_bits & 0x00020000u) {
      force_hdr_wide_gammut_for_sdr_ = from.force_hdr_wide_gammut_for_sdr_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfSettingsGlobal::CopyFrom(const CMsgSystemPerfSettingsGlobal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfSettingsGlobal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfSettingsGlobal::IsInitialized() const {
  return true;
}

void CMsgSystemPerfSettingsGlobal::InternalSwap(CMsgSystemPerfSettingsGlobal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsGlobal, is_color_management_enabled_)
      + sizeof(CMsgSystemPerfSettingsGlobal::is_color_management_enabled_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsGlobal, diagnostic_update_rate_)>(
          reinterpret_cast<char*>(&diagnostic_update_rate_),
          reinterpret_cast<char*>(&other->diagnostic_update_rate_));
  swap(force_hdr_wide_gammut_for_sdr_, other->force_hdr_wide_gammut_for_sdr_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfSettingsGlobal::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[27]);
}

// ===================================================================

class CMsgSystemPerfSettingsPerApp::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfSettingsPerApp>()._has_bits_);
  static void set_has_gpu_performance_manual_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_fps_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_variable_resolution_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_dynamic_refresh_rate_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_tdp_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_cpu_governor(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_cpu_governor_manual_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_scaling_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_fsr_sharpness(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_fps_limit_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_tdp_limit_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_low_latency_mode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_display_refresh_manual_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_game_perf_profile_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_gpu_performance_level(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_nis_sharpness(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_display_external_refresh_manual_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_fps_limit_external(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_is_tearing_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_is_vrr_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_composite_debug_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_force_composite(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_use_dynamic_refresh_rate_in_steam(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_split_scaling_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_split_scaling_scaler(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
};

CMsgSystemPerfSettingsPerApp::CMsgSystemPerfSettingsPerApp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfSettingsPerApp)
}
CMsgSystemPerfSettingsPerApp::CMsgSystemPerfSettingsPerApp(const CMsgSystemPerfSettingsPerApp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&gpu_performance_manual_mhz_, &from.gpu_performance_manual_mhz_,
    static_cast<size_t>(reinterpret_cast<char*>(&split_scaling_scaler_) -
    reinterpret_cast<char*>(&gpu_performance_manual_mhz_)) + sizeof(split_scaling_scaler_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfSettingsPerApp)
}

inline void CMsgSystemPerfSettingsPerApp::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gpu_performance_manual_mhz_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&split_scaling_scaler_) -
    reinterpret_cast<char*>(&gpu_performance_manual_mhz_)) + sizeof(split_scaling_scaler_));
}

CMsgSystemPerfSettingsPerApp::~CMsgSystemPerfSettingsPerApp() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfSettingsPerApp)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfSettingsPerApp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemPerfSettingsPerApp::ArenaDtor(void* object) {
  CMsgSystemPerfSettingsPerApp* _this = reinterpret_cast< CMsgSystemPerfSettingsPerApp* >(object);
  (void)_this;
}
void CMsgSystemPerfSettingsPerApp::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfSettingsPerApp::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfSettingsPerApp::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfSettingsPerApp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&gpu_performance_manual_mhz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_fps_limit_enabled_) -
        reinterpret_cast<char*>(&gpu_performance_manual_mhz_)) + sizeof(is_fps_limit_enabled_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&is_tdp_limit_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_game_perf_profile_enabled_) -
        reinterpret_cast<char*>(&is_tdp_limit_enabled_)) + sizeof(is_game_perf_profile_enabled_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&is_tearing_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&split_scaling_filter_) -
        reinterpret_cast<char*>(&is_tearing_enabled_)) + sizeof(split_scaling_filter_));
  }
  split_scaling_scaler_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfSettingsPerApp::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 gpu_performance_manual_mhz = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gpu_performance_manual_mhz(&has_bits);
          gpu_performance_manual_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fps_limit = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fps_limit(&has_bits);
          fps_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_variable_resolution_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_variable_resolution_enabled(&has_bits);
          is_variable_resolution_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dynamic_refresh_rate_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_dynamic_refresh_rate_enabled(&has_bits);
          is_dynamic_refresh_rate_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tdp_limit = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_tdp_limit(&has_bits);
          tdp_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ECPUGovernor cpu_governor = 6 [default = k_ECPUGovernor_Invalid];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ECPUGovernor_IsValid(val))) {
            _internal_set_cpu_governor(static_cast<::ECPUGovernor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_governor_manual_mhz = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_cpu_governor_manual_mhz(&has_bits);
          cpu_governor_manual_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 scaling_filter = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_scaling_filter(&has_bits);
          scaling_filter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fsr_sharpness = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_fsr_sharpness(&has_bits);
          fsr_sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_fps_limit_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_fps_limit_enabled(&has_bits);
          is_fps_limit_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_tdp_limit_enabled = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_tdp_limit_enabled(&has_bits);
          is_tdp_limit_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_low_latency_mode_enabled = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_low_latency_mode_enabled(&has_bits);
          is_low_latency_mode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_refresh_manual_hz = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_display_refresh_manual_hz(&has_bits);
          display_refresh_manual_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_game_perf_profile_enabled = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_game_perf_profile_enabled(&has_bits);
          is_game_perf_profile_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EGPUPerformanceLevel gpu_performance_level = 15 [default = k_EGPUPerformanceLevel_Invalid];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EGPUPerformanceLevel_IsValid(val))) {
            _internal_set_gpu_performance_level(static_cast<::EGPUPerformanceLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(15, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 nis_sharpness = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_nis_sharpness(&has_bits);
          nis_sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_external_refresh_manual_hz = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_display_external_refresh_manual_hz(&has_bits);
          display_external_refresh_manual_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fps_limit_external = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_fps_limit_external(&has_bits);
          fps_limit_external_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_tearing_enabled = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_is_tearing_enabled(&has_bits);
          is_tearing_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vrr_enabled = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_is_vrr_enabled(&has_bits);
          is_vrr_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_composite_debug_enabled = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_is_composite_debug_enabled(&has_bits);
          is_composite_debug_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool force_composite = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 176)) {
          _Internal::set_has_force_composite(&has_bits);
          force_composite_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_dynamic_refresh_rate_in_steam = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 184)) {
          _Internal::set_has_use_dynamic_refresh_rate_in_steam(&has_bits);
          use_dynamic_refresh_rate_in_steam_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESplitScalingFilter split_scaling_filter = 24 [default = k_ESplitScalingFilter_Invalid];
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 192)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESplitScalingFilter_IsValid(val))) {
            _internal_set_split_scaling_filter(static_cast<::ESplitScalingFilter>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(24, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESplitScalingScaler split_scaling_scaler = 25 [default = k_ESplitScalingScaler_Invalid];
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 200)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESplitScalingScaler_IsValid(val))) {
            _internal_set_split_scaling_scaler(static_cast<::ESplitScalingScaler>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(25, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfSettingsPerApp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfSettingsPerApp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 gpu_performance_manual_mhz = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_gpu_performance_manual_mhz(), target);
  }

  // optional int32 fps_limit = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_fps_limit(), target);
  }

  // optional bool is_variable_resolution_enabled = 3;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_is_variable_resolution_enabled(), target);
  }

  // optional bool is_dynamic_refresh_rate_enabled = 4;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_dynamic_refresh_rate_enabled(), target);
  }

  // optional int32 tdp_limit = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_tdp_limit(), target);
  }

  // optional .ECPUGovernor cpu_governor = 6 [default = k_ECPUGovernor_Invalid];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_cpu_governor(), target);
  }

  // optional int32 cpu_governor_manual_mhz = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_cpu_governor_manual_mhz(), target);
  }

  // optional int32 scaling_filter = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_scaling_filter(), target);
  }

  // optional int32 fsr_sharpness = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_fsr_sharpness(), target);
  }

  // optional bool is_fps_limit_enabled = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_fps_limit_enabled(), target);
  }

  // optional bool is_tdp_limit_enabled = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_tdp_limit_enabled(), target);
  }

  // optional bool is_low_latency_mode_enabled = 12;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_low_latency_mode_enabled(), target);
  }

  // optional int32 display_refresh_manual_hz = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_display_refresh_manual_hz(), target);
  }

  // optional bool is_game_perf_profile_enabled = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_game_perf_profile_enabled(), target);
  }

  // optional .EGPUPerformanceLevel gpu_performance_level = 15 [default = k_EGPUPerformanceLevel_Invalid];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      15, this->_internal_gpu_performance_level(), target);
  }

  // optional int32 nis_sharpness = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(16, this->_internal_nis_sharpness(), target);
  }

  // optional int32 display_external_refresh_manual_hz = 17;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(17, this->_internal_display_external_refresh_manual_hz(), target);
  }

  // optional int32 fps_limit_external = 18;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(18, this->_internal_fps_limit_external(), target);
  }

  // optional bool is_tearing_enabled = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_is_tearing_enabled(), target);
  }

  // optional bool is_vrr_enabled = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_is_vrr_enabled(), target);
  }

  // optional bool is_composite_debug_enabled = 21;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_is_composite_debug_enabled(), target);
  }

  // optional bool force_composite = 22;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(22, this->_internal_force_composite(), target);
  }

  // optional bool use_dynamic_refresh_rate_in_steam = 23;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(23, this->_internal_use_dynamic_refresh_rate_in_steam(), target);
  }

  // optional .ESplitScalingFilter split_scaling_filter = 24 [default = k_ESplitScalingFilter_Invalid];
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      24, this->_internal_split_scaling_filter(), target);
  }

  // optional .ESplitScalingScaler split_scaling_scaler = 25 [default = k_ESplitScalingScaler_Invalid];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      25, this->_internal_split_scaling_scaler(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfSettingsPerApp)
  return target;
}

size_t CMsgSystemPerfSettingsPerApp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfSettingsPerApp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 gpu_performance_manual_mhz = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_gpu_performance_manual_mhz());
    }

    // optional int32 fps_limit = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fps_limit());
    }

    // optional int32 tdp_limit = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tdp_limit());
    }

    // optional .ECPUGovernor cpu_governor = 6 [default = k_ECPUGovernor_Invalid];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cpu_governor());
    }

    // optional int32 cpu_governor_manual_mhz = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_governor_manual_mhz());
    }

    // optional bool is_variable_resolution_enabled = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool is_dynamic_refresh_rate_enabled = 4;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_fps_limit_enabled = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool is_tdp_limit_enabled = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 scaling_filter = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_scaling_filter());
    }

    // optional int32 fsr_sharpness = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fsr_sharpness());
    }

    // optional int32 display_refresh_manual_hz = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_display_refresh_manual_hz());
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 15 [default = k_EGPUPerformanceLevel_Invalid];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gpu_performance_level());
    }

    // optional int32 nis_sharpness = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_nis_sharpness());
    }

    // optional bool is_low_latency_mode_enabled = 12;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool is_game_perf_profile_enabled = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool is_tearing_enabled = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool is_vrr_enabled = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional int32 display_external_refresh_manual_hz = 17;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_display_external_refresh_manual_hz());
    }

    // optional int32 fps_limit_external = 18;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_fps_limit_external());
    }

    // optional bool is_composite_debug_enabled = 21;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 1;
    }

    // optional bool force_composite = 22;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 1;
    }

    // optional bool use_dynamic_refresh_rate_in_steam = 23;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 1;
    }

    // optional .ESplitScalingFilter split_scaling_filter = 24 [default = k_ESplitScalingFilter_Invalid];
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_split_scaling_filter());
    }

  }
  // optional .ESplitScalingScaler split_scaling_scaler = 25 [default = k_ESplitScalingScaler_Invalid];
  if (cached_has_bits & 0x01000000u) {
    total_size += 2 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_split_scaling_scaler());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfSettingsPerApp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfSettingsPerApp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfSettingsPerApp::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfSettingsPerApp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfSettingsPerApp *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfSettingsPerApp &>(from));
}


void CMsgSystemPerfSettingsPerApp::MergeFrom(const CMsgSystemPerfSettingsPerApp& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfSettingsPerApp)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      gpu_performance_manual_mhz_ = from.gpu_performance_manual_mhz_;
    }
    if (cached_has_bits & 0x00000002u) {
      fps_limit_ = from.fps_limit_;
    }
    if (cached_has_bits & 0x00000004u) {
      tdp_limit_ = from.tdp_limit_;
    }
    if (cached_has_bits & 0x00000008u) {
      cpu_governor_ = from.cpu_governor_;
    }
    if (cached_has_bits & 0x00000010u) {
      cpu_governor_manual_mhz_ = from.cpu_governor_manual_mhz_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_variable_resolution_enabled_ = from.is_variable_resolution_enabled_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_dynamic_refresh_rate_enabled_ = from.is_dynamic_refresh_rate_enabled_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_fps_limit_enabled_ = from.is_fps_limit_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      is_tdp_limit_enabled_ = from.is_tdp_limit_enabled_;
    }
    if (cached_has_bits & 0x00000200u) {
      scaling_filter_ = from.scaling_filter_;
    }
    if (cached_has_bits & 0x00000400u) {
      fsr_sharpness_ = from.fsr_sharpness_;
    }
    if (cached_has_bits & 0x00000800u) {
      display_refresh_manual_hz_ = from.display_refresh_manual_hz_;
    }
    if (cached_has_bits & 0x00001000u) {
      gpu_performance_level_ = from.gpu_performance_level_;
    }
    if (cached_has_bits & 0x00002000u) {
      nis_sharpness_ = from.nis_sharpness_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_low_latency_mode_enabled_ = from.is_low_latency_mode_enabled_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_game_perf_profile_enabled_ = from.is_game_perf_profile_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      is_tearing_enabled_ = from.is_tearing_enabled_;
    }
    if (cached_has_bits & 0x00020000u) {
      is_vrr_enabled_ = from.is_vrr_enabled_;
    }
    if (cached_has_bits & 0x00040000u) {
      display_external_refresh_manual_hz_ = from.display_external_refresh_manual_hz_;
    }
    if (cached_has_bits & 0x00080000u) {
      fps_limit_external_ = from.fps_limit_external_;
    }
    if (cached_has_bits & 0x00100000u) {
      is_composite_debug_enabled_ = from.is_composite_debug_enabled_;
    }
    if (cached_has_bits & 0x00200000u) {
      force_composite_ = from.force_composite_;
    }
    if (cached_has_bits & 0x00400000u) {
      use_dynamic_refresh_rate_in_steam_ = from.use_dynamic_refresh_rate_in_steam_;
    }
    if (cached_has_bits & 0x00800000u) {
      split_scaling_filter_ = from.split_scaling_filter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x01000000u) {
    _internal_set_split_scaling_scaler(from._internal_split_scaling_scaler());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfSettingsPerApp::CopyFrom(const CMsgSystemPerfSettingsPerApp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfSettingsPerApp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfSettingsPerApp::IsInitialized() const {
  return true;
}

void CMsgSystemPerfSettingsPerApp::InternalSwap(CMsgSystemPerfSettingsPerApp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsPerApp, split_scaling_scaler_)
      + sizeof(CMsgSystemPerfSettingsPerApp::split_scaling_scaler_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsPerApp, gpu_performance_manual_mhz_)>(
          reinterpret_cast<char*>(&gpu_performance_manual_mhz_),
          reinterpret_cast<char*>(&other->gpu_performance_manual_mhz_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfSettingsPerApp::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[28]);
}

// ===================================================================

class CMsgSystemPerfSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfSettings>()._has_bits_);
  static const ::CMsgSystemPerfSettingsGlobal& global(const CMsgSystemPerfSettings* msg);
  static void set_has_global(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSystemPerfSettingsPerApp& per_app(const CMsgSystemPerfSettings* msg);
  static void set_has_per_app(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgSystemPerfSettingsGlobal&
CMsgSystemPerfSettings::_Internal::global(const CMsgSystemPerfSettings* msg) {
  return *msg->global_;
}
const ::CMsgSystemPerfSettingsPerApp&
CMsgSystemPerfSettings::_Internal::per_app(const CMsgSystemPerfSettings* msg) {
  return *msg->per_app_;
}
CMsgSystemPerfSettings::CMsgSystemPerfSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfSettings)
}
CMsgSystemPerfSettings::CMsgSystemPerfSettings(const CMsgSystemPerfSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_global()) {
    global_ = new ::CMsgSystemPerfSettingsGlobal(*from.global_);
  } else {
    global_ = nullptr;
  }
  if (from._internal_has_per_app()) {
    per_app_ = new ::CMsgSystemPerfSettingsPerApp(*from.per_app_);
  } else {
    per_app_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfSettings)
}

inline void CMsgSystemPerfSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&global_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&per_app_) -
    reinterpret_cast<char*>(&global_)) + sizeof(per_app_));
}

CMsgSystemPerfSettings::~CMsgSystemPerfSettings() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfSettings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete global_;
  if (this != internal_default_instance()) delete per_app_;
}

void CMsgSystemPerfSettings::ArenaDtor(void* object) {
  CMsgSystemPerfSettings* _this = reinterpret_cast< CMsgSystemPerfSettings* >(object);
  (void)_this;
}
void CMsgSystemPerfSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(global_ != nullptr);
      global_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(per_app_ != nullptr);
      per_app_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemPerfSettingsGlobal global = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_global(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSystemPerfSettingsPerApp per_app = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_per_app(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemPerfSettingsGlobal global = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::global(this), target, stream);
  }

  // optional .CMsgSystemPerfSettingsPerApp per_app = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::per_app(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfSettings)
  return target;
}

size_t CMsgSystemPerfSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgSystemPerfSettingsGlobal global = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *global_);
    }

    // optional .CMsgSystemPerfSettingsPerApp per_app = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *per_app_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfSettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfSettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfSettings::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfSettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfSettings *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfSettings &>(from));
}


void CMsgSystemPerfSettings::MergeFrom(const CMsgSystemPerfSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_global()->::CMsgSystemPerfSettingsGlobal::MergeFrom(from._internal_global());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_per_app()->::CMsgSystemPerfSettingsPerApp::MergeFrom(from._internal_per_app());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfSettings::CopyFrom(const CMsgSystemPerfSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfSettings::IsInitialized() const {
  return true;
}

void CMsgSystemPerfSettings::InternalSwap(CMsgSystemPerfSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettings, per_app_)
      + sizeof(CMsgSystemPerfSettings::per_app_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettings, global_)>(
          reinterpret_cast<char*>(&global_),
          reinterpret_cast<char*>(&other->global_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfSettings::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[29]);
}

// ===================================================================

class CMsgSystemPerfSettingsV1::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfSettingsV1>()._has_bits_);
  static void set_has_diagnostic_update_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_system_trace_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_graphics_profiling_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_perf_overlay_service_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_perf_overlay_level(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_gpu_performance_level(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_gpu_performance_manual_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fps_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_variable_resolution_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_dynamic_refresh_rate_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_tdp_limit(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_cpu_governor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_cpu_governor_manual_mhz(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_scaling_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_fsr_sharpness(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_is_fps_limit_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_tdp_limit_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_show_perf_overlay_over_steam_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_low_latency_mode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_display_refresh_manual_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_is_game_perf_profile_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
};

CMsgSystemPerfSettingsV1::CMsgSystemPerfSettingsV1(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfSettingsV1)
}
CMsgSystemPerfSettingsV1::CMsgSystemPerfSettingsV1(const CMsgSystemPerfSettingsV1& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&diagnostic_update_rate_, &from.diagnostic_update_rate_,
    static_cast<size_t>(reinterpret_cast<char*>(&display_refresh_manual_hz_) -
    reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(display_refresh_manual_hz_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfSettingsV1)
}

inline void CMsgSystemPerfSettingsV1::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&diagnostic_update_rate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&display_refresh_manual_hz_) -
    reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(display_refresh_manual_hz_));
}

CMsgSystemPerfSettingsV1::~CMsgSystemPerfSettingsV1() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfSettingsV1)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfSettingsV1::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemPerfSettingsV1::ArenaDtor(void* object) {
  CMsgSystemPerfSettingsV1* _this = reinterpret_cast< CMsgSystemPerfSettingsV1* >(object);
  (void)_this;
}
void CMsgSystemPerfSettingsV1::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfSettingsV1::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfSettingsV1::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfSettingsV1)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&diagnostic_update_rate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&fps_limit_) -
        reinterpret_cast<char*>(&diagnostic_update_rate_)) + sizeof(fps_limit_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&tdp_limit_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scaling_filter_) -
        reinterpret_cast<char*>(&tdp_limit_)) + sizeof(scaling_filter_));
  }
  if (cached_has_bits & 0x001f0000u) {
    ::memset(&fsr_sharpness_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_refresh_manual_hz_) -
        reinterpret_cast<char*>(&fsr_sharpness_)) + sizeof(display_refresh_manual_hz_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfSettingsV1::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float diagnostic_update_rate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_diagnostic_update_rate(&has_bits);
          diagnostic_update_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_system_trace_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_graphics_profiling_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemServiceState_IsValid(val))) {
            _internal_set_perf_overlay_service_state(static_cast<::ESystemServiceState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EGraphicsPerfOverlayLevel_IsValid(val))) {
            _internal_set_perf_overlay_level(static_cast<::EGraphicsPerfOverlayLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EGPUPerformanceLevel gpu_performance_level = 6 [default = k_EGPUPerformanceLevel_Invalid];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EGPUPerformanceLevel_IsValid(val))) {
            _internal_set_gpu_performance_level(static_cast<::EGPUPerformanceLevel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 gpu_performance_manual_mhz = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_gpu_performance_manual_mhz(&has_bits);
          gpu_performance_manual_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fps_limit = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_fps_limit(&has_bits);
          fps_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_variable_resolution_enabled = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_variable_resolution_enabled(&has_bits);
          is_variable_resolution_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dynamic_refresh_rate_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_dynamic_refresh_rate_enabled(&has_bits);
          is_dynamic_refresh_rate_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 tdp_limit = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_tdp_limit(&has_bits);
          tdp_limit_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ECPUGovernor cpu_governor = 12 [default = k_ECPUGovernor_Invalid];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ECPUGovernor_IsValid(val))) {
            _internal_set_cpu_governor(static_cast<::ECPUGovernor>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_governor_manual_mhz = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_cpu_governor_manual_mhz(&has_bits);
          cpu_governor_manual_mhz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 scaling_filter = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_scaling_filter(&has_bits);
          scaling_filter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 fsr_sharpness = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_fsr_sharpness(&has_bits);
          fsr_sharpness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_fps_limit_enabled = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_fps_limit_enabled(&has_bits);
          is_fps_limit_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_tdp_limit_enabled = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_tdp_limit_enabled(&has_bits);
          is_tdp_limit_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_show_perf_overlay_over_steam_enabled = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_show_perf_overlay_over_steam_enabled(&has_bits);
          is_show_perf_overlay_over_steam_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_low_latency_mode_enabled = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_is_low_latency_mode_enabled(&has_bits);
          is_low_latency_mode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 display_refresh_manual_hz = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_display_refresh_manual_hz(&has_bits);
          display_refresh_manual_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_game_perf_profile_enabled = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 168)) {
          _Internal::set_has_is_game_perf_profile_enabled(&has_bits);
          is_game_perf_profile_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfSettingsV1::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfSettingsV1)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float diagnostic_update_rate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_diagnostic_update_rate(), target);
  }

  // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_system_trace_service_state(), target);
  }

  // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_graphics_profiling_service_state(), target);
  }

  // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_perf_overlay_service_state(), target);
  }

  // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_perf_overlay_level(), target);
  }

  // optional .EGPUPerformanceLevel gpu_performance_level = 6 [default = k_EGPUPerformanceLevel_Invalid];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_gpu_performance_level(), target);
  }

  // optional int32 gpu_performance_manual_mhz = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_gpu_performance_manual_mhz(), target);
  }

  // optional int32 fps_limit = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_fps_limit(), target);
  }

  // optional bool is_variable_resolution_enabled = 9;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_variable_resolution_enabled(), target);
  }

  // optional bool is_dynamic_refresh_rate_enabled = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_dynamic_refresh_rate_enabled(), target);
  }

  // optional int32 tdp_limit = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_tdp_limit(), target);
  }

  // optional .ECPUGovernor cpu_governor = 12 [default = k_ECPUGovernor_Invalid];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_cpu_governor(), target);
  }

  // optional int32 cpu_governor_manual_mhz = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_cpu_governor_manual_mhz(), target);
  }

  // optional int32 scaling_filter = 14;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(14, this->_internal_scaling_filter(), target);
  }

  // optional int32 fsr_sharpness = 15;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(15, this->_internal_fsr_sharpness(), target);
  }

  // optional bool is_fps_limit_enabled = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_is_fps_limit_enabled(), target);
  }

  // optional bool is_tdp_limit_enabled = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_is_tdp_limit_enabled(), target);
  }

  // optional bool is_show_perf_overlay_over_steam_enabled = 18;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_is_show_perf_overlay_over_steam_enabled(), target);
  }

  // optional bool is_low_latency_mode_enabled = 19;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(19, this->_internal_is_low_latency_mode_enabled(), target);
  }

  // optional int32 display_refresh_manual_hz = 20;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(20, this->_internal_display_refresh_manual_hz(), target);
  }

  // optional bool is_game_perf_profile_enabled = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(21, this->_internal_is_game_perf_profile_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfSettingsV1)
  return target;
}

size_t CMsgSystemPerfSettingsV1::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfSettingsV1)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float diagnostic_update_rate = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional .ESystemServiceState system_trace_service_state = 2 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_system_trace_service_state());
    }

    // optional .ESystemServiceState graphics_profiling_service_state = 3 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_graphics_profiling_service_state());
    }

    // optional .ESystemServiceState perf_overlay_service_state = 4 [default = k_ESystemServiceState_Unavailable];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_perf_overlay_service_state());
    }

    // optional .EGraphicsPerfOverlayLevel perf_overlay_level = 5 [default = k_EGraphicsPerfOverlayLevel_Hidden];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_perf_overlay_level());
    }

    // optional .EGPUPerformanceLevel gpu_performance_level = 6 [default = k_EGPUPerformanceLevel_Invalid];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_gpu_performance_level());
    }

    // optional int32 gpu_performance_manual_mhz = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_gpu_performance_manual_mhz());
    }

    // optional int32 fps_limit = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fps_limit());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 tdp_limit = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_tdp_limit());
    }

    // optional .ECPUGovernor cpu_governor = 12 [default = k_ECPUGovernor_Invalid];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_cpu_governor());
    }

    // optional int32 cpu_governor_manual_mhz = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_governor_manual_mhz());
    }

    // optional bool is_variable_resolution_enabled = 9;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool is_dynamic_refresh_rate_enabled = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_fps_limit_enabled = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 1;
    }

    // optional bool is_tdp_limit_enabled = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional int32 scaling_filter = 14;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_scaling_filter());
    }

  }
  if (cached_has_bits & 0x001f0000u) {
    // optional int32 fsr_sharpness = 15;
    if (cached_has_bits & 0x00010000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_fsr_sharpness());
    }

    // optional bool is_show_perf_overlay_over_steam_enabled = 18;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool is_low_latency_mode_enabled = 19;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional bool is_game_perf_profile_enabled = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 1;
    }

    // optional int32 display_refresh_manual_hz = 20;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
          this->_internal_display_refresh_manual_hz());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfSettingsV1::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfSettingsV1::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfSettingsV1::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfSettingsV1::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfSettingsV1 *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfSettingsV1 &>(from));
}


void CMsgSystemPerfSettingsV1::MergeFrom(const CMsgSystemPerfSettingsV1& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfSettingsV1)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      diagnostic_update_rate_ = from.diagnostic_update_rate_;
    }
    if (cached_has_bits & 0x00000002u) {
      system_trace_service_state_ = from.system_trace_service_state_;
    }
    if (cached_has_bits & 0x00000004u) {
      graphics_profiling_service_state_ = from.graphics_profiling_service_state_;
    }
    if (cached_has_bits & 0x00000008u) {
      perf_overlay_service_state_ = from.perf_overlay_service_state_;
    }
    if (cached_has_bits & 0x00000010u) {
      perf_overlay_level_ = from.perf_overlay_level_;
    }
    if (cached_has_bits & 0x00000020u) {
      gpu_performance_level_ = from.gpu_performance_level_;
    }
    if (cached_has_bits & 0x00000040u) {
      gpu_performance_manual_mhz_ = from.gpu_performance_manual_mhz_;
    }
    if (cached_has_bits & 0x00000080u) {
      fps_limit_ = from.fps_limit_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      tdp_limit_ = from.tdp_limit_;
    }
    if (cached_has_bits & 0x00000200u) {
      cpu_governor_ = from.cpu_governor_;
    }
    if (cached_has_bits & 0x00000400u) {
      cpu_governor_manual_mhz_ = from.cpu_governor_manual_mhz_;
    }
    if (cached_has_bits & 0x00000800u) {
      is_variable_resolution_enabled_ = from.is_variable_resolution_enabled_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_dynamic_refresh_rate_enabled_ = from.is_dynamic_refresh_rate_enabled_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_fps_limit_enabled_ = from.is_fps_limit_enabled_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_tdp_limit_enabled_ = from.is_tdp_limit_enabled_;
    }
    if (cached_has_bits & 0x00008000u) {
      scaling_filter_ = from.scaling_filter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x001f0000u) {
    if (cached_has_bits & 0x00010000u) {
      fsr_sharpness_ = from.fsr_sharpness_;
    }
    if (cached_has_bits & 0x00020000u) {
      is_show_perf_overlay_over_steam_enabled_ = from.is_show_perf_overlay_over_steam_enabled_;
    }
    if (cached_has_bits & 0x00040000u) {
      is_low_latency_mode_enabled_ = from.is_low_latency_mode_enabled_;
    }
    if (cached_has_bits & 0x00080000u) {
      is_game_perf_profile_enabled_ = from.is_game_perf_profile_enabled_;
    }
    if (cached_has_bits & 0x00100000u) {
      display_refresh_manual_hz_ = from.display_refresh_manual_hz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfSettingsV1::CopyFrom(const CMsgSystemPerfSettingsV1& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfSettingsV1)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfSettingsV1::IsInitialized() const {
  return true;
}

void CMsgSystemPerfSettingsV1::InternalSwap(CMsgSystemPerfSettingsV1* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsV1, display_refresh_manual_hz_)
      + sizeof(CMsgSystemPerfSettingsV1::display_refresh_manual_hz_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfSettingsV1, diagnostic_update_rate_)>(
          reinterpret_cast<char*>(&diagnostic_update_rate_),
          reinterpret_cast<char*>(&other->diagnostic_update_rate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfSettingsV1::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[30]);
}

// ===================================================================

class CMsgSystemPerfState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfState>()._has_bits_);
  static const ::CMsgSystemPerfLimits& limits(const CMsgSystemPerfState* msg);
  static void set_has_limits(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgSystemPerfSettings& settings(const CMsgSystemPerfState* msg);
  static void set_has_settings(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_current_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_active_profile_game_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgSystemPerfLimits&
CMsgSystemPerfState::_Internal::limits(const CMsgSystemPerfState* msg) {
  return *msg->limits_;
}
const ::CMsgSystemPerfSettings&
CMsgSystemPerfState::_Internal::settings(const CMsgSystemPerfState* msg) {
  return *msg->settings_;
}
CMsgSystemPerfState::CMsgSystemPerfState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfState)
}
CMsgSystemPerfState::CMsgSystemPerfState(const CMsgSystemPerfState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_limits()) {
    limits_ = new ::CMsgSystemPerfLimits(*from.limits_);
  } else {
    limits_ = nullptr;
  }
  if (from._internal_has_settings()) {
    settings_ = new ::CMsgSystemPerfSettings(*from.settings_);
  } else {
    settings_ = nullptr;
  }
  ::memcpy(&current_game_id_, &from.current_game_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&active_profile_game_id_) -
    reinterpret_cast<char*>(&current_game_id_)) + sizeof(active_profile_game_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfState)
}

inline void CMsgSystemPerfState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&limits_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&active_profile_game_id_) -
    reinterpret_cast<char*>(&limits_)) + sizeof(active_profile_game_id_));
}

CMsgSystemPerfState::~CMsgSystemPerfState() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete limits_;
  if (this != internal_default_instance()) delete settings_;
}

void CMsgSystemPerfState::ArenaDtor(void* object) {
  CMsgSystemPerfState* _this = reinterpret_cast< CMsgSystemPerfState* >(object);
  (void)_this;
}
void CMsgSystemPerfState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(limits_ != nullptr);
      limits_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(settings_ != nullptr);
      settings_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&current_game_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&active_profile_game_id_) -
        reinterpret_cast<char*>(&current_game_id_)) + sizeof(active_profile_game_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemPerfLimits limits = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_limits(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSystemPerfSettings settings = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 current_game_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_current_game_id(&has_bits);
          current_game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 active_profile_game_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_active_profile_game_id(&has_bits);
          active_profile_game_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemPerfLimits limits = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::limits(this), target, stream);
  }

  // optional .CMsgSystemPerfSettings settings = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::settings(this), target, stream);
  }

  // optional uint64 current_game_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_current_game_id(), target);
  }

  // optional uint64 active_profile_game_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_active_profile_game_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfState)
  return target;
}

size_t CMsgSystemPerfState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgSystemPerfLimits limits = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *limits_);
    }

    // optional .CMsgSystemPerfSettings settings = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *settings_);
    }

    // optional uint64 current_game_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_current_game_id());
    }

    // optional uint64 active_profile_game_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_active_profile_game_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfState::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfState *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfState &>(from));
}


void CMsgSystemPerfState::MergeFrom(const CMsgSystemPerfState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_limits()->::CMsgSystemPerfLimits::MergeFrom(from._internal_limits());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_settings()->::CMsgSystemPerfSettings::MergeFrom(from._internal_settings());
    }
    if (cached_has_bits & 0x00000004u) {
      current_game_id_ = from.current_game_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      active_profile_game_id_ = from.active_profile_game_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfState::CopyFrom(const CMsgSystemPerfState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfState::IsInitialized() const {
  return true;
}

void CMsgSystemPerfState::InternalSwap(CMsgSystemPerfState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfState, active_profile_game_id_)
      + sizeof(CMsgSystemPerfState::active_profile_game_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfState, limits_)>(
          reinterpret_cast<char*>(&limits_),
          reinterpret_cast<char*>(&other->limits_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[31]);
}

// ===================================================================

class CMsgSystemPerfUpdateSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemPerfUpdateSettings>()._has_bits_);
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_skip_storage_update(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSystemPerfSettings& settings_delta(const CMsgSystemPerfUpdateSettings* msg);
};

const ::CMsgSystemPerfSettings&
CMsgSystemPerfUpdateSettings::_Internal::settings_delta(const CMsgSystemPerfUpdateSettings* msg) {
  return *msg->update_.settings_delta_;
}
void CMsgSystemPerfUpdateSettings::set_allocated_settings_delta(::CMsgSystemPerfSettings* settings_delta) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_update();
  if (settings_delta) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CMsgSystemPerfSettings>::GetOwningArena(settings_delta);
    if (message_arena != submessage_arena) {
      settings_delta = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, settings_delta, submessage_arena);
    }
    set_has_settings_delta();
    update_.settings_delta_ = settings_delta;
  }
  // @@protoc_insertion_point(field_set_allocated:CMsgSystemPerfUpdateSettings.settings_delta)
}
CMsgSystemPerfUpdateSettings::CMsgSystemPerfUpdateSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemPerfUpdateSettings)
}
CMsgSystemPerfUpdateSettings::CMsgSystemPerfUpdateSettings(const CMsgSystemPerfUpdateSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&skip_storage_update_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(skip_storage_update_));
  clear_has_update();
  switch (from.update_case()) {
    case kResetToDefault: {
      _internal_set_reset_to_default(from._internal_reset_to_default());
      break;
    }
    case kSettingsDelta: {
      _internal_mutable_settings_delta()->::CMsgSystemPerfSettings::MergeFrom(from._internal_settings_delta());
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemPerfUpdateSettings)
}

inline void CMsgSystemPerfUpdateSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&skip_storage_update_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(skip_storage_update_));
clear_has_update();
}

CMsgSystemPerfUpdateSettings::~CMsgSystemPerfUpdateSettings() {
  // @@protoc_insertion_point(destructor:CMsgSystemPerfUpdateSettings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemPerfUpdateSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_update()) {
    clear_update();
  }
}

void CMsgSystemPerfUpdateSettings::ArenaDtor(void* object) {
  CMsgSystemPerfUpdateSettings* _this = reinterpret_cast< CMsgSystemPerfUpdateSettings* >(object);
  (void)_this;
}
void CMsgSystemPerfUpdateSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemPerfUpdateSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemPerfUpdateSettings::clear_update() {
// @@protoc_insertion_point(one_of_clear_start:CMsgSystemPerfUpdateSettings)
  switch (update_case()) {
    case kResetToDefault: {
      // No need to clear
      break;
    }
    case kSettingsDelta: {
      if (GetArenaForAllocation() == nullptr) {
        delete update_.settings_delta_;
      }
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = UPDATE_NOT_SET;
}


void CMsgSystemPerfUpdateSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemPerfUpdateSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&skip_storage_update_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(skip_storage_update_));
  }
  clear_update();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemPerfUpdateSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 gameid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // bool reset_to_default = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _internal_set_reset_to_default(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CMsgSystemPerfSettings settings_delta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_settings_delta(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool skip_storage_update = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_skip_storage_update(&has_bits);
          skip_storage_update_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemPerfUpdateSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemPerfUpdateSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 gameid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_gameid(), target);
  }

  switch (update_case()) {
    case kResetToDefault: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_reset_to_default(), target);
      break;
    }
    case kSettingsDelta: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::settings_delta(this), target, stream);
      break;
    }
    default: ;
  }
  // optional bool skip_storage_update = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_skip_storage_update(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemPerfUpdateSettings)
  return target;
}

size_t CMsgSystemPerfUpdateSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemPerfUpdateSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 gameid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_gameid());
    }

    // optional bool skip_storage_update = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  switch (update_case()) {
    // bool reset_to_default = 2;
    case kResetToDefault: {
      total_size += 1 + 1;
      break;
    }
    // .CMsgSystemPerfSettings settings_delta = 3;
    case kSettingsDelta: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *update_.settings_delta_);
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemPerfUpdateSettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemPerfUpdateSettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemPerfUpdateSettings::GetClassData() const { return &_class_data_; }

void CMsgSystemPerfUpdateSettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemPerfUpdateSettings *>(to)->MergeFrom(
      static_cast<const CMsgSystemPerfUpdateSettings &>(from));
}


void CMsgSystemPerfUpdateSettings::MergeFrom(const CMsgSystemPerfUpdateSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemPerfUpdateSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000002u) {
      skip_storage_update_ = from.skip_storage_update_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.update_case()) {
    case kResetToDefault: {
      _internal_set_reset_to_default(from._internal_reset_to_default());
      break;
    }
    case kSettingsDelta: {
      _internal_mutable_settings_delta()->::CMsgSystemPerfSettings::MergeFrom(from._internal_settings_delta());
      break;
    }
    case UPDATE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemPerfUpdateSettings::CopyFrom(const CMsgSystemPerfUpdateSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemPerfUpdateSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemPerfUpdateSettings::IsInitialized() const {
  return true;
}

void CMsgSystemPerfUpdateSettings::InternalSwap(CMsgSystemPerfUpdateSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemPerfUpdateSettings, skip_storage_update_)
      + sizeof(CMsgSystemPerfUpdateSettings::skip_storage_update_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemPerfUpdateSettings, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
  swap(update_, other->update_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemPerfUpdateSettings::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[32]);
}

// ===================================================================

class CMsgSystemDockUpdateState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDockUpdateState>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_rtime_last_checked(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_version_current(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version_available(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stage_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_rtime_estimated_completion(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_old_fw_workaround(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CMsgSystemDockUpdateState::CMsgSystemDockUpdateState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDockUpdateState)
}
CMsgSystemDockUpdateState::CMsgSystemDockUpdateState(const CMsgSystemDockUpdateState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_current_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_current_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version_current()) {
    version_current_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version_current(), 
      GetArenaForAllocation());
  }
  version_available_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_available_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version_available()) {
    version_available_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version_available(), 
      GetArenaForAllocation());
  }
  ::memcpy(&state_, &from.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&old_fw_workaround_) -
    reinterpret_cast<char*>(&state_)) + sizeof(old_fw_workaround_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDockUpdateState)
}

inline void CMsgSystemDockUpdateState::SharedCtor() {
version_current_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_current_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
version_available_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_available_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&state_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&old_fw_workaround_) -
    reinterpret_cast<char*>(&state_)) + sizeof(old_fw_workaround_));
}

CMsgSystemDockUpdateState::~CMsgSystemDockUpdateState() {
  // @@protoc_insertion_point(destructor:CMsgSystemDockUpdateState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDockUpdateState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_current_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  version_available_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSystemDockUpdateState::ArenaDtor(void* object) {
  CMsgSystemDockUpdateState* _this = reinterpret_cast< CMsgSystemDockUpdateState* >(object);
  (void)_this;
}
void CMsgSystemDockUpdateState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDockUpdateState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDockUpdateState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDockUpdateState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      version_current_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      version_available_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&old_fw_workaround_) -
        reinterpret_cast<char*>(&state_)) + sizeof(old_fw_workaround_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDockUpdateState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EUpdaterState_IsValid(val))) {
            _internal_set_state(static_cast<::EUpdaterState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtime_last_checked = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_rtime_last_checked(&has_bits);
          rtime_last_checked_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional string version_current = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_version_current();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemDockUpdateState.version_current");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version_available = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_version_available();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemDockUpdateState.version_available");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float stage_progress = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_stage_progress(&has_bits);
          stage_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtime_estimated_completion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_rtime_estimated_completion(&has_bits);
          rtime_estimated_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 old_fw_workaround = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_old_fw_workaround(&has_bits);
          old_fw_workaround_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDockUpdateState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDockUpdateState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // optional fixed32 rtime_last_checked = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(2, this->_internal_rtime_last_checked(), target);
  }

  // optional string version_current = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version_current().data(), static_cast<int>(this->_internal_version_current().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemDockUpdateState.version_current");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_version_current(), target);
  }

  // optional string version_available = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version_available().data(), static_cast<int>(this->_internal_version_available().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemDockUpdateState.version_available");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_version_available(), target);
  }

  // optional float stage_progress = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_stage_progress(), target);
  }

  // optional fixed32 rtime_estimated_completion = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(6, this->_internal_rtime_estimated_completion(), target);
  }

  // optional int32 old_fw_workaround = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_old_fw_workaround(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDockUpdateState)
  return target;
}

size_t CMsgSystemDockUpdateState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDockUpdateState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string version_current = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version_current());
    }

    // optional string version_available = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version_available());
    }

    // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional fixed32 rtime_last_checked = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float stage_progress = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional fixed32 rtime_estimated_completion = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 old_fw_workaround = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_old_fw_workaround());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDockUpdateState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDockUpdateState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDockUpdateState::GetClassData() const { return &_class_data_; }

void CMsgSystemDockUpdateState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDockUpdateState *>(to)->MergeFrom(
      static_cast<const CMsgSystemDockUpdateState &>(from));
}


void CMsgSystemDockUpdateState::MergeFrom(const CMsgSystemDockUpdateState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDockUpdateState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version_current(from._internal_version_current());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_version_available(from._internal_version_available());
    }
    if (cached_has_bits & 0x00000004u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000008u) {
      rtime_last_checked_ = from.rtime_last_checked_;
    }
    if (cached_has_bits & 0x00000010u) {
      stage_progress_ = from.stage_progress_;
    }
    if (cached_has_bits & 0x00000020u) {
      rtime_estimated_completion_ = from.rtime_estimated_completion_;
    }
    if (cached_has_bits & 0x00000040u) {
      old_fw_workaround_ = from.old_fw_workaround_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDockUpdateState::CopyFrom(const CMsgSystemDockUpdateState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDockUpdateState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDockUpdateState::IsInitialized() const {
  return true;
}

void CMsgSystemDockUpdateState::InternalSwap(CMsgSystemDockUpdateState* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_current_, lhs_arena,
      &other->version_current_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_available_, lhs_arena,
      &other->version_available_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemDockUpdateState, old_fw_workaround_)
      + sizeof(CMsgSystemDockUpdateState::old_fw_workaround_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemDockUpdateState, state_)>(
          reinterpret_cast<char*>(&state_),
          reinterpret_cast<char*>(&other->state_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDockUpdateState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[33]);
}

// ===================================================================

class CMsgSystemDockState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDockState>()._has_bits_);
  static const ::CMsgSystemDockUpdateState& update_state(const CMsgSystemDockState* msg);
  static void set_has_update_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSystemDockUpdateState&
CMsgSystemDockState::_Internal::update_state(const CMsgSystemDockState* msg) {
  return *msg->update_state_;
}
CMsgSystemDockState::CMsgSystemDockState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDockState)
}
CMsgSystemDockState::CMsgSystemDockState(const CMsgSystemDockState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_update_state()) {
    update_state_ = new ::CMsgSystemDockUpdateState(*from.update_state_);
  } else {
    update_state_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDockState)
}

inline void CMsgSystemDockState::SharedCtor() {
update_state_ = nullptr;
}

CMsgSystemDockState::~CMsgSystemDockState() {
  // @@protoc_insertion_point(destructor:CMsgSystemDockState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDockState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete update_state_;
}

void CMsgSystemDockState::ArenaDtor(void* object) {
  CMsgSystemDockState* _this = reinterpret_cast< CMsgSystemDockState* >(object);
  (void)_this;
}
void CMsgSystemDockState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDockState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDockState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDockState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(update_state_ != nullptr);
    update_state_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDockState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemDockUpdateState update_state = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_update_state(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDockState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDockState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemDockUpdateState update_state = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::update_state(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDockState)
  return target;
}

size_t CMsgSystemDockState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDockState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgSystemDockUpdateState update_state = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *update_state_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDockState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDockState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDockState::GetClassData() const { return &_class_data_; }

void CMsgSystemDockState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDockState *>(to)->MergeFrom(
      static_cast<const CMsgSystemDockState &>(from));
}


void CMsgSystemDockState::MergeFrom(const CMsgSystemDockState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDockState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_update_state()) {
    _internal_mutable_update_state()->::CMsgSystemDockUpdateState::MergeFrom(from._internal_update_state());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDockState::CopyFrom(const CMsgSystemDockState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDockState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDockState::IsInitialized() const {
  return true;
}

void CMsgSystemDockState::InternalSwap(CMsgSystemDockState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(update_state_, other->update_state_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDockState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[34]);
}

// ===================================================================

class CMsgSystemDockUpdateFirmware::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDockUpdateFirmware>()._has_bits_);
  static void set_has_check_only(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSystemDockUpdateFirmware::CMsgSystemDockUpdateFirmware(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDockUpdateFirmware)
}
CMsgSystemDockUpdateFirmware::CMsgSystemDockUpdateFirmware(const CMsgSystemDockUpdateFirmware& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  check_only_ = from.check_only_;
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDockUpdateFirmware)
}

inline void CMsgSystemDockUpdateFirmware::SharedCtor() {
check_only_ = false;
}

CMsgSystemDockUpdateFirmware::~CMsgSystemDockUpdateFirmware() {
  // @@protoc_insertion_point(destructor:CMsgSystemDockUpdateFirmware)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDockUpdateFirmware::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemDockUpdateFirmware::ArenaDtor(void* object) {
  CMsgSystemDockUpdateFirmware* _this = reinterpret_cast< CMsgSystemDockUpdateFirmware* >(object);
  (void)_this;
}
void CMsgSystemDockUpdateFirmware::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDockUpdateFirmware::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDockUpdateFirmware::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDockUpdateFirmware)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  check_only_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDockUpdateFirmware::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool check_only = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_check_only(&has_bits);
          check_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDockUpdateFirmware::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDockUpdateFirmware)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool check_only = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_check_only(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDockUpdateFirmware)
  return target;
}

size_t CMsgSystemDockUpdateFirmware::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDockUpdateFirmware)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool check_only = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDockUpdateFirmware::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDockUpdateFirmware::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDockUpdateFirmware::GetClassData() const { return &_class_data_; }

void CMsgSystemDockUpdateFirmware::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDockUpdateFirmware *>(to)->MergeFrom(
      static_cast<const CMsgSystemDockUpdateFirmware &>(from));
}


void CMsgSystemDockUpdateFirmware::MergeFrom(const CMsgSystemDockUpdateFirmware& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDockUpdateFirmware)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_check_only()) {
    _internal_set_check_only(from._internal_check_only());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDockUpdateFirmware::CopyFrom(const CMsgSystemDockUpdateFirmware& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDockUpdateFirmware)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDockUpdateFirmware::IsInitialized() const {
  return true;
}

void CMsgSystemDockUpdateFirmware::InternalSwap(CMsgSystemDockUpdateFirmware* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(check_only_, other->check_only_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDockUpdateFirmware::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[35]);
}

// ===================================================================

class CMsgSystemAudioVolume_ChannelEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioVolume_ChannelEntry>()._has_bits_);
  static void set_has_echannel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemAudioVolume_ChannelEntry::CMsgSystemAudioVolume_ChannelEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioVolume.ChannelEntry)
}
CMsgSystemAudioVolume_ChannelEntry::CMsgSystemAudioVolume_ChannelEntry(const CMsgSystemAudioVolume_ChannelEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&echannel_, &from.echannel_,
    static_cast<size_t>(reinterpret_cast<char*>(&volume_) -
    reinterpret_cast<char*>(&echannel_)) + sizeof(volume_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioVolume.ChannelEntry)
}

inline void CMsgSystemAudioVolume_ChannelEntry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&echannel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&volume_) -
    reinterpret_cast<char*>(&echannel_)) + sizeof(volume_));
}

CMsgSystemAudioVolume_ChannelEntry::~CMsgSystemAudioVolume_ChannelEntry() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioVolume.ChannelEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioVolume_ChannelEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemAudioVolume_ChannelEntry::ArenaDtor(void* object) {
  CMsgSystemAudioVolume_ChannelEntry* _this = reinterpret_cast< CMsgSystemAudioVolume_ChannelEntry* >(object);
  (void)_this;
}
void CMsgSystemAudioVolume_ChannelEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioVolume_ChannelEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioVolume_ChannelEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioVolume.ChannelEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&echannel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&volume_) -
        reinterpret_cast<char*>(&echannel_)) + sizeof(volume_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioVolume_ChannelEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ESystemAudioChannel echannel = 1 [default = k_SystemAudioChannel_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemAudioChannel_IsValid(val))) {
            _internal_set_echannel(static_cast<::ESystemAudioChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float volume = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_volume(&has_bits);
          volume_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioVolume_ChannelEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioVolume.ChannelEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ESystemAudioChannel echannel = 1 [default = k_SystemAudioChannel_Invalid];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_echannel(), target);
  }

  // optional float volume = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_volume(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioVolume.ChannelEntry)
  return target;
}

size_t CMsgSystemAudioVolume_ChannelEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioVolume.ChannelEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .ESystemAudioChannel echannel = 1 [default = k_SystemAudioChannel_Invalid];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_echannel());
    }

    // optional float volume = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioVolume_ChannelEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioVolume_ChannelEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioVolume_ChannelEntry::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioVolume_ChannelEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioVolume_ChannelEntry *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioVolume_ChannelEntry &>(from));
}


void CMsgSystemAudioVolume_ChannelEntry::MergeFrom(const CMsgSystemAudioVolume_ChannelEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioVolume.ChannelEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      echannel_ = from.echannel_;
    }
    if (cached_has_bits & 0x00000002u) {
      volume_ = from.volume_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioVolume_ChannelEntry::CopyFrom(const CMsgSystemAudioVolume_ChannelEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioVolume.ChannelEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioVolume_ChannelEntry::IsInitialized() const {
  return true;
}

void CMsgSystemAudioVolume_ChannelEntry::InternalSwap(CMsgSystemAudioVolume_ChannelEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioVolume_ChannelEntry, volume_)
      + sizeof(CMsgSystemAudioVolume_ChannelEntry::volume_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioVolume_ChannelEntry, echannel_)>(
          reinterpret_cast<char*>(&echannel_),
          reinterpret_cast<char*>(&other->echannel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioVolume_ChannelEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[36]);
}

// ===================================================================

class CMsgSystemAudioVolume::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioVolume>()._has_bits_);
  static void set_has_is_muted(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSystemAudioVolume::CMsgSystemAudioVolume(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioVolume)
}
CMsgSystemAudioVolume::CMsgSystemAudioVolume(const CMsgSystemAudioVolume& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  is_muted_ = from.is_muted_;
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioVolume)
}

inline void CMsgSystemAudioVolume::SharedCtor() {
is_muted_ = false;
}

CMsgSystemAudioVolume::~CMsgSystemAudioVolume() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioVolume)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioVolume::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemAudioVolume::ArenaDtor(void* object) {
  CMsgSystemAudioVolume* _this = reinterpret_cast< CMsgSystemAudioVolume* >(object);
  (void)_this;
}
void CMsgSystemAudioVolume::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioVolume::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioVolume)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  is_muted_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioVolume::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSystemAudioVolume.ChannelEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_muted = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_muted(&has_bits);
          is_muted_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioVolume::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioVolume)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSystemAudioVolume.ChannelEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_muted = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_muted(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioVolume)
  return target;
}

size_t CMsgSystemAudioVolume::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioVolume)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemAudioVolume.ChannelEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool is_muted = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioVolume::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioVolume::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioVolume::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioVolume::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioVolume *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioVolume &>(from));
}


void CMsgSystemAudioVolume::MergeFrom(const CMsgSystemAudioVolume& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioVolume)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  if (from._internal_has_is_muted()) {
    _internal_set_is_muted(from._internal_is_muted());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioVolume::CopyFrom(const CMsgSystemAudioVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioVolume::IsInitialized() const {
  return true;
}

void CMsgSystemAudioVolume::InternalSwap(CMsgSystemAudioVolume* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  entries_.InternalSwap(&other->entries_);
  swap(is_muted_, other->is_muted_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioVolume::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[37]);
}

// ===================================================================

class CMsgSystemAudioManagerObject::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerObject>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rtime_last_update(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemAudioManagerObject::CMsgSystemAudioManagerObject(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerObject)
}
CMsgSystemAudioManagerObject::CMsgSystemAudioManagerObject(const CMsgSystemAudioManagerObject& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&rtime_last_update_) -
    reinterpret_cast<char*>(&id_)) + sizeof(rtime_last_update_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerObject)
}

inline void CMsgSystemAudioManagerObject::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rtime_last_update_) -
    reinterpret_cast<char*>(&id_)) + sizeof(rtime_last_update_));
}

CMsgSystemAudioManagerObject::~CMsgSystemAudioManagerObject() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerObject)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerObject::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemAudioManagerObject::ArenaDtor(void* object) {
  CMsgSystemAudioManagerObject* _this = reinterpret_cast< CMsgSystemAudioManagerObject* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerObject::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerObject::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerObject::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerObject)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rtime_last_update_) -
        reinterpret_cast<char*>(&id_)) + sizeof(rtime_last_update_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerObject::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtime_last_update = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_rtime_last_update(&has_bits);
          rtime_last_update_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerObject::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerObject)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_id(), target);
  }

  // optional fixed32 rtime_last_update = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(2, this->_internal_rtime_last_update(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerObject)
  return target;
}

size_t CMsgSystemAudioManagerObject::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerObject)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_id());
    }

    // optional fixed32 rtime_last_update = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerObject::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerObject::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerObject::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerObject::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerObject *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerObject &>(from));
}


void CMsgSystemAudioManagerObject::MergeFrom(const CMsgSystemAudioManagerObject& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerObject)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      rtime_last_update_ = from.rtime_last_update_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerObject::CopyFrom(const CMsgSystemAudioManagerObject& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerObject)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerObject::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerObject::InternalSwap(CMsgSystemAudioManagerObject* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerObject, rtime_last_update_)
      + sizeof(CMsgSystemAudioManagerObject::rtime_last_update_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerObject, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerObject::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[38]);
}

// ===================================================================

class CMsgSystemAudioManagerDevice::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerDevice>()._has_bits_);
  static const ::CMsgSystemAudioManagerObject& base(const CMsgSystemAudioManagerDevice* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nick(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_api(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgSystemAudioManagerObject&
CMsgSystemAudioManagerDevice::_Internal::base(const CMsgSystemAudioManagerDevice* msg) {
  return *msg->base_;
}
CMsgSystemAudioManagerDevice::CMsgSystemAudioManagerDevice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerDevice)
}
CMsgSystemAudioManagerDevice::CMsgSystemAudioManagerDevice(const CMsgSystemAudioManagerDevice& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  nick_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nick_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nick()) {
    nick_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nick(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  api_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    api_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_api()) {
    api_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_api(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    base_ = new ::CMsgSystemAudioManagerObject(*from.base_);
  } else {
    base_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerDevice)
}

inline void CMsgSystemAudioManagerDevice::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nick_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nick_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
api_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  api_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
base_ = nullptr;
}

CMsgSystemAudioManagerDevice::~CMsgSystemAudioManagerDevice() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerDevice)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerDevice::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nick_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  api_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete base_;
}

void CMsgSystemAudioManagerDevice::ArenaDtor(void* object) {
  CMsgSystemAudioManagerDevice* _this = reinterpret_cast< CMsgSystemAudioManagerDevice* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerDevice::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerDevice::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerDevice::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerDevice)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nick_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      api_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerDevice::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemAudioManagerObject base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerDevice.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string nick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_nick();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerDevice.nick");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerDevice.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string api = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_api();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerDevice.api");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerDevice::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerDevice)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemAudioManagerObject base = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerDevice.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string nick = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nick().data(), static_cast<int>(this->_internal_nick().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerDevice.nick");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_nick(), target);
  }

  // optional string description = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerDevice.description");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_description(), target);
  }

  // optional string api = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_api().data(), static_cast<int>(this->_internal_api().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerDevice.api");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_api(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerDevice)
  return target;
}

size_t CMsgSystemAudioManagerDevice::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerDevice)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string nick = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nick());
    }

    // optional string description = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional string api = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_api());
    }

    // optional .CMsgSystemAudioManagerObject base = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerDevice::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerDevice::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerDevice::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerDevice::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerDevice *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerDevice &>(from));
}


void CMsgSystemAudioManagerDevice::MergeFrom(const CMsgSystemAudioManagerDevice& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerDevice)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nick(from._internal_nick());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_api(from._internal_api());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_base()->::CMsgSystemAudioManagerObject::MergeFrom(from._internal_base());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerDevice::CopyFrom(const CMsgSystemAudioManagerDevice& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerDevice)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerDevice::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerDevice::InternalSwap(CMsgSystemAudioManagerDevice* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nick_, lhs_arena,
      &other->nick_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &api_, lhs_arena,
      &other->api_, rhs_arena
  );
  swap(base_, other->base_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerDevice::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[39]);
}

// ===================================================================

class CMsgSystemAudioManagerNode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerNode>()._has_bits_);
  static const ::CMsgSystemAudioManagerObject& base(const CMsgSystemAudioManagerNode* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_device_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_nick(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_edirection(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::CMsgSystemAudioVolume& volume(const CMsgSystemAudioManagerNode* msg);
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSystemAudioManagerObject&
CMsgSystemAudioManagerNode::_Internal::base(const CMsgSystemAudioManagerNode* msg) {
  return *msg->base_;
}
const ::CMsgSystemAudioVolume&
CMsgSystemAudioManagerNode::_Internal::volume(const CMsgSystemAudioManagerNode* msg) {
  return *msg->volume_;
}
CMsgSystemAudioManagerNode::CMsgSystemAudioManagerNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerNode)
}
CMsgSystemAudioManagerNode::CMsgSystemAudioManagerNode(const CMsgSystemAudioManagerNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  nick_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nick_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nick()) {
    nick_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nick(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    base_ = new ::CMsgSystemAudioManagerObject(*from.base_);
  } else {
    base_ = nullptr;
  }
  if (from._internal_has_volume()) {
    volume_ = new ::CMsgSystemAudioVolume(*from.volume_);
  } else {
    volume_ = nullptr;
  }
  ::memcpy(&device_id_, &from.device_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&edirection_) -
    reinterpret_cast<char*>(&device_id_)) + sizeof(edirection_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerNode)
}

inline void CMsgSystemAudioManagerNode::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
nick_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nick_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&edirection_) -
    reinterpret_cast<char*>(&base_)) + sizeof(edirection_));
}

CMsgSystemAudioManagerNode::~CMsgSystemAudioManagerNode() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerNode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  nick_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete base_;
  if (this != internal_default_instance()) delete volume_;
}

void CMsgSystemAudioManagerNode::ArenaDtor(void* object) {
  CMsgSystemAudioManagerNode* _this = reinterpret_cast< CMsgSystemAudioManagerNode* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerNode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerNode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      nick_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(volume_ != nullptr);
      volume_->Clear();
    }
  }
  if (cached_has_bits & 0x00000060u) {
    ::memset(&device_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&edirection_) -
        reinterpret_cast<char*>(&device_id_)) + sizeof(edirection_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerNode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemAudioManagerObject base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 device_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_device_id(&has_bits);
          device_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerNode.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string nick = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_nick();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerNode.nick");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerNode.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemAudioDirection edirection = 6 [default = k_SystemAudioDirection_Invalid];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemAudioDirection_IsValid(val))) {
            _internal_set_edirection(static_cast<::ESystemAudioDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSystemAudioVolume volume = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_volume(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemAudioManagerObject base = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 device_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_device_id(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerNode.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string nick = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nick().data(), static_cast<int>(this->_internal_nick().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerNode.nick");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_nick(), target);
  }

  // optional string description = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerNode.description");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_description(), target);
  }

  // optional .ESystemAudioDirection edirection = 6 [default = k_SystemAudioDirection_Invalid];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_edirection(), target);
  }

  // optional .CMsgSystemAudioVolume volume = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::volume(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerNode)
  return target;
}

size_t CMsgSystemAudioManagerNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string nick = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nick());
    }

    // optional string description = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional .CMsgSystemAudioManagerObject base = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional .CMsgSystemAudioVolume volume = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *volume_);
    }

    // optional uint32 device_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_device_id());
    }

    // optional .ESystemAudioDirection edirection = 6 [default = k_SystemAudioDirection_Invalid];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_edirection());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerNode::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerNode *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerNode &>(from));
}


void CMsgSystemAudioManagerNode::MergeFrom(const CMsgSystemAudioManagerNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerNode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_nick(from._internal_nick());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_base()->::CMsgSystemAudioManagerObject::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_volume()->::CMsgSystemAudioVolume::MergeFrom(from._internal_volume());
    }
    if (cached_has_bits & 0x00000020u) {
      device_id_ = from.device_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      edirection_ = from.edirection_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerNode::CopyFrom(const CMsgSystemAudioManagerNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerNode::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerNode::InternalSwap(CMsgSystemAudioManagerNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nick_, lhs_arena,
      &other->nick_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerNode, edirection_)
      + sizeof(CMsgSystemAudioManagerNode::edirection_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerNode, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerNode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[40]);
}

// ===================================================================

class CMsgSystemAudioManagerPort::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerPort>()._has_bits_);
  static const ::CMsgSystemAudioManagerObject& base(const CMsgSystemAudioManagerPort* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_alias(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_etype(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_edirection(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_is_physical(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_terminal(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_is_control(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_monitor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CMsgSystemAudioManagerObject&
CMsgSystemAudioManagerPort::_Internal::base(const CMsgSystemAudioManagerPort* msg) {
  return *msg->base_;
}
CMsgSystemAudioManagerPort::CMsgSystemAudioManagerPort(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerPort)
}
CMsgSystemAudioManagerPort::CMsgSystemAudioManagerPort(const CMsgSystemAudioManagerPort& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_alias()) {
    alias_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_alias(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_base()) {
    base_ = new ::CMsgSystemAudioManagerObject(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&node_id_, &from.node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_monitor_) -
    reinterpret_cast<char*>(&node_id_)) + sizeof(is_monitor_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerPort)
}

inline void CMsgSystemAudioManagerPort::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
alias_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  alias_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_monitor_) -
    reinterpret_cast<char*>(&base_)) + sizeof(is_monitor_));
}

CMsgSystemAudioManagerPort::~CMsgSystemAudioManagerPort() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerPort)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerPort::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  alias_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete base_;
}

void CMsgSystemAudioManagerPort::ArenaDtor(void* object) {
  CMsgSystemAudioManagerPort* _this = reinterpret_cast< CMsgSystemAudioManagerPort* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerPort::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerPort::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerPort::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerPort)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      alias_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(base_ != nullptr);
      base_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_terminal_) -
        reinterpret_cast<char*>(&node_id_)) + sizeof(is_terminal_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&is_control_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_monitor_) -
        reinterpret_cast<char*>(&is_control_)) + sizeof(is_monitor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerPort::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemAudioManagerObject base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 node_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_node_id(&has_bits);
          node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerPort.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string alias = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_alias();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemAudioManagerPort.alias");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemAudioPortType etype = 6 [default = k_SystemAudioPortType_Invalid];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemAudioPortType_IsValid(val))) {
            _internal_set_etype(static_cast<::ESystemAudioPortType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemAudioPortDirection edirection = 7 [default = k_SystemAudioPortDirection_Invalid];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemAudioPortDirection_IsValid(val))) {
            _internal_set_edirection(static_cast<::ESystemAudioPortDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_physical = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_is_physical(&has_bits);
          is_physical_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_terminal = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_is_terminal(&has_bits);
          is_terminal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_control = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_is_control(&has_bits);
          is_control_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_monitor = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_monitor(&has_bits);
          is_monitor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerPort::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerPort)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemAudioManagerObject base = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 node_id = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_node_id(), target);
  }

  // optional string name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerPort.name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_name(), target);
  }

  // optional string alias = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_alias().data(), static_cast<int>(this->_internal_alias().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemAudioManagerPort.alias");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_alias(), target);
  }

  // optional .ESystemAudioPortType etype = 6 [default = k_SystemAudioPortType_Invalid];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_etype(), target);
  }

  // optional .ESystemAudioPortDirection edirection = 7 [default = k_SystemAudioPortDirection_Invalid];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_edirection(), target);
  }

  // optional bool is_physical = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_is_physical(), target);
  }

  // optional bool is_terminal = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_is_terminal(), target);
  }

  // optional bool is_control = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_is_control(), target);
  }

  // optional bool is_monitor = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_monitor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerPort)
  return target;
}

size_t CMsgSystemAudioManagerPort::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerPort)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string alias = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_alias());
    }

    // optional .CMsgSystemAudioManagerObject base = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 node_id = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_node_id());
    }

    // optional .ESystemAudioPortType etype = 6 [default = k_SystemAudioPortType_Invalid];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_etype());
    }

    // optional .ESystemAudioPortDirection edirection = 7 [default = k_SystemAudioPortDirection_Invalid];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_edirection());
    }

    // optional bool is_physical = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool is_terminal = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool is_control = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool is_monitor = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerPort::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerPort::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerPort::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerPort::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerPort *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerPort &>(from));
}


void CMsgSystemAudioManagerPort::MergeFrom(const CMsgSystemAudioManagerPort& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerPort)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_alias(from._internal_alias());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_base()->::CMsgSystemAudioManagerObject::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000008u) {
      node_id_ = from.node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      etype_ = from.etype_;
    }
    if (cached_has_bits & 0x00000020u) {
      edirection_ = from.edirection_;
    }
    if (cached_has_bits & 0x00000040u) {
      is_physical_ = from.is_physical_;
    }
    if (cached_has_bits & 0x00000080u) {
      is_terminal_ = from.is_terminal_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      is_control_ = from.is_control_;
    }
    if (cached_has_bits & 0x00000200u) {
      is_monitor_ = from.is_monitor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerPort::CopyFrom(const CMsgSystemAudioManagerPort& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerPort)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerPort::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerPort::InternalSwap(CMsgSystemAudioManagerPort* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &alias_, lhs_arena,
      &other->alias_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerPort, is_monitor_)
      + sizeof(CMsgSystemAudioManagerPort::is_monitor_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerPort, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerPort::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[41]);
}

// ===================================================================

class CMsgSystemAudioManagerLink::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerLink>()._has_bits_);
  static const ::CMsgSystemAudioManagerObject& base(const CMsgSystemAudioManagerLink* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_output_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_output_port_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_input_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_input_port_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgSystemAudioManagerObject&
CMsgSystemAudioManagerLink::_Internal::base(const CMsgSystemAudioManagerLink* msg) {
  return *msg->base_;
}
CMsgSystemAudioManagerLink::CMsgSystemAudioManagerLink(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerLink)
}
CMsgSystemAudioManagerLink::CMsgSystemAudioManagerLink(const CMsgSystemAudioManagerLink& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    base_ = new ::CMsgSystemAudioManagerObject(*from.base_);
  } else {
    base_ = nullptr;
  }
  ::memcpy(&output_node_id_, &from.output_node_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&input_port_id_) -
    reinterpret_cast<char*>(&output_node_id_)) + sizeof(input_port_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerLink)
}

inline void CMsgSystemAudioManagerLink::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&base_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&input_port_id_) -
    reinterpret_cast<char*>(&base_)) + sizeof(input_port_id_));
}

CMsgSystemAudioManagerLink::~CMsgSystemAudioManagerLink() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerLink)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerLink::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete base_;
}

void CMsgSystemAudioManagerLink::ArenaDtor(void* object) {
  CMsgSystemAudioManagerLink* _this = reinterpret_cast< CMsgSystemAudioManagerLink* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerLink::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerLink::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerLink::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerLink)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(base_ != nullptr);
    base_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&output_node_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&input_port_id_) -
        reinterpret_cast<char*>(&output_node_id_)) + sizeof(input_port_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerLink::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgSystemAudioManagerObject base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 output_node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_output_node_id(&has_bits);
          output_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 output_port_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_output_port_id(&has_bits);
          output_port_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 input_node_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_input_node_id(&has_bits);
          input_node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 input_port_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_input_port_id(&has_bits);
          input_port_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerLink::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerLink)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CMsgSystemAudioManagerObject base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::base(this), target, stream);
  }

  // optional uint32 output_node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_output_node_id(), target);
  }

  // optional uint32 output_port_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_output_port_id(), target);
  }

  // optional uint32 input_node_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_input_node_id(), target);
  }

  // optional uint32 input_port_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_input_port_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerLink)
  return target;
}

size_t CMsgSystemAudioManagerLink::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerLink)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgSystemAudioManagerObject base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *base_);
    }

    // optional uint32 output_node_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_output_node_id());
    }

    // optional uint32 output_port_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_output_port_id());
    }

    // optional uint32 input_node_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_node_id());
    }

    // optional uint32 input_port_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_port_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerLink::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerLink::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerLink::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerLink::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerLink *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerLink &>(from));
}


void CMsgSystemAudioManagerLink::MergeFrom(const CMsgSystemAudioManagerLink& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerLink)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_base()->::CMsgSystemAudioManagerObject::MergeFrom(from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      output_node_id_ = from.output_node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      output_port_id_ = from.output_port_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      input_node_id_ = from.input_node_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      input_port_id_ = from.input_port_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerLink::CopyFrom(const CMsgSystemAudioManagerLink& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerLink)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerLink::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerLink::InternalSwap(CMsgSystemAudioManagerLink* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerLink, input_port_id_)
      + sizeof(CMsgSystemAudioManagerLink::input_port_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerLink, base_)>(
          reinterpret_cast<char*>(&base_),
          reinterpret_cast<char*>(&other->base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerLink::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[42]);
}

// ===================================================================

class CMsgSystemAudioManagerStateHW::_Internal {
 public:
};

CMsgSystemAudioManagerStateHW::CMsgSystemAudioManagerStateHW(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  devices_(arena),
  nodes_(arena),
  ports_(arena),
  links_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerStateHW)
}
CMsgSystemAudioManagerStateHW::CMsgSystemAudioManagerStateHW(const CMsgSystemAudioManagerStateHW& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      devices_(from.devices_),
      nodes_(from.nodes_),
      ports_(from.ports_),
      links_(from.links_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerStateHW)
}

inline void CMsgSystemAudioManagerStateHW::SharedCtor() {
}

CMsgSystemAudioManagerStateHW::~CMsgSystemAudioManagerStateHW() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerStateHW)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerStateHW::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemAudioManagerStateHW::ArenaDtor(void* object) {
  CMsgSystemAudioManagerStateHW* _this = reinterpret_cast< CMsgSystemAudioManagerStateHW* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerStateHW::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerStateHW::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerStateHW::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerStateHW)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  devices_.Clear();
  nodes_.Clear();
  ports_.Clear();
  links_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerStateHW::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSystemAudioManagerDevice devices = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_devices(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemAudioManagerNode nodes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nodes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemAudioManagerPort ports = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemAudioManagerLink links = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_links(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerStateHW::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerStateHW)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSystemAudioManagerDevice devices = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_devices_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_devices(i), target, stream);
  }

  // repeated .CMsgSystemAudioManagerNode nodes = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_nodes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_nodes(i), target, stream);
  }

  // repeated .CMsgSystemAudioManagerPort ports = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_ports_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_ports(i), target, stream);
  }

  // repeated .CMsgSystemAudioManagerLink links = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_links_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_links(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerStateHW)
  return target;
}

size_t CMsgSystemAudioManagerStateHW::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerStateHW)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemAudioManagerDevice devices = 1;
  total_size += 1UL * this->_internal_devices_size();
  for (const auto& msg : this->devices_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSystemAudioManagerNode nodes = 2;
  total_size += 1UL * this->_internal_nodes_size();
  for (const auto& msg : this->nodes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSystemAudioManagerPort ports = 3;
  total_size += 1UL * this->_internal_ports_size();
  for (const auto& msg : this->ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSystemAudioManagerLink links = 4;
  total_size += 1UL * this->_internal_links_size();
  for (const auto& msg : this->links_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerStateHW::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerStateHW::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerStateHW::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerStateHW::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerStateHW *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerStateHW &>(from));
}


void CMsgSystemAudioManagerStateHW::MergeFrom(const CMsgSystemAudioManagerStateHW& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerStateHW)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  devices_.MergeFrom(from.devices_);
  nodes_.MergeFrom(from.nodes_);
  ports_.MergeFrom(from.ports_);
  links_.MergeFrom(from.links_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerStateHW::CopyFrom(const CMsgSystemAudioManagerStateHW& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerStateHW)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerStateHW::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerStateHW::InternalSwap(CMsgSystemAudioManagerStateHW* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  devices_.InternalSwap(&other->devices_);
  nodes_.InternalSwap(&other->nodes_);
  ports_.InternalSwap(&other->ports_);
  links_.InternalSwap(&other->links_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerStateHW::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[43]);
}

// ===================================================================

class CMsgSystemAudioManagerState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerState>()._has_bits_);
  static void set_has_rtime_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgSystemAudioManagerStateHW& hw(const CMsgSystemAudioManagerState* msg);
  static void set_has_hw(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgSystemAudioManagerStateHW&
CMsgSystemAudioManagerState::_Internal::hw(const CMsgSystemAudioManagerState* msg) {
  return *msg->hw_;
}
CMsgSystemAudioManagerState::CMsgSystemAudioManagerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerState)
}
CMsgSystemAudioManagerState::CMsgSystemAudioManagerState(const CMsgSystemAudioManagerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_hw()) {
    hw_ = new ::CMsgSystemAudioManagerStateHW(*from.hw_);
  } else {
    hw_ = nullptr;
  }
  ::memcpy(&rtime_filter_, &from.rtime_filter_,
    static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&rtime_filter_)) + sizeof(counter_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerState)
}

inline void CMsgSystemAudioManagerState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&hw_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&counter_) -
    reinterpret_cast<char*>(&hw_)) + sizeof(counter_));
}

CMsgSystemAudioManagerState::~CMsgSystemAudioManagerState() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete hw_;
}

void CMsgSystemAudioManagerState::ArenaDtor(void* object) {
  CMsgSystemAudioManagerState* _this = reinterpret_cast< CMsgSystemAudioManagerState* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(hw_ != nullptr);
    hw_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&rtime_filter_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&counter_) -
        reinterpret_cast<char*>(&rtime_filter_)) + sizeof(counter_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 rtime_filter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_rtime_filter(&has_bits);
          rtime_filter_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 counter = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_counter(&has_bits);
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSystemAudioManagerStateHW hw = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_hw(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed32 rtime_filter = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(1, this->_internal_rtime_filter(), target);
  }

  // optional int32 counter = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_counter(), target);
  }

  // optional .CMsgSystemAudioManagerStateHW hw = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::hw(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerState)
  return target;
}

size_t CMsgSystemAudioManagerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgSystemAudioManagerStateHW hw = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *hw_);
    }

    // optional fixed32 rtime_filter = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional int32 counter = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_counter());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerState::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerState *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerState &>(from));
}


void CMsgSystemAudioManagerState::MergeFrom(const CMsgSystemAudioManagerState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_hw()->::CMsgSystemAudioManagerStateHW::MergeFrom(from._internal_hw());
    }
    if (cached_has_bits & 0x00000002u) {
      rtime_filter_ = from.rtime_filter_;
    }
    if (cached_has_bits & 0x00000004u) {
      counter_ = from.counter_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerState::CopyFrom(const CMsgSystemAudioManagerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerState::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerState::InternalSwap(CMsgSystemAudioManagerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerState, counter_)
      + sizeof(CMsgSystemAudioManagerState::counter_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemAudioManagerState, hw_)>(
          reinterpret_cast<char*>(&hw_),
          reinterpret_cast<char*>(&other->hw_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[44]);
}

// ===================================================================

class CMsgSystemAudioManagerUpdateSomething::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemAudioManagerUpdateSomething>()._has_bits_);
  static void set_has_counter(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSystemAudioManagerUpdateSomething::CMsgSystemAudioManagerUpdateSomething(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemAudioManagerUpdateSomething)
}
CMsgSystemAudioManagerUpdateSomething::CMsgSystemAudioManagerUpdateSomething(const CMsgSystemAudioManagerUpdateSomething& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  counter_ = from.counter_;
  // @@protoc_insertion_point(copy_constructor:CMsgSystemAudioManagerUpdateSomething)
}

inline void CMsgSystemAudioManagerUpdateSomething::SharedCtor() {
counter_ = 0;
}

CMsgSystemAudioManagerUpdateSomething::~CMsgSystemAudioManagerUpdateSomething() {
  // @@protoc_insertion_point(destructor:CMsgSystemAudioManagerUpdateSomething)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemAudioManagerUpdateSomething::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemAudioManagerUpdateSomething::ArenaDtor(void* object) {
  CMsgSystemAudioManagerUpdateSomething* _this = reinterpret_cast< CMsgSystemAudioManagerUpdateSomething* >(object);
  (void)_this;
}
void CMsgSystemAudioManagerUpdateSomething::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemAudioManagerUpdateSomething::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemAudioManagerUpdateSomething::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemAudioManagerUpdateSomething)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  counter_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemAudioManagerUpdateSomething::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 counter = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_counter(&has_bits);
          counter_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemAudioManagerUpdateSomething::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemAudioManagerUpdateSomething)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 counter = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_counter(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemAudioManagerUpdateSomething)
  return target;
}

size_t CMsgSystemAudioManagerUpdateSomething::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemAudioManagerUpdateSomething)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 counter = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_counter());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemAudioManagerUpdateSomething::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemAudioManagerUpdateSomething::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemAudioManagerUpdateSomething::GetClassData() const { return &_class_data_; }

void CMsgSystemAudioManagerUpdateSomething::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemAudioManagerUpdateSomething *>(to)->MergeFrom(
      static_cast<const CMsgSystemAudioManagerUpdateSomething &>(from));
}


void CMsgSystemAudioManagerUpdateSomething::MergeFrom(const CMsgSystemAudioManagerUpdateSomething& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemAudioManagerUpdateSomething)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_counter()) {
    _internal_set_counter(from._internal_counter());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemAudioManagerUpdateSomething::CopyFrom(const CMsgSystemAudioManagerUpdateSomething& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemAudioManagerUpdateSomething)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemAudioManagerUpdateSomething::IsInitialized() const {
  return true;
}

void CMsgSystemAudioManagerUpdateSomething::InternalSwap(CMsgSystemAudioManagerUpdateSomething* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(counter_, other->counter_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemAudioManagerUpdateSomething::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[45]);
}

// ===================================================================

class CMsgSystemDisplayMode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDisplayMode>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_refresh_hz(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CMsgSystemDisplayMode::CMsgSystemDisplayMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDisplayMode)
}
CMsgSystemDisplayMode::CMsgSystemDisplayMode(const CMsgSystemDisplayMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&refresh_hz_) -
    reinterpret_cast<char*>(&id_)) + sizeof(refresh_hz_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDisplayMode)
}

inline void CMsgSystemDisplayMode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&refresh_hz_) -
    reinterpret_cast<char*>(&id_)) + sizeof(refresh_hz_));
}

CMsgSystemDisplayMode::~CMsgSystemDisplayMode() {
  // @@protoc_insertion_point(destructor:CMsgSystemDisplayMode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDisplayMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemDisplayMode::ArenaDtor(void* object) {
  CMsgSystemDisplayMode* _this = reinterpret_cast< CMsgSystemDisplayMode* >(object);
  (void)_this;
}
void CMsgSystemDisplayMode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDisplayMode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDisplayMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDisplayMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&refresh_hz_) -
        reinterpret_cast<char*>(&id_)) + sizeof(refresh_hz_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDisplayMode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 refresh_hz = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_refresh_hz(&has_bits);
          refresh_hz_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDisplayMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDisplayMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional int32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // optional int32 height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_height(), target);
  }

  // optional int32 refresh_hz = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_refresh_hz(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDisplayMode)
  return target;
}

size_t CMsgSystemDisplayMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDisplayMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional int32 id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional int32 width = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

    // optional int32 refresh_hz = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_refresh_hz());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDisplayMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDisplayMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDisplayMode::GetClassData() const { return &_class_data_; }

void CMsgSystemDisplayMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDisplayMode *>(to)->MergeFrom(
      static_cast<const CMsgSystemDisplayMode &>(from));
}


void CMsgSystemDisplayMode::MergeFrom(const CMsgSystemDisplayMode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDisplayMode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      refresh_hz_ = from.refresh_hz_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDisplayMode::CopyFrom(const CMsgSystemDisplayMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDisplayMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDisplayMode::IsInitialized() const {
  return true;
}

void CMsgSystemDisplayMode::InternalSwap(CMsgSystemDisplayMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayMode, refresh_hz_)
      + sizeof(CMsgSystemDisplayMode::refresh_hz_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayMode, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDisplayMode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[46]);
}

// ===================================================================

class CMsgSystemDisplay::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDisplay>()._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_description(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_primary(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_internal(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_has_mode_override(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_width_mm(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_height_mm(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_current_mode_id(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_refresh_rate_min(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_refresh_rate_max(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_vrr_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_vrr_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_hdr_capable(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_hdr_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
};

CMsgSystemDisplay::CMsgSystemDisplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  modes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDisplay)
}
CMsgSystemDisplay::CMsgSystemDisplay(const CMsgSystemDisplay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      modes_(from.modes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_name(), 
      GetArenaForAllocation());
  }
  description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_description()) {
    description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_description(), 
      GetArenaForAllocation());
  }
  ::memcpy(&id_, &from.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_hdr_enabled_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_hdr_enabled_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDisplay)
}

inline void CMsgSystemDisplay::SharedCtor() {
name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_hdr_enabled_) -
    reinterpret_cast<char*>(&id_)) + sizeof(is_hdr_enabled_));
}

CMsgSystemDisplay::~CMsgSystemDisplay() {
  // @@protoc_insertion_point(destructor:CMsgSystemDisplay)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDisplay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSystemDisplay::ArenaDtor(void* object) {
  CMsgSystemDisplay* _this = reinterpret_cast< CMsgSystemDisplay* >(object);
  (void)_this;
}
void CMsgSystemDisplay::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDisplay::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDisplay::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDisplay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  modes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      description_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&width_mm_) -
        reinterpret_cast<char*>(&id_)) + sizeof(width_mm_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&height_mm_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_hdr_enabled_) -
        reinterpret_cast<char*>(&height_mm_)) + sizeof(is_hdr_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDisplay::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemDisplay.name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string description = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemDisplay.description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_primary = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_primary(&has_bits);
          is_primary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_enabled(&has_bits);
          is_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_internal = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_internal(&has_bits);
          is_internal_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_mode_override = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_has_mode_override(&has_bits);
          has_mode_override_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width_mm = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_width_mm(&has_bits);
          width_mm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height_mm = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_height_mm(&has_bits);
          height_mm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 current_mode_id = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_current_mode_id(&has_bits);
          current_mode_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemDisplayMode modes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_modes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 refresh_rate_min = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_refresh_rate_min(&has_bits);
          refresh_rate_min_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 refresh_rate_max = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_refresh_rate_max(&has_bits);
          refresh_rate_max_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vrr_capable = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_vrr_capable(&has_bits);
          is_vrr_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_vrr_enabled = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_is_vrr_enabled(&has_bits);
          is_vrr_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hdr_capable = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_hdr_capable(&has_bits);
          is_hdr_capable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hdr_enabled = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_hdr_enabled(&has_bits);
          is_hdr_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDisplay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDisplay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemDisplay.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // optional string description = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_description().data(), static_cast<int>(this->_internal_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemDisplay.description");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_description(), target);
  }

  // optional bool is_primary = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_is_primary(), target);
  }

  // optional bool is_enabled = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_is_enabled(), target);
  }

  // optional bool is_internal = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_internal(), target);
  }

  // optional bool has_mode_override = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_has_mode_override(), target);
  }

  // optional int32 width_mm = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_width_mm(), target);
  }

  // optional int32 height_mm = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_height_mm(), target);
  }

  // optional int32 current_mode_id = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(10, this->_internal_current_mode_id(), target);
  }

  // repeated .CMsgSystemDisplayMode modes = 11;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_modes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, this->_internal_modes(i), target, stream);
  }

  // optional int32 refresh_rate_min = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_refresh_rate_min(), target);
  }

  // optional int32 refresh_rate_max = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(13, this->_internal_refresh_rate_max(), target);
  }

  // optional bool is_vrr_capable = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_vrr_capable(), target);
  }

  // optional bool is_vrr_enabled = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_is_vrr_enabled(), target);
  }

  // optional bool is_hdr_capable = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_is_hdr_capable(), target);
  }

  // optional bool is_hdr_enabled = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_is_hdr_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDisplay)
  return target;
}

size_t CMsgSystemDisplay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDisplay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemDisplayMode modes = 11;
  total_size += 1UL * this->_internal_modes_size();
  for (const auto& msg : this->modes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string description = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_description());
    }

    // optional int32 id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_id());
    }

    // optional bool is_primary = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_enabled = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_internal = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool has_mode_override = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 width_mm = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width_mm());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 height_mm = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_height_mm());
    }

    // optional int32 current_mode_id = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_current_mode_id());
    }

    // optional int32 refresh_rate_min = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_refresh_rate_min());
    }

    // optional int32 refresh_rate_max = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_refresh_rate_max());
    }

    // optional bool is_vrr_capable = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_vrr_enabled = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool is_hdr_capable = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_hdr_enabled = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDisplay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDisplay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDisplay::GetClassData() const { return &_class_data_; }

void CMsgSystemDisplay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDisplay *>(to)->MergeFrom(
      static_cast<const CMsgSystemDisplay &>(from));
}


void CMsgSystemDisplay::MergeFrom(const CMsgSystemDisplay& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDisplay)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  modes_.MergeFrom(from.modes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_description(from._internal_description());
    }
    if (cached_has_bits & 0x00000004u) {
      id_ = from.id_;
    }
    if (cached_has_bits & 0x00000008u) {
      is_primary_ = from.is_primary_;
    }
    if (cached_has_bits & 0x00000010u) {
      is_enabled_ = from.is_enabled_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_internal_ = from.is_internal_;
    }
    if (cached_has_bits & 0x00000040u) {
      has_mode_override_ = from.has_mode_override_;
    }
    if (cached_has_bits & 0x00000080u) {
      width_mm_ = from.width_mm_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      height_mm_ = from.height_mm_;
    }
    if (cached_has_bits & 0x00000200u) {
      current_mode_id_ = from.current_mode_id_;
    }
    if (cached_has_bits & 0x00000400u) {
      refresh_rate_min_ = from.refresh_rate_min_;
    }
    if (cached_has_bits & 0x00000800u) {
      refresh_rate_max_ = from.refresh_rate_max_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_vrr_capable_ = from.is_vrr_capable_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_vrr_enabled_ = from.is_vrr_enabled_;
    }
    if (cached_has_bits & 0x00004000u) {
      is_hdr_capable_ = from.is_hdr_capable_;
    }
    if (cached_has_bits & 0x00008000u) {
      is_hdr_enabled_ = from.is_hdr_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDisplay::CopyFrom(const CMsgSystemDisplay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDisplay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDisplay::IsInitialized() const {
  return true;
}

void CMsgSystemDisplay::InternalSwap(CMsgSystemDisplay* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  modes_.InternalSwap(&other->modes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &description_, lhs_arena,
      &other->description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemDisplay, is_hdr_enabled_)
      + sizeof(CMsgSystemDisplay::is_hdr_enabled_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemDisplay, id_)>(
          reinterpret_cast<char*>(&id_),
          reinterpret_cast<char*>(&other->id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDisplay::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[47]);
}

// ===================================================================

class CMsgSystemDisplayManagerState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDisplayManagerState>()._has_bits_);
  static void set_has_is_mode_switching_supported(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_compatibility_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemDisplayManagerState::CMsgSystemDisplayManagerState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  displays_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDisplayManagerState)
}
CMsgSystemDisplayManagerState::CMsgSystemDisplayManagerState(const CMsgSystemDisplayManagerState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      displays_(from.displays_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&is_mode_switching_supported_, &from.is_mode_switching_supported_,
    static_cast<size_t>(reinterpret_cast<char*>(&compatibility_mode_) -
    reinterpret_cast<char*>(&is_mode_switching_supported_)) + sizeof(compatibility_mode_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDisplayManagerState)
}

inline void CMsgSystemDisplayManagerState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&is_mode_switching_supported_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&compatibility_mode_) -
    reinterpret_cast<char*>(&is_mode_switching_supported_)) + sizeof(compatibility_mode_));
}

CMsgSystemDisplayManagerState::~CMsgSystemDisplayManagerState() {
  // @@protoc_insertion_point(destructor:CMsgSystemDisplayManagerState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDisplayManagerState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemDisplayManagerState::ArenaDtor(void* object) {
  CMsgSystemDisplayManagerState* _this = reinterpret_cast< CMsgSystemDisplayManagerState* >(object);
  (void)_this;
}
void CMsgSystemDisplayManagerState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDisplayManagerState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDisplayManagerState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDisplayManagerState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  displays_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&is_mode_switching_supported_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&compatibility_mode_) -
        reinterpret_cast<char*>(&is_mode_switching_supported_)) + sizeof(compatibility_mode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDisplayManagerState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgSystemDisplay displays = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_displays(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_mode_switching_supported = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_is_mode_switching_supported(&has_bits);
          is_mode_switching_supported_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemDisplayCompatibilityMode compatibility_mode = 3 [default = k_ESystemDisplayCompatibilityMode_Invalid];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemDisplayCompatibilityMode_IsValid(val))) {
            _internal_set_compatibility_mode(static_cast<::ESystemDisplayCompatibilityMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDisplayManagerState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDisplayManagerState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgSystemDisplay displays = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_displays_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_displays(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional bool is_mode_switching_supported = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_is_mode_switching_supported(), target);
  }

  // optional .ESystemDisplayCompatibilityMode compatibility_mode = 3 [default = k_ESystemDisplayCompatibilityMode_Invalid];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_compatibility_mode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDisplayManagerState)
  return target;
}

size_t CMsgSystemDisplayManagerState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDisplayManagerState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemDisplay displays = 1;
  total_size += 1UL * this->_internal_displays_size();
  for (const auto& msg : this->displays_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool is_mode_switching_supported = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional .ESystemDisplayCompatibilityMode compatibility_mode = 3 [default = k_ESystemDisplayCompatibilityMode_Invalid];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_compatibility_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDisplayManagerState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDisplayManagerState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDisplayManagerState::GetClassData() const { return &_class_data_; }

void CMsgSystemDisplayManagerState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDisplayManagerState *>(to)->MergeFrom(
      static_cast<const CMsgSystemDisplayManagerState &>(from));
}


void CMsgSystemDisplayManagerState::MergeFrom(const CMsgSystemDisplayManagerState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDisplayManagerState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  displays_.MergeFrom(from.displays_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      is_mode_switching_supported_ = from.is_mode_switching_supported_;
    }
    if (cached_has_bits & 0x00000002u) {
      compatibility_mode_ = from.compatibility_mode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDisplayManagerState::CopyFrom(const CMsgSystemDisplayManagerState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDisplayManagerState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDisplayManagerState::IsInitialized() const {
  return true;
}

void CMsgSystemDisplayManagerState::InternalSwap(CMsgSystemDisplayManagerState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  displays_.InternalSwap(&other->displays_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayManagerState, compatibility_mode_)
      + sizeof(CMsgSystemDisplayManagerState::compatibility_mode_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayManagerState, is_mode_switching_supported_)>(
          reinterpret_cast<char*>(&is_mode_switching_supported_),
          reinterpret_cast<char*>(&other->is_mode_switching_supported_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDisplayManagerState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[48]);
}

// ===================================================================

class CMsgSystemDisplayManagerSetMode::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemDisplayManagerSetMode>()._has_bits_);
  static void set_has_display_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_mode_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemDisplayManagerSetMode::CMsgSystemDisplayManagerSetMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemDisplayManagerSetMode)
}
CMsgSystemDisplayManagerSetMode::CMsgSystemDisplayManagerSetMode(const CMsgSystemDisplayManagerSetMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&display_id_, &from.display_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&mode_id_) -
    reinterpret_cast<char*>(&display_id_)) + sizeof(mode_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemDisplayManagerSetMode)
}

inline void CMsgSystemDisplayManagerSetMode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&display_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&mode_id_) -
    reinterpret_cast<char*>(&display_id_)) + sizeof(mode_id_));
}

CMsgSystemDisplayManagerSetMode::~CMsgSystemDisplayManagerSetMode() {
  // @@protoc_insertion_point(destructor:CMsgSystemDisplayManagerSetMode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemDisplayManagerSetMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemDisplayManagerSetMode::ArenaDtor(void* object) {
  CMsgSystemDisplayManagerSetMode* _this = reinterpret_cast< CMsgSystemDisplayManagerSetMode* >(object);
  (void)_this;
}
void CMsgSystemDisplayManagerSetMode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemDisplayManagerSetMode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemDisplayManagerSetMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemDisplayManagerSetMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&display_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&mode_id_) -
        reinterpret_cast<char*>(&display_id_)) + sizeof(mode_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemDisplayManagerSetMode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 display_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_display_id(&has_bits);
          display_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 mode_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_mode_id(&has_bits);
          mode_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemDisplayManagerSetMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemDisplayManagerSetMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 display_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_display_id(), target);
  }

  // optional int32 mode_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_mode_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemDisplayManagerSetMode)
  return target;
}

size_t CMsgSystemDisplayManagerSetMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemDisplayManagerSetMode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 display_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_display_id());
    }

    // optional int32 mode_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_mode_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemDisplayManagerSetMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemDisplayManagerSetMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemDisplayManagerSetMode::GetClassData() const { return &_class_data_; }

void CMsgSystemDisplayManagerSetMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemDisplayManagerSetMode *>(to)->MergeFrom(
      static_cast<const CMsgSystemDisplayManagerSetMode &>(from));
}


void CMsgSystemDisplayManagerSetMode::MergeFrom(const CMsgSystemDisplayManagerSetMode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemDisplayManagerSetMode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      display_id_ = from.display_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      mode_id_ = from.mode_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemDisplayManagerSetMode::CopyFrom(const CMsgSystemDisplayManagerSetMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemDisplayManagerSetMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemDisplayManagerSetMode::IsInitialized() const {
  return true;
}

void CMsgSystemDisplayManagerSetMode::InternalSwap(CMsgSystemDisplayManagerSetMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayManagerSetMode, mode_id_)
      + sizeof(CMsgSystemDisplayManagerSetMode::mode_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemDisplayManagerSetMode, display_id_)>(
          reinterpret_cast<char*>(&display_id_),
          reinterpret_cast<char*>(&other->display_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemDisplayManagerSetMode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[49]);
}

// ===================================================================

class CMsgSystemManagerSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemManagerSettings>()._has_bits_);
  static void set_has_idle_backlight_dim_battery_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_idle_backlight_dim_ac_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_idle_suspend_battery_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_idle_suspend_ac_seconds(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_idle_suspend_supressed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_is_adaptive_brightness_available(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_display_adaptive_brightness_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_display_nightmode_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_display_nightmode_tintstrength(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_display_nightmode_maxhue(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_display_nightmode_maxsat(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_display_nightmode_uiexp(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_display_nightmode_blend(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_display_nightmode_reset(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_display_nightmode_schedule_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_display_nightmode_schedule_starttime(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_display_nightmode_schedule_endtime(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_display_diagnostics_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_als_lux_latest(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_als_lux_median(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_display_backlight_raw(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
  static void set_has_display_brightness_adaptivemin(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_display_brightness_adaptivemax(HasBits* has_bits) {
    (*has_bits)[0] |= 8388608u;
  }
  static void set_has_is_wifi_powersave_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_is_fan_control_available(HasBits* has_bits) {
    (*has_bits)[0] |= 33554432u;
  }
  static void set_has_fan_control_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 16777216u;
  }
  static void set_has_is_display_brightness_available(HasBits* has_bits) {
    (*has_bits)[0] |= 67108864u;
  }
  static void set_has_is_display_colormanagement_available(HasBits* has_bits) {
    (*has_bits)[0] |= 134217728u;
  }
  static void set_has_display_colorgamut(HasBits* has_bits) {
    (*has_bits)[0] |= 268435456u;
  }
};

CMsgSystemManagerSettings::CMsgSystemManagerSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemManagerSettings)
}
CMsgSystemManagerSettings::CMsgSystemManagerSettings(const CMsgSystemManagerSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&idle_backlight_dim_battery_seconds_, &from.idle_backlight_dim_battery_seconds_,
    static_cast<size_t>(reinterpret_cast<char*>(&display_colorgamut_) -
    reinterpret_cast<char*>(&idle_backlight_dim_battery_seconds_)) + sizeof(display_colorgamut_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemManagerSettings)
}

inline void CMsgSystemManagerSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&idle_backlight_dim_battery_seconds_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&display_colorgamut_) -
    reinterpret_cast<char*>(&idle_backlight_dim_battery_seconds_)) + sizeof(display_colorgamut_));
}

CMsgSystemManagerSettings::~CMsgSystemManagerSettings() {
  // @@protoc_insertion_point(destructor:CMsgSystemManagerSettings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemManagerSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemManagerSettings::ArenaDtor(void* object) {
  CMsgSystemManagerSettings* _this = reinterpret_cast< CMsgSystemManagerSettings* >(object);
  (void)_this;
}
void CMsgSystemManagerSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemManagerSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemManagerSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemManagerSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&idle_backlight_dim_battery_seconds_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_nightmode_enabled_) -
        reinterpret_cast<char*>(&idle_backlight_dim_battery_seconds_)) + sizeof(display_nightmode_enabled_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&display_nightmode_tintstrength_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_nightmode_reset_) -
        reinterpret_cast<char*>(&display_nightmode_tintstrength_)) + sizeof(display_nightmode_reset_));
  }
  if (cached_has_bits & 0x00ff0000u) {
    ::memset(&display_nightmode_schedule_enabled_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_brightness_adaptivemax_) -
        reinterpret_cast<char*>(&display_nightmode_schedule_enabled_)) + sizeof(display_brightness_adaptivemax_));
  }
  if (cached_has_bits & 0x1f000000u) {
    ::memset(&fan_control_mode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&display_colorgamut_) -
        reinterpret_cast<char*>(&fan_control_mode_)) + sizeof(display_colorgamut_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemManagerSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float idle_backlight_dim_battery_seconds = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_idle_backlight_dim_battery_seconds(&has_bits);
          idle_backlight_dim_battery_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float idle_backlight_dim_ac_seconds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_idle_backlight_dim_ac_seconds(&has_bits);
          idle_backlight_dim_ac_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float idle_suspend_battery_seconds = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_idle_suspend_battery_seconds(&has_bits);
          idle_suspend_battery_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float idle_suspend_ac_seconds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_idle_suspend_ac_seconds(&has_bits);
          idle_suspend_ac_seconds_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool idle_suspend_supressed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_idle_suspend_supressed(&has_bits);
          idle_suspend_supressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_adaptive_brightness_available = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_adaptive_brightness_available(&has_bits);
          is_adaptive_brightness_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool display_adaptive_brightness_enabled = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_display_adaptive_brightness_enabled(&has_bits);
          display_adaptive_brightness_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool display_nightmode_enabled = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_display_nightmode_enabled(&has_bits);
          display_nightmode_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_tintstrength = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_display_nightmode_tintstrength(&has_bits);
          display_nightmode_tintstrength_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_maxhue = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_display_nightmode_maxhue(&has_bits);
          display_nightmode_maxhue_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_maxsat = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_display_nightmode_maxsat(&has_bits);
          display_nightmode_maxsat_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_uiexp = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_display_nightmode_uiexp(&has_bits);
          display_nightmode_uiexp_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_blend = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          _Internal::set_has_display_nightmode_blend(&has_bits);
          display_nightmode_blend_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool display_nightmode_reset = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_display_nightmode_reset(&has_bits);
          display_nightmode_reset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool display_nightmode_schedule_enabled = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_display_nightmode_schedule_enabled(&has_bits);
          display_nightmode_schedule_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_schedule_starttime = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_display_nightmode_schedule_starttime(&has_bits);
          display_nightmode_schedule_starttime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_nightmode_schedule_endtime = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_display_nightmode_schedule_endtime(&has_bits);
          display_nightmode_schedule_endtime_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool display_diagnostics_enabled = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_display_diagnostics_enabled(&has_bits);
          display_diagnostics_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float als_lux_latest = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_als_lux_latest(&has_bits);
          als_lux_latest_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float als_lux_median = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_als_lux_median(&has_bits);
          als_lux_median_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_backlight_raw = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _Internal::set_has_display_backlight_raw(&has_bits);
          display_backlight_raw_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_brightness_adaptivemin = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _Internal::set_has_display_brightness_adaptivemin(&has_bits);
          display_brightness_adaptivemin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float display_brightness_adaptivemax = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_display_brightness_adaptivemax(&has_bits);
          display_brightness_adaptivemax_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_wifi_powersave_enabled = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_is_wifi_powersave_enabled(&has_bits);
          is_wifi_powersave_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_fan_control_available = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_is_fan_control_available(&has_bits);
          is_fan_control_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESystemFanControlMode fan_control_mode = 28 [default = k_SystemFanControlMode_Invalid];
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESystemFanControlMode_IsValid(val))) {
            _internal_set_fan_control_mode(static_cast<::ESystemFanControlMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(28, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool is_display_brightness_available = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_is_display_brightness_available(&has_bits);
          is_display_brightness_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_display_colormanagement_available = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 248)) {
          _Internal::set_has_is_display_colormanagement_available(&has_bits);
          is_display_colormanagement_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float display_colorgamut = 32;
      case 32:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 5)) {
          _Internal::set_has_display_colorgamut(&has_bits);
          display_colorgamut_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemManagerSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemManagerSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float idle_backlight_dim_battery_seconds = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_idle_backlight_dim_battery_seconds(), target);
  }

  // optional float idle_backlight_dim_ac_seconds = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_idle_backlight_dim_ac_seconds(), target);
  }

  // optional float idle_suspend_battery_seconds = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_idle_suspend_battery_seconds(), target);
  }

  // optional float idle_suspend_ac_seconds = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_idle_suspend_ac_seconds(), target);
  }

  // optional bool idle_suspend_supressed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_idle_suspend_supressed(), target);
  }

  // optional bool is_adaptive_brightness_available = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_is_adaptive_brightness_available(), target);
  }

  // optional bool display_adaptive_brightness_enabled = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_display_adaptive_brightness_enabled(), target);
  }

  // optional bool display_nightmode_enabled = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_display_nightmode_enabled(), target);
  }

  // optional float display_nightmode_tintstrength = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_display_nightmode_tintstrength(), target);
  }

  // optional float display_nightmode_maxhue = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(12, this->_internal_display_nightmode_maxhue(), target);
  }

  // optional float display_nightmode_maxsat = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(13, this->_internal_display_nightmode_maxsat(), target);
  }

  // optional float display_nightmode_uiexp = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(14, this->_internal_display_nightmode_uiexp(), target);
  }

  // optional float display_nightmode_blend = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(15, this->_internal_display_nightmode_blend(), target);
  }

  // optional bool display_nightmode_reset = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_display_nightmode_reset(), target);
  }

  // optional bool display_nightmode_schedule_enabled = 17;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_display_nightmode_schedule_enabled(), target);
  }

  // optional float display_nightmode_schedule_starttime = 18;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(18, this->_internal_display_nightmode_schedule_starttime(), target);
  }

  // optional float display_nightmode_schedule_endtime = 19;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(19, this->_internal_display_nightmode_schedule_endtime(), target);
  }

  // optional bool display_diagnostics_enabled = 20;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_display_diagnostics_enabled(), target);
  }

  // optional float als_lux_latest = 21;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(21, this->_internal_als_lux_latest(), target);
  }

  // optional float als_lux_median = 22;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(22, this->_internal_als_lux_median(), target);
  }

  // optional float display_backlight_raw = 23;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(23, this->_internal_display_backlight_raw(), target);
  }

  // optional float display_brightness_adaptivemin = 24;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(24, this->_internal_display_brightness_adaptivemin(), target);
  }

  // optional float display_brightness_adaptivemax = 25;
  if (cached_has_bits & 0x00800000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(25, this->_internal_display_brightness_adaptivemax(), target);
  }

  // optional bool is_wifi_powersave_enabled = 26;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(26, this->_internal_is_wifi_powersave_enabled(), target);
  }

  // optional bool is_fan_control_available = 27;
  if (cached_has_bits & 0x02000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(27, this->_internal_is_fan_control_available(), target);
  }

  // optional .ESystemFanControlMode fan_control_mode = 28 [default = k_SystemFanControlMode_Invalid];
  if (cached_has_bits & 0x01000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      28, this->_internal_fan_control_mode(), target);
  }

  // optional bool is_display_brightness_available = 29;
  if (cached_has_bits & 0x04000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(29, this->_internal_is_display_brightness_available(), target);
  }

  // optional bool is_display_colormanagement_available = 31;
  if (cached_has_bits & 0x08000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(31, this->_internal_is_display_colormanagement_available(), target);
  }

  // optional float display_colorgamut = 32;
  if (cached_has_bits & 0x10000000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(32, this->_internal_display_colorgamut(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemManagerSettings)
  return target;
}

size_t CMsgSystemManagerSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemManagerSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional float idle_backlight_dim_battery_seconds = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float idle_backlight_dim_ac_seconds = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float idle_suspend_battery_seconds = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float idle_suspend_ac_seconds = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool idle_suspend_supressed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool is_adaptive_brightness_available = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool display_adaptive_brightness_enabled = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool display_nightmode_enabled = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional float display_nightmode_tintstrength = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float display_nightmode_maxhue = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional float display_nightmode_maxsat = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float display_nightmode_uiexp = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional float display_nightmode_blend = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float display_nightmode_schedule_starttime = 18;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional float display_nightmode_schedule_endtime = 19;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional bool display_nightmode_reset = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00ff0000u) {
    // optional bool display_nightmode_schedule_enabled = 17;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional bool display_diagnostics_enabled = 20;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 1;
    }

    // optional bool is_wifi_powersave_enabled = 26;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 + 1;
    }

    // optional float als_lux_latest = 21;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 + 4;
    }

    // optional float als_lux_median = 22;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 + 4;
    }

    // optional float display_backlight_raw = 23;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 + 4;
    }

    // optional float display_brightness_adaptivemin = 24;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

    // optional float display_brightness_adaptivemax = 25;
    if (cached_has_bits & 0x00800000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x1f000000u) {
    // optional .ESystemFanControlMode fan_control_mode = 28 [default = k_SystemFanControlMode_Invalid];
    if (cached_has_bits & 0x01000000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_fan_control_mode());
    }

    // optional bool is_fan_control_available = 27;
    if (cached_has_bits & 0x02000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_display_brightness_available = 29;
    if (cached_has_bits & 0x04000000u) {
      total_size += 2 + 1;
    }

    // optional bool is_display_colormanagement_available = 31;
    if (cached_has_bits & 0x08000000u) {
      total_size += 2 + 1;
    }

    // optional float display_colorgamut = 32;
    if (cached_has_bits & 0x10000000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemManagerSettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemManagerSettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemManagerSettings::GetClassData() const { return &_class_data_; }

void CMsgSystemManagerSettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemManagerSettings *>(to)->MergeFrom(
      static_cast<const CMsgSystemManagerSettings &>(from));
}


void CMsgSystemManagerSettings::MergeFrom(const CMsgSystemManagerSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemManagerSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      idle_backlight_dim_battery_seconds_ = from.idle_backlight_dim_battery_seconds_;
    }
    if (cached_has_bits & 0x00000002u) {
      idle_backlight_dim_ac_seconds_ = from.idle_backlight_dim_ac_seconds_;
    }
    if (cached_has_bits & 0x00000004u) {
      idle_suspend_battery_seconds_ = from.idle_suspend_battery_seconds_;
    }
    if (cached_has_bits & 0x00000008u) {
      idle_suspend_ac_seconds_ = from.idle_suspend_ac_seconds_;
    }
    if (cached_has_bits & 0x00000010u) {
      idle_suspend_supressed_ = from.idle_suspend_supressed_;
    }
    if (cached_has_bits & 0x00000020u) {
      is_adaptive_brightness_available_ = from.is_adaptive_brightness_available_;
    }
    if (cached_has_bits & 0x00000040u) {
      display_adaptive_brightness_enabled_ = from.display_adaptive_brightness_enabled_;
    }
    if (cached_has_bits & 0x00000080u) {
      display_nightmode_enabled_ = from.display_nightmode_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      display_nightmode_tintstrength_ = from.display_nightmode_tintstrength_;
    }
    if (cached_has_bits & 0x00000200u) {
      display_nightmode_maxhue_ = from.display_nightmode_maxhue_;
    }
    if (cached_has_bits & 0x00000400u) {
      display_nightmode_maxsat_ = from.display_nightmode_maxsat_;
    }
    if (cached_has_bits & 0x00000800u) {
      display_nightmode_uiexp_ = from.display_nightmode_uiexp_;
    }
    if (cached_has_bits & 0x00001000u) {
      display_nightmode_blend_ = from.display_nightmode_blend_;
    }
    if (cached_has_bits & 0x00002000u) {
      display_nightmode_schedule_starttime_ = from.display_nightmode_schedule_starttime_;
    }
    if (cached_has_bits & 0x00004000u) {
      display_nightmode_schedule_endtime_ = from.display_nightmode_schedule_endtime_;
    }
    if (cached_has_bits & 0x00008000u) {
      display_nightmode_reset_ = from.display_nightmode_reset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00ff0000u) {
    if (cached_has_bits & 0x00010000u) {
      display_nightmode_schedule_enabled_ = from.display_nightmode_schedule_enabled_;
    }
    if (cached_has_bits & 0x00020000u) {
      display_diagnostics_enabled_ = from.display_diagnostics_enabled_;
    }
    if (cached_has_bits & 0x00040000u) {
      is_wifi_powersave_enabled_ = from.is_wifi_powersave_enabled_;
    }
    if (cached_has_bits & 0x00080000u) {
      als_lux_latest_ = from.als_lux_latest_;
    }
    if (cached_has_bits & 0x00100000u) {
      als_lux_median_ = from.als_lux_median_;
    }
    if (cached_has_bits & 0x00200000u) {
      display_backlight_raw_ = from.display_backlight_raw_;
    }
    if (cached_has_bits & 0x00400000u) {
      display_brightness_adaptivemin_ = from.display_brightness_adaptivemin_;
    }
    if (cached_has_bits & 0x00800000u) {
      display_brightness_adaptivemax_ = from.display_brightness_adaptivemax_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x1f000000u) {
    if (cached_has_bits & 0x01000000u) {
      fan_control_mode_ = from.fan_control_mode_;
    }
    if (cached_has_bits & 0x02000000u) {
      is_fan_control_available_ = from.is_fan_control_available_;
    }
    if (cached_has_bits & 0x04000000u) {
      is_display_brightness_available_ = from.is_display_brightness_available_;
    }
    if (cached_has_bits & 0x08000000u) {
      is_display_colormanagement_available_ = from.is_display_colormanagement_available_;
    }
    if (cached_has_bits & 0x10000000u) {
      display_colorgamut_ = from.display_colorgamut_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemManagerSettings::CopyFrom(const CMsgSystemManagerSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemManagerSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemManagerSettings::IsInitialized() const {
  return true;
}

void CMsgSystemManagerSettings::InternalSwap(CMsgSystemManagerSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemManagerSettings, display_colorgamut_)
      + sizeof(CMsgSystemManagerSettings::display_colorgamut_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemManagerSettings, idle_backlight_dim_battery_seconds_)>(
          reinterpret_cast<char*>(&idle_backlight_dim_battery_seconds_),
          reinterpret_cast<char*>(&other->idle_backlight_dim_battery_seconds_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemManagerSettings::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[50]);
}

// ===================================================================

class CMsgSelectOSBranchParams::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSelectOSBranchParams>()._has_bits_);
  static void set_has_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_custom_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgSelectOSBranchParams::CMsgSelectOSBranchParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSelectOSBranchParams)
}
CMsgSelectOSBranchParams::CMsgSelectOSBranchParams(const CMsgSelectOSBranchParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  custom_branch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    custom_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_custom_branch()) {
    custom_branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_custom_branch(), 
      GetArenaForAllocation());
  }
  branch_ = from.branch_;
  // @@protoc_insertion_point(copy_constructor:CMsgSelectOSBranchParams)
}

inline void CMsgSelectOSBranchParams::SharedCtor() {
custom_branch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  custom_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
branch_ = 0;
}

CMsgSelectOSBranchParams::~CMsgSelectOSBranchParams() {
  // @@protoc_insertion_point(destructor:CMsgSelectOSBranchParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSelectOSBranchParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  custom_branch_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSelectOSBranchParams::ArenaDtor(void* object) {
  CMsgSelectOSBranchParams* _this = reinterpret_cast< CMsgSelectOSBranchParams* >(object);
  (void)_this;
}
void CMsgSelectOSBranchParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSelectOSBranchParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSelectOSBranchParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSelectOSBranchParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    custom_branch_.ClearNonDefaultToEmpty();
  }
  branch_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSelectOSBranchParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EOSBranch branch = 1 [default = k_EOSBranch_Unknown];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EOSBranch_IsValid(val))) {
            _internal_set_branch(static_cast<::EOSBranch>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string custom_branch = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_custom_branch();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSelectOSBranchParams.custom_branch");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSelectOSBranchParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSelectOSBranchParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EOSBranch branch = 1 [default = k_EOSBranch_Unknown];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_branch(), target);
  }

  // optional string custom_branch = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_custom_branch().data(), static_cast<int>(this->_internal_custom_branch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSelectOSBranchParams.custom_branch");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_custom_branch(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSelectOSBranchParams)
  return target;
}

size_t CMsgSelectOSBranchParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSelectOSBranchParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string custom_branch = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_custom_branch());
    }

    // optional .EOSBranch branch = 1 [default = k_EOSBranch_Unknown];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_branch());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSelectOSBranchParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSelectOSBranchParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSelectOSBranchParams::GetClassData() const { return &_class_data_; }

void CMsgSelectOSBranchParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSelectOSBranchParams *>(to)->MergeFrom(
      static_cast<const CMsgSelectOSBranchParams &>(from));
}


void CMsgSelectOSBranchParams::MergeFrom(const CMsgSelectOSBranchParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSelectOSBranchParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_custom_branch(from._internal_custom_branch());
    }
    if (cached_has_bits & 0x00000002u) {
      branch_ = from.branch_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSelectOSBranchParams::CopyFrom(const CMsgSelectOSBranchParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSelectOSBranchParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSelectOSBranchParams::IsInitialized() const {
  return true;
}

void CMsgSelectOSBranchParams::InternalSwap(CMsgSelectOSBranchParams* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &custom_branch_, lhs_arena,
      &other->custom_branch_, rhs_arena
  );
  swap(branch_, other->branch_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSelectOSBranchParams::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[51]);
}

// ===================================================================

class CMsgSystemUpdateProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemUpdateProgress>()._has_bits_);
  static void set_has_stage_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stage_size_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rtime_estimated_completion(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSystemUpdateProgress::CMsgSystemUpdateProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemUpdateProgress)
}
CMsgSystemUpdateProgress::CMsgSystemUpdateProgress(const CMsgSystemUpdateProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&stage_size_bytes_, &from.stage_size_bytes_,
    static_cast<size_t>(reinterpret_cast<char*>(&rtime_estimated_completion_) -
    reinterpret_cast<char*>(&stage_size_bytes_)) + sizeof(rtime_estimated_completion_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemUpdateProgress)
}

inline void CMsgSystemUpdateProgress::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stage_size_bytes_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rtime_estimated_completion_) -
    reinterpret_cast<char*>(&stage_size_bytes_)) + sizeof(rtime_estimated_completion_));
}

CMsgSystemUpdateProgress::~CMsgSystemUpdateProgress() {
  // @@protoc_insertion_point(destructor:CMsgSystemUpdateProgress)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemUpdateProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemUpdateProgress::ArenaDtor(void* object) {
  CMsgSystemUpdateProgress* _this = reinterpret_cast< CMsgSystemUpdateProgress* >(object);
  (void)_this;
}
void CMsgSystemUpdateProgress::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemUpdateProgress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemUpdateProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemUpdateProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&stage_size_bytes_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rtime_estimated_completion_) -
        reinterpret_cast<char*>(&stage_size_bytes_)) + sizeof(rtime_estimated_completion_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemUpdateProgress::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float stage_progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_stage_progress(&has_bits);
          stage_progress_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int64 stage_size_bytes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_stage_size_bytes(&has_bits);
          stage_size_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtime_estimated_completion = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_rtime_estimated_completion(&has_bits);
          rtime_estimated_completion_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemUpdateProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemUpdateProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float stage_progress = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_stage_progress(), target);
  }

  // optional int64 stage_size_bytes = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt64ToArray(2, this->_internal_stage_size_bytes(), target);
  }

  // optional fixed32 rtime_estimated_completion = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_rtime_estimated_completion(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemUpdateProgress)
  return target;
}

size_t CMsgSystemUpdateProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemUpdateProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int64 stage_size_bytes = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int64SizePlusOne(this->_internal_stage_size_bytes());
    }

    // optional float stage_progress = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional fixed32 rtime_estimated_completion = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemUpdateProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemUpdateProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemUpdateProgress::GetClassData() const { return &_class_data_; }

void CMsgSystemUpdateProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemUpdateProgress *>(to)->MergeFrom(
      static_cast<const CMsgSystemUpdateProgress &>(from));
}


void CMsgSystemUpdateProgress::MergeFrom(const CMsgSystemUpdateProgress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemUpdateProgress)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      stage_size_bytes_ = from.stage_size_bytes_;
    }
    if (cached_has_bits & 0x00000002u) {
      stage_progress_ = from.stage_progress_;
    }
    if (cached_has_bits & 0x00000004u) {
      rtime_estimated_completion_ = from.rtime_estimated_completion_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemUpdateProgress::CopyFrom(const CMsgSystemUpdateProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemUpdateProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemUpdateProgress::IsInitialized() const {
  return true;
}

void CMsgSystemUpdateProgress::InternalSwap(CMsgSystemUpdateProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateProgress, rtime_estimated_completion_)
      + sizeof(CMsgSystemUpdateProgress::rtime_estimated_completion_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateProgress, stage_size_bytes_)>(
          reinterpret_cast<char*>(&stage_size_bytes_),
          reinterpret_cast<char*>(&other->stage_size_bytes_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemUpdateProgress::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[52]);
}

// ===================================================================

class CMsgSystemUpdateCheckResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemUpdateCheckResult>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_rtime_checked(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_available(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_auto_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgSystemUpdateCheckResult::CMsgSystemUpdateCheckResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemUpdateCheckResult)
}
CMsgSystemUpdateCheckResult::CMsgSystemUpdateCheckResult(const CMsgSystemUpdateCheckResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_version()) {
    version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_version(), 
      GetArenaForAllocation());
  }
  auto_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    auto_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auto_message()) {
    auto_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auto_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&eresult_) -
    reinterpret_cast<char*>(&type_)) + sizeof(eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemUpdateCheckResult)
}

inline void CMsgSystemUpdateCheckResult::SharedCtor() {
version_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
auto_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  auto_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&available_) -
    reinterpret_cast<char*>(&type_)) + sizeof(available_));
eresult_ = 2u;
}

CMsgSystemUpdateCheckResult::~CMsgSystemUpdateCheckResult() {
  // @@protoc_insertion_point(destructor:CMsgSystemUpdateCheckResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemUpdateCheckResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  version_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  auto_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgSystemUpdateCheckResult::ArenaDtor(void* object) {
  CMsgSystemUpdateCheckResult* _this = reinterpret_cast< CMsgSystemUpdateCheckResult* >(object);
  (void)_this;
}
void CMsgSystemUpdateCheckResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemUpdateCheckResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemUpdateCheckResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemUpdateCheckResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      version_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      auto_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&available_) -
        reinterpret_cast<char*>(&type_)) + sizeof(available_));
    eresult_ = 2u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemUpdateCheckResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EUpdaterType_IsValid(val))) {
            _internal_set_type(static_cast<::EUpdaterType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eresult = 2 [default = 2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_eresult(&has_bits);
          eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 rtime_checked = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_rtime_checked(&has_bits);
          rtime_checked_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool available = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_available(&has_bits);
          available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string version = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_version();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemUpdateCheckResult.version");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string auto_message = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_auto_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgSystemUpdateCheckResult.auto_message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemUpdateCheckResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemUpdateCheckResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 eresult = 2 [default = 2];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_eresult(), target);
  }

  // optional fixed32 rtime_checked = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed32ToArray(3, this->_internal_rtime_checked(), target);
  }

  // optional bool available = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_available(), target);
  }

  // optional string version = 5;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_version().data(), static_cast<int>(this->_internal_version().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemUpdateCheckResult.version");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_version(), target);
  }

  // optional string auto_message = 6;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_auto_message().data(), static_cast<int>(this->_internal_auto_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgSystemUpdateCheckResult.auto_message");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_auto_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemUpdateCheckResult)
  return target;
}

size_t CMsgSystemUpdateCheckResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemUpdateCheckResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string version = 5;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_version());
    }

    // optional string auto_message = 6;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auto_message());
    }

    // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional fixed32 rtime_checked = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool available = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional uint32 eresult = 2 [default = 2];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemUpdateCheckResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemUpdateCheckResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemUpdateCheckResult::GetClassData() const { return &_class_data_; }

void CMsgSystemUpdateCheckResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemUpdateCheckResult *>(to)->MergeFrom(
      static_cast<const CMsgSystemUpdateCheckResult &>(from));
}


void CMsgSystemUpdateCheckResult::MergeFrom(const CMsgSystemUpdateCheckResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemUpdateCheckResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_version(from._internal_version());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_auto_message(from._internal_auto_message());
    }
    if (cached_has_bits & 0x00000004u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      rtime_checked_ = from.rtime_checked_;
    }
    if (cached_has_bits & 0x00000010u) {
      available_ = from.available_;
    }
    if (cached_has_bits & 0x00000020u) {
      eresult_ = from.eresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemUpdateCheckResult::CopyFrom(const CMsgSystemUpdateCheckResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemUpdateCheckResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemUpdateCheckResult::IsInitialized() const {
  return true;
}

void CMsgSystemUpdateCheckResult::InternalSwap(CMsgSystemUpdateCheckResult* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &version_, lhs_arena,
      &other->version_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auto_message_, lhs_arena,
      &other->auto_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateCheckResult, available_)
      + sizeof(CMsgSystemUpdateCheckResult::available_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateCheckResult, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
  swap(eresult_, other->eresult_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemUpdateCheckResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[53]);
}

// ===================================================================

class CMsgSystemUpdateApplyParams::_Internal {
 public:
};

CMsgSystemUpdateApplyParams::CMsgSystemUpdateApplyParams(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  apply_types_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemUpdateApplyParams)
}
CMsgSystemUpdateApplyParams::CMsgSystemUpdateApplyParams(const CMsgSystemUpdateApplyParams& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      apply_types_(from.apply_types_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgSystemUpdateApplyParams)
}

inline void CMsgSystemUpdateApplyParams::SharedCtor() {
}

CMsgSystemUpdateApplyParams::~CMsgSystemUpdateApplyParams() {
  // @@protoc_insertion_point(destructor:CMsgSystemUpdateApplyParams)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemUpdateApplyParams::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemUpdateApplyParams::ArenaDtor(void* object) {
  CMsgSystemUpdateApplyParams* _this = reinterpret_cast< CMsgSystemUpdateApplyParams* >(object);
  (void)_this;
}
void CMsgSystemUpdateApplyParams::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemUpdateApplyParams::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemUpdateApplyParams::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemUpdateApplyParams)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  apply_types_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemUpdateApplyParams::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .EUpdaterType apply_types = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EUpdaterType_IsValid(val))) {
              _internal_add_apply_types(static_cast<::EUpdaterType>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_apply_types(), ptr, ctx, ::EUpdaterType_IsValid, &_internal_metadata_, 1);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemUpdateApplyParams::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemUpdateApplyParams)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .EUpdaterType apply_types = 1;
  for (int i = 0, n = this->_internal_apply_types_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        1, this->_internal_apply_types(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemUpdateApplyParams)
  return target;
}

size_t CMsgSystemUpdateApplyParams::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemUpdateApplyParams)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EUpdaterType apply_types = 1;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_apply_types_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_apply_types(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemUpdateApplyParams::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemUpdateApplyParams::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemUpdateApplyParams::GetClassData() const { return &_class_data_; }

void CMsgSystemUpdateApplyParams::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemUpdateApplyParams *>(to)->MergeFrom(
      static_cast<const CMsgSystemUpdateApplyParams &>(from));
}


void CMsgSystemUpdateApplyParams::MergeFrom(const CMsgSystemUpdateApplyParams& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemUpdateApplyParams)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  apply_types_.MergeFrom(from.apply_types_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemUpdateApplyParams::CopyFrom(const CMsgSystemUpdateApplyParams& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemUpdateApplyParams)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemUpdateApplyParams::IsInitialized() const {
  return true;
}

void CMsgSystemUpdateApplyParams::InternalSwap(CMsgSystemUpdateApplyParams* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  apply_types_.InternalSwap(&other->apply_types_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemUpdateApplyParams::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[54]);
}

// ===================================================================

class CMsgSystemUpdateApplyResult::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemUpdateApplyResult>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_eresult(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_requires_client_restart(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_requires_system_restart(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CMsgSystemUpdateApplyResult::CMsgSystemUpdateApplyResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemUpdateApplyResult)
}
CMsgSystemUpdateApplyResult::CMsgSystemUpdateApplyResult(const CMsgSystemUpdateApplyResult& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&eresult_) -
    reinterpret_cast<char*>(&type_)) + sizeof(eresult_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemUpdateApplyResult)
}

inline void CMsgSystemUpdateApplyResult::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&requires_system_restart_) -
    reinterpret_cast<char*>(&type_)) + sizeof(requires_system_restart_));
eresult_ = 2u;
}

CMsgSystemUpdateApplyResult::~CMsgSystemUpdateApplyResult() {
  // @@protoc_insertion_point(destructor:CMsgSystemUpdateApplyResult)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemUpdateApplyResult::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgSystemUpdateApplyResult::ArenaDtor(void* object) {
  CMsgSystemUpdateApplyResult* _this = reinterpret_cast< CMsgSystemUpdateApplyResult* >(object);
  (void)_this;
}
void CMsgSystemUpdateApplyResult::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemUpdateApplyResult::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemUpdateApplyResult::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemUpdateApplyResult)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&requires_system_restart_) -
        reinterpret_cast<char*>(&type_)) + sizeof(requires_system_restart_));
    eresult_ = 2u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemUpdateApplyResult::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EUpdaterType_IsValid(val))) {
            _internal_set_type(static_cast<::EUpdaterType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 eresult = 2 [default = 2];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_eresult(&has_bits);
          eresult_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool requires_client_restart = 3 [default = false];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_requires_client_restart(&has_bits);
          requires_client_restart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool requires_system_restart = 4 [default = false];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_requires_system_restart(&has_bits);
          requires_system_restart_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemUpdateApplyResult::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemUpdateApplyResult)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 eresult = 2 [default = 2];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_eresult(), target);
  }

  // optional bool requires_client_restart = 3 [default = false];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_requires_client_restart(), target);
  }

  // optional bool requires_system_restart = 4 [default = false];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_requires_system_restart(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemUpdateApplyResult)
  return target;
}

size_t CMsgSystemUpdateApplyResult::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemUpdateApplyResult)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .EUpdaterType type = 1 [default = k_EUpdaterType_Invalid];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional bool requires_client_restart = 3 [default = false];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool requires_system_restart = 4 [default = false];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional uint32 eresult = 2 [default = 2];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_eresult());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemUpdateApplyResult::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemUpdateApplyResult::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemUpdateApplyResult::GetClassData() const { return &_class_data_; }

void CMsgSystemUpdateApplyResult::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemUpdateApplyResult *>(to)->MergeFrom(
      static_cast<const CMsgSystemUpdateApplyResult &>(from));
}


void CMsgSystemUpdateApplyResult::MergeFrom(const CMsgSystemUpdateApplyResult& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemUpdateApplyResult)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      requires_client_restart_ = from.requires_client_restart_;
    }
    if (cached_has_bits & 0x00000004u) {
      requires_system_restart_ = from.requires_system_restart_;
    }
    if (cached_has_bits & 0x00000008u) {
      eresult_ = from.eresult_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemUpdateApplyResult::CopyFrom(const CMsgSystemUpdateApplyResult& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemUpdateApplyResult)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemUpdateApplyResult::IsInitialized() const {
  return true;
}

void CMsgSystemUpdateApplyResult::InternalSwap(CMsgSystemUpdateApplyResult* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateApplyResult, requires_system_restart_)
      + sizeof(CMsgSystemUpdateApplyResult::requires_system_restart_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateApplyResult, type_)>(
          reinterpret_cast<char*>(&type_),
          reinterpret_cast<char*>(&other->type_));
  swap(eresult_, other->eresult_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemUpdateApplyResult::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[55]);
}

// ===================================================================

class CMsgSystemUpdateState::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgSystemUpdateState>()._has_bits_);
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgSystemUpdateProgress& progress(const CMsgSystemUpdateState* msg);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_os_updates(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgSystemUpdateProgress&
CMsgSystemUpdateState::_Internal::progress(const CMsgSystemUpdateState* msg) {
  return *msg->progress_;
}
CMsgSystemUpdateState::CMsgSystemUpdateState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  update_check_results_(arena),
  update_apply_results_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgSystemUpdateState)
}
CMsgSystemUpdateState::CMsgSystemUpdateState(const CMsgSystemUpdateState& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      update_check_results_(from.update_check_results_),
      update_apply_results_(from.update_apply_results_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_progress()) {
    progress_ = new ::CMsgSystemUpdateProgress(*from.progress_);
  } else {
    progress_ = nullptr;
  }
  ::memcpy(&state_, &from.state_,
    static_cast<size_t>(reinterpret_cast<char*>(&supports_os_updates_) -
    reinterpret_cast<char*>(&state_)) + sizeof(supports_os_updates_));
  // @@protoc_insertion_point(copy_constructor:CMsgSystemUpdateState)
}

inline void CMsgSystemUpdateState::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&progress_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&supports_os_updates_) -
    reinterpret_cast<char*>(&progress_)) + sizeof(supports_os_updates_));
}

CMsgSystemUpdateState::~CMsgSystemUpdateState() {
  // @@protoc_insertion_point(destructor:CMsgSystemUpdateState)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgSystemUpdateState::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete progress_;
}

void CMsgSystemUpdateState::ArenaDtor(void* object) {
  CMsgSystemUpdateState* _this = reinterpret_cast< CMsgSystemUpdateState* >(object);
  (void)_this;
}
void CMsgSystemUpdateState::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgSystemUpdateState::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgSystemUpdateState::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgSystemUpdateState)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  update_check_results_.Clear();
  update_apply_results_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(progress_ != nullptr);
    progress_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&state_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&supports_os_updates_) -
        reinterpret_cast<char*>(&state_)) + sizeof(supports_os_updates_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgSystemUpdateState::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EUpdaterState_IsValid(val))) {
            _internal_set_state(static_cast<::EUpdaterState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgSystemUpdateProgress progress = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_progress(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemUpdateCheckResult update_check_results = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_check_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgSystemUpdateApplyResult update_apply_results = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_update_apply_results(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_os_updates = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_supports_os_updates(&has_bits);
          supports_os_updates_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgSystemUpdateState::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgSystemUpdateState)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_state(), target);
  }

  // optional .CMsgSystemUpdateProgress progress = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::progress(this), target, stream);
  }

  // repeated .CMsgSystemUpdateCheckResult update_check_results = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_check_results_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_update_check_results(i), target, stream);
  }

  // repeated .CMsgSystemUpdateApplyResult update_apply_results = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_update_apply_results_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_update_apply_results(i), target, stream);
  }

  // optional bool supports_os_updates = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_supports_os_updates(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgSystemUpdateState)
  return target;
}

size_t CMsgSystemUpdateState::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgSystemUpdateState)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgSystemUpdateCheckResult update_check_results = 3;
  total_size += 1UL * this->_internal_update_check_results_size();
  for (const auto& msg : this->update_check_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgSystemUpdateApplyResult update_apply_results = 4;
  total_size += 1UL * this->_internal_update_apply_results_size();
  for (const auto& msg : this->update_apply_results_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgSystemUpdateProgress progress = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *progress_);
    }

    // optional .EUpdaterState state = 1 [default = k_EUpdaterState_Invalid];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_state());
    }

    // optional bool supports_os_updates = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgSystemUpdateState::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgSystemUpdateState::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgSystemUpdateState::GetClassData() const { return &_class_data_; }

void CMsgSystemUpdateState::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgSystemUpdateState *>(to)->MergeFrom(
      static_cast<const CMsgSystemUpdateState &>(from));
}


void CMsgSystemUpdateState::MergeFrom(const CMsgSystemUpdateState& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgSystemUpdateState)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  update_check_results_.MergeFrom(from.update_check_results_);
  update_apply_results_.MergeFrom(from.update_apply_results_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_progress()->::CMsgSystemUpdateProgress::MergeFrom(from._internal_progress());
    }
    if (cached_has_bits & 0x00000002u) {
      state_ = from.state_;
    }
    if (cached_has_bits & 0x00000004u) {
      supports_os_updates_ = from.supports_os_updates_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgSystemUpdateState::CopyFrom(const CMsgSystemUpdateState& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgSystemUpdateState)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgSystemUpdateState::IsInitialized() const {
  return true;
}

void CMsgSystemUpdateState::InternalSwap(CMsgSystemUpdateState* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  update_check_results_.InternalSwap(&other->update_check_results_);
  update_apply_results_.InternalSwap(&other->update_apply_results_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateState, supports_os_updates_)
      + sizeof(CMsgSystemUpdateState::supports_os_updates_)
      - PROTOBUF_FIELD_OFFSET(CMsgSystemUpdateState, progress_)>(
          reinterpret_cast<char*>(&progress_),
          reinterpret_cast<char*>(&other->progress_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgSystemUpdateState::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[56]);
}

// ===================================================================

class CMsgAchievementChange::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgAchievementChange>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgAchievementChange::CMsgAchievementChange(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgAchievementChange)
}
CMsgAchievementChange::CMsgAchievementChange(const CMsgAchievementChange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CMsgAchievementChange)
}

inline void CMsgAchievementChange::SharedCtor() {
appid_ = 0u;
}

CMsgAchievementChange::~CMsgAchievementChange() {
  // @@protoc_insertion_point(destructor:CMsgAchievementChange)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgAchievementChange::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgAchievementChange::ArenaDtor(void* object) {
  CMsgAchievementChange* _this = reinterpret_cast< CMsgAchievementChange* >(object);
  (void)_this;
}
void CMsgAchievementChange::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgAchievementChange::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgAchievementChange::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgAchievementChange)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgAchievementChange::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgAchievementChange::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgAchievementChange)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgAchievementChange)
  return target;
}

size_t CMsgAchievementChange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgAchievementChange)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 appid = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgAchievementChange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgAchievementChange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgAchievementChange::GetClassData() const { return &_class_data_; }

void CMsgAchievementChange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgAchievementChange *>(to)->MergeFrom(
      static_cast<const CMsgAchievementChange &>(from));
}


void CMsgAchievementChange::MergeFrom(const CMsgAchievementChange& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgAchievementChange)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_appid()) {
    _internal_set_appid(from._internal_appid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgAchievementChange::CopyFrom(const CMsgAchievementChange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgAchievementChange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgAchievementChange::IsInitialized() const {
  return true;
}

void CMsgAchievementChange::InternalSwap(CMsgAchievementChange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgAchievementChange::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[57]);
}

// ===================================================================

class CMsgCellList_Cell::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgCellList_Cell>()._has_bits_);
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_loc_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgCellList_Cell::CMsgCellList_Cell(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgCellList.Cell)
}
CMsgCellList_Cell::CMsgCellList_Cell(const CMsgCellList_Cell& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  loc_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    loc_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_loc_name()) {
    loc_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_loc_name(), 
      GetArenaForAllocation());
  }
  cell_id_ = from.cell_id_;
  // @@protoc_insertion_point(copy_constructor:CMsgCellList.Cell)
}

inline void CMsgCellList_Cell::SharedCtor() {
loc_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  loc_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
cell_id_ = 0u;
}

CMsgCellList_Cell::~CMsgCellList_Cell() {
  // @@protoc_insertion_point(destructor:CMsgCellList.Cell)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgCellList_Cell::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  loc_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgCellList_Cell::ArenaDtor(void* object) {
  CMsgCellList_Cell* _this = reinterpret_cast< CMsgCellList_Cell* >(object);
  (void)_this;
}
void CMsgCellList_Cell::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgCellList_Cell::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgCellList_Cell::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCellList.Cell)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    loc_name_.ClearNonDefaultToEmpty();
  }
  cell_id_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCellList_Cell::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 cell_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cell_id(&has_bits);
          cell_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string loc_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_loc_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgCellList.Cell.loc_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCellList_Cell::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCellList.Cell)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 cell_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_cell_id(), target);
  }

  // optional string loc_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_loc_name().data(), static_cast<int>(this->_internal_loc_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgCellList.Cell.loc_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_loc_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCellList.Cell)
  return target;
}

size_t CMsgCellList_Cell::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCellList.Cell)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string loc_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_loc_name());
    }

    // optional uint32 cell_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cell_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCellList_Cell::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgCellList_Cell::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCellList_Cell::GetClassData() const { return &_class_data_; }

void CMsgCellList_Cell::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgCellList_Cell *>(to)->MergeFrom(
      static_cast<const CMsgCellList_Cell &>(from));
}


void CMsgCellList_Cell::MergeFrom(const CMsgCellList_Cell& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgCellList.Cell)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_loc_name(from._internal_loc_name());
    }
    if (cached_has_bits & 0x00000002u) {
      cell_id_ = from.cell_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCellList_Cell::CopyFrom(const CMsgCellList_Cell& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCellList.Cell)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCellList_Cell::IsInitialized() const {
  return true;
}

void CMsgCellList_Cell::InternalSwap(CMsgCellList_Cell* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &loc_name_, lhs_arena,
      &other->loc_name_, rhs_arena
  );
  swap(cell_id_, other->cell_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCellList_Cell::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[58]);
}

// ===================================================================

class CMsgCellList::_Internal {
 public:
};

CMsgCellList::CMsgCellList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  cells_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgCellList)
}
CMsgCellList::CMsgCellList(const CMsgCellList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      cells_(from.cells_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgCellList)
}

inline void CMsgCellList::SharedCtor() {
}

CMsgCellList::~CMsgCellList() {
  // @@protoc_insertion_point(destructor:CMsgCellList)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgCellList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgCellList::ArenaDtor(void* object) {
  CMsgCellList* _this = reinterpret_cast< CMsgCellList* >(object);
  (void)_this;
}
void CMsgCellList::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgCellList::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgCellList::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgCellList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cells_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgCellList::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgCellList.Cell cells = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_cells(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgCellList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgCellList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgCellList.Cell cells = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_cells_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_cells(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgCellList)
  return target;
}

size_t CMsgCellList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgCellList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgCellList.Cell cells = 1;
  total_size += 1UL * this->_internal_cells_size();
  for (const auto& msg : this->cells_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgCellList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgCellList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgCellList::GetClassData() const { return &_class_data_; }

void CMsgCellList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgCellList *>(to)->MergeFrom(
      static_cast<const CMsgCellList &>(from));
}


void CMsgCellList::MergeFrom(const CMsgCellList& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgCellList)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cells_.MergeFrom(from.cells_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgCellList::CopyFrom(const CMsgCellList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgCellList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgCellList::IsInitialized() const {
  return true;
}

void CMsgCellList::InternalSwap(CMsgCellList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  cells_.InternalSwap(&other->cells_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgCellList::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[59]);
}

// ===================================================================

class CMsgShortcutInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgShortcutInfo>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_exe(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_start_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_args(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_app_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_override_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_flatpak_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_is_remote(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_is_hidden(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_is_temporary(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_is_openvr(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_allow_desktop_config(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_allow_overlay(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_rt_last_played_time(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_is_devkit_shortcut(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_devkit_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgShortcutInfo::CMsgShortcutInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  tags_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgShortcutInfo)
}
CMsgShortcutInfo::CMsgShortcutInfo(const CMsgShortcutInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      tags_(from.tags_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  exe_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    exe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_exe()) {
    exe_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_exe(), 
      GetArenaForAllocation());
  }
  start_dir_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    start_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_start_dir()) {
    start_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_start_dir(), 
      GetArenaForAllocation());
  }
  icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_icon()) {
    icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_icon(), 
      GetArenaForAllocation());
  }
  path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_path(), 
      GetArenaForAllocation());
  }
  args_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    args_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_args()) {
    args_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_args(), 
      GetArenaForAllocation());
  }
  app_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    app_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_name()) {
    app_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_app_name(), 
      GetArenaForAllocation());
  }
  flatpak_appid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    flatpak_appid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_flatpak_appid()) {
    flatpak_appid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_flatpak_appid(), 
      GetArenaForAllocation());
  }
  devkit_gameid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    devkit_gameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_devkit_gameid()) {
    devkit_gameid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_devkit_gameid(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&rt_last_played_time_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(rt_last_played_time_));
  // @@protoc_insertion_point(copy_constructor:CMsgShortcutInfo)
}

inline void CMsgShortcutInfo::SharedCtor() {
exe_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  exe_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
start_dir_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  start_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
args_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  args_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
app_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  app_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
flatpak_appid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  flatpak_appid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
devkit_gameid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  devkit_gameid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&rt_last_played_time_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(rt_last_played_time_));
}

CMsgShortcutInfo::~CMsgShortcutInfo() {
  // @@protoc_insertion_point(destructor:CMsgShortcutInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgShortcutInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  exe_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  start_dir_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  icon_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  args_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  app_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  flatpak_appid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  devkit_gameid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgShortcutInfo::ArenaDtor(void* object) {
  CMsgShortcutInfo* _this = reinterpret_cast< CMsgShortcutInfo* >(object);
  (void)_this;
}
void CMsgShortcutInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgShortcutInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgShortcutInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgShortcutInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  tags_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      exe_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      start_dir_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      icon_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      args_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      app_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      flatpak_appid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000080u) {
      devkit_gameid_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_overlay_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(allow_overlay_));
  }
  if (cached_has_bits & 0x00030000u) {
    ::memset(&is_devkit_shortcut_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&rt_last_played_time_) -
        reinterpret_cast<char*>(&is_devkit_shortcut_)) + sizeof(rt_last_played_time_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgShortcutInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string exe = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_exe();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.exe");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string start_dir = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_start_dir();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.start_dir");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string icon = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_icon();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.icon");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string path = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string args = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_args();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.args");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string app_name = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_app_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.app_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 override_appid = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_override_appid(&has_bits);
          override_appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string flatpak_appid = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_flatpak_appid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.flatpak_appid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated string tags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_tags();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            #ifndef NDEBUG
            ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.tags");
            #endif  // !NDEBUG
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<82>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool is_remote = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_is_remote(&has_bits);
          is_remote_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hidden = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_is_hidden(&has_bits);
          is_hidden_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_temporary = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_is_temporary(&has_bits);
          is_temporary_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_openvr = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_is_openvr(&has_bits);
          is_openvr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_desktop_config = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_allow_desktop_config(&has_bits);
          allow_desktop_config_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_overlay = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_allow_overlay(&has_bits);
          allow_overlay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 rt_last_played_time = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_rt_last_played_time(&has_bits);
          rt_last_played_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_devkit_shortcut = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_is_devkit_shortcut(&has_bits);
          is_devkit_shortcut_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string devkit_gameid = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          auto str = _internal_mutable_devkit_gameid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgShortcutInfo.devkit_gameid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgShortcutInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgShortcutInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string exe = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_exe().data(), static_cast<int>(this->_internal_exe().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.exe");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_exe(), target);
  }

  // optional string start_dir = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_start_dir().data(), static_cast<int>(this->_internal_start_dir().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.start_dir");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_start_dir(), target);
  }

  // optional string icon = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.icon");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_icon(), target);
  }

  // optional string path = 5;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.path");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_path(), target);
  }

  // optional string args = 6;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_args().data(), static_cast<int>(this->_internal_args().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.args");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_args(), target);
  }

  // optional string app_name = 7;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_app_name().data(), static_cast<int>(this->_internal_app_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.app_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_app_name(), target);
  }

  // optional uint32 override_appid = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_override_appid(), target);
  }

  // optional string flatpak_appid = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_flatpak_appid().data(), static_cast<int>(this->_internal_flatpak_appid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.flatpak_appid");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_flatpak_appid(), target);
  }

  // repeated string tags = 10;
  for (int i = 0, n = this->_internal_tags_size(); i < n; i++) {
    const auto& s = this->_internal_tags(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.tags");
    target = stream->WriteString(10, s, target);
  }

  // optional bool is_remote = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_is_remote(), target);
  }

  // optional bool is_hidden = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_is_hidden(), target);
  }

  // optional bool is_temporary = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_is_temporary(), target);
  }

  // optional bool is_openvr = 14;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_is_openvr(), target);
  }

  // optional bool allow_desktop_config = 15;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_allow_desktop_config(), target);
  }

  // optional bool allow_overlay = 16;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(16, this->_internal_allow_overlay(), target);
  }

  // optional uint32 rt_last_played_time = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(17, this->_internal_rt_last_played_time(), target);
  }

  // optional bool is_devkit_shortcut = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(18, this->_internal_is_devkit_shortcut(), target);
  }

  // optional string devkit_gameid = 19;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_devkit_gameid().data(), static_cast<int>(this->_internal_devkit_gameid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgShortcutInfo.devkit_gameid");
    target = stream->WriteStringMaybeAliased(
        19, this->_internal_devkit_gameid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgShortcutInfo)
  return target;
}

size_t CMsgShortcutInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgShortcutInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string tags = 10;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(tags_.size());
  for (int i = 0, n = tags_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      tags_.Get(i));
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string exe = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_exe());
    }

    // optional string start_dir = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_start_dir());
    }

    // optional string icon = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_icon());
    }

    // optional string path = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional string args = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_args());
    }

    // optional string app_name = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_name());
    }

    // optional string flatpak_appid = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_flatpak_appid());
    }

    // optional string devkit_gameid = 19;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_devkit_gameid());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 override_appid = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_override_appid());
    }

    // optional bool is_remote = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool is_hidden = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool is_temporary = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

    // optional bool is_openvr = 14;
    if (cached_has_bits & 0x00002000u) {
      total_size += 1 + 1;
    }

    // optional bool allow_desktop_config = 15;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool allow_overlay = 16;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00030000u) {
    // optional bool is_devkit_shortcut = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 1;
    }

    // optional uint32 rt_last_played_time = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_rt_last_played_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgShortcutInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgShortcutInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgShortcutInfo::GetClassData() const { return &_class_data_; }

void CMsgShortcutInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgShortcutInfo *>(to)->MergeFrom(
      static_cast<const CMsgShortcutInfo &>(from));
}


void CMsgShortcutInfo::MergeFrom(const CMsgShortcutInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgShortcutInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  tags_.MergeFrom(from.tags_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_exe(from._internal_exe());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_start_dir(from._internal_start_dir());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_icon(from._internal_icon());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_args(from._internal_args());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_app_name(from._internal_app_name());
    }
    if (cached_has_bits & 0x00000040u) {
      _internal_set_flatpak_appid(from._internal_flatpak_appid());
    }
    if (cached_has_bits & 0x00000080u) {
      _internal_set_devkit_gameid(from._internal_devkit_gameid());
    }
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000200u) {
      override_appid_ = from.override_appid_;
    }
    if (cached_has_bits & 0x00000400u) {
      is_remote_ = from.is_remote_;
    }
    if (cached_has_bits & 0x00000800u) {
      is_hidden_ = from.is_hidden_;
    }
    if (cached_has_bits & 0x00001000u) {
      is_temporary_ = from.is_temporary_;
    }
    if (cached_has_bits & 0x00002000u) {
      is_openvr_ = from.is_openvr_;
    }
    if (cached_has_bits & 0x00004000u) {
      allow_desktop_config_ = from.allow_desktop_config_;
    }
    if (cached_has_bits & 0x00008000u) {
      allow_overlay_ = from.allow_overlay_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00030000u) {
    if (cached_has_bits & 0x00010000u) {
      is_devkit_shortcut_ = from.is_devkit_shortcut_;
    }
    if (cached_has_bits & 0x00020000u) {
      rt_last_played_time_ = from.rt_last_played_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgShortcutInfo::CopyFrom(const CMsgShortcutInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgShortcutInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgShortcutInfo::IsInitialized() const {
  return true;
}

void CMsgShortcutInfo::InternalSwap(CMsgShortcutInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  tags_.InternalSwap(&other->tags_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &exe_, lhs_arena,
      &other->exe_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &start_dir_, lhs_arena,
      &other->start_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &icon_, lhs_arena,
      &other->icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &path_, lhs_arena,
      &other->path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &args_, lhs_arena,
      &other->args_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &app_name_, lhs_arena,
      &other->app_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &flatpak_appid_, lhs_arena,
      &other->flatpak_appid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &devkit_gameid_, lhs_arena,
      &other->devkit_gameid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgShortcutInfo, rt_last_played_time_)
      + sizeof(CMsgShortcutInfo::rt_last_played_time_)
      - PROTOBUF_FIELD_OFFSET(CMsgShortcutInfo, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgShortcutInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[60]);
}

// ===================================================================

class CMsgShortcutAppIds::_Internal {
 public:
};

CMsgShortcutAppIds::CMsgShortcutAppIds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  appids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgShortcutAppIds)
}
CMsgShortcutAppIds::CMsgShortcutAppIds(const CMsgShortcutAppIds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      appids_(from.appids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CMsgShortcutAppIds)
}

inline void CMsgShortcutAppIds::SharedCtor() {
}

CMsgShortcutAppIds::~CMsgShortcutAppIds() {
  // @@protoc_insertion_point(destructor:CMsgShortcutAppIds)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgShortcutAppIds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgShortcutAppIds::ArenaDtor(void* object) {
  CMsgShortcutAppIds* _this = reinterpret_cast< CMsgShortcutAppIds* >(object);
  (void)_this;
}
void CMsgShortcutAppIds::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgShortcutAppIds::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgShortcutAppIds::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgShortcutAppIds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgShortcutAppIds::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 appids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgShortcutAppIds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgShortcutAppIds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 appids = 1;
  for (int i = 0, n = this->_internal_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgShortcutAppIds)
  return target;
}

size_t CMsgShortcutAppIds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgShortcutAppIds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 appids = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->appids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_appids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgShortcutAppIds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgShortcutAppIds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgShortcutAppIds::GetClassData() const { return &_class_data_; }

void CMsgShortcutAppIds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgShortcutAppIds *>(to)->MergeFrom(
      static_cast<const CMsgShortcutAppIds &>(from));
}


void CMsgShortcutAppIds::MergeFrom(const CMsgShortcutAppIds& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgShortcutAppIds)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  appids_.MergeFrom(from.appids_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgShortcutAppIds::CopyFrom(const CMsgShortcutAppIds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgShortcutAppIds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgShortcutAppIds::IsInitialized() const {
  return true;
}

void CMsgShortcutAppIds::InternalSwap(CMsgShortcutAppIds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  appids_.InternalSwap(&other->appids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgShortcutAppIds::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[61]);
}

// ===================================================================

class CMsgMonitorInfo_MonitorInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonitorInfo_MonitorInfo>()._has_bits_);
  static void set_has_monitor_device_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_monitor_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CMsgMonitorInfo_MonitorInfo::CMsgMonitorInfo_MonitorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgMonitorInfo.MonitorInfo)
}
CMsgMonitorInfo_MonitorInfo::CMsgMonitorInfo_MonitorInfo(const CMsgMonitorInfo_MonitorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  monitor_device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    monitor_device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_monitor_device_name()) {
    monitor_device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_monitor_device_name(), 
      GetArenaForAllocation());
  }
  monitor_display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    monitor_display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_monitor_display_name()) {
    monitor_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_monitor_display_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgMonitorInfo.MonitorInfo)
}

inline void CMsgMonitorInfo_MonitorInfo::SharedCtor() {
monitor_device_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  monitor_device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
monitor_display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  monitor_display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgMonitorInfo_MonitorInfo::~CMsgMonitorInfo_MonitorInfo() {
  // @@protoc_insertion_point(destructor:CMsgMonitorInfo.MonitorInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgMonitorInfo_MonitorInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  monitor_device_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  monitor_display_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgMonitorInfo_MonitorInfo::ArenaDtor(void* object) {
  CMsgMonitorInfo_MonitorInfo* _this = reinterpret_cast< CMsgMonitorInfo_MonitorInfo* >(object);
  (void)_this;
}
void CMsgMonitorInfo_MonitorInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgMonitorInfo_MonitorInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgMonitorInfo_MonitorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonitorInfo.MonitorInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      monitor_device_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      monitor_display_name_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonitorInfo_MonitorInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string monitor_device_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_monitor_device_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgMonitorInfo.MonitorInfo.monitor_device_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string monitor_display_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_monitor_display_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgMonitorInfo.MonitorInfo.monitor_display_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonitorInfo_MonitorInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonitorInfo.MonitorInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string monitor_device_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_monitor_device_name().data(), static_cast<int>(this->_internal_monitor_device_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgMonitorInfo.MonitorInfo.monitor_device_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_monitor_device_name(), target);
  }

  // required string monitor_display_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_monitor_display_name().data(), static_cast<int>(this->_internal_monitor_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgMonitorInfo.MonitorInfo.monitor_display_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_monitor_display_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonitorInfo.MonitorInfo)
  return target;
}

size_t CMsgMonitorInfo_MonitorInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CMsgMonitorInfo.MonitorInfo)
  size_t total_size = 0;

  if (_internal_has_monitor_device_name()) {
    // required string monitor_device_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_device_name());
  }

  if (_internal_has_monitor_display_name()) {
    // required string monitor_display_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_display_name());
  }

  return total_size;
}
size_t CMsgMonitorInfo_MonitorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonitorInfo.MonitorInfo)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string monitor_device_name = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_device_name());

    // required string monitor_display_name = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_monitor_display_name());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonitorInfo_MonitorInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgMonitorInfo_MonitorInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonitorInfo_MonitorInfo::GetClassData() const { return &_class_data_; }

void CMsgMonitorInfo_MonitorInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgMonitorInfo_MonitorInfo *>(to)->MergeFrom(
      static_cast<const CMsgMonitorInfo_MonitorInfo &>(from));
}


void CMsgMonitorInfo_MonitorInfo::MergeFrom(const CMsgMonitorInfo_MonitorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonitorInfo.MonitorInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_monitor_device_name(from._internal_monitor_device_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_monitor_display_name(from._internal_monitor_display_name());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonitorInfo_MonitorInfo::CopyFrom(const CMsgMonitorInfo_MonitorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonitorInfo.MonitorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonitorInfo_MonitorInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CMsgMonitorInfo_MonitorInfo::InternalSwap(CMsgMonitorInfo_MonitorInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &monitor_device_name_, lhs_arena,
      &other->monitor_device_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &monitor_display_name_, lhs_arena,
      &other->monitor_display_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonitorInfo_MonitorInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[62]);
}

// ===================================================================

class CMsgMonitorInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgMonitorInfo>()._has_bits_);
  static void set_has_selected_display_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CMsgMonitorInfo::CMsgMonitorInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  monitors_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgMonitorInfo)
}
CMsgMonitorInfo::CMsgMonitorInfo(const CMsgMonitorInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      monitors_(from.monitors_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  selected_display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    selected_display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_selected_display_name()) {
    selected_display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_selected_display_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgMonitorInfo)
}

inline void CMsgMonitorInfo::SharedCtor() {
selected_display_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  selected_display_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgMonitorInfo::~CMsgMonitorInfo() {
  // @@protoc_insertion_point(destructor:CMsgMonitorInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgMonitorInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  selected_display_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgMonitorInfo::ArenaDtor(void* object) {
  CMsgMonitorInfo* _this = reinterpret_cast< CMsgMonitorInfo* >(object);
  (void)_this;
}
void CMsgMonitorInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgMonitorInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgMonitorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgMonitorInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  monitors_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    selected_display_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgMonitorInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required string selected_display_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_selected_display_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgMonitorInfo.selected_display_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgMonitorInfo.MonitorInfo monitors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_monitors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgMonitorInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgMonitorInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required string selected_display_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_selected_display_name().data(), static_cast<int>(this->_internal_selected_display_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgMonitorInfo.selected_display_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_selected_display_name(), target);
  }

  // repeated .CMsgMonitorInfo.MonitorInfo monitors = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_monitors_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_monitors(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgMonitorInfo)
  return target;
}

size_t CMsgMonitorInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgMonitorInfo)
  size_t total_size = 0;

  // required string selected_display_name = 1;
  if (_internal_has_selected_display_name()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_selected_display_name());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgMonitorInfo.MonitorInfo monitors = 2;
  total_size += 1UL * this->_internal_monitors_size();
  for (const auto& msg : this->monitors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgMonitorInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgMonitorInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgMonitorInfo::GetClassData() const { return &_class_data_; }

void CMsgMonitorInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgMonitorInfo *>(to)->MergeFrom(
      static_cast<const CMsgMonitorInfo &>(from));
}


void CMsgMonitorInfo::MergeFrom(const CMsgMonitorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgMonitorInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  monitors_.MergeFrom(from.monitors_);
  if (from._internal_has_selected_display_name()) {
    _internal_set_selected_display_name(from._internal_selected_display_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgMonitorInfo::CopyFrom(const CMsgMonitorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgMonitorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgMonitorInfo::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(monitors_))
    return false;
  return true;
}

void CMsgMonitorInfo::InternalSwap(CMsgMonitorInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  monitors_.InternalSwap(&other->monitors_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &selected_display_name_, lhs_arena,
      &other->selected_display_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgMonitorInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[63]);
}

// ===================================================================

class CMsgGenerateSystemReportReply::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgGenerateSystemReportReply>()._has_bits_);
  static void set_has_report_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgGenerateSystemReportReply::CMsgGenerateSystemReportReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgGenerateSystemReportReply)
}
CMsgGenerateSystemReportReply::CMsgGenerateSystemReportReply(const CMsgGenerateSystemReportReply& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  report_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    report_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_report_id()) {
    report_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_report_id(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CMsgGenerateSystemReportReply)
}

inline void CMsgGenerateSystemReportReply::SharedCtor() {
report_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  report_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgGenerateSystemReportReply::~CMsgGenerateSystemReportReply() {
  // @@protoc_insertion_point(destructor:CMsgGenerateSystemReportReply)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgGenerateSystemReportReply::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  report_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgGenerateSystemReportReply::ArenaDtor(void* object) {
  CMsgGenerateSystemReportReply* _this = reinterpret_cast< CMsgGenerateSystemReportReply* >(object);
  (void)_this;
}
void CMsgGenerateSystemReportReply::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgGenerateSystemReportReply::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgGenerateSystemReportReply::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgGenerateSystemReportReply)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    report_id_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgGenerateSystemReportReply::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string report_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_report_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgGenerateSystemReportReply.report_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgGenerateSystemReportReply::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgGenerateSystemReportReply)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string report_id = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_report_id().data(), static_cast<int>(this->_internal_report_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgGenerateSystemReportReply.report_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_report_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgGenerateSystemReportReply)
  return target;
}

size_t CMsgGenerateSystemReportReply::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgGenerateSystemReportReply)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string report_id = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_report_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgGenerateSystemReportReply::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgGenerateSystemReportReply::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgGenerateSystemReportReply::GetClassData() const { return &_class_data_; }

void CMsgGenerateSystemReportReply::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgGenerateSystemReportReply *>(to)->MergeFrom(
      static_cast<const CMsgGenerateSystemReportReply &>(from));
}


void CMsgGenerateSystemReportReply::MergeFrom(const CMsgGenerateSystemReportReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgGenerateSystemReportReply)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_report_id()) {
    _internal_set_report_id(from._internal_report_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgGenerateSystemReportReply::CopyFrom(const CMsgGenerateSystemReportReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgGenerateSystemReportReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgGenerateSystemReportReply::IsInitialized() const {
  return true;
}

void CMsgGenerateSystemReportReply::InternalSwap(CMsgGenerateSystemReportReply* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &report_id_, lhs_arena,
      &other->report_id_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgGenerateSystemReportReply::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[64]);
}

// ===================================================================

class CMsgWebUITransportInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgWebUITransportInfo>()._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_auth_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgWebUITransportInfo::CMsgWebUITransportInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CMsgWebUITransportInfo)
}
CMsgWebUITransportInfo::CMsgWebUITransportInfo(const CMsgWebUITransportInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_auth_key()) {
    auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_auth_key(), 
      GetArenaForAllocation());
  }
  port_ = from.port_;
  // @@protoc_insertion_point(copy_constructor:CMsgWebUITransportInfo)
}

inline void CMsgWebUITransportInfo::SharedCtor() {
auth_key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
port_ = 0u;
}

CMsgWebUITransportInfo::~CMsgWebUITransportInfo() {
  // @@protoc_insertion_point(destructor:CMsgWebUITransportInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CMsgWebUITransportInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  auth_key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CMsgWebUITransportInfo::ArenaDtor(void* object) {
  CMsgWebUITransportInfo* _this = reinterpret_cast< CMsgWebUITransportInfo* >(object);
  (void)_this;
}
void CMsgWebUITransportInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CMsgWebUITransportInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CMsgWebUITransportInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgWebUITransportInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    auth_key_.ClearNonDefaultToEmpty();
  }
  port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgWebUITransportInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string auth_key = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_auth_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CMsgWebUITransportInfo.auth_key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgWebUITransportInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgWebUITransportInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 port = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_port(), target);
  }

  // optional string auth_key = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_auth_key().data(), static_cast<int>(this->_internal_auth_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgWebUITransportInfo.auth_key");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_auth_key(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgWebUITransportInfo)
  return target;
}

size_t CMsgWebUITransportInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgWebUITransportInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string auth_key = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_auth_key());
    }

    // optional uint32 port = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgWebUITransportInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CMsgWebUITransportInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgWebUITransportInfo::GetClassData() const { return &_class_data_; }

void CMsgWebUITransportInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CMsgWebUITransportInfo *>(to)->MergeFrom(
      static_cast<const CMsgWebUITransportInfo &>(from));
}


void CMsgWebUITransportInfo::MergeFrom(const CMsgWebUITransportInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CMsgWebUITransportInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_auth_key(from._internal_auth_key());
    }
    if (cached_has_bits & 0x00000002u) {
      port_ = from.port_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgWebUITransportInfo::CopyFrom(const CMsgWebUITransportInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgWebUITransportInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgWebUITransportInfo::IsInitialized() const {
  return true;
}

void CMsgWebUITransportInfo::InternalSwap(CMsgWebUITransportInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &auth_key_, lhs_arena,
      &other->auth_key_, rhs_arena
  );
  swap(port_, other->port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgWebUITransportInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fclient_5fobjects_2eproto_getter, &descriptor_table_steammessages_5fclient_5fobjects_2eproto_once,
      file_level_metadata_steammessages_5fclient_5fobjects_2eproto[65]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::SteamMessagesClientIClientForcedEnumDependencies* Arena::CreateMaybeMessage< ::SteamMessagesClientIClientForcedEnumDependencies >(Arena* arena) {
  return Arena::CreateMessageInternal< ::SteamMessagesClientIClientForcedEnumDependencies >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceIP4Address* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceIP4Address >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceIP4Address >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceIP4Config* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceIP4Config >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceIP4Config >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceIP6Address* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceIP6Address >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceIP6Address >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceIP6Config* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceIP6Config >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceIP6Config >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDevicesData_Device_Wired* Arena::CreateMaybeMessage< ::CMsgNetworkDevicesData_Device_Wired >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDevicesData_Device_Wired >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDevicesData_Device_Wireless_AP* Arena::CreateMaybeMessage< ::CMsgNetworkDevicesData_Device_Wireless_AP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDevicesData_Device_Wireless_AP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDevicesData_Device_Wireless* Arena::CreateMaybeMessage< ::CMsgNetworkDevicesData_Device_Wireless >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDevicesData_Device_Wireless >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDevicesData_Device* Arena::CreateMaybeMessage< ::CMsgNetworkDevicesData_Device >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDevicesData_Device >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDevicesData* Arena::CreateMaybeMessage< ::CMsgNetworkDevicesData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDevicesData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceConnect_KnownAP* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceConnect_KnownAP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceConnect_KnownAP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceConnect_CustomAP* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceConnect_CustomAP >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceConnect_CustomAP >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceConnect_Credentials* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceConnect_Credentials >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceConnect_Credentials >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgNetworkDeviceConnect* Arena::CreateMaybeMessage< ::CMsgNetworkDeviceConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgNetworkDeviceConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStorageDevicesData_Drive* Arena::CreateMaybeMessage< ::CMsgStorageDevicesData_Drive >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStorageDevicesData_Drive >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStorageDevicesData_BlockDevice* Arena::CreateMaybeMessage< ::CMsgStorageDevicesData_BlockDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStorageDevicesData_BlockDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgStorageDevicesData* Arena::CreateMaybeMessage< ::CMsgStorageDevicesData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgStorageDevicesData >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloud_PendingRemoteOperation* Arena::CreateMaybeMessage< ::CCloud_PendingRemoteOperation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloud_PendingRemoteOperation >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCloudPendingRemoteOperations* Arena::CreateMaybeMessage< ::CMsgCloudPendingRemoteOperations >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCloudPendingRemoteOperations >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgBluetoothDevicesData_Adapter* Arena::CreateMaybeMessage< ::CMsgBluetoothDevicesData_Adapter >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgBluetoothDevicesData_Adapter >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgBluetoothDevicesData_Device* Arena::CreateMaybeMessage< ::CMsgBluetoothDevicesData_Device >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgBluetoothDevicesData_Device >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgBluetoothDevicesData_Manager* Arena::CreateMaybeMessage< ::CMsgBluetoothDevicesData_Manager >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgBluetoothDevicesData_Manager >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgBluetoothDevicesData* Arena::CreateMaybeMessage< ::CMsgBluetoothDevicesData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgBluetoothDevicesData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfDiagnosticEntry* Arena::CreateMaybeMessage< ::CMsgSystemPerfDiagnosticEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfDiagnosticEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfNetworkInterface* Arena::CreateMaybeMessage< ::CMsgSystemPerfNetworkInterface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfNetworkInterface >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfDiagnosticInfo* Arena::CreateMaybeMessage< ::CMsgSystemPerfDiagnosticInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfDiagnosticInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfLimits* Arena::CreateMaybeMessage< ::CMsgSystemPerfLimits >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfLimits >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfSettingsGlobal* Arena::CreateMaybeMessage< ::CMsgSystemPerfSettingsGlobal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfSettingsGlobal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfSettingsPerApp* Arena::CreateMaybeMessage< ::CMsgSystemPerfSettingsPerApp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfSettingsPerApp >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfSettings* Arena::CreateMaybeMessage< ::CMsgSystemPerfSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfSettingsV1* Arena::CreateMaybeMessage< ::CMsgSystemPerfSettingsV1 >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfSettingsV1 >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfState* Arena::CreateMaybeMessage< ::CMsgSystemPerfState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemPerfUpdateSettings* Arena::CreateMaybeMessage< ::CMsgSystemPerfUpdateSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemPerfUpdateSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDockUpdateState* Arena::CreateMaybeMessage< ::CMsgSystemDockUpdateState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDockUpdateState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDockState* Arena::CreateMaybeMessage< ::CMsgSystemDockState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDockState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDockUpdateFirmware* Arena::CreateMaybeMessage< ::CMsgSystemDockUpdateFirmware >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDockUpdateFirmware >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioVolume_ChannelEntry* Arena::CreateMaybeMessage< ::CMsgSystemAudioVolume_ChannelEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioVolume_ChannelEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioVolume* Arena::CreateMaybeMessage< ::CMsgSystemAudioVolume >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioVolume >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerObject* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerObject >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerObject >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerDevice* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerDevice >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerDevice >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerNode* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerNode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerPort* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerPort >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerPort >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerLink* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerLink >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerLink >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerStateHW* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerStateHW >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerStateHW >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerState* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemAudioManagerUpdateSomething* Arena::CreateMaybeMessage< ::CMsgSystemAudioManagerUpdateSomething >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemAudioManagerUpdateSomething >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDisplayMode* Arena::CreateMaybeMessage< ::CMsgSystemDisplayMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDisplayMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDisplay* Arena::CreateMaybeMessage< ::CMsgSystemDisplay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDisplay >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDisplayManagerState* Arena::CreateMaybeMessage< ::CMsgSystemDisplayManagerState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDisplayManagerState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemDisplayManagerSetMode* Arena::CreateMaybeMessage< ::CMsgSystemDisplayManagerSetMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemDisplayManagerSetMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemManagerSettings* Arena::CreateMaybeMessage< ::CMsgSystemManagerSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemManagerSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSelectOSBranchParams* Arena::CreateMaybeMessage< ::CMsgSelectOSBranchParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSelectOSBranchParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemUpdateProgress* Arena::CreateMaybeMessage< ::CMsgSystemUpdateProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemUpdateProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemUpdateCheckResult* Arena::CreateMaybeMessage< ::CMsgSystemUpdateCheckResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemUpdateCheckResult >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemUpdateApplyParams* Arena::CreateMaybeMessage< ::CMsgSystemUpdateApplyParams >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemUpdateApplyParams >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemUpdateApplyResult* Arena::CreateMaybeMessage< ::CMsgSystemUpdateApplyResult >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemUpdateApplyResult >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgSystemUpdateState* Arena::CreateMaybeMessage< ::CMsgSystemUpdateState >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgSystemUpdateState >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgAchievementChange* Arena::CreateMaybeMessage< ::CMsgAchievementChange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgAchievementChange >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCellList_Cell* Arena::CreateMaybeMessage< ::CMsgCellList_Cell >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCellList_Cell >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgCellList* Arena::CreateMaybeMessage< ::CMsgCellList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgCellList >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgShortcutInfo* Arena::CreateMaybeMessage< ::CMsgShortcutInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgShortcutInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgShortcutAppIds* Arena::CreateMaybeMessage< ::CMsgShortcutAppIds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgShortcutAppIds >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonitorInfo_MonitorInfo* Arena::CreateMaybeMessage< ::CMsgMonitorInfo_MonitorInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonitorInfo_MonitorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgMonitorInfo* Arena::CreateMaybeMessage< ::CMsgMonitorInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgMonitorInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgGenerateSystemReportReply* Arena::CreateMaybeMessage< ::CMsgGenerateSystemReportReply >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgGenerateSystemReportReply >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgWebUITransportInfo* Arena::CreateMaybeMessage< ::CMsgWebUITransportInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgWebUITransportInfo >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
