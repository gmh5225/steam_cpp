// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_clientnotificationtypes.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientnotificationtypes_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientnotificationtypes_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fclientnotificationtypes_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fclientnotificationtypes_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[32]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fclientnotificationtypes_2eproto;
class CClientNotificationAchievement;
struct CClientNotificationAchievementDefaultTypeInternal;
extern CClientNotificationAchievementDefaultTypeInternal _CClientNotificationAchievement_default_instance_;
class CClientNotificationBatteryTemperature;
struct CClientNotificationBatteryTemperatureDefaultTypeInternal;
extern CClientNotificationBatteryTemperatureDefaultTypeInternal _CClientNotificationBatteryTemperature_default_instance_;
class CClientNotificationBroadcastAvailableToWatch;
struct CClientNotificationBroadcastAvailableToWatchDefaultTypeInternal;
extern CClientNotificationBroadcastAvailableToWatchDefaultTypeInternal _CClientNotificationBroadcastAvailableToWatch_default_instance_;
class CClientNotificationCannotReadControllerGuideButton;
struct CClientNotificationCannotReadControllerGuideButtonDefaultTypeInternal;
extern CClientNotificationCannotReadControllerGuideButtonDefaultTypeInternal _CClientNotificationCannotReadControllerGuideButton_default_instance_;
class CClientNotificationClaimSteamDeckRewards;
struct CClientNotificationClaimSteamDeckRewardsDefaultTypeInternal;
extern CClientNotificationClaimSteamDeckRewardsDefaultTypeInternal _CClientNotificationClaimSteamDeckRewards_default_instance_;
class CClientNotificationCloudSyncConflict;
struct CClientNotificationCloudSyncConflictDefaultTypeInternal;
extern CClientNotificationCloudSyncConflictDefaultTypeInternal _CClientNotificationCloudSyncConflict_default_instance_;
class CClientNotificationCloudSyncFailure;
struct CClientNotificationCloudSyncFailureDefaultTypeInternal;
extern CClientNotificationCloudSyncFailureDefaultTypeInternal _CClientNotificationCloudSyncFailure_default_instance_;
class CClientNotificationDockUnsupportedFirmware;
struct CClientNotificationDockUnsupportedFirmwareDefaultTypeInternal;
extern CClientNotificationDockUnsupportedFirmwareDefaultTypeInternal _CClientNotificationDockUnsupportedFirmware_default_instance_;
class CClientNotificationDownloadCompleted;
struct CClientNotificationDownloadCompletedDefaultTypeInternal;
extern CClientNotificationDownloadCompletedDefaultTypeInternal _CClientNotificationDownloadCompleted_default_instance_;
class CClientNotificationFamilySharingDeviceAuthorizationChanged;
struct CClientNotificationFamilySharingDeviceAuthorizationChangedDefaultTypeInternal;
extern CClientNotificationFamilySharingDeviceAuthorizationChangedDefaultTypeInternal _CClientNotificationFamilySharingDeviceAuthorizationChanged_default_instance_;
class CClientNotificationFamilySharingLibraryAvailable;
struct CClientNotificationFamilySharingLibraryAvailableDefaultTypeInternal;
extern CClientNotificationFamilySharingLibraryAvailableDefaultTypeInternal _CClientNotificationFamilySharingLibraryAvailable_default_instance_;
class CClientNotificationFamilySharingStopPlaying;
struct CClientNotificationFamilySharingStopPlayingDefaultTypeInternal;
extern CClientNotificationFamilySharingStopPlayingDefaultTypeInternal _CClientNotificationFamilySharingStopPlaying_default_instance_;
class CClientNotificationFriendInGame;
struct CClientNotificationFriendInGameDefaultTypeInternal;
extern CClientNotificationFriendInGameDefaultTypeInternal _CClientNotificationFriendInGame_default_instance_;
class CClientNotificationFriendInvite;
struct CClientNotificationFriendInviteDefaultTypeInternal;
extern CClientNotificationFriendInviteDefaultTypeInternal _CClientNotificationFriendInvite_default_instance_;
class CClientNotificationFriendInviteRollup;
struct CClientNotificationFriendInviteRollupDefaultTypeInternal;
extern CClientNotificationFriendInviteRollupDefaultTypeInternal _CClientNotificationFriendInviteRollup_default_instance_;
class CClientNotificationFriendMessage;
struct CClientNotificationFriendMessageDefaultTypeInternal;
extern CClientNotificationFriendMessageDefaultTypeInternal _CClientNotificationFriendMessage_default_instance_;
class CClientNotificationFriendOnline;
struct CClientNotificationFriendOnlineDefaultTypeInternal;
extern CClientNotificationFriendOnlineDefaultTypeInternal _CClientNotificationFriendOnline_default_instance_;
class CClientNotificationGiftReceived;
struct CClientNotificationGiftReceivedDefaultTypeInternal;
extern CClientNotificationGiftReceivedDefaultTypeInternal _CClientNotificationGiftReceived_default_instance_;
class CClientNotificationGroupChatMessage;
struct CClientNotificationGroupChatMessageDefaultTypeInternal;
extern CClientNotificationGroupChatMessageDefaultTypeInternal _CClientNotificationGroupChatMessage_default_instance_;
class CClientNotificationHardwareSurveyPending;
struct CClientNotificationHardwareSurveyPendingDefaultTypeInternal;
extern CClientNotificationHardwareSurveyPendingDefaultTypeInternal _CClientNotificationHardwareSurveyPending_default_instance_;
class CClientNotificationIncomingVoiceChat;
struct CClientNotificationIncomingVoiceChatDefaultTypeInternal;
extern CClientNotificationIncomingVoiceChatDefaultTypeInternal _CClientNotificationIncomingVoiceChat_default_instance_;
class CClientNotificationItemAnnouncement;
struct CClientNotificationItemAnnouncementDefaultTypeInternal;
extern CClientNotificationItemAnnouncementDefaultTypeInternal _CClientNotificationItemAnnouncement_default_instance_;
class CClientNotificationLoginRefresh;
struct CClientNotificationLoginRefreshDefaultTypeInternal;
extern CClientNotificationLoginRefreshDefaultTypeInternal _CClientNotificationLoginRefresh_default_instance_;
class CClientNotificationLowBattery;
struct CClientNotificationLowBatteryDefaultTypeInternal;
extern CClientNotificationLowBatteryDefaultTypeInternal _CClientNotificationLowBattery_default_instance_;
class CClientNotificationLowDiskSpace;
struct CClientNotificationLowDiskSpaceDefaultTypeInternal;
extern CClientNotificationLowDiskSpaceDefaultTypeInternal _CClientNotificationLowDiskSpace_default_instance_;
class CClientNotificationOverlaySplashScreen;
struct CClientNotificationOverlaySplashScreenDefaultTypeInternal;
extern CClientNotificationOverlaySplashScreenDefaultTypeInternal _CClientNotificationOverlaySplashScreen_default_instance_;
class CClientNotificationPeerContentUpload;
struct CClientNotificationPeerContentUploadDefaultTypeInternal;
extern CClientNotificationPeerContentUploadDefaultTypeInternal _CClientNotificationPeerContentUpload_default_instance_;
class CClientNotificationScreenshot;
struct CClientNotificationScreenshotDefaultTypeInternal;
extern CClientNotificationScreenshotDefaultTypeInternal _CClientNotificationScreenshot_default_instance_;
class CClientNotificationSteamInputActionSetChanged;
struct CClientNotificationSteamInputActionSetChangedDefaultTypeInternal;
extern CClientNotificationSteamInputActionSetChangedDefaultTypeInternal _CClientNotificationSteamInputActionSetChanged_default_instance_;
class CClientNotificationSystemUpdate;
struct CClientNotificationSystemUpdateDefaultTypeInternal;
extern CClientNotificationSystemUpdateDefaultTypeInternal _CClientNotificationSystemUpdate_default_instance_;
class CClientNotificationTimedTrialRemaining;
struct CClientNotificationTimedTrialRemainingDefaultTypeInternal;
extern CClientNotificationTimedTrialRemainingDefaultTypeInternal _CClientNotificationTimedTrialRemaining_default_instance_;
class CClientNotificationTimerExpired;
struct CClientNotificationTimerExpiredDefaultTypeInternal;
extern CClientNotificationTimerExpiredDefaultTypeInternal _CClientNotificationTimerExpired_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CClientNotificationAchievement* Arena::CreateMaybeMessage<::CClientNotificationAchievement>(Arena*);
template<> ::CClientNotificationBatteryTemperature* Arena::CreateMaybeMessage<::CClientNotificationBatteryTemperature>(Arena*);
template<> ::CClientNotificationBroadcastAvailableToWatch* Arena::CreateMaybeMessage<::CClientNotificationBroadcastAvailableToWatch>(Arena*);
template<> ::CClientNotificationCannotReadControllerGuideButton* Arena::CreateMaybeMessage<::CClientNotificationCannotReadControllerGuideButton>(Arena*);
template<> ::CClientNotificationClaimSteamDeckRewards* Arena::CreateMaybeMessage<::CClientNotificationClaimSteamDeckRewards>(Arena*);
template<> ::CClientNotificationCloudSyncConflict* Arena::CreateMaybeMessage<::CClientNotificationCloudSyncConflict>(Arena*);
template<> ::CClientNotificationCloudSyncFailure* Arena::CreateMaybeMessage<::CClientNotificationCloudSyncFailure>(Arena*);
template<> ::CClientNotificationDockUnsupportedFirmware* Arena::CreateMaybeMessage<::CClientNotificationDockUnsupportedFirmware>(Arena*);
template<> ::CClientNotificationDownloadCompleted* Arena::CreateMaybeMessage<::CClientNotificationDownloadCompleted>(Arena*);
template<> ::CClientNotificationFamilySharingDeviceAuthorizationChanged* Arena::CreateMaybeMessage<::CClientNotificationFamilySharingDeviceAuthorizationChanged>(Arena*);
template<> ::CClientNotificationFamilySharingLibraryAvailable* Arena::CreateMaybeMessage<::CClientNotificationFamilySharingLibraryAvailable>(Arena*);
template<> ::CClientNotificationFamilySharingStopPlaying* Arena::CreateMaybeMessage<::CClientNotificationFamilySharingStopPlaying>(Arena*);
template<> ::CClientNotificationFriendInGame* Arena::CreateMaybeMessage<::CClientNotificationFriendInGame>(Arena*);
template<> ::CClientNotificationFriendInvite* Arena::CreateMaybeMessage<::CClientNotificationFriendInvite>(Arena*);
template<> ::CClientNotificationFriendInviteRollup* Arena::CreateMaybeMessage<::CClientNotificationFriendInviteRollup>(Arena*);
template<> ::CClientNotificationFriendMessage* Arena::CreateMaybeMessage<::CClientNotificationFriendMessage>(Arena*);
template<> ::CClientNotificationFriendOnline* Arena::CreateMaybeMessage<::CClientNotificationFriendOnline>(Arena*);
template<> ::CClientNotificationGiftReceived* Arena::CreateMaybeMessage<::CClientNotificationGiftReceived>(Arena*);
template<> ::CClientNotificationGroupChatMessage* Arena::CreateMaybeMessage<::CClientNotificationGroupChatMessage>(Arena*);
template<> ::CClientNotificationHardwareSurveyPending* Arena::CreateMaybeMessage<::CClientNotificationHardwareSurveyPending>(Arena*);
template<> ::CClientNotificationIncomingVoiceChat* Arena::CreateMaybeMessage<::CClientNotificationIncomingVoiceChat>(Arena*);
template<> ::CClientNotificationItemAnnouncement* Arena::CreateMaybeMessage<::CClientNotificationItemAnnouncement>(Arena*);
template<> ::CClientNotificationLoginRefresh* Arena::CreateMaybeMessage<::CClientNotificationLoginRefresh>(Arena*);
template<> ::CClientNotificationLowBattery* Arena::CreateMaybeMessage<::CClientNotificationLowBattery>(Arena*);
template<> ::CClientNotificationLowDiskSpace* Arena::CreateMaybeMessage<::CClientNotificationLowDiskSpace>(Arena*);
template<> ::CClientNotificationOverlaySplashScreen* Arena::CreateMaybeMessage<::CClientNotificationOverlaySplashScreen>(Arena*);
template<> ::CClientNotificationPeerContentUpload* Arena::CreateMaybeMessage<::CClientNotificationPeerContentUpload>(Arena*);
template<> ::CClientNotificationScreenshot* Arena::CreateMaybeMessage<::CClientNotificationScreenshot>(Arena*);
template<> ::CClientNotificationSteamInputActionSetChanged* Arena::CreateMaybeMessage<::CClientNotificationSteamInputActionSetChanged>(Arena*);
template<> ::CClientNotificationSystemUpdate* Arena::CreateMaybeMessage<::CClientNotificationSystemUpdate>(Arena*);
template<> ::CClientNotificationTimedTrialRemaining* Arena::CreateMaybeMessage<::CClientNotificationTimedTrialRemaining>(Arena*);
template<> ::CClientNotificationTimerExpired* Arena::CreateMaybeMessage<::CClientNotificationTimerExpired>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum EClientNotificationType : int {
  k_EClientNotificationType_Invalid = 0,
  k_EClientNotificationType_DownloadCompleted = 1,
  k_EClientNotificationType_FriendInvite = 2,
  k_EClientNotificationType_FriendInGame = 3,
  k_EClientNotificationType_FriendOnline = 4,
  k_EClientNotificationType_Achievement = 5,
  k_EClientNotificationType_LowBattery = 6,
  k_EClientNotificationType_SystemUpdate = 7,
  k_EClientNotificationType_FriendMessage = 8,
  k_EClientNotificationType_GroupChatMessage = 9,
  k_EClientNotificationType_FriendInviteRollup = 10,
  k_EClientNotificationType_FamilySharingDeviceAuthorizationChanged = 11,
  k_EClientNotificationType_FamilySharingStopPlaying = 12,
  k_EClientNotificationType_FamilySharingLibraryAvailable = 13,
  k_EClientNotificationType_Screenshot = 14,
  k_EClientNotificationType_CloudSyncFailure = 15,
  k_EClientNotificationType_CloudSyncConflict = 16,
  k_EClientNotificationType_IncomingVoiceChat = 17,
  k_EClientNotificationType_ClaimSteamDeckRewards = 18,
  k_EClientNotificationType_GiftReceived = 19,
  k_EClientNotificationType_ItemAnnouncement = 20,
  k_EClientNotificationType_HardwareSurvey = 21,
  k_EClientNotificationType_LowDiskSpace = 22,
  k_EClientNotificationType_BatteryTemperature = 23,
  k_EClientNotificationType_DockUnsupportedFirmware = 24,
  k_EClientNotificationType_PeerContentUpload = 25,
  k_EClientNotificationType_CannotReadControllerGuideButton = 26,
  k_EClientNotificationType_Comment = 27,
  k_EClientNotificationType_Wishlist = 28,
  k_EClientNotificationType_TradeOffer = 29,
  k_EClientNotificationType_AsyncGame = 30,
  k_EClientNotificationType_General = 31,
  k_EClientNotificationType_HelpRequest = 32,
  k_EClientNotificationType_OverlaySplashScreen = 33,
  k_EClientNotificationType_BroadcastAvailableToWatch = 34,
  k_EClientNotificationType_TimedTrialRemaining = 35,
  k_EClientNotificationType_LoginRefresh = 36,
  k_EClientNotificationType_MajorSale = 37,
  k_EClientNotificationType_TimerExpired = 38,
  k_EClientNotificationType_ModeratorMsg = 39,
  k_EClientNotificationType_SteamInputActionSetChanged = 40
};
bool EClientNotificationType_IsValid(int value);
constexpr EClientNotificationType EClientNotificationType_MIN = k_EClientNotificationType_Invalid;
constexpr EClientNotificationType EClientNotificationType_MAX = k_EClientNotificationType_SteamInputActionSetChanged;
constexpr int EClientNotificationType_ARRAYSIZE = EClientNotificationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EClientNotificationType_descriptor();
template<typename T>
inline const std::string& EClientNotificationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EClientNotificationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EClientNotificationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EClientNotificationType_descriptor(), enum_t_value);
}
inline bool EClientNotificationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EClientNotificationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EClientNotificationType>(
    EClientNotificationType_descriptor(), name, value);
}
enum ESystemUpdateNotificationType : int {
  k_ESystemUpdateNotificationType_Invalid = 0,
  k_ESystemUpdateNotificationType_Available = 1,
  k_ESystemUpdateNotificationType_NeedsRestart = 2
};
bool ESystemUpdateNotificationType_IsValid(int value);
constexpr ESystemUpdateNotificationType ESystemUpdateNotificationType_MIN = k_ESystemUpdateNotificationType_Invalid;
constexpr ESystemUpdateNotificationType ESystemUpdateNotificationType_MAX = k_ESystemUpdateNotificationType_NeedsRestart;
constexpr int ESystemUpdateNotificationType_ARRAYSIZE = ESystemUpdateNotificationType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESystemUpdateNotificationType_descriptor();
template<typename T>
inline const std::string& ESystemUpdateNotificationType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESystemUpdateNotificationType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESystemUpdateNotificationType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESystemUpdateNotificationType_descriptor(), enum_t_value);
}
inline bool ESystemUpdateNotificationType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESystemUpdateNotificationType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESystemUpdateNotificationType>(
    ESystemUpdateNotificationType_descriptor(), name, value);
}
// ===================================================================

class CClientNotificationCloudSyncFailure final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationCloudSyncFailure) */ {
 public:
  inline CClientNotificationCloudSyncFailure() : CClientNotificationCloudSyncFailure(nullptr) {}
  ~CClientNotificationCloudSyncFailure() override;
  explicit constexpr CClientNotificationCloudSyncFailure(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationCloudSyncFailure(const CClientNotificationCloudSyncFailure& from);
  CClientNotificationCloudSyncFailure(CClientNotificationCloudSyncFailure&& from) noexcept
    : CClientNotificationCloudSyncFailure() {
    *this = ::std::move(from);
  }

  inline CClientNotificationCloudSyncFailure& operator=(const CClientNotificationCloudSyncFailure& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationCloudSyncFailure& operator=(CClientNotificationCloudSyncFailure&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationCloudSyncFailure& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationCloudSyncFailure* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationCloudSyncFailure*>(
               &_CClientNotificationCloudSyncFailure_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CClientNotificationCloudSyncFailure& a, CClientNotificationCloudSyncFailure& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationCloudSyncFailure* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationCloudSyncFailure* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationCloudSyncFailure* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationCloudSyncFailure>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationCloudSyncFailure& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationCloudSyncFailure& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationCloudSyncFailure* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationCloudSyncFailure";
  }
  protected:
  explicit CClientNotificationCloudSyncFailure(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationCloudSyncFailure)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationCloudSyncConflict final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationCloudSyncConflict) */ {
 public:
  inline CClientNotificationCloudSyncConflict() : CClientNotificationCloudSyncConflict(nullptr) {}
  ~CClientNotificationCloudSyncConflict() override;
  explicit constexpr CClientNotificationCloudSyncConflict(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationCloudSyncConflict(const CClientNotificationCloudSyncConflict& from);
  CClientNotificationCloudSyncConflict(CClientNotificationCloudSyncConflict&& from) noexcept
    : CClientNotificationCloudSyncConflict() {
    *this = ::std::move(from);
  }

  inline CClientNotificationCloudSyncConflict& operator=(const CClientNotificationCloudSyncConflict& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationCloudSyncConflict& operator=(CClientNotificationCloudSyncConflict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationCloudSyncConflict& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationCloudSyncConflict* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationCloudSyncConflict*>(
               &_CClientNotificationCloudSyncConflict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CClientNotificationCloudSyncConflict& a, CClientNotificationCloudSyncConflict& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationCloudSyncConflict* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationCloudSyncConflict* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationCloudSyncConflict* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationCloudSyncConflict>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationCloudSyncConflict& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationCloudSyncConflict& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationCloudSyncConflict* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationCloudSyncConflict";
  }
  protected:
  explicit CClientNotificationCloudSyncConflict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationCloudSyncConflict)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationScreenshot final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationScreenshot) */ {
 public:
  inline CClientNotificationScreenshot() : CClientNotificationScreenshot(nullptr) {}
  ~CClientNotificationScreenshot() override;
  explicit constexpr CClientNotificationScreenshot(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationScreenshot(const CClientNotificationScreenshot& from);
  CClientNotificationScreenshot(CClientNotificationScreenshot&& from) noexcept
    : CClientNotificationScreenshot() {
    *this = ::std::move(from);
  }

  inline CClientNotificationScreenshot& operator=(const CClientNotificationScreenshot& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationScreenshot& operator=(CClientNotificationScreenshot&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationScreenshot& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationScreenshot* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationScreenshot*>(
               &_CClientNotificationScreenshot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CClientNotificationScreenshot& a, CClientNotificationScreenshot& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationScreenshot* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationScreenshot* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationScreenshot* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationScreenshot>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationScreenshot& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationScreenshot& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationScreenshot* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationScreenshot";
  }
  protected:
  explicit CClientNotificationScreenshot(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenshotHandleFieldNumber = 1,
    kDescriptionFieldNumber = 2,
    kLocalUrlFieldNumber = 3,
  };
  // optional string screenshot_handle = 1;
  bool has_screenshot_handle() const;
  private:
  bool _internal_has_screenshot_handle() const;
  public:
  void clear_screenshot_handle();
  const std::string& screenshot_handle() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenshot_handle(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenshot_handle();
  PROTOBUF_NODISCARD std::string* release_screenshot_handle();
  void set_allocated_screenshot_handle(std::string* screenshot_handle);
  private:
  const std::string& _internal_screenshot_handle() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenshot_handle(const std::string& value);
  std::string* _internal_mutable_screenshot_handle();
  public:

  // optional string description = 2;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string local_url = 3;
  bool has_local_url() const;
  private:
  bool _internal_has_local_url() const;
  public:
  void clear_local_url();
  const std::string& local_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_local_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_local_url();
  PROTOBUF_NODISCARD std::string* release_local_url();
  void set_allocated_local_url(std::string* local_url);
  private:
  const std::string& _internal_local_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_local_url(const std::string& value);
  std::string* _internal_mutable_local_url();
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationScreenshot)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenshot_handle_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr local_url_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationDownloadCompleted final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationDownloadCompleted) */ {
 public:
  inline CClientNotificationDownloadCompleted() : CClientNotificationDownloadCompleted(nullptr) {}
  ~CClientNotificationDownloadCompleted() override;
  explicit constexpr CClientNotificationDownloadCompleted(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationDownloadCompleted(const CClientNotificationDownloadCompleted& from);
  CClientNotificationDownloadCompleted(CClientNotificationDownloadCompleted&& from) noexcept
    : CClientNotificationDownloadCompleted() {
    *this = ::std::move(from);
  }

  inline CClientNotificationDownloadCompleted& operator=(const CClientNotificationDownloadCompleted& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationDownloadCompleted& operator=(CClientNotificationDownloadCompleted&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationDownloadCompleted& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationDownloadCompleted* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationDownloadCompleted*>(
               &_CClientNotificationDownloadCompleted_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CClientNotificationDownloadCompleted& a, CClientNotificationDownloadCompleted& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationDownloadCompleted* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationDownloadCompleted* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationDownloadCompleted* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationDownloadCompleted>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationDownloadCompleted& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationDownloadCompleted& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationDownloadCompleted* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationDownloadCompleted";
  }
  protected:
  explicit CClientNotificationDownloadCompleted(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationDownloadCompleted)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFriendInvite final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFriendInvite) */ {
 public:
  inline CClientNotificationFriendInvite() : CClientNotificationFriendInvite(nullptr) {}
  ~CClientNotificationFriendInvite() override;
  explicit constexpr CClientNotificationFriendInvite(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFriendInvite(const CClientNotificationFriendInvite& from);
  CClientNotificationFriendInvite(CClientNotificationFriendInvite&& from) noexcept
    : CClientNotificationFriendInvite() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFriendInvite& operator=(const CClientNotificationFriendInvite& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFriendInvite& operator=(CClientNotificationFriendInvite&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFriendInvite& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFriendInvite* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFriendInvite*>(
               &_CClientNotificationFriendInvite_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CClientNotificationFriendInvite& a, CClientNotificationFriendInvite& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFriendInvite* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFriendInvite* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFriendInvite* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFriendInvite>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFriendInvite& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFriendInvite& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFriendInvite* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFriendInvite";
  }
  protected:
  explicit CClientNotificationFriendInvite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
  };
  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFriendInvite)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFriendInviteRollup final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFriendInviteRollup) */ {
 public:
  inline CClientNotificationFriendInviteRollup() : CClientNotificationFriendInviteRollup(nullptr) {}
  ~CClientNotificationFriendInviteRollup() override;
  explicit constexpr CClientNotificationFriendInviteRollup(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFriendInviteRollup(const CClientNotificationFriendInviteRollup& from);
  CClientNotificationFriendInviteRollup(CClientNotificationFriendInviteRollup&& from) noexcept
    : CClientNotificationFriendInviteRollup() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFriendInviteRollup& operator=(const CClientNotificationFriendInviteRollup& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFriendInviteRollup& operator=(CClientNotificationFriendInviteRollup&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFriendInviteRollup& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFriendInviteRollup* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFriendInviteRollup*>(
               &_CClientNotificationFriendInviteRollup_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CClientNotificationFriendInviteRollup& a, CClientNotificationFriendInviteRollup& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFriendInviteRollup* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFriendInviteRollup* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFriendInviteRollup* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFriendInviteRollup>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFriendInviteRollup& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFriendInviteRollup& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFriendInviteRollup* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFriendInviteRollup";
  }
  protected:
  explicit CClientNotificationFriendInviteRollup(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewInviteCountFieldNumber = 1,
  };
  // optional uint32 new_invite_count = 1;
  bool has_new_invite_count() const;
  private:
  bool _internal_has_new_invite_count() const;
  public:
  void clear_new_invite_count();
  uint32_t new_invite_count() const;
  void set_new_invite_count(uint32_t value);
  private:
  uint32_t _internal_new_invite_count() const;
  void _internal_set_new_invite_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFriendInviteRollup)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t new_invite_count_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFriendInGame final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFriendInGame) */ {
 public:
  inline CClientNotificationFriendInGame() : CClientNotificationFriendInGame(nullptr) {}
  ~CClientNotificationFriendInGame() override;
  explicit constexpr CClientNotificationFriendInGame(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFriendInGame(const CClientNotificationFriendInGame& from);
  CClientNotificationFriendInGame(CClientNotificationFriendInGame&& from) noexcept
    : CClientNotificationFriendInGame() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFriendInGame& operator=(const CClientNotificationFriendInGame& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFriendInGame& operator=(CClientNotificationFriendInGame&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFriendInGame& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFriendInGame* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFriendInGame*>(
               &_CClientNotificationFriendInGame_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CClientNotificationFriendInGame& a, CClientNotificationFriendInGame& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFriendInGame* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFriendInGame* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFriendInGame* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFriendInGame>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFriendInGame& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFriendInGame& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFriendInGame* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFriendInGame";
  }
  protected:
  explicit CClientNotificationFriendInGame(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 2,
    kSteamidFieldNumber = 1,
  };
  // optional string game_name = 2;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFriendInGame)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFriendOnline final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFriendOnline) */ {
 public:
  inline CClientNotificationFriendOnline() : CClientNotificationFriendOnline(nullptr) {}
  ~CClientNotificationFriendOnline() override;
  explicit constexpr CClientNotificationFriendOnline(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFriendOnline(const CClientNotificationFriendOnline& from);
  CClientNotificationFriendOnline(CClientNotificationFriendOnline&& from) noexcept
    : CClientNotificationFriendOnline() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFriendOnline& operator=(const CClientNotificationFriendOnline& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFriendOnline& operator=(CClientNotificationFriendOnline&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFriendOnline& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFriendOnline* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFriendOnline*>(
               &_CClientNotificationFriendOnline_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CClientNotificationFriendOnline& a, CClientNotificationFriendOnline& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFriendOnline* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFriendOnline* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFriendOnline* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFriendOnline>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFriendOnline& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFriendOnline& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFriendOnline* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFriendOnline";
  }
  protected:
  explicit CClientNotificationFriendOnline(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
  };
  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFriendOnline)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationAchievement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationAchievement) */ {
 public:
  inline CClientNotificationAchievement() : CClientNotificationAchievement(nullptr) {}
  ~CClientNotificationAchievement() override;
  explicit constexpr CClientNotificationAchievement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationAchievement(const CClientNotificationAchievement& from);
  CClientNotificationAchievement(CClientNotificationAchievement&& from) noexcept
    : CClientNotificationAchievement() {
    *this = ::std::move(from);
  }

  inline CClientNotificationAchievement& operator=(const CClientNotificationAchievement& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationAchievement& operator=(CClientNotificationAchievement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationAchievement& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationAchievement* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationAchievement*>(
               &_CClientNotificationAchievement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CClientNotificationAchievement& a, CClientNotificationAchievement& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationAchievement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationAchievement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationAchievement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationAchievement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationAchievement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationAchievement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationAchievement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationAchievement";
  }
  protected:
  explicit CClientNotificationAchievement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAchievementIdFieldNumber = 1,
    kNameFieldNumber = 3,
    kDescriptionFieldNumber = 4,
    kImageUrlFieldNumber = 5,
    kAppidFieldNumber = 2,
    kAchievedFieldNumber = 6,
    kRtimeUnlockedFieldNumber = 7,
    kMinProgressFieldNumber = 8,
    kCurrentProgressFieldNumber = 9,
    kMaxProgressFieldNumber = 10,
    kGlobalAchievedPctFieldNumber = 11,
  };
  // optional string achievement_id = 1;
  bool has_achievement_id() const;
  private:
  bool _internal_has_achievement_id() const;
  public:
  void clear_achievement_id();
  const std::string& achievement_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_achievement_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_achievement_id();
  PROTOBUF_NODISCARD std::string* release_achievement_id();
  void set_allocated_achievement_id(std::string* achievement_id);
  private:
  const std::string& _internal_achievement_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_achievement_id(const std::string& value);
  std::string* _internal_mutable_achievement_id();
  public:

  // optional string name = 3;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional string description = 4;
  bool has_description() const;
  private:
  bool _internal_has_description() const;
  public:
  void clear_description();
  const std::string& description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_description();
  PROTOBUF_NODISCARD std::string* release_description();
  void set_allocated_description(std::string* description);
  private:
  const std::string& _internal_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_description(const std::string& value);
  std::string* _internal_mutable_description();
  public:

  // optional string image_url = 5;
  bool has_image_url() const;
  private:
  bool _internal_has_image_url() const;
  public:
  void clear_image_url();
  const std::string& image_url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image_url();
  PROTOBUF_NODISCARD std::string* release_image_url();
  void set_allocated_image_url(std::string* image_url);
  private:
  const std::string& _internal_image_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image_url(const std::string& value);
  std::string* _internal_mutable_image_url();
  public:

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional bool achieved = 6;
  bool has_achieved() const;
  private:
  bool _internal_has_achieved() const;
  public:
  void clear_achieved();
  bool achieved() const;
  void set_achieved(bool value);
  private:
  bool _internal_achieved() const;
  void _internal_set_achieved(bool value);
  public:

  // optional uint32 rtime_unlocked = 7;
  bool has_rtime_unlocked() const;
  private:
  bool _internal_has_rtime_unlocked() const;
  public:
  void clear_rtime_unlocked();
  uint32_t rtime_unlocked() const;
  void set_rtime_unlocked(uint32_t value);
  private:
  uint32_t _internal_rtime_unlocked() const;
  void _internal_set_rtime_unlocked(uint32_t value);
  public:

  // optional float min_progress = 8;
  bool has_min_progress() const;
  private:
  bool _internal_has_min_progress() const;
  public:
  void clear_min_progress();
  float min_progress() const;
  void set_min_progress(float value);
  private:
  float _internal_min_progress() const;
  void _internal_set_min_progress(float value);
  public:

  // optional float current_progress = 9;
  bool has_current_progress() const;
  private:
  bool _internal_has_current_progress() const;
  public:
  void clear_current_progress();
  float current_progress() const;
  void set_current_progress(float value);
  private:
  float _internal_current_progress() const;
  void _internal_set_current_progress(float value);
  public:

  // optional float max_progress = 10;
  bool has_max_progress() const;
  private:
  bool _internal_has_max_progress() const;
  public:
  void clear_max_progress();
  float max_progress() const;
  void set_max_progress(float value);
  private:
  float _internal_max_progress() const;
  void _internal_set_max_progress(float value);
  public:

  // optional float global_achieved_pct = 11;
  bool has_global_achieved_pct() const;
  private:
  bool _internal_has_global_achieved_pct() const;
  public:
  void clear_global_achieved_pct();
  float global_achieved_pct() const;
  void set_global_achieved_pct(float value);
  private:
  float _internal_global_achieved_pct() const;
  void _internal_set_global_achieved_pct(float value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationAchievement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr achievement_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_url_;
  uint32_t appid_;
  bool achieved_;
  uint32_t rtime_unlocked_;
  float min_progress_;
  float current_progress_;
  float max_progress_;
  float global_achieved_pct_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationLowBattery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationLowBattery) */ {
 public:
  inline CClientNotificationLowBattery() : CClientNotificationLowBattery(nullptr) {}
  ~CClientNotificationLowBattery() override;
  explicit constexpr CClientNotificationLowBattery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationLowBattery(const CClientNotificationLowBattery& from);
  CClientNotificationLowBattery(CClientNotificationLowBattery&& from) noexcept
    : CClientNotificationLowBattery() {
    *this = ::std::move(from);
  }

  inline CClientNotificationLowBattery& operator=(const CClientNotificationLowBattery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationLowBattery& operator=(CClientNotificationLowBattery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationLowBattery& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationLowBattery* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationLowBattery*>(
               &_CClientNotificationLowBattery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CClientNotificationLowBattery& a, CClientNotificationLowBattery& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationLowBattery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationLowBattery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationLowBattery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationLowBattery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationLowBattery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationLowBattery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationLowBattery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationLowBattery";
  }
  protected:
  explicit CClientNotificationLowBattery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPctRemainingFieldNumber = 1,
  };
  // optional float pct_remaining = 1;
  bool has_pct_remaining() const;
  private:
  bool _internal_has_pct_remaining() const;
  public:
  void clear_pct_remaining();
  float pct_remaining() const;
  void set_pct_remaining(float value);
  private:
  float _internal_pct_remaining() const;
  void _internal_set_pct_remaining(float value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationLowBattery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float pct_remaining_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationSystemUpdate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationSystemUpdate) */ {
 public:
  inline CClientNotificationSystemUpdate() : CClientNotificationSystemUpdate(nullptr) {}
  ~CClientNotificationSystemUpdate() override;
  explicit constexpr CClientNotificationSystemUpdate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationSystemUpdate(const CClientNotificationSystemUpdate& from);
  CClientNotificationSystemUpdate(CClientNotificationSystemUpdate&& from) noexcept
    : CClientNotificationSystemUpdate() {
    *this = ::std::move(from);
  }

  inline CClientNotificationSystemUpdate& operator=(const CClientNotificationSystemUpdate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationSystemUpdate& operator=(CClientNotificationSystemUpdate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationSystemUpdate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationSystemUpdate* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationSystemUpdate*>(
               &_CClientNotificationSystemUpdate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CClientNotificationSystemUpdate& a, CClientNotificationSystemUpdate& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationSystemUpdate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationSystemUpdate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationSystemUpdate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationSystemUpdate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationSystemUpdate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationSystemUpdate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationSystemUpdate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationSystemUpdate";
  }
  protected:
  explicit CClientNotificationSystemUpdate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
  };
  // optional .ESystemUpdateNotificationType type = 1 [default = k_ESystemUpdateNotificationType_Invalid];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ESystemUpdateNotificationType type() const;
  void set_type(::ESystemUpdateNotificationType value);
  private:
  ::ESystemUpdateNotificationType _internal_type() const;
  void _internal_set_type(::ESystemUpdateNotificationType value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationSystemUpdate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int type_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFriendMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFriendMessage) */ {
 public:
  inline CClientNotificationFriendMessage() : CClientNotificationFriendMessage(nullptr) {}
  ~CClientNotificationFriendMessage() override;
  explicit constexpr CClientNotificationFriendMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFriendMessage(const CClientNotificationFriendMessage& from);
  CClientNotificationFriendMessage(CClientNotificationFriendMessage&& from) noexcept
    : CClientNotificationFriendMessage() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFriendMessage& operator=(const CClientNotificationFriendMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFriendMessage& operator=(CClientNotificationFriendMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFriendMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFriendMessage* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFriendMessage*>(
               &_CClientNotificationFriendMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CClientNotificationFriendMessage& a, CClientNotificationFriendMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFriendMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFriendMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFriendMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFriendMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFriendMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFriendMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFriendMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFriendMessage";
  }
  protected:
  explicit CClientNotificationFriendMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kSteamidFieldNumber = 2,
    kTitleFieldNumber = 3,
    kBodyFieldNumber = 4,
    kIconFieldNumber = 5,
    kResponseSteamurlFieldNumber = 7,
    kNotificationidFieldNumber = 6,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string steamid = 2;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  const std::string& steamid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steamid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steamid();
  PROTOBUF_NODISCARD std::string* release_steamid();
  void set_allocated_steamid(std::string* steamid);
  private:
  const std::string& _internal_steamid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steamid(const std::string& value);
  std::string* _internal_mutable_steamid();
  public:

  // optional string title = 3;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string body = 4;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // optional string icon = 5;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional string response_steamurl = 7;
  bool has_response_steamurl() const;
  private:
  bool _internal_has_response_steamurl() const;
  public:
  void clear_response_steamurl();
  const std::string& response_steamurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response_steamurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response_steamurl();
  PROTOBUF_NODISCARD std::string* release_response_steamurl();
  void set_allocated_response_steamurl(std::string* response_steamurl);
  private:
  const std::string& _internal_response_steamurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response_steamurl(const std::string& value);
  std::string* _internal_mutable_response_steamurl();
  public:

  // optional uint32 notificationid = 6;
  bool has_notificationid() const;
  private:
  bool _internal_has_notificationid() const;
  public:
  void clear_notificationid();
  uint32_t notificationid() const;
  void set_notificationid(uint32_t value);
  private:
  uint32_t _internal_notificationid() const;
  void _internal_set_notificationid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFriendMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steamid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_steamurl_;
  uint32_t notificationid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationGroupChatMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationGroupChatMessage) */ {
 public:
  inline CClientNotificationGroupChatMessage() : CClientNotificationGroupChatMessage(nullptr) {}
  ~CClientNotificationGroupChatMessage() override;
  explicit constexpr CClientNotificationGroupChatMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationGroupChatMessage(const CClientNotificationGroupChatMessage& from);
  CClientNotificationGroupChatMessage(CClientNotificationGroupChatMessage&& from) noexcept
    : CClientNotificationGroupChatMessage() {
    *this = ::std::move(from);
  }

  inline CClientNotificationGroupChatMessage& operator=(const CClientNotificationGroupChatMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationGroupChatMessage& operator=(CClientNotificationGroupChatMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationGroupChatMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationGroupChatMessage* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationGroupChatMessage*>(
               &_CClientNotificationGroupChatMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CClientNotificationGroupChatMessage& a, CClientNotificationGroupChatMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationGroupChatMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationGroupChatMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationGroupChatMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationGroupChatMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationGroupChatMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationGroupChatMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationGroupChatMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationGroupChatMessage";
  }
  protected:
  explicit CClientNotificationGroupChatMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTagFieldNumber = 1,
    kSteamidSenderFieldNumber = 2,
    kChatGroupIdFieldNumber = 3,
    kChatIdFieldNumber = 4,
    kTitleFieldNumber = 5,
    kBodyFieldNumber = 6,
    kRawbodyFieldNumber = 7,
    kIconFieldNumber = 8,
    kNotificationidFieldNumber = 9,
  };
  // optional string tag = 1;
  bool has_tag() const;
  private:
  bool _internal_has_tag() const;
  public:
  void clear_tag();
  const std::string& tag() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_tag(ArgT0&& arg0, ArgT... args);
  std::string* mutable_tag();
  PROTOBUF_NODISCARD std::string* release_tag();
  void set_allocated_tag(std::string* tag);
  private:
  const std::string& _internal_tag() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_tag(const std::string& value);
  std::string* _internal_mutable_tag();
  public:

  // optional string steamid_sender = 2;
  bool has_steamid_sender() const;
  private:
  bool _internal_has_steamid_sender() const;
  public:
  void clear_steamid_sender();
  const std::string& steamid_sender() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_steamid_sender(ArgT0&& arg0, ArgT... args);
  std::string* mutable_steamid_sender();
  PROTOBUF_NODISCARD std::string* release_steamid_sender();
  void set_allocated_steamid_sender(std::string* steamid_sender);
  private:
  const std::string& _internal_steamid_sender() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_steamid_sender(const std::string& value);
  std::string* _internal_mutable_steamid_sender();
  public:

  // optional string chat_group_id = 3;
  bool has_chat_group_id() const;
  private:
  bool _internal_has_chat_group_id() const;
  public:
  void clear_chat_group_id();
  const std::string& chat_group_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_group_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_group_id();
  PROTOBUF_NODISCARD std::string* release_chat_group_id();
  void set_allocated_chat_group_id(std::string* chat_group_id);
  private:
  const std::string& _internal_chat_group_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_group_id(const std::string& value);
  std::string* _internal_mutable_chat_group_id();
  public:

  // optional string chat_id = 4;
  bool has_chat_id() const;
  private:
  bool _internal_has_chat_id() const;
  public:
  void clear_chat_id();
  const std::string& chat_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chat_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chat_id();
  PROTOBUF_NODISCARD std::string* release_chat_id();
  void set_allocated_chat_id(std::string* chat_id);
  private:
  const std::string& _internal_chat_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chat_id(const std::string& value);
  std::string* _internal_mutable_chat_id();
  public:

  // optional string title = 5;
  bool has_title() const;
  private:
  bool _internal_has_title() const;
  public:
  void clear_title();
  const std::string& title() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_title(ArgT0&& arg0, ArgT... args);
  std::string* mutable_title();
  PROTOBUF_NODISCARD std::string* release_title();
  void set_allocated_title(std::string* title);
  private:
  const std::string& _internal_title() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_title(const std::string& value);
  std::string* _internal_mutable_title();
  public:

  // optional string body = 6;
  bool has_body() const;
  private:
  bool _internal_has_body() const;
  public:
  void clear_body();
  const std::string& body() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_body(ArgT0&& arg0, ArgT... args);
  std::string* mutable_body();
  PROTOBUF_NODISCARD std::string* release_body();
  void set_allocated_body(std::string* body);
  private:
  const std::string& _internal_body() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_body(const std::string& value);
  std::string* _internal_mutable_body();
  public:

  // optional string rawbody = 7;
  bool has_rawbody() const;
  private:
  bool _internal_has_rawbody() const;
  public:
  void clear_rawbody();
  const std::string& rawbody() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_rawbody(ArgT0&& arg0, ArgT... args);
  std::string* mutable_rawbody();
  PROTOBUF_NODISCARD std::string* release_rawbody();
  void set_allocated_rawbody(std::string* rawbody);
  private:
  const std::string& _internal_rawbody() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_rawbody(const std::string& value);
  std::string* _internal_mutable_rawbody();
  public:

  // optional string icon = 8;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional uint32 notificationid = 9;
  bool has_notificationid() const;
  private:
  bool _internal_has_notificationid() const;
  public:
  void clear_notificationid();
  uint32_t notificationid() const;
  void set_notificationid(uint32_t value);
  private:
  uint32_t _internal_notificationid() const;
  void _internal_set_notificationid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationGroupChatMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr tag_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr steamid_sender_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_group_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chat_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr title_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr body_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr rawbody_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  uint32_t notificationid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFamilySharingDeviceAuthorizationChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFamilySharingDeviceAuthorizationChanged) */ {
 public:
  inline CClientNotificationFamilySharingDeviceAuthorizationChanged() : CClientNotificationFamilySharingDeviceAuthorizationChanged(nullptr) {}
  ~CClientNotificationFamilySharingDeviceAuthorizationChanged() override;
  explicit constexpr CClientNotificationFamilySharingDeviceAuthorizationChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFamilySharingDeviceAuthorizationChanged(const CClientNotificationFamilySharingDeviceAuthorizationChanged& from);
  CClientNotificationFamilySharingDeviceAuthorizationChanged(CClientNotificationFamilySharingDeviceAuthorizationChanged&& from) noexcept
    : CClientNotificationFamilySharingDeviceAuthorizationChanged() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFamilySharingDeviceAuthorizationChanged& operator=(const CClientNotificationFamilySharingDeviceAuthorizationChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFamilySharingDeviceAuthorizationChanged& operator=(CClientNotificationFamilySharingDeviceAuthorizationChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFamilySharingDeviceAuthorizationChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFamilySharingDeviceAuthorizationChanged* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFamilySharingDeviceAuthorizationChanged*>(
               &_CClientNotificationFamilySharingDeviceAuthorizationChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CClientNotificationFamilySharingDeviceAuthorizationChanged& a, CClientNotificationFamilySharingDeviceAuthorizationChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFamilySharingDeviceAuthorizationChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFamilySharingDeviceAuthorizationChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFamilySharingDeviceAuthorizationChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFamilySharingDeviceAuthorizationChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFamilySharingDeviceAuthorizationChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFamilySharingDeviceAuthorizationChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFamilySharingDeviceAuthorizationChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFamilySharingDeviceAuthorizationChanged";
  }
  protected:
  explicit CClientNotificationFamilySharingDeviceAuthorizationChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountidOwnerFieldNumber = 1,
    kAuthorizedFieldNumber = 2,
  };
  // optional uint32 accountid_owner = 1;
  bool has_accountid_owner() const;
  private:
  bool _internal_has_accountid_owner() const;
  public:
  void clear_accountid_owner();
  uint32_t accountid_owner() const;
  void set_accountid_owner(uint32_t value);
  private:
  uint32_t _internal_accountid_owner() const;
  void _internal_set_accountid_owner(uint32_t value);
  public:

  // optional bool authorized = 2;
  bool has_authorized() const;
  private:
  bool _internal_has_authorized() const;
  public:
  void clear_authorized();
  bool authorized() const;
  void set_authorized(bool value);
  private:
  bool _internal_authorized() const;
  void _internal_set_authorized(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFamilySharingDeviceAuthorizationChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t accountid_owner_;
  bool authorized_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFamilySharingStopPlaying final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFamilySharingStopPlaying) */ {
 public:
  inline CClientNotificationFamilySharingStopPlaying() : CClientNotificationFamilySharingStopPlaying(nullptr) {}
  ~CClientNotificationFamilySharingStopPlaying() override;
  explicit constexpr CClientNotificationFamilySharingStopPlaying(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFamilySharingStopPlaying(const CClientNotificationFamilySharingStopPlaying& from);
  CClientNotificationFamilySharingStopPlaying(CClientNotificationFamilySharingStopPlaying&& from) noexcept
    : CClientNotificationFamilySharingStopPlaying() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFamilySharingStopPlaying& operator=(const CClientNotificationFamilySharingStopPlaying& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFamilySharingStopPlaying& operator=(CClientNotificationFamilySharingStopPlaying&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFamilySharingStopPlaying& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFamilySharingStopPlaying* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFamilySharingStopPlaying*>(
               &_CClientNotificationFamilySharingStopPlaying_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CClientNotificationFamilySharingStopPlaying& a, CClientNotificationFamilySharingStopPlaying& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFamilySharingStopPlaying* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFamilySharingStopPlaying* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFamilySharingStopPlaying* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFamilySharingStopPlaying>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFamilySharingStopPlaying& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFamilySharingStopPlaying& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFamilySharingStopPlaying* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFamilySharingStopPlaying";
  }
  protected:
  explicit CClientNotificationFamilySharingStopPlaying(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountidOwnerFieldNumber = 1,
    kSecondsRemainingFieldNumber = 2,
  };
  // optional uint32 accountid_owner = 1;
  bool has_accountid_owner() const;
  private:
  bool _internal_has_accountid_owner() const;
  public:
  void clear_accountid_owner();
  uint32_t accountid_owner() const;
  void set_accountid_owner(uint32_t value);
  private:
  uint32_t _internal_accountid_owner() const;
  void _internal_set_accountid_owner(uint32_t value);
  public:

  // optional uint32 seconds_remaining = 2;
  bool has_seconds_remaining() const;
  private:
  bool _internal_has_seconds_remaining() const;
  public:
  void clear_seconds_remaining();
  uint32_t seconds_remaining() const;
  void set_seconds_remaining(uint32_t value);
  private:
  uint32_t _internal_seconds_remaining() const;
  void _internal_set_seconds_remaining(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFamilySharingStopPlaying)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t accountid_owner_;
  uint32_t seconds_remaining_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationFamilySharingLibraryAvailable final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationFamilySharingLibraryAvailable) */ {
 public:
  inline CClientNotificationFamilySharingLibraryAvailable() : CClientNotificationFamilySharingLibraryAvailable(nullptr) {}
  ~CClientNotificationFamilySharingLibraryAvailable() override;
  explicit constexpr CClientNotificationFamilySharingLibraryAvailable(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationFamilySharingLibraryAvailable(const CClientNotificationFamilySharingLibraryAvailable& from);
  CClientNotificationFamilySharingLibraryAvailable(CClientNotificationFamilySharingLibraryAvailable&& from) noexcept
    : CClientNotificationFamilySharingLibraryAvailable() {
    *this = ::std::move(from);
  }

  inline CClientNotificationFamilySharingLibraryAvailable& operator=(const CClientNotificationFamilySharingLibraryAvailable& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationFamilySharingLibraryAvailable& operator=(CClientNotificationFamilySharingLibraryAvailable&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationFamilySharingLibraryAvailable& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationFamilySharingLibraryAvailable* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationFamilySharingLibraryAvailable*>(
               &_CClientNotificationFamilySharingLibraryAvailable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CClientNotificationFamilySharingLibraryAvailable& a, CClientNotificationFamilySharingLibraryAvailable& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationFamilySharingLibraryAvailable* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationFamilySharingLibraryAvailable* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationFamilySharingLibraryAvailable* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationFamilySharingLibraryAvailable>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationFamilySharingLibraryAvailable& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationFamilySharingLibraryAvailable& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationFamilySharingLibraryAvailable* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationFamilySharingLibraryAvailable";
  }
  protected:
  explicit CClientNotificationFamilySharingLibraryAvailable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountidOwnerFieldNumber = 1,
  };
  // optional uint32 accountid_owner = 1;
  bool has_accountid_owner() const;
  private:
  bool _internal_has_accountid_owner() const;
  public:
  void clear_accountid_owner();
  uint32_t accountid_owner() const;
  void set_accountid_owner(uint32_t value);
  private:
  uint32_t _internal_accountid_owner() const;
  void _internal_set_accountid_owner(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationFamilySharingLibraryAvailable)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t accountid_owner_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationIncomingVoiceChat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationIncomingVoiceChat) */ {
 public:
  inline CClientNotificationIncomingVoiceChat() : CClientNotificationIncomingVoiceChat(nullptr) {}
  ~CClientNotificationIncomingVoiceChat() override;
  explicit constexpr CClientNotificationIncomingVoiceChat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationIncomingVoiceChat(const CClientNotificationIncomingVoiceChat& from);
  CClientNotificationIncomingVoiceChat(CClientNotificationIncomingVoiceChat&& from) noexcept
    : CClientNotificationIncomingVoiceChat() {
    *this = ::std::move(from);
  }

  inline CClientNotificationIncomingVoiceChat& operator=(const CClientNotificationIncomingVoiceChat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationIncomingVoiceChat& operator=(CClientNotificationIncomingVoiceChat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationIncomingVoiceChat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationIncomingVoiceChat* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationIncomingVoiceChat*>(
               &_CClientNotificationIncomingVoiceChat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CClientNotificationIncomingVoiceChat& a, CClientNotificationIncomingVoiceChat& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationIncomingVoiceChat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationIncomingVoiceChat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationIncomingVoiceChat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationIncomingVoiceChat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationIncomingVoiceChat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationIncomingVoiceChat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationIncomingVoiceChat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationIncomingVoiceChat";
  }
  protected:
  explicit CClientNotificationIncomingVoiceChat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
  };
  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationIncomingVoiceChat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steamid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationClaimSteamDeckRewards final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationClaimSteamDeckRewards) */ {
 public:
  inline CClientNotificationClaimSteamDeckRewards() : CClientNotificationClaimSteamDeckRewards(nullptr) {}
  explicit constexpr CClientNotificationClaimSteamDeckRewards(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationClaimSteamDeckRewards(const CClientNotificationClaimSteamDeckRewards& from);
  CClientNotificationClaimSteamDeckRewards(CClientNotificationClaimSteamDeckRewards&& from) noexcept
    : CClientNotificationClaimSteamDeckRewards() {
    *this = ::std::move(from);
  }

  inline CClientNotificationClaimSteamDeckRewards& operator=(const CClientNotificationClaimSteamDeckRewards& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationClaimSteamDeckRewards& operator=(CClientNotificationClaimSteamDeckRewards&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationClaimSteamDeckRewards& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationClaimSteamDeckRewards* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationClaimSteamDeckRewards*>(
               &_CClientNotificationClaimSteamDeckRewards_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CClientNotificationClaimSteamDeckRewards& a, CClientNotificationClaimSteamDeckRewards& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationClaimSteamDeckRewards* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationClaimSteamDeckRewards* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationClaimSteamDeckRewards* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationClaimSteamDeckRewards>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationClaimSteamDeckRewards& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationClaimSteamDeckRewards& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationClaimSteamDeckRewards";
  }
  protected:
  explicit CClientNotificationClaimSteamDeckRewards(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationClaimSteamDeckRewards)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationGiftReceived final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationGiftReceived) */ {
 public:
  inline CClientNotificationGiftReceived() : CClientNotificationGiftReceived(nullptr) {}
  ~CClientNotificationGiftReceived() override;
  explicit constexpr CClientNotificationGiftReceived(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationGiftReceived(const CClientNotificationGiftReceived& from);
  CClientNotificationGiftReceived(CClientNotificationGiftReceived&& from) noexcept
    : CClientNotificationGiftReceived() {
    *this = ::std::move(from);
  }

  inline CClientNotificationGiftReceived& operator=(const CClientNotificationGiftReceived& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationGiftReceived& operator=(CClientNotificationGiftReceived&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationGiftReceived& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationGiftReceived* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationGiftReceived*>(
               &_CClientNotificationGiftReceived_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CClientNotificationGiftReceived& a, CClientNotificationGiftReceived& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationGiftReceived* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationGiftReceived* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationGiftReceived* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationGiftReceived>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationGiftReceived& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationGiftReceived& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationGiftReceived* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationGiftReceived";
  }
  protected:
  explicit CClientNotificationGiftReceived(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSenderNameFieldNumber = 1,
  };
  // optional string sender_name = 1;
  bool has_sender_name() const;
  private:
  bool _internal_has_sender_name() const;
  public:
  void clear_sender_name();
  const std::string& sender_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_name();
  PROTOBUF_NODISCARD std::string* release_sender_name();
  void set_allocated_sender_name(std::string* sender_name);
  private:
  const std::string& _internal_sender_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_name(const std::string& value);
  std::string* _internal_mutable_sender_name();
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationGiftReceived)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_name_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationItemAnnouncement final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationItemAnnouncement) */ {
 public:
  inline CClientNotificationItemAnnouncement() : CClientNotificationItemAnnouncement(nullptr) {}
  ~CClientNotificationItemAnnouncement() override;
  explicit constexpr CClientNotificationItemAnnouncement(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationItemAnnouncement(const CClientNotificationItemAnnouncement& from);
  CClientNotificationItemAnnouncement(CClientNotificationItemAnnouncement&& from) noexcept
    : CClientNotificationItemAnnouncement() {
    *this = ::std::move(from);
  }

  inline CClientNotificationItemAnnouncement& operator=(const CClientNotificationItemAnnouncement& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationItemAnnouncement& operator=(CClientNotificationItemAnnouncement&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationItemAnnouncement& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationItemAnnouncement* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationItemAnnouncement*>(
               &_CClientNotificationItemAnnouncement_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CClientNotificationItemAnnouncement& a, CClientNotificationItemAnnouncement& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationItemAnnouncement* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationItemAnnouncement* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationItemAnnouncement* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationItemAnnouncement>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationItemAnnouncement& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationItemAnnouncement& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationItemAnnouncement* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationItemAnnouncement";
  }
  protected:
  explicit CClientNotificationItemAnnouncement(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNewItemCountFieldNumber = 1,
    kNewBackpackItemsFieldNumber = 2,
  };
  // optional uint32 new_item_count = 1;
  bool has_new_item_count() const;
  private:
  bool _internal_has_new_item_count() const;
  public:
  void clear_new_item_count();
  uint32_t new_item_count() const;
  void set_new_item_count(uint32_t value);
  private:
  uint32_t _internal_new_item_count() const;
  void _internal_set_new_item_count(uint32_t value);
  public:

  // optional bool new_backpack_items = 2;
  bool has_new_backpack_items() const;
  private:
  bool _internal_has_new_backpack_items() const;
  public:
  void clear_new_backpack_items();
  bool new_backpack_items() const;
  void set_new_backpack_items(bool value);
  private:
  bool _internal_new_backpack_items() const;
  void _internal_set_new_backpack_items(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationItemAnnouncement)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t new_item_count_;
  bool new_backpack_items_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationHardwareSurveyPending final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationHardwareSurveyPending) */ {
 public:
  inline CClientNotificationHardwareSurveyPending() : CClientNotificationHardwareSurveyPending(nullptr) {}
  explicit constexpr CClientNotificationHardwareSurveyPending(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationHardwareSurveyPending(const CClientNotificationHardwareSurveyPending& from);
  CClientNotificationHardwareSurveyPending(CClientNotificationHardwareSurveyPending&& from) noexcept
    : CClientNotificationHardwareSurveyPending() {
    *this = ::std::move(from);
  }

  inline CClientNotificationHardwareSurveyPending& operator=(const CClientNotificationHardwareSurveyPending& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationHardwareSurveyPending& operator=(CClientNotificationHardwareSurveyPending&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationHardwareSurveyPending& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationHardwareSurveyPending* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationHardwareSurveyPending*>(
               &_CClientNotificationHardwareSurveyPending_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CClientNotificationHardwareSurveyPending& a, CClientNotificationHardwareSurveyPending& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationHardwareSurveyPending* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationHardwareSurveyPending* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationHardwareSurveyPending* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationHardwareSurveyPending>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationHardwareSurveyPending& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationHardwareSurveyPending& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationHardwareSurveyPending";
  }
  protected:
  explicit CClientNotificationHardwareSurveyPending(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationHardwareSurveyPending)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationLowDiskSpace final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationLowDiskSpace) */ {
 public:
  inline CClientNotificationLowDiskSpace() : CClientNotificationLowDiskSpace(nullptr) {}
  ~CClientNotificationLowDiskSpace() override;
  explicit constexpr CClientNotificationLowDiskSpace(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationLowDiskSpace(const CClientNotificationLowDiskSpace& from);
  CClientNotificationLowDiskSpace(CClientNotificationLowDiskSpace&& from) noexcept
    : CClientNotificationLowDiskSpace() {
    *this = ::std::move(from);
  }

  inline CClientNotificationLowDiskSpace& operator=(const CClientNotificationLowDiskSpace& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationLowDiskSpace& operator=(CClientNotificationLowDiskSpace&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationLowDiskSpace& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationLowDiskSpace* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationLowDiskSpace*>(
               &_CClientNotificationLowDiskSpace_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CClientNotificationLowDiskSpace& a, CClientNotificationLowDiskSpace& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationLowDiskSpace* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationLowDiskSpace* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationLowDiskSpace* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationLowDiskSpace>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationLowDiskSpace& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationLowDiskSpace& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationLowDiskSpace* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationLowDiskSpace";
  }
  protected:
  explicit CClientNotificationLowDiskSpace(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFolderIndexFieldNumber = 1,
  };
  // optional uint32 folder_index = 1;
  bool has_folder_index() const;
  private:
  bool _internal_has_folder_index() const;
  public:
  void clear_folder_index();
  uint32_t folder_index() const;
  void set_folder_index(uint32_t value);
  private:
  uint32_t _internal_folder_index() const;
  void _internal_set_folder_index(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationLowDiskSpace)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t folder_index_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationBatteryTemperature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationBatteryTemperature) */ {
 public:
  inline CClientNotificationBatteryTemperature() : CClientNotificationBatteryTemperature(nullptr) {}
  ~CClientNotificationBatteryTemperature() override;
  explicit constexpr CClientNotificationBatteryTemperature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationBatteryTemperature(const CClientNotificationBatteryTemperature& from);
  CClientNotificationBatteryTemperature(CClientNotificationBatteryTemperature&& from) noexcept
    : CClientNotificationBatteryTemperature() {
    *this = ::std::move(from);
  }

  inline CClientNotificationBatteryTemperature& operator=(const CClientNotificationBatteryTemperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationBatteryTemperature& operator=(CClientNotificationBatteryTemperature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationBatteryTemperature& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationBatteryTemperature* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationBatteryTemperature*>(
               &_CClientNotificationBatteryTemperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CClientNotificationBatteryTemperature& a, CClientNotificationBatteryTemperature& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationBatteryTemperature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationBatteryTemperature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationBatteryTemperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationBatteryTemperature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationBatteryTemperature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationBatteryTemperature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationBatteryTemperature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationBatteryTemperature";
  }
  protected:
  explicit CClientNotificationBatteryTemperature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNotificationTypeFieldNumber = 2,
    kTemperatureFieldNumber = 1,
  };
  // optional string notification_type = 2;
  bool has_notification_type() const;
  private:
  bool _internal_has_notification_type() const;
  public:
  void clear_notification_type();
  const std::string& notification_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_notification_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_notification_type();
  PROTOBUF_NODISCARD std::string* release_notification_type();
  void set_allocated_notification_type(std::string* notification_type);
  private:
  const std::string& _internal_notification_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_notification_type(const std::string& value);
  std::string* _internal_mutable_notification_type();
  public:

  // optional uint32 temperature = 1;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  uint32_t temperature() const;
  void set_temperature(uint32_t value);
  private:
  uint32_t _internal_temperature() const;
  void _internal_set_temperature(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationBatteryTemperature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr notification_type_;
  uint32_t temperature_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationDockUnsupportedFirmware final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationDockUnsupportedFirmware) */ {
 public:
  inline CClientNotificationDockUnsupportedFirmware() : CClientNotificationDockUnsupportedFirmware(nullptr) {}
  explicit constexpr CClientNotificationDockUnsupportedFirmware(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationDockUnsupportedFirmware(const CClientNotificationDockUnsupportedFirmware& from);
  CClientNotificationDockUnsupportedFirmware(CClientNotificationDockUnsupportedFirmware&& from) noexcept
    : CClientNotificationDockUnsupportedFirmware() {
    *this = ::std::move(from);
  }

  inline CClientNotificationDockUnsupportedFirmware& operator=(const CClientNotificationDockUnsupportedFirmware& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationDockUnsupportedFirmware& operator=(CClientNotificationDockUnsupportedFirmware&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationDockUnsupportedFirmware& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationDockUnsupportedFirmware* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationDockUnsupportedFirmware*>(
               &_CClientNotificationDockUnsupportedFirmware_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CClientNotificationDockUnsupportedFirmware& a, CClientNotificationDockUnsupportedFirmware& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationDockUnsupportedFirmware* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationDockUnsupportedFirmware* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationDockUnsupportedFirmware* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationDockUnsupportedFirmware>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationDockUnsupportedFirmware& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationDockUnsupportedFirmware& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationDockUnsupportedFirmware";
  }
  protected:
  explicit CClientNotificationDockUnsupportedFirmware(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationDockUnsupportedFirmware)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationPeerContentUpload final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationPeerContentUpload) */ {
 public:
  inline CClientNotificationPeerContentUpload() : CClientNotificationPeerContentUpload(nullptr) {}
  ~CClientNotificationPeerContentUpload() override;
  explicit constexpr CClientNotificationPeerContentUpload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationPeerContentUpload(const CClientNotificationPeerContentUpload& from);
  CClientNotificationPeerContentUpload(CClientNotificationPeerContentUpload&& from) noexcept
    : CClientNotificationPeerContentUpload() {
    *this = ::std::move(from);
  }

  inline CClientNotificationPeerContentUpload& operator=(const CClientNotificationPeerContentUpload& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationPeerContentUpload& operator=(CClientNotificationPeerContentUpload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationPeerContentUpload& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationPeerContentUpload* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationPeerContentUpload*>(
               &_CClientNotificationPeerContentUpload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CClientNotificationPeerContentUpload& a, CClientNotificationPeerContentUpload& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationPeerContentUpload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationPeerContentUpload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationPeerContentUpload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationPeerContentUpload>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationPeerContentUpload& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationPeerContentUpload& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationPeerContentUpload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationPeerContentUpload";
  }
  protected:
  explicit CClientNotificationPeerContentUpload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPeerNameFieldNumber = 2,
    kAppidFieldNumber = 1,
  };
  // optional string peer_name = 2;
  bool has_peer_name() const;
  private:
  bool _internal_has_peer_name() const;
  public:
  void clear_peer_name();
  const std::string& peer_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_peer_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_peer_name();
  PROTOBUF_NODISCARD std::string* release_peer_name();
  void set_allocated_peer_name(std::string* peer_name);
  private:
  const std::string& _internal_peer_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_peer_name(const std::string& value);
  std::string* _internal_mutable_peer_name();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationPeerContentUpload)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr peer_name_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationCannotReadControllerGuideButton final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationCannotReadControllerGuideButton) */ {
 public:
  inline CClientNotificationCannotReadControllerGuideButton() : CClientNotificationCannotReadControllerGuideButton(nullptr) {}
  ~CClientNotificationCannotReadControllerGuideButton() override;
  explicit constexpr CClientNotificationCannotReadControllerGuideButton(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationCannotReadControllerGuideButton(const CClientNotificationCannotReadControllerGuideButton& from);
  CClientNotificationCannotReadControllerGuideButton(CClientNotificationCannotReadControllerGuideButton&& from) noexcept
    : CClientNotificationCannotReadControllerGuideButton() {
    *this = ::std::move(from);
  }

  inline CClientNotificationCannotReadControllerGuideButton& operator=(const CClientNotificationCannotReadControllerGuideButton& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationCannotReadControllerGuideButton& operator=(CClientNotificationCannotReadControllerGuideButton&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationCannotReadControllerGuideButton& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationCannotReadControllerGuideButton* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationCannotReadControllerGuideButton*>(
               &_CClientNotificationCannotReadControllerGuideButton_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CClientNotificationCannotReadControllerGuideButton& a, CClientNotificationCannotReadControllerGuideButton& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationCannotReadControllerGuideButton* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationCannotReadControllerGuideButton* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationCannotReadControllerGuideButton* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationCannotReadControllerGuideButton>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationCannotReadControllerGuideButton& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationCannotReadControllerGuideButton& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationCannotReadControllerGuideButton* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationCannotReadControllerGuideButton";
  }
  protected:
  explicit CClientNotificationCannotReadControllerGuideButton(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerIndexFieldNumber = 1,
  };
  // optional int32 controller_index = 1;
  bool has_controller_index() const;
  private:
  bool _internal_has_controller_index() const;
  public:
  void clear_controller_index();
  int32_t controller_index() const;
  void set_controller_index(int32_t value);
  private:
  int32_t _internal_controller_index() const;
  void _internal_set_controller_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationCannotReadControllerGuideButton)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t controller_index_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationOverlaySplashScreen final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationOverlaySplashScreen) */ {
 public:
  inline CClientNotificationOverlaySplashScreen() : CClientNotificationOverlaySplashScreen(nullptr) {}
  explicit constexpr CClientNotificationOverlaySplashScreen(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationOverlaySplashScreen(const CClientNotificationOverlaySplashScreen& from);
  CClientNotificationOverlaySplashScreen(CClientNotificationOverlaySplashScreen&& from) noexcept
    : CClientNotificationOverlaySplashScreen() {
    *this = ::std::move(from);
  }

  inline CClientNotificationOverlaySplashScreen& operator=(const CClientNotificationOverlaySplashScreen& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationOverlaySplashScreen& operator=(CClientNotificationOverlaySplashScreen&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationOverlaySplashScreen& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationOverlaySplashScreen* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationOverlaySplashScreen*>(
               &_CClientNotificationOverlaySplashScreen_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CClientNotificationOverlaySplashScreen& a, CClientNotificationOverlaySplashScreen& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationOverlaySplashScreen* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationOverlaySplashScreen* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationOverlaySplashScreen* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationOverlaySplashScreen>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationOverlaySplashScreen& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationOverlaySplashScreen& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationOverlaySplashScreen";
  }
  protected:
  explicit CClientNotificationOverlaySplashScreen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationOverlaySplashScreen)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationBroadcastAvailableToWatch final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationBroadcastAvailableToWatch) */ {
 public:
  inline CClientNotificationBroadcastAvailableToWatch() : CClientNotificationBroadcastAvailableToWatch(nullptr) {}
  ~CClientNotificationBroadcastAvailableToWatch() override;
  explicit constexpr CClientNotificationBroadcastAvailableToWatch(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationBroadcastAvailableToWatch(const CClientNotificationBroadcastAvailableToWatch& from);
  CClientNotificationBroadcastAvailableToWatch(CClientNotificationBroadcastAvailableToWatch&& from) noexcept
    : CClientNotificationBroadcastAvailableToWatch() {
    *this = ::std::move(from);
  }

  inline CClientNotificationBroadcastAvailableToWatch& operator=(const CClientNotificationBroadcastAvailableToWatch& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationBroadcastAvailableToWatch& operator=(CClientNotificationBroadcastAvailableToWatch&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationBroadcastAvailableToWatch& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationBroadcastAvailableToWatch* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationBroadcastAvailableToWatch*>(
               &_CClientNotificationBroadcastAvailableToWatch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CClientNotificationBroadcastAvailableToWatch& a, CClientNotificationBroadcastAvailableToWatch& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationBroadcastAvailableToWatch* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationBroadcastAvailableToWatch* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationBroadcastAvailableToWatch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationBroadcastAvailableToWatch>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationBroadcastAvailableToWatch& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationBroadcastAvailableToWatch& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationBroadcastAvailableToWatch* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationBroadcastAvailableToWatch";
  }
  protected:
  explicit CClientNotificationBroadcastAvailableToWatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBroadcastPermissionFieldNumber = 1,
  };
  // optional int32 broadcast_permission = 1;
  bool has_broadcast_permission() const;
  private:
  bool _internal_has_broadcast_permission() const;
  public:
  void clear_broadcast_permission();
  int32_t broadcast_permission() const;
  void set_broadcast_permission(int32_t value);
  private:
  int32_t _internal_broadcast_permission() const;
  void _internal_set_broadcast_permission(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationBroadcastAvailableToWatch)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t broadcast_permission_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationTimedTrialRemaining final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationTimedTrialRemaining) */ {
 public:
  inline CClientNotificationTimedTrialRemaining() : CClientNotificationTimedTrialRemaining(nullptr) {}
  ~CClientNotificationTimedTrialRemaining() override;
  explicit constexpr CClientNotificationTimedTrialRemaining(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationTimedTrialRemaining(const CClientNotificationTimedTrialRemaining& from);
  CClientNotificationTimedTrialRemaining(CClientNotificationTimedTrialRemaining&& from) noexcept
    : CClientNotificationTimedTrialRemaining() {
    *this = ::std::move(from);
  }

  inline CClientNotificationTimedTrialRemaining& operator=(const CClientNotificationTimedTrialRemaining& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationTimedTrialRemaining& operator=(CClientNotificationTimedTrialRemaining&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationTimedTrialRemaining& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationTimedTrialRemaining* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationTimedTrialRemaining*>(
               &_CClientNotificationTimedTrialRemaining_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CClientNotificationTimedTrialRemaining& a, CClientNotificationTimedTrialRemaining& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationTimedTrialRemaining* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationTimedTrialRemaining* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationTimedTrialRemaining* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationTimedTrialRemaining>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationTimedTrialRemaining& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationTimedTrialRemaining& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationTimedTrialRemaining* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationTimedTrialRemaining";
  }
  protected:
  explicit CClientNotificationTimedTrialRemaining(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconFieldNumber = 2,
    kAppidFieldNumber = 1,
    kOfflineFieldNumber = 3,
    kAllowedSecondsFieldNumber = 4,
    kPlayedSecondsFieldNumber = 5,
  };
  // optional string icon = 2;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional bool offline = 3;
  bool has_offline() const;
  private:
  bool _internal_has_offline() const;
  public:
  void clear_offline();
  bool offline() const;
  void set_offline(bool value);
  private:
  bool _internal_offline() const;
  void _internal_set_offline(bool value);
  public:

  // optional uint32 allowed_seconds = 4;
  bool has_allowed_seconds() const;
  private:
  bool _internal_has_allowed_seconds() const;
  public:
  void clear_allowed_seconds();
  uint32_t allowed_seconds() const;
  void set_allowed_seconds(uint32_t value);
  private:
  uint32_t _internal_allowed_seconds() const;
  void _internal_set_allowed_seconds(uint32_t value);
  public:

  // optional uint32 played_seconds = 5;
  bool has_played_seconds() const;
  private:
  bool _internal_has_played_seconds() const;
  public:
  void clear_played_seconds();
  uint32_t played_seconds() const;
  void set_played_seconds(uint32_t value);
  private:
  uint32_t _internal_played_seconds() const;
  void _internal_set_played_seconds(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationTimedTrialRemaining)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  uint32_t appid_;
  bool offline_;
  uint32_t allowed_seconds_;
  uint32_t played_seconds_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationLoginRefresh final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationLoginRefresh) */ {
 public:
  inline CClientNotificationLoginRefresh() : CClientNotificationLoginRefresh(nullptr) {}
  explicit constexpr CClientNotificationLoginRefresh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationLoginRefresh(const CClientNotificationLoginRefresh& from);
  CClientNotificationLoginRefresh(CClientNotificationLoginRefresh&& from) noexcept
    : CClientNotificationLoginRefresh() {
    *this = ::std::move(from);
  }

  inline CClientNotificationLoginRefresh& operator=(const CClientNotificationLoginRefresh& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationLoginRefresh& operator=(CClientNotificationLoginRefresh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationLoginRefresh& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationLoginRefresh* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationLoginRefresh*>(
               &_CClientNotificationLoginRefresh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CClientNotificationLoginRefresh& a, CClientNotificationLoginRefresh& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationLoginRefresh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationLoginRefresh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationLoginRefresh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationLoginRefresh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationLoginRefresh& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationLoginRefresh& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationLoginRefresh";
  }
  protected:
  explicit CClientNotificationLoginRefresh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationLoginRefresh)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationTimerExpired final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CClientNotificationTimerExpired) */ {
 public:
  inline CClientNotificationTimerExpired() : CClientNotificationTimerExpired(nullptr) {}
  explicit constexpr CClientNotificationTimerExpired(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationTimerExpired(const CClientNotificationTimerExpired& from);
  CClientNotificationTimerExpired(CClientNotificationTimerExpired&& from) noexcept
    : CClientNotificationTimerExpired() {
    *this = ::std::move(from);
  }

  inline CClientNotificationTimerExpired& operator=(const CClientNotificationTimerExpired& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationTimerExpired& operator=(CClientNotificationTimerExpired&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationTimerExpired& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationTimerExpired* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationTimerExpired*>(
               &_CClientNotificationTimerExpired_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CClientNotificationTimerExpired& a, CClientNotificationTimerExpired& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationTimerExpired* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationTimerExpired* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationTimerExpired* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationTimerExpired>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CClientNotificationTimerExpired& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CClientNotificationTimerExpired& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationTimerExpired";
  }
  protected:
  explicit CClientNotificationTimerExpired(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CClientNotificationTimerExpired)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// -------------------------------------------------------------------

class CClientNotificationSteamInputActionSetChanged final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientNotificationSteamInputActionSetChanged) */ {
 public:
  inline CClientNotificationSteamInputActionSetChanged() : CClientNotificationSteamInputActionSetChanged(nullptr) {}
  ~CClientNotificationSteamInputActionSetChanged() override;
  explicit constexpr CClientNotificationSteamInputActionSetChanged(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientNotificationSteamInputActionSetChanged(const CClientNotificationSteamInputActionSetChanged& from);
  CClientNotificationSteamInputActionSetChanged(CClientNotificationSteamInputActionSetChanged&& from) noexcept
    : CClientNotificationSteamInputActionSetChanged() {
    *this = ::std::move(from);
  }

  inline CClientNotificationSteamInputActionSetChanged& operator=(const CClientNotificationSteamInputActionSetChanged& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientNotificationSteamInputActionSetChanged& operator=(CClientNotificationSteamInputActionSetChanged&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientNotificationSteamInputActionSetChanged& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientNotificationSteamInputActionSetChanged* internal_default_instance() {
    return reinterpret_cast<const CClientNotificationSteamInputActionSetChanged*>(
               &_CClientNotificationSteamInputActionSetChanged_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CClientNotificationSteamInputActionSetChanged& a, CClientNotificationSteamInputActionSetChanged& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientNotificationSteamInputActionSetChanged* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientNotificationSteamInputActionSetChanged* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientNotificationSteamInputActionSetChanged* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientNotificationSteamInputActionSetChanged>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientNotificationSteamInputActionSetChanged& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientNotificationSteamInputActionSetChanged& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientNotificationSteamInputActionSetChanged* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientNotificationSteamInputActionSetChanged";
  }
  protected:
  explicit CClientNotificationSteamInputActionSetChanged(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kActionSetNameFieldNumber = 2,
    kControllerIndexFieldNumber = 1,
  };
  // optional string action_set_name = 2;
  bool has_action_set_name() const;
  private:
  bool _internal_has_action_set_name() const;
  public:
  void clear_action_set_name();
  const std::string& action_set_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_action_set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_action_set_name();
  PROTOBUF_NODISCARD std::string* release_action_set_name();
  void set_allocated_action_set_name(std::string* action_set_name);
  private:
  const std::string& _internal_action_set_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_action_set_name(const std::string& value);
  std::string* _internal_mutable_action_set_name();
  public:

  // optional int32 controller_index = 1;
  bool has_controller_index() const;
  private:
  bool _internal_has_controller_index() const;
  public:
  void clear_controller_index();
  int32_t controller_index() const;
  void set_controller_index(int32_t value);
  private:
  int32_t _internal_controller_index() const;
  void _internal_set_controller_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CClientNotificationSteamInputActionSetChanged)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr action_set_name_;
  int32_t controller_index_;
  friend struct ::TableStruct_steammessages_5fclientnotificationtypes_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CClientNotificationCloudSyncFailure

// optional uint32 appid = 1;
inline bool CClientNotificationCloudSyncFailure::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationCloudSyncFailure::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationCloudSyncFailure::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationCloudSyncFailure::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationCloudSyncFailure::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationCloudSyncFailure.appid)
  return _internal_appid();
}
inline void CClientNotificationCloudSyncFailure::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CClientNotificationCloudSyncFailure::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationCloudSyncFailure.appid)
}

// -------------------------------------------------------------------

// CClientNotificationCloudSyncConflict

// optional uint32 appid = 1;
inline bool CClientNotificationCloudSyncConflict::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationCloudSyncConflict::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationCloudSyncConflict::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationCloudSyncConflict::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationCloudSyncConflict::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationCloudSyncConflict.appid)
  return _internal_appid();
}
inline void CClientNotificationCloudSyncConflict::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CClientNotificationCloudSyncConflict::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationCloudSyncConflict.appid)
}

// -------------------------------------------------------------------

// CClientNotificationScreenshot

// optional string screenshot_handle = 1;
inline bool CClientNotificationScreenshot::_internal_has_screenshot_handle() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationScreenshot::has_screenshot_handle() const {
  return _internal_has_screenshot_handle();
}
inline void CClientNotificationScreenshot::clear_screenshot_handle() {
  screenshot_handle_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationScreenshot::screenshot_handle() const {
  // @@protoc_insertion_point(field_get:CClientNotificationScreenshot.screenshot_handle)
  return _internal_screenshot_handle();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationScreenshot::set_screenshot_handle(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 screenshot_handle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationScreenshot.screenshot_handle)
}
inline std::string* CClientNotificationScreenshot::mutable_screenshot_handle() {
  std::string* _s = _internal_mutable_screenshot_handle();
  // @@protoc_insertion_point(field_mutable:CClientNotificationScreenshot.screenshot_handle)
  return _s;
}
inline const std::string& CClientNotificationScreenshot::_internal_screenshot_handle() const {
  return screenshot_handle_.Get();
}
inline void CClientNotificationScreenshot::_internal_set_screenshot_handle(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  screenshot_handle_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::_internal_mutable_screenshot_handle() {
  _has_bits_[0] |= 0x00000001u;
  return screenshot_handle_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::release_screenshot_handle() {
  // @@protoc_insertion_point(field_release:CClientNotificationScreenshot.screenshot_handle)
  if (!_internal_has_screenshot_handle()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = screenshot_handle_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_handle_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_handle_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationScreenshot::set_allocated_screenshot_handle(std::string* screenshot_handle) {
  if (screenshot_handle != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  screenshot_handle_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), screenshot_handle,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_handle_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_handle_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationScreenshot.screenshot_handle)
}

// optional string description = 2;
inline bool CClientNotificationScreenshot::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationScreenshot::has_description() const {
  return _internal_has_description();
}
inline void CClientNotificationScreenshot::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CClientNotificationScreenshot::description() const {
  // @@protoc_insertion_point(field_get:CClientNotificationScreenshot.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationScreenshot::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationScreenshot.description)
}
inline std::string* CClientNotificationScreenshot::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:CClientNotificationScreenshot.description)
  return _s;
}
inline const std::string& CClientNotificationScreenshot::_internal_description() const {
  return description_.Get();
}
inline void CClientNotificationScreenshot::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000002u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::release_description() {
  // @@protoc_insertion_point(field_release:CClientNotificationScreenshot.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationScreenshot::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationScreenshot.description)
}

// optional string local_url = 3;
inline bool CClientNotificationScreenshot::_internal_has_local_url() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CClientNotificationScreenshot::has_local_url() const {
  return _internal_has_local_url();
}
inline void CClientNotificationScreenshot::clear_local_url() {
  local_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CClientNotificationScreenshot::local_url() const {
  // @@protoc_insertion_point(field_get:CClientNotificationScreenshot.local_url)
  return _internal_local_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationScreenshot::set_local_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 local_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationScreenshot.local_url)
}
inline std::string* CClientNotificationScreenshot::mutable_local_url() {
  std::string* _s = _internal_mutable_local_url();
  // @@protoc_insertion_point(field_mutable:CClientNotificationScreenshot.local_url)
  return _s;
}
inline const std::string& CClientNotificationScreenshot::_internal_local_url() const {
  return local_url_.Get();
}
inline void CClientNotificationScreenshot::_internal_set_local_url(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  local_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::_internal_mutable_local_url() {
  _has_bits_[0] |= 0x00000004u;
  return local_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationScreenshot::release_local_url() {
  // @@protoc_insertion_point(field_release:CClientNotificationScreenshot.local_url)
  if (!_internal_has_local_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = local_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (local_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    local_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationScreenshot::set_allocated_local_url(std::string* local_url) {
  if (local_url != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  local_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), local_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (local_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    local_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationScreenshot.local_url)
}

// -------------------------------------------------------------------

// CClientNotificationDownloadCompleted

// optional uint32 appid = 1;
inline bool CClientNotificationDownloadCompleted::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationDownloadCompleted::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationDownloadCompleted::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationDownloadCompleted::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationDownloadCompleted::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationDownloadCompleted.appid)
  return _internal_appid();
}
inline void CClientNotificationDownloadCompleted::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CClientNotificationDownloadCompleted::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationDownloadCompleted.appid)
}

// -------------------------------------------------------------------

// CClientNotificationFriendInvite

// optional fixed64 steamid = 1;
inline bool CClientNotificationFriendInvite::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFriendInvite::has_steamid() const {
  return _internal_has_steamid();
}
inline void CClientNotificationFriendInvite::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CClientNotificationFriendInvite::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CClientNotificationFriendInvite::steamid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendInvite.steamid)
  return _internal_steamid();
}
inline void CClientNotificationFriendInvite::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = value;
}
inline void CClientNotificationFriendInvite::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFriendInvite.steamid)
}

// -------------------------------------------------------------------

// CClientNotificationFriendInviteRollup

// optional uint32 new_invite_count = 1;
inline bool CClientNotificationFriendInviteRollup::_internal_has_new_invite_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFriendInviteRollup::has_new_invite_count() const {
  return _internal_has_new_invite_count();
}
inline void CClientNotificationFriendInviteRollup::clear_new_invite_count() {
  new_invite_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationFriendInviteRollup::_internal_new_invite_count() const {
  return new_invite_count_;
}
inline uint32_t CClientNotificationFriendInviteRollup::new_invite_count() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendInviteRollup.new_invite_count)
  return _internal_new_invite_count();
}
inline void CClientNotificationFriendInviteRollup::_internal_set_new_invite_count(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  new_invite_count_ = value;
}
inline void CClientNotificationFriendInviteRollup::set_new_invite_count(uint32_t value) {
  _internal_set_new_invite_count(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFriendInviteRollup.new_invite_count)
}

// -------------------------------------------------------------------

// CClientNotificationFriendInGame

// optional fixed64 steamid = 1;
inline bool CClientNotificationFriendInGame::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationFriendInGame::has_steamid() const {
  return _internal_has_steamid();
}
inline void CClientNotificationFriendInGame::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CClientNotificationFriendInGame::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CClientNotificationFriendInGame::steamid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendInGame.steamid)
  return _internal_steamid();
}
inline void CClientNotificationFriendInGame::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CClientNotificationFriendInGame::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFriendInGame.steamid)
}

// optional string game_name = 2;
inline bool CClientNotificationFriendInGame::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFriendInGame::has_game_name() const {
  return _internal_has_game_name();
}
inline void CClientNotificationFriendInGame::clear_game_name() {
  game_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationFriendInGame::game_name() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendInGame.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendInGame::set_game_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendInGame.game_name)
}
inline std::string* CClientNotificationFriendInGame::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendInGame.game_name)
  return _s;
}
inline const std::string& CClientNotificationFriendInGame::_internal_game_name() const {
  return game_name_.Get();
}
inline void CClientNotificationFriendInGame::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendInGame::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  return game_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendInGame::release_game_name() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendInGame.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendInGame::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendInGame.game_name)
}

// -------------------------------------------------------------------

// CClientNotificationFriendOnline

// optional fixed64 steamid = 1;
inline bool CClientNotificationFriendOnline::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFriendOnline::has_steamid() const {
  return _internal_has_steamid();
}
inline void CClientNotificationFriendOnline::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CClientNotificationFriendOnline::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CClientNotificationFriendOnline::steamid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendOnline.steamid)
  return _internal_steamid();
}
inline void CClientNotificationFriendOnline::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = value;
}
inline void CClientNotificationFriendOnline::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFriendOnline.steamid)
}

// -------------------------------------------------------------------

// CClientNotificationAchievement

// optional string achievement_id = 1;
inline bool CClientNotificationAchievement::_internal_has_achievement_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_achievement_id() const {
  return _internal_has_achievement_id();
}
inline void CClientNotificationAchievement::clear_achievement_id() {
  achievement_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationAchievement::achievement_id() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.achievement_id)
  return _internal_achievement_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationAchievement::set_achievement_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 achievement_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.achievement_id)
}
inline std::string* CClientNotificationAchievement::mutable_achievement_id() {
  std::string* _s = _internal_mutable_achievement_id();
  // @@protoc_insertion_point(field_mutable:CClientNotificationAchievement.achievement_id)
  return _s;
}
inline const std::string& CClientNotificationAchievement::_internal_achievement_id() const {
  return achievement_id_.Get();
}
inline void CClientNotificationAchievement::_internal_set_achievement_id(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  achievement_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::_internal_mutable_achievement_id() {
  _has_bits_[0] |= 0x00000001u;
  return achievement_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::release_achievement_id() {
  // @@protoc_insertion_point(field_release:CClientNotificationAchievement.achievement_id)
  if (!_internal_has_achievement_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = achievement_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (achievement_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    achievement_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationAchievement::set_allocated_achievement_id(std::string* achievement_id) {
  if (achievement_id != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  achievement_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), achievement_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (achievement_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    achievement_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationAchievement.achievement_id)
}

// optional uint32 appid = 2;
inline bool CClientNotificationAchievement::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationAchievement::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CClientNotificationAchievement::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationAchievement::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.appid)
  return _internal_appid();
}
inline void CClientNotificationAchievement::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  appid_ = value;
}
inline void CClientNotificationAchievement::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.appid)
}

// optional string name = 3;
inline bool CClientNotificationAchievement::_internal_has_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_name() const {
  return _internal_has_name();
}
inline void CClientNotificationAchievement::clear_name() {
  name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CClientNotificationAchievement::name() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationAchievement::set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.name)
}
inline std::string* CClientNotificationAchievement::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:CClientNotificationAchievement.name)
  return _s;
}
inline const std::string& CClientNotificationAchievement::_internal_name() const {
  return name_.Get();
}
inline void CClientNotificationAchievement::_internal_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::_internal_mutable_name() {
  _has_bits_[0] |= 0x00000002u;
  return name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::release_name() {
  // @@protoc_insertion_point(field_release:CClientNotificationAchievement.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationAchievement::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationAchievement.name)
}

// optional string description = 4;
inline bool CClientNotificationAchievement::_internal_has_description() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_description() const {
  return _internal_has_description();
}
inline void CClientNotificationAchievement::clear_description() {
  description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CClientNotificationAchievement::description() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.description)
  return _internal_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationAchievement::set_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.description)
}
inline std::string* CClientNotificationAchievement::mutable_description() {
  std::string* _s = _internal_mutable_description();
  // @@protoc_insertion_point(field_mutable:CClientNotificationAchievement.description)
  return _s;
}
inline const std::string& CClientNotificationAchievement::_internal_description() const {
  return description_.Get();
}
inline void CClientNotificationAchievement::_internal_set_description(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::_internal_mutable_description() {
  _has_bits_[0] |= 0x00000004u;
  return description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::release_description() {
  // @@protoc_insertion_point(field_release:CClientNotificationAchievement.description)
  if (!_internal_has_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationAchievement::set_allocated_description(std::string* description) {
  if (description != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationAchievement.description)
}

// optional string image_url = 5;
inline bool CClientNotificationAchievement::_internal_has_image_url() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_image_url() const {
  return _internal_has_image_url();
}
inline void CClientNotificationAchievement::clear_image_url() {
  image_url_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CClientNotificationAchievement::image_url() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.image_url)
  return _internal_image_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationAchievement::set_image_url(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.image_url)
}
inline std::string* CClientNotificationAchievement::mutable_image_url() {
  std::string* _s = _internal_mutable_image_url();
  // @@protoc_insertion_point(field_mutable:CClientNotificationAchievement.image_url)
  return _s;
}
inline const std::string& CClientNotificationAchievement::_internal_image_url() const {
  return image_url_.Get();
}
inline void CClientNotificationAchievement::_internal_set_image_url(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  image_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::_internal_mutable_image_url() {
  _has_bits_[0] |= 0x00000008u;
  return image_url_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationAchievement::release_image_url() {
  // @@protoc_insertion_point(field_release:CClientNotificationAchievement.image_url)
  if (!_internal_has_image_url()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = image_url_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationAchievement::set_allocated_image_url(std::string* image_url) {
  if (image_url != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  image_url_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image_url,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_url_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationAchievement.image_url)
}

// optional bool achieved = 6;
inline bool CClientNotificationAchievement::_internal_has_achieved() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_achieved() const {
  return _internal_has_achieved();
}
inline void CClientNotificationAchievement::clear_achieved() {
  achieved_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CClientNotificationAchievement::_internal_achieved() const {
  return achieved_;
}
inline bool CClientNotificationAchievement::achieved() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.achieved)
  return _internal_achieved();
}
inline void CClientNotificationAchievement::_internal_set_achieved(bool value) {
  _has_bits_[0] |= 0x00000020u;
  achieved_ = value;
}
inline void CClientNotificationAchievement::set_achieved(bool value) {
  _internal_set_achieved(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.achieved)
}

// optional uint32 rtime_unlocked = 7;
inline bool CClientNotificationAchievement::_internal_has_rtime_unlocked() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_rtime_unlocked() const {
  return _internal_has_rtime_unlocked();
}
inline void CClientNotificationAchievement::clear_rtime_unlocked() {
  rtime_unlocked_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CClientNotificationAchievement::_internal_rtime_unlocked() const {
  return rtime_unlocked_;
}
inline uint32_t CClientNotificationAchievement::rtime_unlocked() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.rtime_unlocked)
  return _internal_rtime_unlocked();
}
inline void CClientNotificationAchievement::_internal_set_rtime_unlocked(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  rtime_unlocked_ = value;
}
inline void CClientNotificationAchievement::set_rtime_unlocked(uint32_t value) {
  _internal_set_rtime_unlocked(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.rtime_unlocked)
}

// optional float min_progress = 8;
inline bool CClientNotificationAchievement::_internal_has_min_progress() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_min_progress() const {
  return _internal_has_min_progress();
}
inline void CClientNotificationAchievement::clear_min_progress() {
  min_progress_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CClientNotificationAchievement::_internal_min_progress() const {
  return min_progress_;
}
inline float CClientNotificationAchievement::min_progress() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.min_progress)
  return _internal_min_progress();
}
inline void CClientNotificationAchievement::_internal_set_min_progress(float value) {
  _has_bits_[0] |= 0x00000080u;
  min_progress_ = value;
}
inline void CClientNotificationAchievement::set_min_progress(float value) {
  _internal_set_min_progress(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.min_progress)
}

// optional float current_progress = 9;
inline bool CClientNotificationAchievement::_internal_has_current_progress() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_current_progress() const {
  return _internal_has_current_progress();
}
inline void CClientNotificationAchievement::clear_current_progress() {
  current_progress_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CClientNotificationAchievement::_internal_current_progress() const {
  return current_progress_;
}
inline float CClientNotificationAchievement::current_progress() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.current_progress)
  return _internal_current_progress();
}
inline void CClientNotificationAchievement::_internal_set_current_progress(float value) {
  _has_bits_[0] |= 0x00000100u;
  current_progress_ = value;
}
inline void CClientNotificationAchievement::set_current_progress(float value) {
  _internal_set_current_progress(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.current_progress)
}

// optional float max_progress = 10;
inline bool CClientNotificationAchievement::_internal_has_max_progress() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_max_progress() const {
  return _internal_has_max_progress();
}
inline void CClientNotificationAchievement::clear_max_progress() {
  max_progress_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float CClientNotificationAchievement::_internal_max_progress() const {
  return max_progress_;
}
inline float CClientNotificationAchievement::max_progress() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.max_progress)
  return _internal_max_progress();
}
inline void CClientNotificationAchievement::_internal_set_max_progress(float value) {
  _has_bits_[0] |= 0x00000200u;
  max_progress_ = value;
}
inline void CClientNotificationAchievement::set_max_progress(float value) {
  _internal_set_max_progress(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.max_progress)
}

// optional float global_achieved_pct = 11;
inline bool CClientNotificationAchievement::_internal_has_global_achieved_pct() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CClientNotificationAchievement::has_global_achieved_pct() const {
  return _internal_has_global_achieved_pct();
}
inline void CClientNotificationAchievement::clear_global_achieved_pct() {
  global_achieved_pct_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline float CClientNotificationAchievement::_internal_global_achieved_pct() const {
  return global_achieved_pct_;
}
inline float CClientNotificationAchievement::global_achieved_pct() const {
  // @@protoc_insertion_point(field_get:CClientNotificationAchievement.global_achieved_pct)
  return _internal_global_achieved_pct();
}
inline void CClientNotificationAchievement::_internal_set_global_achieved_pct(float value) {
  _has_bits_[0] |= 0x00000400u;
  global_achieved_pct_ = value;
}
inline void CClientNotificationAchievement::set_global_achieved_pct(float value) {
  _internal_set_global_achieved_pct(value);
  // @@protoc_insertion_point(field_set:CClientNotificationAchievement.global_achieved_pct)
}

// -------------------------------------------------------------------

// CClientNotificationLowBattery

// optional float pct_remaining = 1;
inline bool CClientNotificationLowBattery::_internal_has_pct_remaining() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationLowBattery::has_pct_remaining() const {
  return _internal_has_pct_remaining();
}
inline void CClientNotificationLowBattery::clear_pct_remaining() {
  pct_remaining_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float CClientNotificationLowBattery::_internal_pct_remaining() const {
  return pct_remaining_;
}
inline float CClientNotificationLowBattery::pct_remaining() const {
  // @@protoc_insertion_point(field_get:CClientNotificationLowBattery.pct_remaining)
  return _internal_pct_remaining();
}
inline void CClientNotificationLowBattery::_internal_set_pct_remaining(float value) {
  _has_bits_[0] |= 0x00000001u;
  pct_remaining_ = value;
}
inline void CClientNotificationLowBattery::set_pct_remaining(float value) {
  _internal_set_pct_remaining(value);
  // @@protoc_insertion_point(field_set:CClientNotificationLowBattery.pct_remaining)
}

// -------------------------------------------------------------------

// CClientNotificationSystemUpdate

// optional .ESystemUpdateNotificationType type = 1 [default = k_ESystemUpdateNotificationType_Invalid];
inline bool CClientNotificationSystemUpdate::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationSystemUpdate::has_type() const {
  return _internal_has_type();
}
inline void CClientNotificationSystemUpdate::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ESystemUpdateNotificationType CClientNotificationSystemUpdate::_internal_type() const {
  return static_cast< ::ESystemUpdateNotificationType >(type_);
}
inline ::ESystemUpdateNotificationType CClientNotificationSystemUpdate::type() const {
  // @@protoc_insertion_point(field_get:CClientNotificationSystemUpdate.type)
  return _internal_type();
}
inline void CClientNotificationSystemUpdate::_internal_set_type(::ESystemUpdateNotificationType value) {
  assert(::ESystemUpdateNotificationType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  type_ = value;
}
inline void CClientNotificationSystemUpdate::set_type(::ESystemUpdateNotificationType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CClientNotificationSystemUpdate.type)
}

// -------------------------------------------------------------------

// CClientNotificationFriendMessage

// optional string tag = 1;
inline bool CClientNotificationFriendMessage::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_tag() const {
  return _internal_has_tag();
}
inline void CClientNotificationFriendMessage::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationFriendMessage::tag() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.tag)
}
inline std::string* CClientNotificationFriendMessage::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.tag)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_tag() const {
  return tag_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_tag() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.tag)
}

// optional string steamid = 2;
inline bool CClientNotificationFriendMessage::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_steamid() const {
  return _internal_has_steamid();
}
inline void CClientNotificationFriendMessage::clear_steamid() {
  steamid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CClientNotificationFriendMessage::steamid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.steamid)
  return _internal_steamid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_steamid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 steamid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.steamid)
}
inline std::string* CClientNotificationFriendMessage::mutable_steamid() {
  std::string* _s = _internal_mutable_steamid();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.steamid)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_steamid() const {
  return steamid_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_steamid(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_steamid() {
  _has_bits_[0] |= 0x00000002u;
  return steamid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_steamid() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.steamid)
  if (!_internal_has_steamid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = steamid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (steamid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    steamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_steamid(std::string* steamid) {
  if (steamid != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  steamid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), steamid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (steamid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    steamid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.steamid)
}

// optional string title = 3;
inline bool CClientNotificationFriendMessage::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_title() const {
  return _internal_has_title();
}
inline void CClientNotificationFriendMessage::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CClientNotificationFriendMessage::title() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.title)
}
inline std::string* CClientNotificationFriendMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.title)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_title() const {
  return title_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000004u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_title() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.title)
}

// optional string body = 4;
inline bool CClientNotificationFriendMessage::_internal_has_body() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_body() const {
  return _internal_has_body();
}
inline void CClientNotificationFriendMessage::clear_body() {
  body_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CClientNotificationFriendMessage::body() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_body(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.body)
}
inline std::string* CClientNotificationFriendMessage::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.body)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_body() const {
  return body_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_body(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_body() {
  _has_bits_[0] |= 0x00000008u;
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_body() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = body_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.body)
}

// optional string icon = 5;
inline bool CClientNotificationFriendMessage::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_icon() const {
  return _internal_has_icon();
}
inline void CClientNotificationFriendMessage::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CClientNotificationFriendMessage::icon() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.icon)
}
inline std::string* CClientNotificationFriendMessage::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.icon)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_icon() const {
  return icon_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000010u;
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_icon() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.icon)
}

// optional uint32 notificationid = 6;
inline bool CClientNotificationFriendMessage::_internal_has_notificationid() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_notificationid() const {
  return _internal_has_notificationid();
}
inline void CClientNotificationFriendMessage::clear_notificationid() {
  notificationid_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CClientNotificationFriendMessage::_internal_notificationid() const {
  return notificationid_;
}
inline uint32_t CClientNotificationFriendMessage::notificationid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.notificationid)
  return _internal_notificationid();
}
inline void CClientNotificationFriendMessage::_internal_set_notificationid(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  notificationid_ = value;
}
inline void CClientNotificationFriendMessage::set_notificationid(uint32_t value) {
  _internal_set_notificationid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.notificationid)
}

// optional string response_steamurl = 7;
inline bool CClientNotificationFriendMessage::_internal_has_response_steamurl() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CClientNotificationFriendMessage::has_response_steamurl() const {
  return _internal_has_response_steamurl();
}
inline void CClientNotificationFriendMessage::clear_response_steamurl() {
  response_steamurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CClientNotificationFriendMessage::response_steamurl() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFriendMessage.response_steamurl)
  return _internal_response_steamurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationFriendMessage::set_response_steamurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 response_steamurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationFriendMessage.response_steamurl)
}
inline std::string* CClientNotificationFriendMessage::mutable_response_steamurl() {
  std::string* _s = _internal_mutable_response_steamurl();
  // @@protoc_insertion_point(field_mutable:CClientNotificationFriendMessage.response_steamurl)
  return _s;
}
inline const std::string& CClientNotificationFriendMessage::_internal_response_steamurl() const {
  return response_steamurl_.Get();
}
inline void CClientNotificationFriendMessage::_internal_set_response_steamurl(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  response_steamurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::_internal_mutable_response_steamurl() {
  _has_bits_[0] |= 0x00000020u;
  return response_steamurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationFriendMessage::release_response_steamurl() {
  // @@protoc_insertion_point(field_release:CClientNotificationFriendMessage.response_steamurl)
  if (!_internal_has_response_steamurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = response_steamurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_steamurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    response_steamurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationFriendMessage::set_allocated_response_steamurl(std::string* response_steamurl) {
  if (response_steamurl != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  response_steamurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response_steamurl,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_steamurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    response_steamurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationFriendMessage.response_steamurl)
}

// -------------------------------------------------------------------

// CClientNotificationGroupChatMessage

// optional string tag = 1;
inline bool CClientNotificationGroupChatMessage::_internal_has_tag() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_tag() const {
  return _internal_has_tag();
}
inline void CClientNotificationGroupChatMessage::clear_tag() {
  tag_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationGroupChatMessage::tag() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.tag)
  return _internal_tag();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_tag(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.tag)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_tag() {
  std::string* _s = _internal_mutable_tag();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.tag)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_tag() const {
  return tag_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_tag(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  tag_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_tag() {
  _has_bits_[0] |= 0x00000001u;
  return tag_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_tag() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.tag)
  if (!_internal_has_tag()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = tag_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_tag(std::string* tag) {
  if (tag != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  tag_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), tag,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (tag_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    tag_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.tag)
}

// optional string steamid_sender = 2;
inline bool CClientNotificationGroupChatMessage::_internal_has_steamid_sender() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_steamid_sender() const {
  return _internal_has_steamid_sender();
}
inline void CClientNotificationGroupChatMessage::clear_steamid_sender() {
  steamid_sender_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CClientNotificationGroupChatMessage::steamid_sender() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.steamid_sender)
  return _internal_steamid_sender();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_steamid_sender(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 steamid_sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.steamid_sender)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_steamid_sender() {
  std::string* _s = _internal_mutable_steamid_sender();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.steamid_sender)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_steamid_sender() const {
  return steamid_sender_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_steamid_sender(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_sender_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_steamid_sender() {
  _has_bits_[0] |= 0x00000002u;
  return steamid_sender_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_steamid_sender() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.steamid_sender)
  if (!_internal_has_steamid_sender()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = steamid_sender_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (steamid_sender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    steamid_sender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_steamid_sender(std::string* steamid_sender) {
  if (steamid_sender != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  steamid_sender_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), steamid_sender,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (steamid_sender_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    steamid_sender_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.steamid_sender)
}

// optional string chat_group_id = 3;
inline bool CClientNotificationGroupChatMessage::_internal_has_chat_group_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_chat_group_id() const {
  return _internal_has_chat_group_id();
}
inline void CClientNotificationGroupChatMessage::clear_chat_group_id() {
  chat_group_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CClientNotificationGroupChatMessage::chat_group_id() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.chat_group_id)
  return _internal_chat_group_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_chat_group_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 chat_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.chat_group_id)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_chat_group_id() {
  std::string* _s = _internal_mutable_chat_group_id();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.chat_group_id)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_chat_group_id() const {
  return chat_group_id_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_chat_group_id(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  chat_group_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_chat_group_id() {
  _has_bits_[0] |= 0x00000004u;
  return chat_group_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_chat_group_id() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.chat_group_id)
  if (!_internal_has_chat_group_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = chat_group_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_group_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chat_group_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_chat_group_id(std::string* chat_group_id) {
  if (chat_group_id != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  chat_group_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chat_group_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_group_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chat_group_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.chat_group_id)
}

// optional string chat_id = 4;
inline bool CClientNotificationGroupChatMessage::_internal_has_chat_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_chat_id() const {
  return _internal_has_chat_id();
}
inline void CClientNotificationGroupChatMessage::clear_chat_id() {
  chat_id_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CClientNotificationGroupChatMessage::chat_id() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.chat_id)
  return _internal_chat_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_chat_id(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 chat_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.chat_id)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_chat_id() {
  std::string* _s = _internal_mutable_chat_id();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.chat_id)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_chat_id() const {
  return chat_id_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_chat_id(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  chat_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_chat_id() {
  _has_bits_[0] |= 0x00000008u;
  return chat_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_chat_id() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.chat_id)
  if (!_internal_has_chat_id()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = chat_id_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chat_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_chat_id(std::string* chat_id) {
  if (chat_id != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  chat_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chat_id,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (chat_id_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    chat_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.chat_id)
}

// optional string title = 5;
inline bool CClientNotificationGroupChatMessage::_internal_has_title() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_title() const {
  return _internal_has_title();
}
inline void CClientNotificationGroupChatMessage::clear_title() {
  title_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CClientNotificationGroupChatMessage::title() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.title)
  return _internal_title();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_title(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.title)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_title() {
  std::string* _s = _internal_mutable_title();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.title)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_title() const {
  return title_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_title(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  title_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_title() {
  _has_bits_[0] |= 0x00000010u;
  return title_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_title() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.title)
  if (!_internal_has_title()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = title_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_title(std::string* title) {
  if (title != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  title_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), title,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (title_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    title_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.title)
}

// optional string body = 6;
inline bool CClientNotificationGroupChatMessage::_internal_has_body() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_body() const {
  return _internal_has_body();
}
inline void CClientNotificationGroupChatMessage::clear_body() {
  body_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CClientNotificationGroupChatMessage::body() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.body)
  return _internal_body();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_body(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.body)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_body() {
  std::string* _s = _internal_mutable_body();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.body)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_body() const {
  return body_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_body(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  body_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_body() {
  _has_bits_[0] |= 0x00000020u;
  return body_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_body() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.body)
  if (!_internal_has_body()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = body_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_body(std::string* body) {
  if (body != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  body_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), body,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (body_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    body_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.body)
}

// optional string rawbody = 7;
inline bool CClientNotificationGroupChatMessage::_internal_has_rawbody() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_rawbody() const {
  return _internal_has_rawbody();
}
inline void CClientNotificationGroupChatMessage::clear_rawbody() {
  rawbody_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CClientNotificationGroupChatMessage::rawbody() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.rawbody)
  return _internal_rawbody();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_rawbody(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 rawbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.rawbody)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_rawbody() {
  std::string* _s = _internal_mutable_rawbody();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.rawbody)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_rawbody() const {
  return rawbody_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_rawbody(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  rawbody_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_rawbody() {
  _has_bits_[0] |= 0x00000040u;
  return rawbody_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_rawbody() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.rawbody)
  if (!_internal_has_rawbody()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = rawbody_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rawbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rawbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_rawbody(std::string* rawbody) {
  if (rawbody != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  rawbody_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), rawbody,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (rawbody_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    rawbody_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.rawbody)
}

// optional string icon = 8;
inline bool CClientNotificationGroupChatMessage::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_icon() const {
  return _internal_has_icon();
}
inline void CClientNotificationGroupChatMessage::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CClientNotificationGroupChatMessage::icon() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGroupChatMessage::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.icon)
}
inline std::string* CClientNotificationGroupChatMessage::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGroupChatMessage.icon)
  return _s;
}
inline const std::string& CClientNotificationGroupChatMessage::_internal_icon() const {
  return icon_.Get();
}
inline void CClientNotificationGroupChatMessage::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000080u;
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGroupChatMessage::release_icon() {
  // @@protoc_insertion_point(field_release:CClientNotificationGroupChatMessage.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGroupChatMessage::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGroupChatMessage.icon)
}

// optional uint32 notificationid = 9;
inline bool CClientNotificationGroupChatMessage::_internal_has_notificationid() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CClientNotificationGroupChatMessage::has_notificationid() const {
  return _internal_has_notificationid();
}
inline void CClientNotificationGroupChatMessage::clear_notificationid() {
  notificationid_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CClientNotificationGroupChatMessage::_internal_notificationid() const {
  return notificationid_;
}
inline uint32_t CClientNotificationGroupChatMessage::notificationid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGroupChatMessage.notificationid)
  return _internal_notificationid();
}
inline void CClientNotificationGroupChatMessage::_internal_set_notificationid(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  notificationid_ = value;
}
inline void CClientNotificationGroupChatMessage::set_notificationid(uint32_t value) {
  _internal_set_notificationid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationGroupChatMessage.notificationid)
}

// -------------------------------------------------------------------

// CClientNotificationFamilySharingDeviceAuthorizationChanged

// optional uint32 accountid_owner = 1;
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_has_accountid_owner() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::has_accountid_owner() const {
  return _internal_has_accountid_owner();
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::clear_accountid_owner() {
  accountid_owner_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_accountid_owner() const {
  return accountid_owner_;
}
inline uint32_t CClientNotificationFamilySharingDeviceAuthorizationChanged::accountid_owner() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFamilySharingDeviceAuthorizationChanged.accountid_owner)
  return _internal_accountid_owner();
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_set_accountid_owner(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  accountid_owner_ = value;
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::set_accountid_owner(uint32_t value) {
  _internal_set_accountid_owner(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFamilySharingDeviceAuthorizationChanged.accountid_owner)
}

// optional bool authorized = 2;
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_has_authorized() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::has_authorized() const {
  return _internal_has_authorized();
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::clear_authorized() {
  authorized_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_authorized() const {
  return authorized_;
}
inline bool CClientNotificationFamilySharingDeviceAuthorizationChanged::authorized() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFamilySharingDeviceAuthorizationChanged.authorized)
  return _internal_authorized();
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::_internal_set_authorized(bool value) {
  _has_bits_[0] |= 0x00000002u;
  authorized_ = value;
}
inline void CClientNotificationFamilySharingDeviceAuthorizationChanged::set_authorized(bool value) {
  _internal_set_authorized(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFamilySharingDeviceAuthorizationChanged.authorized)
}

// -------------------------------------------------------------------

// CClientNotificationFamilySharingStopPlaying

// optional uint32 accountid_owner = 1;
inline bool CClientNotificationFamilySharingStopPlaying::_internal_has_accountid_owner() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFamilySharingStopPlaying::has_accountid_owner() const {
  return _internal_has_accountid_owner();
}
inline void CClientNotificationFamilySharingStopPlaying::clear_accountid_owner() {
  accountid_owner_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationFamilySharingStopPlaying::_internal_accountid_owner() const {
  return accountid_owner_;
}
inline uint32_t CClientNotificationFamilySharingStopPlaying::accountid_owner() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFamilySharingStopPlaying.accountid_owner)
  return _internal_accountid_owner();
}
inline void CClientNotificationFamilySharingStopPlaying::_internal_set_accountid_owner(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  accountid_owner_ = value;
}
inline void CClientNotificationFamilySharingStopPlaying::set_accountid_owner(uint32_t value) {
  _internal_set_accountid_owner(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFamilySharingStopPlaying.accountid_owner)
}

// optional uint32 seconds_remaining = 2;
inline bool CClientNotificationFamilySharingStopPlaying::_internal_has_seconds_remaining() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationFamilySharingStopPlaying::has_seconds_remaining() const {
  return _internal_has_seconds_remaining();
}
inline void CClientNotificationFamilySharingStopPlaying::clear_seconds_remaining() {
  seconds_remaining_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CClientNotificationFamilySharingStopPlaying::_internal_seconds_remaining() const {
  return seconds_remaining_;
}
inline uint32_t CClientNotificationFamilySharingStopPlaying::seconds_remaining() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFamilySharingStopPlaying.seconds_remaining)
  return _internal_seconds_remaining();
}
inline void CClientNotificationFamilySharingStopPlaying::_internal_set_seconds_remaining(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  seconds_remaining_ = value;
}
inline void CClientNotificationFamilySharingStopPlaying::set_seconds_remaining(uint32_t value) {
  _internal_set_seconds_remaining(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFamilySharingStopPlaying.seconds_remaining)
}

// -------------------------------------------------------------------

// CClientNotificationFamilySharingLibraryAvailable

// optional uint32 accountid_owner = 1;
inline bool CClientNotificationFamilySharingLibraryAvailable::_internal_has_accountid_owner() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationFamilySharingLibraryAvailable::has_accountid_owner() const {
  return _internal_has_accountid_owner();
}
inline void CClientNotificationFamilySharingLibraryAvailable::clear_accountid_owner() {
  accountid_owner_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationFamilySharingLibraryAvailable::_internal_accountid_owner() const {
  return accountid_owner_;
}
inline uint32_t CClientNotificationFamilySharingLibraryAvailable::accountid_owner() const {
  // @@protoc_insertion_point(field_get:CClientNotificationFamilySharingLibraryAvailable.accountid_owner)
  return _internal_accountid_owner();
}
inline void CClientNotificationFamilySharingLibraryAvailable::_internal_set_accountid_owner(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  accountid_owner_ = value;
}
inline void CClientNotificationFamilySharingLibraryAvailable::set_accountid_owner(uint32_t value) {
  _internal_set_accountid_owner(value);
  // @@protoc_insertion_point(field_set:CClientNotificationFamilySharingLibraryAvailable.accountid_owner)
}

// -------------------------------------------------------------------

// CClientNotificationIncomingVoiceChat

// optional fixed64 steamid = 1;
inline bool CClientNotificationIncomingVoiceChat::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationIncomingVoiceChat::has_steamid() const {
  return _internal_has_steamid();
}
inline void CClientNotificationIncomingVoiceChat::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CClientNotificationIncomingVoiceChat::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CClientNotificationIncomingVoiceChat::steamid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationIncomingVoiceChat.steamid)
  return _internal_steamid();
}
inline void CClientNotificationIncomingVoiceChat::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = value;
}
inline void CClientNotificationIncomingVoiceChat::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationIncomingVoiceChat.steamid)
}

// -------------------------------------------------------------------

// CClientNotificationClaimSteamDeckRewards

// -------------------------------------------------------------------

// CClientNotificationGiftReceived

// optional string sender_name = 1;
inline bool CClientNotificationGiftReceived::_internal_has_sender_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationGiftReceived::has_sender_name() const {
  return _internal_has_sender_name();
}
inline void CClientNotificationGiftReceived::clear_sender_name() {
  sender_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationGiftReceived::sender_name() const {
  // @@protoc_insertion_point(field_get:CClientNotificationGiftReceived.sender_name)
  return _internal_sender_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationGiftReceived::set_sender_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sender_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationGiftReceived.sender_name)
}
inline std::string* CClientNotificationGiftReceived::mutable_sender_name() {
  std::string* _s = _internal_mutable_sender_name();
  // @@protoc_insertion_point(field_mutable:CClientNotificationGiftReceived.sender_name)
  return _s;
}
inline const std::string& CClientNotificationGiftReceived::_internal_sender_name() const {
  return sender_name_.Get();
}
inline void CClientNotificationGiftReceived::_internal_set_sender_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sender_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationGiftReceived::_internal_mutable_sender_name() {
  _has_bits_[0] |= 0x00000001u;
  return sender_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationGiftReceived::release_sender_name() {
  // @@protoc_insertion_point(field_release:CClientNotificationGiftReceived.sender_name)
  if (!_internal_has_sender_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sender_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sender_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationGiftReceived::set_allocated_sender_name(std::string* sender_name) {
  if (sender_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sender_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sender_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sender_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationGiftReceived.sender_name)
}

// -------------------------------------------------------------------

// CClientNotificationItemAnnouncement

// optional uint32 new_item_count = 1;
inline bool CClientNotificationItemAnnouncement::_internal_has_new_item_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationItemAnnouncement::has_new_item_count() const {
  return _internal_has_new_item_count();
}
inline void CClientNotificationItemAnnouncement::clear_new_item_count() {
  new_item_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationItemAnnouncement::_internal_new_item_count() const {
  return new_item_count_;
}
inline uint32_t CClientNotificationItemAnnouncement::new_item_count() const {
  // @@protoc_insertion_point(field_get:CClientNotificationItemAnnouncement.new_item_count)
  return _internal_new_item_count();
}
inline void CClientNotificationItemAnnouncement::_internal_set_new_item_count(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  new_item_count_ = value;
}
inline void CClientNotificationItemAnnouncement::set_new_item_count(uint32_t value) {
  _internal_set_new_item_count(value);
  // @@protoc_insertion_point(field_set:CClientNotificationItemAnnouncement.new_item_count)
}

// optional bool new_backpack_items = 2;
inline bool CClientNotificationItemAnnouncement::_internal_has_new_backpack_items() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationItemAnnouncement::has_new_backpack_items() const {
  return _internal_has_new_backpack_items();
}
inline void CClientNotificationItemAnnouncement::clear_new_backpack_items() {
  new_backpack_items_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CClientNotificationItemAnnouncement::_internal_new_backpack_items() const {
  return new_backpack_items_;
}
inline bool CClientNotificationItemAnnouncement::new_backpack_items() const {
  // @@protoc_insertion_point(field_get:CClientNotificationItemAnnouncement.new_backpack_items)
  return _internal_new_backpack_items();
}
inline void CClientNotificationItemAnnouncement::_internal_set_new_backpack_items(bool value) {
  _has_bits_[0] |= 0x00000002u;
  new_backpack_items_ = value;
}
inline void CClientNotificationItemAnnouncement::set_new_backpack_items(bool value) {
  _internal_set_new_backpack_items(value);
  // @@protoc_insertion_point(field_set:CClientNotificationItemAnnouncement.new_backpack_items)
}

// -------------------------------------------------------------------

// CClientNotificationHardwareSurveyPending

// -------------------------------------------------------------------

// CClientNotificationLowDiskSpace

// optional uint32 folder_index = 1;
inline bool CClientNotificationLowDiskSpace::_internal_has_folder_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationLowDiskSpace::has_folder_index() const {
  return _internal_has_folder_index();
}
inline void CClientNotificationLowDiskSpace::clear_folder_index() {
  folder_index_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CClientNotificationLowDiskSpace::_internal_folder_index() const {
  return folder_index_;
}
inline uint32_t CClientNotificationLowDiskSpace::folder_index() const {
  // @@protoc_insertion_point(field_get:CClientNotificationLowDiskSpace.folder_index)
  return _internal_folder_index();
}
inline void CClientNotificationLowDiskSpace::_internal_set_folder_index(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  folder_index_ = value;
}
inline void CClientNotificationLowDiskSpace::set_folder_index(uint32_t value) {
  _internal_set_folder_index(value);
  // @@protoc_insertion_point(field_set:CClientNotificationLowDiskSpace.folder_index)
}

// -------------------------------------------------------------------

// CClientNotificationBatteryTemperature

// optional uint32 temperature = 1;
inline bool CClientNotificationBatteryTemperature::_internal_has_temperature() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationBatteryTemperature::has_temperature() const {
  return _internal_has_temperature();
}
inline void CClientNotificationBatteryTemperature::clear_temperature() {
  temperature_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CClientNotificationBatteryTemperature::_internal_temperature() const {
  return temperature_;
}
inline uint32_t CClientNotificationBatteryTemperature::temperature() const {
  // @@protoc_insertion_point(field_get:CClientNotificationBatteryTemperature.temperature)
  return _internal_temperature();
}
inline void CClientNotificationBatteryTemperature::_internal_set_temperature(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  temperature_ = value;
}
inline void CClientNotificationBatteryTemperature::set_temperature(uint32_t value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:CClientNotificationBatteryTemperature.temperature)
}

// optional string notification_type = 2;
inline bool CClientNotificationBatteryTemperature::_internal_has_notification_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationBatteryTemperature::has_notification_type() const {
  return _internal_has_notification_type();
}
inline void CClientNotificationBatteryTemperature::clear_notification_type() {
  notification_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationBatteryTemperature::notification_type() const {
  // @@protoc_insertion_point(field_get:CClientNotificationBatteryTemperature.notification_type)
  return _internal_notification_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationBatteryTemperature::set_notification_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 notification_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationBatteryTemperature.notification_type)
}
inline std::string* CClientNotificationBatteryTemperature::mutable_notification_type() {
  std::string* _s = _internal_mutable_notification_type();
  // @@protoc_insertion_point(field_mutable:CClientNotificationBatteryTemperature.notification_type)
  return _s;
}
inline const std::string& CClientNotificationBatteryTemperature::_internal_notification_type() const {
  return notification_type_.Get();
}
inline void CClientNotificationBatteryTemperature::_internal_set_notification_type(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  notification_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationBatteryTemperature::_internal_mutable_notification_type() {
  _has_bits_[0] |= 0x00000001u;
  return notification_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationBatteryTemperature::release_notification_type() {
  // @@protoc_insertion_point(field_release:CClientNotificationBatteryTemperature.notification_type)
  if (!_internal_has_notification_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = notification_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notification_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    notification_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationBatteryTemperature::set_allocated_notification_type(std::string* notification_type) {
  if (notification_type != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  notification_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), notification_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (notification_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    notification_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationBatteryTemperature.notification_type)
}

// -------------------------------------------------------------------

// CClientNotificationDockUnsupportedFirmware

// -------------------------------------------------------------------

// CClientNotificationPeerContentUpload

// optional uint32 appid = 1;
inline bool CClientNotificationPeerContentUpload::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationPeerContentUpload::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationPeerContentUpload::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CClientNotificationPeerContentUpload::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationPeerContentUpload::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationPeerContentUpload.appid)
  return _internal_appid();
}
inline void CClientNotificationPeerContentUpload::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CClientNotificationPeerContentUpload::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationPeerContentUpload.appid)
}

// optional string peer_name = 2;
inline bool CClientNotificationPeerContentUpload::_internal_has_peer_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationPeerContentUpload::has_peer_name() const {
  return _internal_has_peer_name();
}
inline void CClientNotificationPeerContentUpload::clear_peer_name() {
  peer_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationPeerContentUpload::peer_name() const {
  // @@protoc_insertion_point(field_get:CClientNotificationPeerContentUpload.peer_name)
  return _internal_peer_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationPeerContentUpload::set_peer_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 peer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationPeerContentUpload.peer_name)
}
inline std::string* CClientNotificationPeerContentUpload::mutable_peer_name() {
  std::string* _s = _internal_mutable_peer_name();
  // @@protoc_insertion_point(field_mutable:CClientNotificationPeerContentUpload.peer_name)
  return _s;
}
inline const std::string& CClientNotificationPeerContentUpload::_internal_peer_name() const {
  return peer_name_.Get();
}
inline void CClientNotificationPeerContentUpload::_internal_set_peer_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  peer_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationPeerContentUpload::_internal_mutable_peer_name() {
  _has_bits_[0] |= 0x00000001u;
  return peer_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationPeerContentUpload::release_peer_name() {
  // @@protoc_insertion_point(field_release:CClientNotificationPeerContentUpload.peer_name)
  if (!_internal_has_peer_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = peer_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationPeerContentUpload::set_allocated_peer_name(std::string* peer_name) {
  if (peer_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  peer_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), peer_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (peer_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    peer_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationPeerContentUpload.peer_name)
}

// -------------------------------------------------------------------

// CClientNotificationCannotReadControllerGuideButton

// optional int32 controller_index = 1;
inline bool CClientNotificationCannotReadControllerGuideButton::_internal_has_controller_index() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationCannotReadControllerGuideButton::has_controller_index() const {
  return _internal_has_controller_index();
}
inline void CClientNotificationCannotReadControllerGuideButton::clear_controller_index() {
  controller_index_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CClientNotificationCannotReadControllerGuideButton::_internal_controller_index() const {
  return controller_index_;
}
inline int32_t CClientNotificationCannotReadControllerGuideButton::controller_index() const {
  // @@protoc_insertion_point(field_get:CClientNotificationCannotReadControllerGuideButton.controller_index)
  return _internal_controller_index();
}
inline void CClientNotificationCannotReadControllerGuideButton::_internal_set_controller_index(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  controller_index_ = value;
}
inline void CClientNotificationCannotReadControllerGuideButton::set_controller_index(int32_t value) {
  _internal_set_controller_index(value);
  // @@protoc_insertion_point(field_set:CClientNotificationCannotReadControllerGuideButton.controller_index)
}

// -------------------------------------------------------------------

// CClientNotificationOverlaySplashScreen

// -------------------------------------------------------------------

// CClientNotificationBroadcastAvailableToWatch

// optional int32 broadcast_permission = 1;
inline bool CClientNotificationBroadcastAvailableToWatch::_internal_has_broadcast_permission() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationBroadcastAvailableToWatch::has_broadcast_permission() const {
  return _internal_has_broadcast_permission();
}
inline void CClientNotificationBroadcastAvailableToWatch::clear_broadcast_permission() {
  broadcast_permission_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CClientNotificationBroadcastAvailableToWatch::_internal_broadcast_permission() const {
  return broadcast_permission_;
}
inline int32_t CClientNotificationBroadcastAvailableToWatch::broadcast_permission() const {
  // @@protoc_insertion_point(field_get:CClientNotificationBroadcastAvailableToWatch.broadcast_permission)
  return _internal_broadcast_permission();
}
inline void CClientNotificationBroadcastAvailableToWatch::_internal_set_broadcast_permission(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  broadcast_permission_ = value;
}
inline void CClientNotificationBroadcastAvailableToWatch::set_broadcast_permission(int32_t value) {
  _internal_set_broadcast_permission(value);
  // @@protoc_insertion_point(field_set:CClientNotificationBroadcastAvailableToWatch.broadcast_permission)
}

// -------------------------------------------------------------------

// CClientNotificationTimedTrialRemaining

// optional uint32 appid = 1;
inline bool CClientNotificationTimedTrialRemaining::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationTimedTrialRemaining::has_appid() const {
  return _internal_has_appid();
}
inline void CClientNotificationTimedTrialRemaining::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CClientNotificationTimedTrialRemaining::_internal_appid() const {
  return appid_;
}
inline uint32_t CClientNotificationTimedTrialRemaining::appid() const {
  // @@protoc_insertion_point(field_get:CClientNotificationTimedTrialRemaining.appid)
  return _internal_appid();
}
inline void CClientNotificationTimedTrialRemaining::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CClientNotificationTimedTrialRemaining::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CClientNotificationTimedTrialRemaining.appid)
}

// optional string icon = 2;
inline bool CClientNotificationTimedTrialRemaining::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationTimedTrialRemaining::has_icon() const {
  return _internal_has_icon();
}
inline void CClientNotificationTimedTrialRemaining::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationTimedTrialRemaining::icon() const {
  // @@protoc_insertion_point(field_get:CClientNotificationTimedTrialRemaining.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationTimedTrialRemaining::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationTimedTrialRemaining.icon)
}
inline std::string* CClientNotificationTimedTrialRemaining::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:CClientNotificationTimedTrialRemaining.icon)
  return _s;
}
inline const std::string& CClientNotificationTimedTrialRemaining::_internal_icon() const {
  return icon_.Get();
}
inline void CClientNotificationTimedTrialRemaining::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationTimedTrialRemaining::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000001u;
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationTimedTrialRemaining::release_icon() {
  // @@protoc_insertion_point(field_release:CClientNotificationTimedTrialRemaining.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationTimedTrialRemaining::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationTimedTrialRemaining.icon)
}

// optional bool offline = 3;
inline bool CClientNotificationTimedTrialRemaining::_internal_has_offline() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CClientNotificationTimedTrialRemaining::has_offline() const {
  return _internal_has_offline();
}
inline void CClientNotificationTimedTrialRemaining::clear_offline() {
  offline_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CClientNotificationTimedTrialRemaining::_internal_offline() const {
  return offline_;
}
inline bool CClientNotificationTimedTrialRemaining::offline() const {
  // @@protoc_insertion_point(field_get:CClientNotificationTimedTrialRemaining.offline)
  return _internal_offline();
}
inline void CClientNotificationTimedTrialRemaining::_internal_set_offline(bool value) {
  _has_bits_[0] |= 0x00000004u;
  offline_ = value;
}
inline void CClientNotificationTimedTrialRemaining::set_offline(bool value) {
  _internal_set_offline(value);
  // @@protoc_insertion_point(field_set:CClientNotificationTimedTrialRemaining.offline)
}

// optional uint32 allowed_seconds = 4;
inline bool CClientNotificationTimedTrialRemaining::_internal_has_allowed_seconds() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CClientNotificationTimedTrialRemaining::has_allowed_seconds() const {
  return _internal_has_allowed_seconds();
}
inline void CClientNotificationTimedTrialRemaining::clear_allowed_seconds() {
  allowed_seconds_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CClientNotificationTimedTrialRemaining::_internal_allowed_seconds() const {
  return allowed_seconds_;
}
inline uint32_t CClientNotificationTimedTrialRemaining::allowed_seconds() const {
  // @@protoc_insertion_point(field_get:CClientNotificationTimedTrialRemaining.allowed_seconds)
  return _internal_allowed_seconds();
}
inline void CClientNotificationTimedTrialRemaining::_internal_set_allowed_seconds(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  allowed_seconds_ = value;
}
inline void CClientNotificationTimedTrialRemaining::set_allowed_seconds(uint32_t value) {
  _internal_set_allowed_seconds(value);
  // @@protoc_insertion_point(field_set:CClientNotificationTimedTrialRemaining.allowed_seconds)
}

// optional uint32 played_seconds = 5;
inline bool CClientNotificationTimedTrialRemaining::_internal_has_played_seconds() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CClientNotificationTimedTrialRemaining::has_played_seconds() const {
  return _internal_has_played_seconds();
}
inline void CClientNotificationTimedTrialRemaining::clear_played_seconds() {
  played_seconds_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CClientNotificationTimedTrialRemaining::_internal_played_seconds() const {
  return played_seconds_;
}
inline uint32_t CClientNotificationTimedTrialRemaining::played_seconds() const {
  // @@protoc_insertion_point(field_get:CClientNotificationTimedTrialRemaining.played_seconds)
  return _internal_played_seconds();
}
inline void CClientNotificationTimedTrialRemaining::_internal_set_played_seconds(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  played_seconds_ = value;
}
inline void CClientNotificationTimedTrialRemaining::set_played_seconds(uint32_t value) {
  _internal_set_played_seconds(value);
  // @@protoc_insertion_point(field_set:CClientNotificationTimedTrialRemaining.played_seconds)
}

// -------------------------------------------------------------------

// CClientNotificationLoginRefresh

// -------------------------------------------------------------------

// CClientNotificationTimerExpired

// -------------------------------------------------------------------

// CClientNotificationSteamInputActionSetChanged

// optional int32 controller_index = 1;
inline bool CClientNotificationSteamInputActionSetChanged::_internal_has_controller_index() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CClientNotificationSteamInputActionSetChanged::has_controller_index() const {
  return _internal_has_controller_index();
}
inline void CClientNotificationSteamInputActionSetChanged::clear_controller_index() {
  controller_index_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CClientNotificationSteamInputActionSetChanged::_internal_controller_index() const {
  return controller_index_;
}
inline int32_t CClientNotificationSteamInputActionSetChanged::controller_index() const {
  // @@protoc_insertion_point(field_get:CClientNotificationSteamInputActionSetChanged.controller_index)
  return _internal_controller_index();
}
inline void CClientNotificationSteamInputActionSetChanged::_internal_set_controller_index(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  controller_index_ = value;
}
inline void CClientNotificationSteamInputActionSetChanged::set_controller_index(int32_t value) {
  _internal_set_controller_index(value);
  // @@protoc_insertion_point(field_set:CClientNotificationSteamInputActionSetChanged.controller_index)
}

// optional string action_set_name = 2;
inline bool CClientNotificationSteamInputActionSetChanged::_internal_has_action_set_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CClientNotificationSteamInputActionSetChanged::has_action_set_name() const {
  return _internal_has_action_set_name();
}
inline void CClientNotificationSteamInputActionSetChanged::clear_action_set_name() {
  action_set_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CClientNotificationSteamInputActionSetChanged::action_set_name() const {
  // @@protoc_insertion_point(field_get:CClientNotificationSteamInputActionSetChanged.action_set_name)
  return _internal_action_set_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CClientNotificationSteamInputActionSetChanged::set_action_set_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 action_set_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CClientNotificationSteamInputActionSetChanged.action_set_name)
}
inline std::string* CClientNotificationSteamInputActionSetChanged::mutable_action_set_name() {
  std::string* _s = _internal_mutable_action_set_name();
  // @@protoc_insertion_point(field_mutable:CClientNotificationSteamInputActionSetChanged.action_set_name)
  return _s;
}
inline const std::string& CClientNotificationSteamInputActionSetChanged::_internal_action_set_name() const {
  return action_set_name_.Get();
}
inline void CClientNotificationSteamInputActionSetChanged::_internal_set_action_set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  action_set_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CClientNotificationSteamInputActionSetChanged::_internal_mutable_action_set_name() {
  _has_bits_[0] |= 0x00000001u;
  return action_set_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CClientNotificationSteamInputActionSetChanged::release_action_set_name() {
  // @@protoc_insertion_point(field_release:CClientNotificationSteamInputActionSetChanged.action_set_name)
  if (!_internal_has_action_set_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = action_set_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_set_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_set_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CClientNotificationSteamInputActionSetChanged::set_allocated_action_set_name(std::string* action_set_name) {
  if (action_set_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  action_set_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), action_set_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (action_set_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    action_set_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CClientNotificationSteamInputActionSetChanged.action_set_name)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::EClientNotificationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EClientNotificationType>() {
  return ::EClientNotificationType_descriptor();
}
template <> struct is_proto_enum< ::ESystemUpdateNotificationType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ESystemUpdateNotificationType>() {
  return ::ESystemUpdateNotificationType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientnotificationtypes_2eproto
