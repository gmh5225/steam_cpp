// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_gamenotifications.steamclient.proto

#include "steammessages_gamenotifications.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CGameNotifications_Variable::CGameNotifications_Variable(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : key_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , value_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CGameNotifications_VariableDefaultTypeInternal {
  constexpr CGameNotifications_VariableDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_VariableDefaultTypeInternal() {}
  union {
    CGameNotifications_Variable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_VariableDefaultTypeInternal _CGameNotifications_Variable_default_instance_;
constexpr CGameNotifications_LocalizedText::CGameNotifications_LocalizedText(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : variables_()
  , token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , rendered_text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CGameNotifications_LocalizedTextDefaultTypeInternal {
  constexpr CGameNotifications_LocalizedTextDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_LocalizedTextDefaultTypeInternal() {}
  union {
    CGameNotifications_LocalizedText _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_LocalizedTextDefaultTypeInternal _CGameNotifications_LocalizedText_default_instance_;
constexpr CGameNotifications_UserStatus::CGameNotifications_UserStatus(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : state_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , title_(nullptr)
  , message_(nullptr)
  , steamid_(uint64_t{0u}){}
struct CGameNotifications_UserStatusDefaultTypeInternal {
  constexpr CGameNotifications_UserStatusDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_UserStatusDefaultTypeInternal() {}
  union {
    CGameNotifications_UserStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_UserStatusDefaultTypeInternal _CGameNotifications_UserStatus_default_instance_;
constexpr CGameNotifications_CreateSession_Request::CGameNotifications_CreateSession_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : users_()
  , title_(nullptr)
  , context_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , appid_(0u){}
struct CGameNotifications_CreateSession_RequestDefaultTypeInternal {
  constexpr CGameNotifications_CreateSession_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_CreateSession_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_CreateSession_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_CreateSession_RequestDefaultTypeInternal _CGameNotifications_CreateSession_Request_default_instance_;
constexpr CGameNotifications_CreateSession_Response::CGameNotifications_CreateSession_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessionid_(uint64_t{0u}){}
struct CGameNotifications_CreateSession_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_CreateSession_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_CreateSession_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_CreateSession_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_CreateSession_ResponseDefaultTypeInternal _CGameNotifications_CreateSession_Response_default_instance_;
constexpr CGameNotifications_DeleteSession_Request::CGameNotifications_DeleteSession_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessionid_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , appid_(0u){}
struct CGameNotifications_DeleteSession_RequestDefaultTypeInternal {
  constexpr CGameNotifications_DeleteSession_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_DeleteSession_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_DeleteSession_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_DeleteSession_RequestDefaultTypeInternal _CGameNotifications_DeleteSession_Request_default_instance_;
constexpr CGameNotifications_DeleteSession_Response::CGameNotifications_DeleteSession_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CGameNotifications_DeleteSession_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_DeleteSession_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_DeleteSession_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_DeleteSession_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_DeleteSession_ResponseDefaultTypeInternal _CGameNotifications_DeleteSession_Response_default_instance_;
constexpr CGameNotifications_UpdateSession_Request::CGameNotifications_UpdateSession_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : users_()
  , title_(nullptr)
  , sessionid_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , appid_(0u){}
struct CGameNotifications_UpdateSession_RequestDefaultTypeInternal {
  constexpr CGameNotifications_UpdateSession_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_UpdateSession_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_UpdateSession_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_UpdateSession_RequestDefaultTypeInternal _CGameNotifications_UpdateSession_Request_default_instance_;
constexpr CGameNotifications_UpdateSession_Response::CGameNotifications_UpdateSession_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CGameNotifications_UpdateSession_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_UpdateSession_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_UpdateSession_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_UpdateSession_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_UpdateSession_ResponseDefaultTypeInternal _CGameNotifications_UpdateSession_Response_default_instance_;
constexpr CGameNotifications_EnumerateSessions_Request::CGameNotifications_EnumerateSessions_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : language_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , include_all_user_messages_(false)
  , include_auth_user_message_(false){}
struct CGameNotifications_EnumerateSessions_RequestDefaultTypeInternal {
  constexpr CGameNotifications_EnumerateSessions_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_EnumerateSessions_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_EnumerateSessions_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_EnumerateSessions_RequestDefaultTypeInternal _CGameNotifications_EnumerateSessions_Request_default_instance_;
constexpr CGameNotifications_Session::CGameNotifications_Session(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : user_status_()
  , title_(nullptr)
  , sessionid_(uint64_t{0u})
  , appid_(uint64_t{0u})
  , context_(uint64_t{0u})
  , time_created_(0u)
  , time_updated_(0u){}
struct CGameNotifications_SessionDefaultTypeInternal {
  constexpr CGameNotifications_SessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_SessionDefaultTypeInternal() {}
  union {
    CGameNotifications_Session _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_SessionDefaultTypeInternal _CGameNotifications_Session_default_instance_;
constexpr CGameNotifications_EnumerateSessions_Response::CGameNotifications_EnumerateSessions_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessions_(){}
struct CGameNotifications_EnumerateSessions_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_EnumerateSessions_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_EnumerateSessions_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_EnumerateSessions_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_EnumerateSessions_ResponseDefaultTypeInternal _CGameNotifications_EnumerateSessions_Response_default_instance_;
constexpr CGameNotifications_GetSessionDetails_Request_RequestedSession::CGameNotifications_GetSessionDetails_Request_RequestedSession(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessionid_(uint64_t{0u})
  , include_auth_user_message_(false){}
struct CGameNotifications_GetSessionDetails_Request_RequestedSessionDefaultTypeInternal {
  constexpr CGameNotifications_GetSessionDetails_Request_RequestedSessionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_GetSessionDetails_Request_RequestedSessionDefaultTypeInternal() {}
  union {
    CGameNotifications_GetSessionDetails_Request_RequestedSession _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_GetSessionDetails_Request_RequestedSessionDefaultTypeInternal _CGameNotifications_GetSessionDetails_Request_RequestedSession_default_instance_;
constexpr CGameNotifications_GetSessionDetails_Request::CGameNotifications_GetSessionDetails_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessions_()
  , language_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u){}
struct CGameNotifications_GetSessionDetails_RequestDefaultTypeInternal {
  constexpr CGameNotifications_GetSessionDetails_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_GetSessionDetails_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_GetSessionDetails_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_GetSessionDetails_RequestDefaultTypeInternal _CGameNotifications_GetSessionDetails_Request_default_instance_;
constexpr CGameNotifications_GetSessionDetails_Response::CGameNotifications_GetSessionDetails_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sessions_(){}
struct CGameNotifications_GetSessionDetails_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_GetSessionDetails_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_GetSessionDetails_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_GetSessionDetails_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_GetSessionDetails_ResponseDefaultTypeInternal _CGameNotifications_GetSessionDetails_Response_default_instance_;
constexpr GameNotificationSettings::GameNotificationSettings(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , allow_notifications_(false){}
struct GameNotificationSettingsDefaultTypeInternal {
  constexpr GameNotificationSettingsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~GameNotificationSettingsDefaultTypeInternal() {}
  union {
    GameNotificationSettings _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT GameNotificationSettingsDefaultTypeInternal _GameNotificationSettings_default_instance_;
constexpr CGameNotifications_UpdateNotificationSettings_Request::CGameNotifications_UpdateNotificationSettings_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : game_notification_settings_(){}
struct CGameNotifications_UpdateNotificationSettings_RequestDefaultTypeInternal {
  constexpr CGameNotifications_UpdateNotificationSettings_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_UpdateNotificationSettings_RequestDefaultTypeInternal() {}
  union {
    CGameNotifications_UpdateNotificationSettings_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_UpdateNotificationSettings_RequestDefaultTypeInternal _CGameNotifications_UpdateNotificationSettings_Request_default_instance_;
constexpr CGameNotifications_UpdateNotificationSettings_Response::CGameNotifications_UpdateNotificationSettings_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CGameNotifications_UpdateNotificationSettings_ResponseDefaultTypeInternal {
  constexpr CGameNotifications_UpdateNotificationSettings_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_UpdateNotificationSettings_ResponseDefaultTypeInternal() {}
  union {
    CGameNotifications_UpdateNotificationSettings_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_UpdateNotificationSettings_ResponseDefaultTypeInternal _CGameNotifications_UpdateNotificationSettings_Response_default_instance_;
constexpr CGameNotifications_OnNotificationsRequested_Notification::CGameNotifications_OnNotificationsRequested_Notification(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : steamid_(uint64_t{0u})
  , appid_(0u){}
struct CGameNotifications_OnNotificationsRequested_NotificationDefaultTypeInternal {
  constexpr CGameNotifications_OnNotificationsRequested_NotificationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_OnNotificationsRequested_NotificationDefaultTypeInternal() {}
  union {
    CGameNotifications_OnNotificationsRequested_Notification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_OnNotificationsRequested_NotificationDefaultTypeInternal _CGameNotifications_OnNotificationsRequested_Notification_default_instance_;
constexpr CGameNotifications_OnUserStatusChanged_Notification::CGameNotifications_OnUserStatusChanged_Notification(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : status_(nullptr)
  , steamid_(uint64_t{0u})
  , sessionid_(uint64_t{0u})
  , appid_(0u)
  , removed_(false){}
struct CGameNotifications_OnUserStatusChanged_NotificationDefaultTypeInternal {
  constexpr CGameNotifications_OnUserStatusChanged_NotificationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGameNotifications_OnUserStatusChanged_NotificationDefaultTypeInternal() {}
  union {
    CGameNotifications_OnUserStatusChanged_Notification _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGameNotifications_OnUserStatusChanged_NotificationDefaultTypeInternal _CGameNotifications_OnUserStatusChanged_Notification_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[20];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto = nullptr;
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[2];

const uint32_t TableStruct_steammessages_5fgamenotifications_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Variable, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Variable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Variable, key_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Variable, value_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_LocalizedText, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_LocalizedText, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_LocalizedText, token_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_LocalizedText, variables_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_LocalizedText, rendered_text_),
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, steamid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, state_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, title_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UserStatus, message_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, context_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, title_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, users_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Request, steamid_),
  3,
  1,
  0,
  ~0u,
  2,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_CreateSession_Response, sessionid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Request, sessionid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Request, steamid_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_DeleteSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, sessionid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, title_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, users_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Request, steamid_),
  1,
  3,
  0,
  ~0u,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, include_all_user_messages_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, include_auth_user_message_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Request, language_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, sessionid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, context_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, title_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, time_created_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, time_updated_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_Session, user_status_),
  1,
  2,
  3,
  0,
  4,
  5,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_EnumerateSessions_Response, sessions_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request_RequestedSession, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request_RequestedSession, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request_RequestedSession, sessionid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request_RequestedSession, include_auth_user_message_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request, sessions_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Request, language_),
  ~0u,
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_GetSessionDetails_Response, sessions_),
  PROTOBUF_FIELD_OFFSET(::GameNotificationSettings, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::GameNotificationSettings, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::GameNotificationSettings, appid_),
  PROTOBUF_FIELD_OFFSET(::GameNotificationSettings, allow_notifications_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateNotificationSettings_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateNotificationSettings_Request, game_notification_settings_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_UpdateNotificationSettings_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnNotificationsRequested_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnNotificationsRequested_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnNotificationsRequested_Notification, steamid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnNotificationsRequested_Notification, appid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, steamid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, sessionid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, appid_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, status_),
  PROTOBUF_FIELD_OFFSET(::CGameNotifications_OnUserStatusChanged_Notification, removed_),
  1,
  2,
  3,
  0,
  4,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CGameNotifications_Variable)},
  { 10, 19, -1, sizeof(::CGameNotifications_LocalizedText)},
  { 22, 32, -1, sizeof(::CGameNotifications_UserStatus)},
  { 36, 47, -1, sizeof(::CGameNotifications_CreateSession_Request)},
  { 52, 59, -1, sizeof(::CGameNotifications_CreateSession_Response)},
  { 60, 69, -1, sizeof(::CGameNotifications_DeleteSession_Request)},
  { 72, -1, -1, sizeof(::CGameNotifications_DeleteSession_Response)},
  { 78, 89, -1, sizeof(::CGameNotifications_UpdateSession_Request)},
  { 94, -1, -1, sizeof(::CGameNotifications_UpdateSession_Response)},
  { 100, 110, -1, sizeof(::CGameNotifications_EnumerateSessions_Request)},
  { 114, 127, -1, sizeof(::CGameNotifications_Session)},
  { 134, -1, -1, sizeof(::CGameNotifications_EnumerateSessions_Response)},
  { 141, 149, -1, sizeof(::CGameNotifications_GetSessionDetails_Request_RequestedSession)},
  { 151, 160, -1, sizeof(::CGameNotifications_GetSessionDetails_Request)},
  { 163, -1, -1, sizeof(::CGameNotifications_GetSessionDetails_Response)},
  { 170, 178, -1, sizeof(::GameNotificationSettings)},
  { 180, -1, -1, sizeof(::CGameNotifications_UpdateNotificationSettings_Request)},
  { 187, -1, -1, sizeof(::CGameNotifications_UpdateNotificationSettings_Response)},
  { 193, 201, -1, sizeof(::CGameNotifications_OnNotificationsRequested_Notification)},
  { 203, 214, -1, sizeof(::CGameNotifications_OnUserStatusChanged_Notification)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_Variable_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_LocalizedText_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_UserStatus_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_CreateSession_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_CreateSession_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_DeleteSession_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_DeleteSession_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_UpdateSession_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_UpdateSession_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_EnumerateSessions_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_Session_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_EnumerateSessions_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_GetSessionDetails_Request_RequestedSession_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_GetSessionDetails_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_GetSessionDetails_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_GameNotificationSettings_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_UpdateNotificationSettings_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_UpdateNotificationSettings_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_OnNotificationsRequested_Notification_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGameNotifications_OnUserStatusChanged_Notification_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fgamenotifications_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n1steammessages_gamenotifications.steamc"
  "lient.proto\032\030steammessages_base.proto\032,s"
  "teammessages_unified_base.steamclient.pr"
  "oto\"\340\002\n\033CGameNotifications_Variable\022\246\001\n\003"
  "key\030\001 \001(\tB\230\001\202\265\030\223\001The name of the variabl"
  "e in the localized text -- anywhere that"
  " %variablename% is found within the text"
  " it will be substituded with the given v"
  "alue\022\227\001\n\005value\030\002 \001(\tB\207\001\202\265\030\202\001The value of"
  " the variable to substitute in the local"
  "ized text in place of the given variable"
  ".  Can itself be a localization token.\"\205"
  "\003\n CGameNotifications_LocalizedText\022H\n\005t"
  "oken\030\001 \001(\tB9\202\265\0305A localization token tha"
  "t maps to the desired string.\022\215\001\n\tvariab"
  "les\030\002 \003(\0132\034.CGameNotifications_VariableB"
  "\\\202\265\030XA list of variables values to subst"
  "itute in any variables found in the loca"
  "lized string.\022\206\001\n\rrendered_text\030\003 \001(\tBo\202"
  "\265\030kText rendered in the requested langua"
  "ge, complete with variable substitutions"
  ", if a language was specified.\"\225\004\n\035CGame"
  "Notifications_UserStatus\0221\n\007steamid\030\001 \001("
  "\006B \202\265\030\034The specific user\'s steamid.\022\244\001\n\005"
  "state\030\002 \001(\tB\224\001\202\265\030\217\001The user\'s state.  re"
  "ady -- the user is ready to play.  waiti"
  "ng -- The game is waiting on an action f"
  "rom the user. completed, the game is ove"
  "r.\022\204\001\n\005title\030\003 \001(\0132!.CGameNotifications_"
  "LocalizedTextBR\202\265\030NTitle of the session "
  "to display to this user in their list of"
  " active sessions.\022\222\001\n\007message\030\004 \001(\0132!.CG"
  "ameNotifications_LocalizedTextB^\202\265\030ZSubt"
  "itle of the session to display to this u"
  "ser user within their list of active ses"
  "sions.\"\223\005\n(CGameNotifications_CreateSess"
  "ion_Request\0227\n\005appid\030\001 \001(\rB(\202\265\030$The appi"
  "d to create the session for.\022\177\n\007context\030"
  "\002 \001(\004Bn\202\265\030jGame-specified context value "
  "the game can used to associate the sessi"
  "on with some object on their backend.\022\203\001"
  "\n\005title\030\003 \001(\0132!.CGameNotifications_Local"
  "izedTextBQ\202\265\030MThe title of the session t"
  "o be displayed within each user\'s list o"
  "f sessions.\022a\n\005users\030\004 \003(\0132\036.CGameNotifi"
  "cations_UserStatusB2\202\265\030.The initial stat"
  "e of all users in the session.\022\303\001\n\007steam"
  "id\030\005 \001(\006B\261\001\202\265\030\254\001(Optional) steamid to ma"
  "ke the request on behalf of -- if specif"
  "ied, the user must be in the session and"
  " all users being added to the session mu"
  "st be friends with the user.\"i\n)CGameNot"
  "ifications_CreateSession_Response\022<\n\tses"
  "sionid\030\001 \001(\004B)\202\265\030%The sessionid of the c"
  "reated session.\"\217\002\n(CGameNotifications_D"
  "eleteSession_Request\022/\n\tsessionid\030\001 \001(\004B"
  "\034\202\265\030\030The sessionid to delete.\0226\n\005appid\030\002"
  " \001(\rB\'\202\265\030#The appid of the session to de"
  "lete.\022z\n\007steamid\030\003 \001(\006Bi\202\265\030e(Optional) s"
  "teamid to make the request on behalf of "
  "-- if specified, the user must be in the"
  " session.\"+\n)CGameNotifications_DeleteSe"
  "ssion_Response\"\275\005\n(CGameNotifications_Up"
  "dateSession_Request\022/\n\tsessionid\030\001 \001(\004B\034"
  "\202\265\030\030The sessionid to update.\0226\n\005appid\030\002 "
  "\001(\rB\'\202\265\030#The appid of the session to upd"
  "ate.\022\220\001\n\005title\030\003 \001(\0132!.CGameNotification"
  "s_LocalizedTextB^\202\265\030Z(Optional) The new "
  "title of the session.  If not specified,"
  " the title will not be changed.\022\316\001\n\005user"
  "s\030\004 \003(\0132\036.CGameNotifications_UserStatusB"
  "\236\001\202\265\030\231\001(Optional) A list of users whose "
  "state will be updated to reflect the giv"
  "en state. If the users are not already i"
  "n the session, they will be added to it."
  "\022\303\001\n\007steamid\030\006 \001(\006B\261\001\202\265\030\254\001(Optional) ste"
  "amid to make the request on behalf of --"
  " if specified, the user must be in the s"
  "ession and all users being added to the "
  "session must be friends with the user.\"+"
  "\n)CGameNotifications_UpdateSession_Respo"
  "nse\"\241\004\n,CGameNotifications_EnumerateSess"
  "ions_Request\022~\n\005appid\030\001 \001(\rBo\202\265\030kThe ses"
  "sionid to request details for. Optional."
  " If not specified, all the user\'s sessio"
  "ns will be returned.\022\216\001\n\031include_all_use"
  "r_messages\030\003 \001(\010Bk\202\265\030g(Optional) Boolean"
  " determining whether the message for all"
  " users should be included. Defaults to f"
  "alse.\022\233\001\n\031include_auth_user_message\030\004 \001("
  "\010Bx\202\265\030t(Optional) Boolean determining wh"
  "ether the message for the authenticated "
  "user should be included. Defaults to fal"
  "se.\022B\n\010language\030\005 \001(\tB0\202\265\030,(Optional) La"
  "nguage to localize the text in.\"\303\004\n\032CGam"
  "eNotifications_Session\0226\n\tsessionid\030\001 \001("
  "\004B#\202\265\030\037The sessionid for this session.\022-"
  "\n\005appid\030\002 \001(\004B\036\202\265\030\032The appid for the ses"
  "sion.\022\177\n\007context\030\003 \001(\004Bn\202\265\030jGame-specifi"
  "ed context value the game can used to as"
  "sociate the session with some object on "
  "their backend.\022X\n\005title\030\004 \001(\0132!.CGameNot"
  "ifications_LocalizedTextB&\202\265\030\"The curren"
  "t title for the session.\022;\n\014time_created"
  "\030\005 \001(\rB%\202\265\030!The time the session was cre"
  "ated.\022@\n\014time_updated\030\006 \001(\rB*\202\265\030&The las"
  "t time the session was updated.\022d\n\013user_"
  "status\030\007 \003(\0132\036.CGameNotifications_UserSt"
  "atusB/\202\265\030+The status of all the users in"
  " the session.\"\202\001\n-CGameNotifications_Enu"
  "merateSessions_Response\022Q\n\010sessions\030\001 \003("
  "\0132\033.CGameNotifications_SessionB\"\202\265\030\036A li"
  "st of the user\'s sessions.\"\326\003\n,CGameNoti"
  "fications_GetSessionDetails_Request\022P\n\010s"
  "essions\030\001 \003(\0132>.CGameNotifications_GetSe"
  "ssionDetails_Request.RequestedSession\022.\n"
  "\005appid\030\002 \001(\rB\037\202\265\030\033The appid for the sess"
  "ions.\0227\n\010language\030\003 \001(\tB%\202\265\030!Language to"
  " localize the text in.\032\352\001\n\020RequestedSess"
  "ion\0228\n\tsessionid\030\001 \001(\004B%\202\265\030!The sessioni"
  "d to get details for.\022\233\001\n\031include_auth_u"
  "ser_message\030\003 \001(\010Bx\202\265\030t(Optional) Boolea"
  "n determining whether the message for th"
  "e authenticated user should be included."
  " Defaults to false.\"\177\n-CGameNotification"
  "s_GetSessionDetails_Response\022N\n\010sessions"
  "\030\001 \003(\0132\033.CGameNotifications_SessionB\037\202\265\030"
  "\033The details of the session.\"\250\001\n\030GameNot"
  "ificationSettings\0227\n\005appid\030\001 \001(\rB(\202\265\030$Th"
  "e appid to create the session for.\022S\n\023al"
  "low_notifications\030\002 \001(\010B6\202\265\0302Whether the"
  " user allows notification for this app.\""
  "v\n5CGameNotifications_UpdateNotification"
  "Settings_Request\022=\n\032game_notification_se"
  "ttings\030\001 \003(\0132\031.GameNotificationSettings\""
  "8\n6CGameNotifications_UpdateNotification"
  "Settings_Response\"\306\001\n8CGameNotifications"
  "_OnNotificationsRequested_Notification\022N"
  "\n\007steamid\030\001 \001(\006B=\202\265\0309steamid of the user"
  " who notifications were requested for.\022:"
  "\n\005appid\030\002 \001(\rB+\202\265\030\'The appid that reques"
  "ted notifications.\"\276\003\n3CGameNotification"
  "s_OnUserStatusChanged_Notification\022>\n\007st"
  "eamid\030\001 \001(\006B-\202\265\030)steamid of the user who"
  "se status changed.\022X\n\tsessionid\030\002 \001(\004BE\202"
  "\265\030AThe sessionid of the session where th"
  "e user\'s status was changed.\022L\n\005appid\030\003 "
  "\001(\rB=\202\265\0309The appid of the session where "
  "the user\'s status changed.\022V\n\006status\030\004 \001"
  "(\0132\036.CGameNotifications_UserStatusB&\202\265\030\""
  "(Optional) New status of the user.\022G\n\007re"
  "moved\030\005 \001(\010B6\202\265\0302(Optional) User has bee"
  "n removed from the session.2\246\010\n\021GameNoti"
  "fications\022\215\001\n\021UserCreateSession\022).CGameN"
  "otifications_CreateSession_Request\032*.CGa"
  "meNotifications_CreateSession_Response\"!"
  "\202\265\030\035Creates an async game session\022\215\001\n\021Us"
  "erDeleteSession\022).CGameNotifications_Del"
  "eteSession_Request\032*.CGameNotifications_"
  "DeleteSession_Response\"!\202\265\030\035Deletes an a"
  "sync game session\022\215\001\n\021UserUpdateSession\022"
  ").CGameNotifications_UpdateSession_Reque"
  "st\032*.CGameNotifications_UpdateSession_Re"
  "sponse\"!\202\265\030\035Updates an async game sessio"
  "n\022\224\001\n\021EnumerateSessions\022-.CGameNotificat"
  "ions_EnumerateSessions_Request\032..CGameNo"
  "tifications_EnumerateSessions_Response\" "
  "\202\265\030\034Enumerates a user\'s sessions\022\236\001\n\021Get"
  "SessionDetails\022-.CGameNotifications_GetS"
  "essionDetails_Request\032..CGameNotificatio"
  "ns_GetSessionDetails_Response\"*\202\265\030&Get t"
  "he details for a specific session\022\326\001\n\032Up"
  "dateNotificationSettings\0226.CGameNotifica"
  "tions_UpdateNotificationSettings_Request"
  "\0327.CGameNotifications_UpdateNotification"
  "Settings_Response\"G\202\265\030CUpdates whether a"
  " user allows game notifications for a sp"
  "ecific app\032P\202\265\030LA service for functions "
  "related to the asyncronous game notifica"
  "tion server.2\337\002\n\027GameNotificationsClient"
  "\022\225\001\n\030OnNotificationsRequested\0229.CGameNot"
  "ifications_OnNotificationsRequested_Noti"
  "fication\032\013.NoResponse\"1\202\265\030-Requests that"
  " the user opt into notifications\022\215\001\n\023OnU"
  "serStatusChanged\0224.CGameNotifications_On"
  "UserStatusChanged_Notification\032\013.NoRespo"
  "nse\"3\202\265\030/Notification that the user\'s st"
  "atus has changed\032\034\202\265\030\024Client notificatio"
  "ns\300\265\030\002B\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_deps[2] = {
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto = {
  false, false, 7531, descriptor_table_protodef_steammessages_5fgamenotifications_2esteamclient_2eproto, "steammessages_gamenotifications.steamclient.proto", 
  &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once, descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_deps, 2, 20,
  schemas, file_default_instances, TableStruct_steammessages_5fgamenotifications_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter() {
  return &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fgamenotifications_2esteamclient_2eproto(&descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto);

// ===================================================================

class CGameNotifications_Variable::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_Variable>()._has_bits_);
  static void set_has_key(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGameNotifications_Variable::CGameNotifications_Variable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_Variable)
}
CGameNotifications_Variable::CGameNotifications_Variable(const CGameNotifications_Variable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_key()) {
    key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_key(), 
      GetArenaForAllocation());
  }
  value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_value(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_Variable)
}

inline void CGameNotifications_Variable::SharedCtor() {
key_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
value_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  value_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGameNotifications_Variable::~CGameNotifications_Variable() {
  // @@protoc_insertion_point(destructor:CGameNotifications_Variable)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_Variable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  key_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_Variable::ArenaDtor(void* object) {
  CGameNotifications_Variable* _this = reinterpret_cast< CGameNotifications_Variable* >(object);
  (void)_this;
}
void CGameNotifications_Variable::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_Variable::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_Variable::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_Variable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      key_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      value_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_Variable::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string key = 1 [(.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_key();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_Variable.key");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string value = 2 [(.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_value();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_Variable.value");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_Variable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_Variable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string key = 1 [(.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_key().data(), static_cast<int>(this->_internal_key().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_Variable.key");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_key(), target);
  }

  // optional string value = 2 [(.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_Variable.value");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_Variable)
  return target;
}

size_t CGameNotifications_Variable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_Variable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string key = 1 [(.description) = "The name of the variable in the localized text -- anywhere that %variablename% is found within the text it will be substituded with the given value"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_key());
    }

    // optional string value = 2 [(.description) = "The value of the variable to substitute in the localized text in place of the given variable.  Can itself be a localization token."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_Variable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_Variable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_Variable::GetClassData() const { return &_class_data_; }

void CGameNotifications_Variable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_Variable *>(to)->MergeFrom(
      static_cast<const CGameNotifications_Variable &>(from));
}


void CGameNotifications_Variable::MergeFrom(const CGameNotifications_Variable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_Variable)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_key(from._internal_key());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_value(from._internal_value());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_Variable::CopyFrom(const CGameNotifications_Variable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_Variable::IsInitialized() const {
  return true;
}

void CGameNotifications_Variable::InternalSwap(CGameNotifications_Variable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &key_, lhs_arena,
      &other->key_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &value_, lhs_arena,
      &other->value_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_Variable::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[0]);
}

// ===================================================================

class CGameNotifications_LocalizedText::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_LocalizedText>()._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_rendered_text(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGameNotifications_LocalizedText::CGameNotifications_LocalizedText(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  variables_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_LocalizedText)
}
CGameNotifications_LocalizedText::CGameNotifications_LocalizedText(const CGameNotifications_LocalizedText& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      variables_(from.variables_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  rendered_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    rendered_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_rendered_text()) {
    rendered_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_rendered_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_LocalizedText)
}

inline void CGameNotifications_LocalizedText::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
rendered_text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  rendered_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CGameNotifications_LocalizedText::~CGameNotifications_LocalizedText() {
  // @@protoc_insertion_point(destructor:CGameNotifications_LocalizedText)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_LocalizedText::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  rendered_text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_LocalizedText::ArenaDtor(void* object) {
  CGameNotifications_LocalizedText* _this = reinterpret_cast< CGameNotifications_LocalizedText* >(object);
  (void)_this;
}
void CGameNotifications_LocalizedText::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_LocalizedText::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_LocalizedText::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_LocalizedText)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  variables_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      rendered_text_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_LocalizedText::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string token = 1 [(.description) = "A localization token that maps to the desired string."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_LocalizedText.token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CGameNotifications_Variable variables = 2 [(.description) = "A list of variables values to substitute in any variables found in the localized string."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_variables(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional string rendered_text = 3 [(.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_rendered_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_LocalizedText.rendered_text");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_LocalizedText::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_LocalizedText)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string token = 1 [(.description) = "A localization token that maps to the desired string."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_LocalizedText.token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token(), target);
  }

  // repeated .CGameNotifications_Variable variables = 2 [(.description) = "A list of variables values to substitute in any variables found in the localized string."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_variables_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_variables(i), target, stream);
  }

  // optional string rendered_text = 3 [(.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_rendered_text().data(), static_cast<int>(this->_internal_rendered_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_LocalizedText.rendered_text");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_rendered_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_LocalizedText)
  return target;
}

size_t CGameNotifications_LocalizedText::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_LocalizedText)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_Variable variables = 2 [(.description) = "A list of variables values to substitute in any variables found in the localized string."];
  total_size += 1UL * this->_internal_variables_size();
  for (const auto& msg : this->variables_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token = 1 [(.description) = "A localization token that maps to the desired string."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional string rendered_text = 3 [(.description) = "Text rendered in the requested language, complete with variable substitutions, if a language was specified."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_rendered_text());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_LocalizedText::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_LocalizedText::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_LocalizedText::GetClassData() const { return &_class_data_; }

void CGameNotifications_LocalizedText::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_LocalizedText *>(to)->MergeFrom(
      static_cast<const CGameNotifications_LocalizedText &>(from));
}


void CGameNotifications_LocalizedText::MergeFrom(const CGameNotifications_LocalizedText& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_LocalizedText)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  variables_.MergeFrom(from.variables_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_rendered_text(from._internal_rendered_text());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_LocalizedText::CopyFrom(const CGameNotifications_LocalizedText& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_LocalizedText)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_LocalizedText::IsInitialized() const {
  return true;
}

void CGameNotifications_LocalizedText::InternalSwap(CGameNotifications_LocalizedText* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  variables_.InternalSwap(&other->variables_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &rendered_text_, lhs_arena,
      &other->rendered_text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_LocalizedText::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[1]);
}

// ===================================================================

class CGameNotifications_UserStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_UserStatus>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CGameNotifications_LocalizedText& title(const CGameNotifications_UserStatus* msg);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CGameNotifications_LocalizedText& message(const CGameNotifications_UserStatus* msg);
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CGameNotifications_LocalizedText&
CGameNotifications_UserStatus::_Internal::title(const CGameNotifications_UserStatus* msg) {
  return *msg->title_;
}
const ::CGameNotifications_LocalizedText&
CGameNotifications_UserStatus::_Internal::message(const CGameNotifications_UserStatus* msg) {
  return *msg->message_;
}
CGameNotifications_UserStatus::CGameNotifications_UserStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_UserStatus)
}
CGameNotifications_UserStatus::CGameNotifications_UserStatus(const CGameNotifications_UserStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_title()) {
    title_ = new ::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  if (from._internal_has_message()) {
    message_ = new ::CGameNotifications_LocalizedText(*from.message_);
  } else {
    message_ = nullptr;
  }
  steamid_ = from.steamid_;
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_UserStatus)
}

inline void CGameNotifications_UserStatus::SharedCtor() {
state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&title_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steamid_) -
    reinterpret_cast<char*>(&title_)) + sizeof(steamid_));
}

CGameNotifications_UserStatus::~CGameNotifications_UserStatus() {
  // @@protoc_insertion_point(destructor:CGameNotifications_UserStatus)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_UserStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete title_;
  if (this != internal_default_instance()) delete message_;
}

void CGameNotifications_UserStatus::ArenaDtor(void* object) {
  CGameNotifications_UserStatus* _this = reinterpret_cast< CGameNotifications_UserStatus* >(object);
  (void)_this;
}
void CGameNotifications_UserStatus::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_UserStatus::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_UserStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_UserStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(title_ != nullptr);
      title_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(message_ != nullptr);
      message_->Clear();
    }
  }
  steamid_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_UserStatus::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.description) = "The specific user\'s steamid."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string state = 2 [(.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_UserStatus.state");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "Title of the session to display to this user in their list of active sessions."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_LocalizedText message = 4 [(.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_UserStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_UserStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.description) = "The specific user\'s steamid."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string state = 2 [(.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_state().data(), static_cast<int>(this->_internal_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_UserStatus.state");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_state(), target);
  }

  // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "Title of the session to display to this user in their list of active sessions."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::title(this), target, stream);
  }

  // optional .CGameNotifications_LocalizedText message = 4 [(.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::message(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_UserStatus)
  return target;
}

size_t CGameNotifications_UserStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_UserStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string state = 2 [(.description) = "The user\'s state.  ready -- the user is ready to play.  waiting -- The game is waiting on an action from the user. completed, the game is over."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state());
    }

    // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "Title of the session to display to this user in their list of active sessions."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional .CGameNotifications_LocalizedText message = 4 [(.description) = "Subtitle of the session to display to this user user within their list of active sessions."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *message_);
    }

    // optional fixed64 steamid = 1 [(.description) = "The specific user\'s steamid."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_UserStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_UserStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_UserStatus::GetClassData() const { return &_class_data_; }

void CGameNotifications_UserStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_UserStatus *>(to)->MergeFrom(
      static_cast<const CGameNotifications_UserStatus &>(from));
}


void CGameNotifications_UserStatus::MergeFrom(const CGameNotifications_UserStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_UserStatus)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_title()->::CGameNotifications_LocalizedText::MergeFrom(from._internal_title());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_message()->::CGameNotifications_LocalizedText::MergeFrom(from._internal_message());
    }
    if (cached_has_bits & 0x00000008u) {
      steamid_ = from.steamid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_UserStatus::CopyFrom(const CGameNotifications_UserStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_UserStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UserStatus::IsInitialized() const {
  return true;
}

void CGameNotifications_UserStatus::InternalSwap(CGameNotifications_UserStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_, lhs_arena,
      &other->state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_UserStatus, steamid_)
      + sizeof(CGameNotifications_UserStatus::steamid_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_UserStatus, title_)>(
          reinterpret_cast<char*>(&title_),
          reinterpret_cast<char*>(&other->title_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_UserStatus::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[2]);
}

// ===================================================================

class CGameNotifications_CreateSession_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_CreateSession_Request>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CGameNotifications_LocalizedText& title(const CGameNotifications_CreateSession_Request* msg);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CGameNotifications_LocalizedText&
CGameNotifications_CreateSession_Request::_Internal::title(const CGameNotifications_CreateSession_Request* msg) {
  return *msg->title_;
}
CGameNotifications_CreateSession_Request::CGameNotifications_CreateSession_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  users_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_CreateSession_Request)
}
CGameNotifications_CreateSession_Request::CGameNotifications_CreateSession_Request(const CGameNotifications_CreateSession_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      users_(from.users_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_title()) {
    title_ = new ::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&context_, &from.context_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&context_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_CreateSession_Request)
}

inline void CGameNotifications_CreateSession_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&title_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&title_)) + sizeof(appid_));
}

CGameNotifications_CreateSession_Request::~CGameNotifications_CreateSession_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_CreateSession_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_CreateSession_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_CreateSession_Request::ArenaDtor(void* object) {
  CGameNotifications_CreateSession_Request* _this = reinterpret_cast< CGameNotifications_CreateSession_Request* >(object);
  (void)_this;
}
void CGameNotifications_CreateSession_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_CreateSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_CreateSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_CreateSession_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  users_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&context_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&context_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_CreateSession_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 context = 2 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_context(&has_bits);
          context_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "The title of the session to be displayed within each user\'s list of sessions."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "The initial state of all users in the session."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_users(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 5 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_CreateSession_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_CreateSession_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint64 context = 2 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_context(), target);
  }

  // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "The title of the session to be displayed within each user\'s list of sessions."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::title(this), target, stream);
  }

  // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "The initial state of all users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_users_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_users(i), target, stream);
  }

  // optional fixed64 steamid = 5 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(5, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_CreateSession_Request)
  return target;
}

size_t CGameNotifications_CreateSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_CreateSession_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "The initial state of all users in the session."];
  total_size += 1UL * this->_internal_users_size();
  for (const auto& msg : this->users_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "The title of the session to be displayed within each user\'s list of sessions."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 context = 2 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_context());
    }

    // optional fixed64 steamid = 5 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_CreateSession_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_CreateSession_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_CreateSession_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_CreateSession_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_CreateSession_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_CreateSession_Request &>(from));
}


void CGameNotifications_CreateSession_Request::MergeFrom(const CGameNotifications_CreateSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_CreateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  users_.MergeFrom(from.users_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_title()->::CGameNotifications_LocalizedText::MergeFrom(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      context_ = from.context_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_CreateSession_Request::CopyFrom(const CGameNotifications_CreateSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_CreateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_CreateSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_CreateSession_Request::InternalSwap(CGameNotifications_CreateSession_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  users_.InternalSwap(&other->users_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_CreateSession_Request, appid_)
      + sizeof(CGameNotifications_CreateSession_Request::appid_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_CreateSession_Request, title_)>(
          reinterpret_cast<char*>(&title_),
          reinterpret_cast<char*>(&other->title_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_CreateSession_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[3]);
}

// ===================================================================

class CGameNotifications_CreateSession_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_CreateSession_Response>()._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGameNotifications_CreateSession_Response::CGameNotifications_CreateSession_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_CreateSession_Response)
}
CGameNotifications_CreateSession_Response::CGameNotifications_CreateSession_Response(const CGameNotifications_CreateSession_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sessionid_ = from.sessionid_;
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_CreateSession_Response)
}

inline void CGameNotifications_CreateSession_Response::SharedCtor() {
sessionid_ = uint64_t{0u};
}

CGameNotifications_CreateSession_Response::~CGameNotifications_CreateSession_Response() {
  // @@protoc_insertion_point(destructor:CGameNotifications_CreateSession_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_CreateSession_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_CreateSession_Response::ArenaDtor(void* object) {
  CGameNotifications_CreateSession_Response* _this = reinterpret_cast< CGameNotifications_CreateSession_Response* >(object);
  (void)_this;
}
void CGameNotifications_CreateSession_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_CreateSession_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_CreateSession_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_CreateSession_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessionid_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_CreateSession_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.description) = "The sessionid of the created session."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_CreateSession_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_CreateSession_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.description) = "The sessionid of the created session."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sessionid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_CreateSession_Response)
  return target;
}

size_t CGameNotifications_CreateSession_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_CreateSession_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 sessionid = 1 [(.description) = "The sessionid of the created session."];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_CreateSession_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_CreateSession_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_CreateSession_Response::GetClassData() const { return &_class_data_; }

void CGameNotifications_CreateSession_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_CreateSession_Response *>(to)->MergeFrom(
      static_cast<const CGameNotifications_CreateSession_Response &>(from));
}


void CGameNotifications_CreateSession_Response::MergeFrom(const CGameNotifications_CreateSession_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_CreateSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_sessionid()) {
    _internal_set_sessionid(from._internal_sessionid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_CreateSession_Response::CopyFrom(const CGameNotifications_CreateSession_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_CreateSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_CreateSession_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_CreateSession_Response::InternalSwap(CGameNotifications_CreateSession_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(sessionid_, other->sessionid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_CreateSession_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[4]);
}

// ===================================================================

class CGameNotifications_DeleteSession_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_DeleteSession_Request>()._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGameNotifications_DeleteSession_Request::CGameNotifications_DeleteSession_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_DeleteSession_Request)
}
CGameNotifications_DeleteSession_Request::CGameNotifications_DeleteSession_Request(const CGameNotifications_DeleteSession_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_DeleteSession_Request)
}

inline void CGameNotifications_DeleteSession_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sessionid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
}

CGameNotifications_DeleteSession_Request::~CGameNotifications_DeleteSession_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_DeleteSession_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_DeleteSession_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_DeleteSession_Request::ArenaDtor(void* object) {
  CGameNotifications_DeleteSession_Request* _this = reinterpret_cast< CGameNotifications_DeleteSession_Request* >(object);
  (void)_this;
}
void CGameNotifications_DeleteSession_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_DeleteSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_DeleteSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_DeleteSession_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_DeleteSession_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.description) = "The sessionid to delete."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2 [(.description) = "The appid of the session to delete."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 3 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_DeleteSession_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_DeleteSession_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.description) = "The sessionid to delete."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sessionid(), target);
  }

  // optional uint32 appid = 2 [(.description) = "The appid of the session to delete."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  // optional fixed64 steamid = 3 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_DeleteSession_Request)
  return target;
}

size_t CGameNotifications_DeleteSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_DeleteSession_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 sessionid = 1 [(.description) = "The sessionid to delete."];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
    }

    // optional fixed64 steamid = 3 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.description) = "The appid of the session to delete."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_DeleteSession_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_DeleteSession_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_DeleteSession_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_DeleteSession_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_DeleteSession_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_DeleteSession_Request &>(from));
}


void CGameNotifications_DeleteSession_Request::MergeFrom(const CGameNotifications_DeleteSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_DeleteSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_DeleteSession_Request::CopyFrom(const CGameNotifications_DeleteSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_DeleteSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_DeleteSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_DeleteSession_Request::InternalSwap(CGameNotifications_DeleteSession_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_DeleteSession_Request, appid_)
      + sizeof(CGameNotifications_DeleteSession_Request::appid_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_DeleteSession_Request, sessionid_)>(
          reinterpret_cast<char*>(&sessionid_),
          reinterpret_cast<char*>(&other->sessionid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_DeleteSession_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[5]);
}

// ===================================================================

class CGameNotifications_DeleteSession_Response::_Internal {
 public:
};

CGameNotifications_DeleteSession_Response::CGameNotifications_DeleteSession_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_DeleteSession_Response)
}
CGameNotifications_DeleteSession_Response::CGameNotifications_DeleteSession_Response(const CGameNotifications_DeleteSession_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_DeleteSession_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_DeleteSession_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_DeleteSession_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_DeleteSession_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[6]);
}

// ===================================================================

class CGameNotifications_UpdateSession_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_UpdateSession_Request>()._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CGameNotifications_LocalizedText& title(const CGameNotifications_UpdateSession_Request* msg);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CGameNotifications_LocalizedText&
CGameNotifications_UpdateSession_Request::_Internal::title(const CGameNotifications_UpdateSession_Request* msg) {
  return *msg->title_;
}
CGameNotifications_UpdateSession_Request::CGameNotifications_UpdateSession_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  users_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_UpdateSession_Request)
}
CGameNotifications_UpdateSession_Request::CGameNotifications_UpdateSession_Request(const CGameNotifications_UpdateSession_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      users_(from.users_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_title()) {
    title_ = new ::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_UpdateSession_Request)
}

inline void CGameNotifications_UpdateSession_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&title_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&title_)) + sizeof(appid_));
}

CGameNotifications_UpdateSession_Request::~CGameNotifications_UpdateSession_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_UpdateSession_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_UpdateSession_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_UpdateSession_Request::ArenaDtor(void* object) {
  CGameNotifications_UpdateSession_Request* _this = reinterpret_cast< CGameNotifications_UpdateSession_Request* >(object);
  (void)_this;
}
void CGameNotifications_UpdateSession_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_UpdateSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_UpdateSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_UpdateSession_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  users_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_UpdateSession_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.description) = "The sessionid to update."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2 [(.description) = "The appid of the session to update."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_users(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 6 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_UpdateSession_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_UpdateSession_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.description) = "The sessionid to update."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sessionid(), target);
  }

  // optional uint32 appid = 2 [(.description) = "The appid of the session to update."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::title(this), target, stream);
  }

  // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_users_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_users(i), target, stream);
  }

  // optional fixed64 steamid = 6 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(6, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_UpdateSession_Request)
  return target;
}

size_t CGameNotifications_UpdateSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_UpdateSession_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_UserStatus users = 4 [(.description) = "(Optional) A list of users whose state will be updated to reflect the given state. If the users are not already in the session, they will be added to it."];
  total_size += 1UL * this->_internal_users_size();
  for (const auto& msg : this->users_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CGameNotifications_LocalizedText title = 3 [(.description) = "(Optional) The new title of the session.  If not specified, the title will not be changed."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 sessionid = 1 [(.description) = "The sessionid to update."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
    }

    // optional fixed64 steamid = 6 [(.description) = "(Optional) steamid to make the request on behalf of -- if specified, the user must be in the session and all users being added to the session must be friends with the user."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.description) = "The appid of the session to update."];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_UpdateSession_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_UpdateSession_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_UpdateSession_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_UpdateSession_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_UpdateSession_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_UpdateSession_Request &>(from));
}


void CGameNotifications_UpdateSession_Request::MergeFrom(const CGameNotifications_UpdateSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_UpdateSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  users_.MergeFrom(from.users_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_title()->::CGameNotifications_LocalizedText::MergeFrom(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_UpdateSession_Request::CopyFrom(const CGameNotifications_UpdateSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_UpdateSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateSession_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateSession_Request::InternalSwap(CGameNotifications_UpdateSession_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  users_.InternalSwap(&other->users_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_UpdateSession_Request, appid_)
      + sizeof(CGameNotifications_UpdateSession_Request::appid_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_UpdateSession_Request, title_)>(
          reinterpret_cast<char*>(&title_),
          reinterpret_cast<char*>(&other->title_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_UpdateSession_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[7]);
}

// ===================================================================

class CGameNotifications_UpdateSession_Response::_Internal {
 public:
};

CGameNotifications_UpdateSession_Response::CGameNotifications_UpdateSession_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_UpdateSession_Response)
}
CGameNotifications_UpdateSession_Response::CGameNotifications_UpdateSession_Response(const CGameNotifications_UpdateSession_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_UpdateSession_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_UpdateSession_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_UpdateSession_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_UpdateSession_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[8]);
}

// ===================================================================

class CGameNotifications_EnumerateSessions_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_EnumerateSessions_Request>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_include_all_user_messages(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_include_auth_user_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGameNotifications_EnumerateSessions_Request::CGameNotifications_EnumerateSessions_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_EnumerateSessions_Request)
}
CGameNotifications_EnumerateSessions_Request::CGameNotifications_EnumerateSessions_Request(const CGameNotifications_EnumerateSessions_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_language(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_EnumerateSessions_Request)
}

inline void CGameNotifications_EnumerateSessions_Request::SharedCtor() {
language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
}

CGameNotifications_EnumerateSessions_Request::~CGameNotifications_EnumerateSessions_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_EnumerateSessions_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_EnumerateSessions_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  language_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_EnumerateSessions_Request::ArenaDtor(void* object) {
  CGameNotifications_EnumerateSessions_Request* _this = reinterpret_cast< CGameNotifications_EnumerateSessions_Request* >(object);
  (void)_this;
}
void CGameNotifications_EnumerateSessions_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_EnumerateSessions_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_EnumerateSessions_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_EnumerateSessions_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    language_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_auth_user_message_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(include_auth_user_message_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_EnumerateSessions_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_all_user_messages = 3 [(.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_include_all_user_messages(&has_bits);
          include_all_user_messages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_auth_user_message = 4 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_include_auth_user_message(&has_bits);
          include_auth_user_message_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 5 [(.description) = "(Optional) Language to localize the text in."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_language();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_EnumerateSessions_Request.language");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_EnumerateSessions_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_EnumerateSessions_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional bool include_all_user_messages = 3 [(.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_include_all_user_messages(), target);
  }

  // optional bool include_auth_user_message = 4 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_include_auth_user_message(), target);
  }

  // optional string language = 5 [(.description) = "(Optional) Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_EnumerateSessions_Request.language");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_EnumerateSessions_Request)
  return target;
}

size_t CGameNotifications_EnumerateSessions_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_EnumerateSessions_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string language = 5 [(.description) = "(Optional) Language to localize the text in."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional uint32 appid = 1 [(.description) = "The sessionid to request details for. Optional. If not specified, all the user\'s sessions will be returned."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional bool include_all_user_messages = 3 [(.description) = "(Optional) Boolean determining whether the message for all users should be included. Defaults to false."];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool include_auth_user_message = 4 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_EnumerateSessions_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_EnumerateSessions_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_EnumerateSessions_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_EnumerateSessions_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_EnumerateSessions_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_EnumerateSessions_Request &>(from));
}


void CGameNotifications_EnumerateSessions_Request::MergeFrom(const CGameNotifications_EnumerateSessions_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_EnumerateSessions_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000004u) {
      include_all_user_messages_ = from.include_all_user_messages_;
    }
    if (cached_has_bits & 0x00000008u) {
      include_auth_user_message_ = from.include_auth_user_message_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_EnumerateSessions_Request::CopyFrom(const CGameNotifications_EnumerateSessions_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_EnumerateSessions_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_EnumerateSessions_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_EnumerateSessions_Request::InternalSwap(CGameNotifications_EnumerateSessions_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &language_, lhs_arena,
      &other->language_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_EnumerateSessions_Request, include_auth_user_message_)
      + sizeof(CGameNotifications_EnumerateSessions_Request::include_auth_user_message_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_EnumerateSessions_Request, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_EnumerateSessions_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[9]);
}

// ===================================================================

class CGameNotifications_Session::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_Session>()._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_context(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CGameNotifications_LocalizedText& title(const CGameNotifications_Session* msg);
  static void set_has_title(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_created(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_time_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CGameNotifications_LocalizedText&
CGameNotifications_Session::_Internal::title(const CGameNotifications_Session* msg) {
  return *msg->title_;
}
CGameNotifications_Session::CGameNotifications_Session(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  user_status_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_Session)
}
CGameNotifications_Session::CGameNotifications_Session(const CGameNotifications_Session& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      user_status_(from.user_status_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_title()) {
    title_ = new ::CGameNotifications_LocalizedText(*from.title_);
  } else {
    title_ = nullptr;
  }
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&time_updated_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(time_updated_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_Session)
}

inline void CGameNotifications_Session::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&title_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_updated_) -
    reinterpret_cast<char*>(&title_)) + sizeof(time_updated_));
}

CGameNotifications_Session::~CGameNotifications_Session() {
  // @@protoc_insertion_point(destructor:CGameNotifications_Session)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_Session::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete title_;
}

void CGameNotifications_Session::ArenaDtor(void* object) {
  CGameNotifications_Session* _this = reinterpret_cast< CGameNotifications_Session* >(object);
  (void)_this;
}
void CGameNotifications_Session::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_Session::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_Session::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_Session)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  user_status_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(title_ != nullptr);
    title_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&time_updated_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(time_updated_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_Session::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.description) = "The sessionid for this session."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 appid = 2 [(.description) = "The appid for the session."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 context = 3 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_context(&has_bits);
          context_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_LocalizedText title = 4 [(.description) = "The current title for the session."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_title(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_created = 5 [(.description) = "The time the session was created."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_time_created(&has_bits);
          time_created_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_updated = 6 [(.description) = "The last time the session was updated."];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_time_updated(&has_bits);
          time_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CGameNotifications_UserStatus user_status = 7 [(.description) = "The status of all the users in the session."];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_user_status(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_Session::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_Session)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.description) = "The sessionid for this session."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sessionid(), target);
  }

  // optional uint64 appid = 2 [(.description) = "The appid for the session."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_appid(), target);
  }

  // optional uint64 context = 3 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_context(), target);
  }

  // optional .CGameNotifications_LocalizedText title = 4 [(.description) = "The current title for the session."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::title(this), target, stream);
  }

  // optional uint32 time_created = 5 [(.description) = "The time the session was created."];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_time_created(), target);
  }

  // optional uint32 time_updated = 6 [(.description) = "The last time the session was updated."];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_time_updated(), target);
  }

  // repeated .CGameNotifications_UserStatus user_status = 7 [(.description) = "The status of all the users in the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_user_status_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, this->_internal_user_status(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_Session)
  return target;
}

size_t CGameNotifications_Session::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_Session)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_UserStatus user_status = 7 [(.description) = "The status of all the users in the session."];
  total_size += 1UL * this->_internal_user_status_size();
  for (const auto& msg : this->user_status_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CGameNotifications_LocalizedText title = 4 [(.description) = "The current title for the session."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *title_);
    }

    // optional uint64 sessionid = 1 [(.description) = "The sessionid for this session."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
    }

    // optional uint64 appid = 2 [(.description) = "The appid for the session."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_appid());
    }

    // optional uint64 context = 3 [(.description) = "Game-specified context value the game can used to associate the session with some object on their backend."];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_context());
    }

    // optional uint32 time_created = 5 [(.description) = "The time the session was created."];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time_created());
    }

    // optional uint32 time_updated = 6 [(.description) = "The last time the session was updated."];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time_updated());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_Session::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_Session::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_Session::GetClassData() const { return &_class_data_; }

void CGameNotifications_Session::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_Session *>(to)->MergeFrom(
      static_cast<const CGameNotifications_Session &>(from));
}


void CGameNotifications_Session::MergeFrom(const CGameNotifications_Session& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_Session)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  user_status_.MergeFrom(from.user_status_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_title()->::CGameNotifications_LocalizedText::MergeFrom(from._internal_title());
    }
    if (cached_has_bits & 0x00000002u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      context_ = from.context_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_created_ = from.time_created_;
    }
    if (cached_has_bits & 0x00000020u) {
      time_updated_ = from.time_updated_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_Session::CopyFrom(const CGameNotifications_Session& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_Session)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_Session::IsInitialized() const {
  return true;
}

void CGameNotifications_Session::InternalSwap(CGameNotifications_Session* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  user_status_.InternalSwap(&other->user_status_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_Session, time_updated_)
      + sizeof(CGameNotifications_Session::time_updated_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_Session, title_)>(
          reinterpret_cast<char*>(&title_),
          reinterpret_cast<char*>(&other->title_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_Session::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[10]);
}

// ===================================================================

class CGameNotifications_EnumerateSessions_Response::_Internal {
 public:
};

CGameNotifications_EnumerateSessions_Response::CGameNotifications_EnumerateSessions_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sessions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_EnumerateSessions_Response)
}
CGameNotifications_EnumerateSessions_Response::CGameNotifications_EnumerateSessions_Response(const CGameNotifications_EnumerateSessions_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_EnumerateSessions_Response)
}

inline void CGameNotifications_EnumerateSessions_Response::SharedCtor() {
}

CGameNotifications_EnumerateSessions_Response::~CGameNotifications_EnumerateSessions_Response() {
  // @@protoc_insertion_point(destructor:CGameNotifications_EnumerateSessions_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_EnumerateSessions_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_EnumerateSessions_Response::ArenaDtor(void* object) {
  CGameNotifications_EnumerateSessions_Response* _this = reinterpret_cast< CGameNotifications_EnumerateSessions_Response* >(object);
  (void)_this;
}
void CGameNotifications_EnumerateSessions_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_EnumerateSessions_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_EnumerateSessions_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_EnumerateSessions_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_EnumerateSessions_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGameNotifications_Session sessions = 1 [(.description) = "A list of the user\'s sessions."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_EnumerateSessions_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_EnumerateSessions_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGameNotifications_Session sessions = 1 [(.description) = "A list of the user\'s sessions."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sessions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sessions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_EnumerateSessions_Response)
  return target;
}

size_t CGameNotifications_EnumerateSessions_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_EnumerateSessions_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_Session sessions = 1 [(.description) = "A list of the user\'s sessions."];
  total_size += 1UL * this->_internal_sessions_size();
  for (const auto& msg : this->sessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_EnumerateSessions_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_EnumerateSessions_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_EnumerateSessions_Response::GetClassData() const { return &_class_data_; }

void CGameNotifications_EnumerateSessions_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_EnumerateSessions_Response *>(to)->MergeFrom(
      static_cast<const CGameNotifications_EnumerateSessions_Response &>(from));
}


void CGameNotifications_EnumerateSessions_Response::MergeFrom(const CGameNotifications_EnumerateSessions_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_EnumerateSessions_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_EnumerateSessions_Response::CopyFrom(const CGameNotifications_EnumerateSessions_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_EnumerateSessions_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_EnumerateSessions_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_EnumerateSessions_Response::InternalSwap(CGameNotifications_EnumerateSessions_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sessions_.InternalSwap(&other->sessions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_EnumerateSessions_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[11]);
}

// ===================================================================

class CGameNotifications_GetSessionDetails_Request_RequestedSession::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_GetSessionDetails_Request_RequestedSession>()._has_bits_);
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_include_auth_user_message(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGameNotifications_GetSessionDetails_Request_RequestedSession::CGameNotifications_GetSessionDetails_Request_RequestedSession(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_GetSessionDetails_Request.RequestedSession)
}
CGameNotifications_GetSessionDetails_Request_RequestedSession::CGameNotifications_GetSessionDetails_Request_RequestedSession(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sessionid_, &from.sessionid_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_GetSessionDetails_Request.RequestedSession)
}

inline void CGameNotifications_GetSessionDetails_Request_RequestedSession::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sessionid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&include_auth_user_message_) -
    reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
}

CGameNotifications_GetSessionDetails_Request_RequestedSession::~CGameNotifications_GetSessionDetails_Request_RequestedSession() {
  // @@protoc_insertion_point(destructor:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_GetSessionDetails_Request_RequestedSession::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::ArenaDtor(void* object) {
  CGameNotifications_GetSessionDetails_Request_RequestedSession* _this = reinterpret_cast< CGameNotifications_GetSessionDetails_Request_RequestedSession* >(object);
  (void)_this;
}
void CGameNotifications_GetSessionDetails_Request_RequestedSession::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_GetSessionDetails_Request_RequestedSession::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sessionid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_auth_user_message_) -
        reinterpret_cast<char*>(&sessionid_)) + sizeof(include_auth_user_message_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_GetSessionDetails_Request_RequestedSession::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 sessionid = 1 [(.description) = "The sessionid to get details for."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_auth_user_message = 3 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_include_auth_user_message(&has_bits);
          include_auth_user_message_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_GetSessionDetails_Request_RequestedSession::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 sessionid = 1 [(.description) = "The sessionid to get details for."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_sessionid(), target);
  }

  // optional bool include_auth_user_message = 3 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_include_auth_user_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Request_RequestedSession::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint64 sessionid = 1 [(.description) = "The sessionid to get details for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
    }

    // optional bool include_auth_user_message = 3 [(.description) = "(Optional) Boolean determining whether the message for the authenticated user should be included. Defaults to false."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_GetSessionDetails_Request_RequestedSession::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_GetSessionDetails_Request_RequestedSession::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_GetSessionDetails_Request_RequestedSession::GetClassData() const { return &_class_data_; }

void CGameNotifications_GetSessionDetails_Request_RequestedSession::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_GetSessionDetails_Request_RequestedSession *>(to)->MergeFrom(
      static_cast<const CGameNotifications_GetSessionDetails_Request_RequestedSession &>(from));
}


void CGameNotifications_GetSessionDetails_Request_RequestedSession::MergeFrom(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000002u) {
      include_auth_user_message_ = from.include_auth_user_message_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::CopyFrom(const CGameNotifications_GetSessionDetails_Request_RequestedSession& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_GetSessionDetails_Request.RequestedSession)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Request_RequestedSession::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Request_RequestedSession::InternalSwap(CGameNotifications_GetSessionDetails_Request_RequestedSession* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_GetSessionDetails_Request_RequestedSession, include_auth_user_message_)
      + sizeof(CGameNotifications_GetSessionDetails_Request_RequestedSession::include_auth_user_message_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_GetSessionDetails_Request_RequestedSession, sessionid_)>(
          reinterpret_cast<char*>(&sessionid_),
          reinterpret_cast<char*>(&other->sessionid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_GetSessionDetails_Request_RequestedSession::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[12]);
}

// ===================================================================

class CGameNotifications_GetSessionDetails_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_GetSessionDetails_Request>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGameNotifications_GetSessionDetails_Request::CGameNotifications_GetSessionDetails_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sessions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_GetSessionDetails_Request)
}
CGameNotifications_GetSessionDetails_Request::CGameNotifications_GetSessionDetails_Request(const CGameNotifications_GetSessionDetails_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_language()) {
    language_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_language(), 
      GetArenaForAllocation());
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_GetSessionDetails_Request)
}

inline void CGameNotifications_GetSessionDetails_Request::SharedCtor() {
language_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  language_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
appid_ = 0u;
}

CGameNotifications_GetSessionDetails_Request::~CGameNotifications_GetSessionDetails_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_GetSessionDetails_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_GetSessionDetails_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  language_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CGameNotifications_GetSessionDetails_Request::ArenaDtor(void* object) {
  CGameNotifications_GetSessionDetails_Request* _this = reinterpret_cast< CGameNotifications_GetSessionDetails_Request* >(object);
  (void)_this;
}
void CGameNotifications_GetSessionDetails_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_GetSessionDetails_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_GetSessionDetails_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_GetSessionDetails_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    language_.ClearNonDefaultToEmpty();
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_GetSessionDetails_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2 [(.description) = "The appid for the sessions."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string language = 3 [(.description) = "Language to localize the text in."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_language();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGameNotifications_GetSessionDetails_Request.language");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_GetSessionDetails_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_GetSessionDetails_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sessions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sessions(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 2 [(.description) = "The appid for the sessions."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  // optional string language = 3 [(.description) = "Language to localize the text in."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_language().data(), static_cast<int>(this->_internal_language().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGameNotifications_GetSessionDetails_Request.language");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_language(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_GetSessionDetails_Request)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_GetSessionDetails_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_GetSessionDetails_Request.RequestedSession sessions = 1;
  total_size += 1UL * this->_internal_sessions_size();
  for (const auto& msg : this->sessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string language = 3 [(.description) = "Language to localize the text in."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_language());
    }

    // optional uint32 appid = 2 [(.description) = "The appid for the sessions."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_GetSessionDetails_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_GetSessionDetails_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_GetSessionDetails_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_GetSessionDetails_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_GetSessionDetails_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_GetSessionDetails_Request &>(from));
}


void CGameNotifications_GetSessionDetails_Request::MergeFrom(const CGameNotifications_GetSessionDetails_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_GetSessionDetails_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_language(from._internal_language());
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_GetSessionDetails_Request::CopyFrom(const CGameNotifications_GetSessionDetails_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_GetSessionDetails_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Request::InternalSwap(CGameNotifications_GetSessionDetails_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sessions_.InternalSwap(&other->sessions_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &language_, lhs_arena,
      &other->language_, rhs_arena
  );
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_GetSessionDetails_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[13]);
}

// ===================================================================

class CGameNotifications_GetSessionDetails_Response::_Internal {
 public:
};

CGameNotifications_GetSessionDetails_Response::CGameNotifications_GetSessionDetails_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sessions_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_GetSessionDetails_Response)
}
CGameNotifications_GetSessionDetails_Response::CGameNotifications_GetSessionDetails_Response(const CGameNotifications_GetSessionDetails_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      sessions_(from.sessions_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_GetSessionDetails_Response)
}

inline void CGameNotifications_GetSessionDetails_Response::SharedCtor() {
}

CGameNotifications_GetSessionDetails_Response::~CGameNotifications_GetSessionDetails_Response() {
  // @@protoc_insertion_point(destructor:CGameNotifications_GetSessionDetails_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_GetSessionDetails_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_GetSessionDetails_Response::ArenaDtor(void* object) {
  CGameNotifications_GetSessionDetails_Response* _this = reinterpret_cast< CGameNotifications_GetSessionDetails_Response* >(object);
  (void)_this;
}
void CGameNotifications_GetSessionDetails_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_GetSessionDetails_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_GetSessionDetails_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_GetSessionDetails_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sessions_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_GetSessionDetails_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CGameNotifications_Session sessions = 1 [(.description) = "The details of the session."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sessions(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_GetSessionDetails_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_GetSessionDetails_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CGameNotifications_Session sessions = 1 [(.description) = "The details of the session."];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_sessions_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_sessions(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_GetSessionDetails_Response)
  return target;
}

size_t CGameNotifications_GetSessionDetails_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_GetSessionDetails_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CGameNotifications_Session sessions = 1 [(.description) = "The details of the session."];
  total_size += 1UL * this->_internal_sessions_size();
  for (const auto& msg : this->sessions_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_GetSessionDetails_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_GetSessionDetails_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_GetSessionDetails_Response::GetClassData() const { return &_class_data_; }

void CGameNotifications_GetSessionDetails_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_GetSessionDetails_Response *>(to)->MergeFrom(
      static_cast<const CGameNotifications_GetSessionDetails_Response &>(from));
}


void CGameNotifications_GetSessionDetails_Response::MergeFrom(const CGameNotifications_GetSessionDetails_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_GetSessionDetails_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sessions_.MergeFrom(from.sessions_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_GetSessionDetails_Response::CopyFrom(const CGameNotifications_GetSessionDetails_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_GetSessionDetails_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_GetSessionDetails_Response::IsInitialized() const {
  return true;
}

void CGameNotifications_GetSessionDetails_Response::InternalSwap(CGameNotifications_GetSessionDetails_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  sessions_.InternalSwap(&other->sessions_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_GetSessionDetails_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[14]);
}

// ===================================================================

class GameNotificationSettings::_Internal {
 public:
  using HasBits = decltype(std::declval<GameNotificationSettings>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_allow_notifications(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

GameNotificationSettings::GameNotificationSettings(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:GameNotificationSettings)
}
GameNotificationSettings::GameNotificationSettings(const GameNotificationSettings& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&allow_notifications_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
  // @@protoc_insertion_point(copy_constructor:GameNotificationSettings)
}

inline void GameNotificationSettings::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&allow_notifications_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
}

GameNotificationSettings::~GameNotificationSettings() {
  // @@protoc_insertion_point(destructor:GameNotificationSettings)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void GameNotificationSettings::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void GameNotificationSettings::ArenaDtor(void* object) {
  GameNotificationSettings* _this = reinterpret_cast< GameNotificationSettings* >(object);
  (void)_this;
}
void GameNotificationSettings::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void GameNotificationSettings::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void GameNotificationSettings::Clear() {
// @@protoc_insertion_point(message_clear_start:GameNotificationSettings)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&allow_notifications_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(allow_notifications_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* GameNotificationSettings::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool allow_notifications = 2 [(.description) = "Whether the user allows notification for this app."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_allow_notifications(&has_bits);
          allow_notifications_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* GameNotificationSettings::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:GameNotificationSettings)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional bool allow_notifications = 2 [(.description) = "Whether the user allows notification for this app."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_allow_notifications(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:GameNotificationSettings)
  return target;
}

size_t GameNotificationSettings::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:GameNotificationSettings)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1 [(.description) = "The appid to create the session for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional bool allow_notifications = 2 [(.description) = "Whether the user allows notification for this app."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData GameNotificationSettings::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    GameNotificationSettings::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GameNotificationSettings::GetClassData() const { return &_class_data_; }

void GameNotificationSettings::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<GameNotificationSettings *>(to)->MergeFrom(
      static_cast<const GameNotificationSettings &>(from));
}


void GameNotificationSettings::MergeFrom(const GameNotificationSettings& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:GameNotificationSettings)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      allow_notifications_ = from.allow_notifications_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void GameNotificationSettings::CopyFrom(const GameNotificationSettings& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:GameNotificationSettings)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GameNotificationSettings::IsInitialized() const {
  return true;
}

void GameNotificationSettings::InternalSwap(GameNotificationSettings* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(GameNotificationSettings, allow_notifications_)
      + sizeof(GameNotificationSettings::allow_notifications_)
      - PROTOBUF_FIELD_OFFSET(GameNotificationSettings, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata GameNotificationSettings::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[15]);
}

// ===================================================================

class CGameNotifications_UpdateNotificationSettings_Request::_Internal {
 public:
};

CGameNotifications_UpdateNotificationSettings_Request::CGameNotifications_UpdateNotificationSettings_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  game_notification_settings_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_UpdateNotificationSettings_Request)
}
CGameNotifications_UpdateNotificationSettings_Request::CGameNotifications_UpdateNotificationSettings_Request(const CGameNotifications_UpdateNotificationSettings_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      game_notification_settings_(from.game_notification_settings_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_UpdateNotificationSettings_Request)
}

inline void CGameNotifications_UpdateNotificationSettings_Request::SharedCtor() {
}

CGameNotifications_UpdateNotificationSettings_Request::~CGameNotifications_UpdateNotificationSettings_Request() {
  // @@protoc_insertion_point(destructor:CGameNotifications_UpdateNotificationSettings_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_UpdateNotificationSettings_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_UpdateNotificationSettings_Request::ArenaDtor(void* object) {
  CGameNotifications_UpdateNotificationSettings_Request* _this = reinterpret_cast< CGameNotifications_UpdateNotificationSettings_Request* >(object);
  (void)_this;
}
void CGameNotifications_UpdateNotificationSettings_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_UpdateNotificationSettings_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_UpdateNotificationSettings_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_UpdateNotificationSettings_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  game_notification_settings_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_UpdateNotificationSettings_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .GameNotificationSettings game_notification_settings = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_game_notification_settings(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_UpdateNotificationSettings_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_UpdateNotificationSettings_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .GameNotificationSettings game_notification_settings = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_game_notification_settings_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_game_notification_settings(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_UpdateNotificationSettings_Request)
  return target;
}

size_t CGameNotifications_UpdateNotificationSettings_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_UpdateNotificationSettings_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .GameNotificationSettings game_notification_settings = 1;
  total_size += 1UL * this->_internal_game_notification_settings_size();
  for (const auto& msg : this->game_notification_settings_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_UpdateNotificationSettings_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_UpdateNotificationSettings_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_UpdateNotificationSettings_Request::GetClassData() const { return &_class_data_; }

void CGameNotifications_UpdateNotificationSettings_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_UpdateNotificationSettings_Request *>(to)->MergeFrom(
      static_cast<const CGameNotifications_UpdateNotificationSettings_Request &>(from));
}


void CGameNotifications_UpdateNotificationSettings_Request::MergeFrom(const CGameNotifications_UpdateNotificationSettings_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_UpdateNotificationSettings_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  game_notification_settings_.MergeFrom(from.game_notification_settings_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_UpdateNotificationSettings_Request::CopyFrom(const CGameNotifications_UpdateNotificationSettings_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_UpdateNotificationSettings_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_UpdateNotificationSettings_Request::IsInitialized() const {
  return true;
}

void CGameNotifications_UpdateNotificationSettings_Request::InternalSwap(CGameNotifications_UpdateNotificationSettings_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  game_notification_settings_.InternalSwap(&other->game_notification_settings_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_UpdateNotificationSettings_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[16]);
}

// ===================================================================

class CGameNotifications_UpdateNotificationSettings_Response::_Internal {
 public:
};

CGameNotifications_UpdateNotificationSettings_Response::CGameNotifications_UpdateNotificationSettings_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_UpdateNotificationSettings_Response)
}
CGameNotifications_UpdateNotificationSettings_Response::CGameNotifications_UpdateNotificationSettings_Response(const CGameNotifications_UpdateNotificationSettings_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_UpdateNotificationSettings_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_UpdateNotificationSettings_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_UpdateNotificationSettings_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_UpdateNotificationSettings_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[17]);
}

// ===================================================================

class CGameNotifications_OnNotificationsRequested_Notification::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_OnNotificationsRequested_Notification>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CGameNotifications_OnNotificationsRequested_Notification::CGameNotifications_OnNotificationsRequested_Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_OnNotificationsRequested_Notification)
}
CGameNotifications_OnNotificationsRequested_Notification::CGameNotifications_OnNotificationsRequested_Notification(const CGameNotifications_OnNotificationsRequested_Notification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_OnNotificationsRequested_Notification)
}

inline void CGameNotifications_OnNotificationsRequested_Notification::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
}

CGameNotifications_OnNotificationsRequested_Notification::~CGameNotifications_OnNotificationsRequested_Notification() {
  // @@protoc_insertion_point(destructor:CGameNotifications_OnNotificationsRequested_Notification)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_OnNotificationsRequested_Notification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGameNotifications_OnNotificationsRequested_Notification::ArenaDtor(void* object) {
  CGameNotifications_OnNotificationsRequested_Notification* _this = reinterpret_cast< CGameNotifications_OnNotificationsRequested_Notification* >(object);
  (void)_this;
}
void CGameNotifications_OnNotificationsRequested_Notification::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_OnNotificationsRequested_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_OnNotificationsRequested_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_OnNotificationsRequested_Notification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_OnNotificationsRequested_Notification::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.description) = "steamid of the user who notifications were requested for."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2 [(.description) = "The appid that requested notifications."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_OnNotificationsRequested_Notification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_OnNotificationsRequested_Notification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.description) = "steamid of the user who notifications were requested for."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint32 appid = 2 [(.description) = "The appid that requested notifications."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_OnNotificationsRequested_Notification)
  return target;
}

size_t CGameNotifications_OnNotificationsRequested_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_OnNotificationsRequested_Notification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1 [(.description) = "steamid of the user who notifications were requested for."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 appid = 2 [(.description) = "The appid that requested notifications."];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_OnNotificationsRequested_Notification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_OnNotificationsRequested_Notification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_OnNotificationsRequested_Notification::GetClassData() const { return &_class_data_; }

void CGameNotifications_OnNotificationsRequested_Notification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_OnNotificationsRequested_Notification *>(to)->MergeFrom(
      static_cast<const CGameNotifications_OnNotificationsRequested_Notification &>(from));
}


void CGameNotifications_OnNotificationsRequested_Notification::MergeFrom(const CGameNotifications_OnNotificationsRequested_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_OnNotificationsRequested_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_OnNotificationsRequested_Notification::CopyFrom(const CGameNotifications_OnNotificationsRequested_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_OnNotificationsRequested_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_OnNotificationsRequested_Notification::IsInitialized() const {
  return true;
}

void CGameNotifications_OnNotificationsRequested_Notification::InternalSwap(CGameNotifications_OnNotificationsRequested_Notification* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_OnNotificationsRequested_Notification, appid_)
      + sizeof(CGameNotifications_OnNotificationsRequested_Notification::appid_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_OnNotificationsRequested_Notification, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_OnNotificationsRequested_Notification::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[18]);
}

// ===================================================================

class CGameNotifications_OnUserStatusChanged_Notification::_Internal {
 public:
  using HasBits = decltype(std::declval<CGameNotifications_OnUserStatusChanged_Notification>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sessionid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CGameNotifications_UserStatus& status(const CGameNotifications_OnUserStatusChanged_Notification* msg);
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_removed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CGameNotifications_UserStatus&
CGameNotifications_OnUserStatusChanged_Notification::_Internal::status(const CGameNotifications_OnUserStatusChanged_Notification* msg) {
  return *msg->status_;
}
CGameNotifications_OnUserStatusChanged_Notification::CGameNotifications_OnUserStatusChanged_Notification(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGameNotifications_OnUserStatusChanged_Notification)
}
CGameNotifications_OnUserStatusChanged_Notification::CGameNotifications_OnUserStatusChanged_Notification(const CGameNotifications_OnUserStatusChanged_Notification& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_status()) {
    status_ = new ::CGameNotifications_UserStatus(*from.status_);
  } else {
    status_ = nullptr;
  }
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&removed_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(removed_));
  // @@protoc_insertion_point(copy_constructor:CGameNotifications_OnUserStatusChanged_Notification)
}

inline void CGameNotifications_OnUserStatusChanged_Notification::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&status_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&removed_) -
    reinterpret_cast<char*>(&status_)) + sizeof(removed_));
}

CGameNotifications_OnUserStatusChanged_Notification::~CGameNotifications_OnUserStatusChanged_Notification() {
  // @@protoc_insertion_point(destructor:CGameNotifications_OnUserStatusChanged_Notification)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGameNotifications_OnUserStatusChanged_Notification::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete status_;
}

void CGameNotifications_OnUserStatusChanged_Notification::ArenaDtor(void* object) {
  CGameNotifications_OnUserStatusChanged_Notification* _this = reinterpret_cast< CGameNotifications_OnUserStatusChanged_Notification* >(object);
  (void)_this;
}
void CGameNotifications_OnUserStatusChanged_Notification::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGameNotifications_OnUserStatusChanged_Notification::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGameNotifications_OnUserStatusChanged_Notification::Clear() {
// @@protoc_insertion_point(message_clear_start:CGameNotifications_OnUserStatusChanged_Notification)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(status_ != nullptr);
    status_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&removed_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(removed_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGameNotifications_OnUserStatusChanged_Notification::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.description) = "steamid of the user whose status changed."];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 sessionid = 2 [(.description) = "The sessionid of the session where the user\'s status was changed."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sessionid(&has_bits);
          sessionid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 3 [(.description) = "The appid of the session where the user\'s status changed."];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CGameNotifications_UserStatus status = 4 [(.description) = "(Optional) New status of the user."];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_status(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool removed = 5 [(.description) = "(Optional) User has been removed from the session."];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_removed(&has_bits);
          removed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGameNotifications_OnUserStatusChanged_Notification::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGameNotifications_OnUserStatusChanged_Notification)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.description) = "steamid of the user whose status changed."];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional uint64 sessionid = 2 [(.description) = "The sessionid of the session where the user\'s status was changed."];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_sessionid(), target);
  }

  // optional uint32 appid = 3 [(.description) = "The appid of the session where the user\'s status changed."];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_appid(), target);
  }

  // optional .CGameNotifications_UserStatus status = 4 [(.description) = "(Optional) New status of the user."];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::status(this), target, stream);
  }

  // optional bool removed = 5 [(.description) = "(Optional) User has been removed from the session."];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_removed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGameNotifications_OnUserStatusChanged_Notification)
  return target;
}

size_t CGameNotifications_OnUserStatusChanged_Notification::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGameNotifications_OnUserStatusChanged_Notification)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CGameNotifications_UserStatus status = 4 [(.description) = "(Optional) New status of the user."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *status_);
    }

    // optional fixed64 steamid = 1 [(.description) = "steamid of the user whose status changed."];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint64 sessionid = 2 [(.description) = "The sessionid of the session where the user\'s status was changed."];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_sessionid());
    }

    // optional uint32 appid = 3 [(.description) = "The appid of the session where the user\'s status changed."];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional bool removed = 5 [(.description) = "(Optional) User has been removed from the session."];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGameNotifications_OnUserStatusChanged_Notification::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGameNotifications_OnUserStatusChanged_Notification::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGameNotifications_OnUserStatusChanged_Notification::GetClassData() const { return &_class_data_; }

void CGameNotifications_OnUserStatusChanged_Notification::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGameNotifications_OnUserStatusChanged_Notification *>(to)->MergeFrom(
      static_cast<const CGameNotifications_OnUserStatusChanged_Notification &>(from));
}


void CGameNotifications_OnUserStatusChanged_Notification::MergeFrom(const CGameNotifications_OnUserStatusChanged_Notification& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGameNotifications_OnUserStatusChanged_Notification)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_status()->::CGameNotifications_UserStatus::MergeFrom(from._internal_status());
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      sessionid_ = from.sessionid_;
    }
    if (cached_has_bits & 0x00000008u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000010u) {
      removed_ = from.removed_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGameNotifications_OnUserStatusChanged_Notification::CopyFrom(const CGameNotifications_OnUserStatusChanged_Notification& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGameNotifications_OnUserStatusChanged_Notification)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGameNotifications_OnUserStatusChanged_Notification::IsInitialized() const {
  return true;
}

void CGameNotifications_OnUserStatusChanged_Notification::InternalSwap(CGameNotifications_OnUserStatusChanged_Notification* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CGameNotifications_OnUserStatusChanged_Notification, removed_)
      + sizeof(CGameNotifications_OnUserStatusChanged_Notification::removed_)
      - PROTOBUF_FIELD_OFFSET(CGameNotifications_OnUserStatusChanged_Notification, status_)>(
          reinterpret_cast<char*>(&status_),
          reinterpret_cast<char*>(&other->status_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CGameNotifications_OnUserStatusChanged_Notification::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fgamenotifications_2esteamclient_2eproto[19]);
}

// ===================================================================

GameNotifications::~GameNotifications() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GameNotifications::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GameNotifications::GetDescriptor() {
  return descriptor();
}

void GameNotifications::UserCreateSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_CreateSession_Request*,
                         ::CGameNotifications_CreateSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserCreateSession() not implemented.");
  done->Run();
}

void GameNotifications::UserDeleteSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_DeleteSession_Request*,
                         ::CGameNotifications_DeleteSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserDeleteSession() not implemented.");
  done->Run();
}

void GameNotifications::UserUpdateSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_UpdateSession_Request*,
                         ::CGameNotifications_UpdateSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UserUpdateSession() not implemented.");
  done->Run();
}

void GameNotifications::EnumerateSessions(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_EnumerateSessions_Request*,
                         ::CGameNotifications_EnumerateSessions_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method EnumerateSessions() not implemented.");
  done->Run();
}

void GameNotifications::GetSessionDetails(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_GetSessionDetails_Request*,
                         ::CGameNotifications_GetSessionDetails_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetSessionDetails() not implemented.");
  done->Run();
}

void GameNotifications::UpdateNotificationSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_UpdateNotificationSettings_Request*,
                         ::CGameNotifications_UpdateNotificationSettings_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UpdateNotificationSettings() not implemented.");
  done->Run();
}

void GameNotifications::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      UserCreateSession(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_CreateSession_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_CreateSession_Response*>(
                 response),
             done);
      break;
    case 1:
      UserDeleteSession(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_DeleteSession_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_DeleteSession_Response*>(
                 response),
             done);
      break;
    case 2:
      UserUpdateSession(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_UpdateSession_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_UpdateSession_Response*>(
                 response),
             done);
      break;
    case 3:
      EnumerateSessions(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_EnumerateSessions_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_EnumerateSessions_Response*>(
                 response),
             done);
      break;
    case 4:
      GetSessionDetails(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_GetSessionDetails_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_GetSessionDetails_Response*>(
                 response),
             done);
      break;
    case 5:
      UpdateNotificationSettings(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_UpdateNotificationSettings_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CGameNotifications_UpdateNotificationSettings_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& GameNotifications::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CGameNotifications_CreateSession_Request::default_instance();
    case 1:
      return ::CGameNotifications_DeleteSession_Request::default_instance();
    case 2:
      return ::CGameNotifications_UpdateSession_Request::default_instance();
    case 3:
      return ::CGameNotifications_EnumerateSessions_Request::default_instance();
    case 4:
      return ::CGameNotifications_GetSessionDetails_Request::default_instance();
    case 5:
      return ::CGameNotifications_UpdateNotificationSettings_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& GameNotifications::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CGameNotifications_CreateSession_Response::default_instance();
    case 1:
      return ::CGameNotifications_DeleteSession_Response::default_instance();
    case 2:
      return ::CGameNotifications_UpdateSession_Response::default_instance();
    case 3:
      return ::CGameNotifications_EnumerateSessions_Response::default_instance();
    case 4:
      return ::CGameNotifications_GetSessionDetails_Response::default_instance();
    case 5:
      return ::CGameNotifications_UpdateNotificationSettings_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

GameNotifications_Stub::GameNotifications_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
GameNotifications_Stub::GameNotifications_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
GameNotifications_Stub::~GameNotifications_Stub() {
  if (owns_channel_) delete channel_;
}

void GameNotifications_Stub::UserCreateSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_CreateSession_Request* request,
                              ::CGameNotifications_CreateSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void GameNotifications_Stub::UserDeleteSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_DeleteSession_Request* request,
                              ::CGameNotifications_DeleteSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void GameNotifications_Stub::UserUpdateSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_UpdateSession_Request* request,
                              ::CGameNotifications_UpdateSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void GameNotifications_Stub::EnumerateSessions(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_EnumerateSessions_Request* request,
                              ::CGameNotifications_EnumerateSessions_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void GameNotifications_Stub::GetSessionDetails(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_GetSessionDetails_Request* request,
                              ::CGameNotifications_GetSessionDetails_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void GameNotifications_Stub::UpdateNotificationSettings(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_UpdateNotificationSettings_Request* request,
                              ::CGameNotifications_UpdateNotificationSettings_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
// ===================================================================

GameNotificationsClient::~GameNotificationsClient() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GameNotificationsClient::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fgamenotifications_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[1];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GameNotificationsClient::GetDescriptor() {
  return descriptor();
}

void GameNotificationsClient::OnNotificationsRequested(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_OnNotificationsRequested_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method OnNotificationsRequested() not implemented.");
  done->Run();
}

void GameNotificationsClient::OnUserStatusChanged(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CGameNotifications_OnUserStatusChanged_Notification*,
                         ::NoResponse*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method OnUserStatusChanged() not implemented.");
  done->Run();
}

void GameNotificationsClient::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fgamenotifications_2esteamclient_2eproto[1]);
  switch(method->index()) {
    case 0:
      OnNotificationsRequested(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_OnNotificationsRequested_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    case 1:
      OnUserStatusChanged(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CGameNotifications_OnUserStatusChanged_Notification*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::NoResponse*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& GameNotificationsClient::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CGameNotifications_OnNotificationsRequested_Notification::default_instance();
    case 1:
      return ::CGameNotifications_OnUserStatusChanged_Notification::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& GameNotificationsClient::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::NoResponse::default_instance();
    case 1:
      return ::NoResponse::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

GameNotificationsClient_Stub::GameNotificationsClient_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
GameNotificationsClient_Stub::GameNotificationsClient_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
GameNotificationsClient_Stub::~GameNotificationsClient_Stub() {
  if (owns_channel_) delete channel_;
}

void GameNotificationsClient_Stub::OnNotificationsRequested(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_OnNotificationsRequested_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void GameNotificationsClient_Stub::OnUserStatusChanged(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CGameNotifications_OnUserStatusChanged_Notification* request,
                              ::NoResponse* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CGameNotifications_Variable* Arena::CreateMaybeMessage< ::CGameNotifications_Variable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_Variable >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_LocalizedText* Arena::CreateMaybeMessage< ::CGameNotifications_LocalizedText >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_LocalizedText >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_UserStatus* Arena::CreateMaybeMessage< ::CGameNotifications_UserStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_UserStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_CreateSession_Request* Arena::CreateMaybeMessage< ::CGameNotifications_CreateSession_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_CreateSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_CreateSession_Response* Arena::CreateMaybeMessage< ::CGameNotifications_CreateSession_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_CreateSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_DeleteSession_Request* Arena::CreateMaybeMessage< ::CGameNotifications_DeleteSession_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_DeleteSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_DeleteSession_Response* Arena::CreateMaybeMessage< ::CGameNotifications_DeleteSession_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_DeleteSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_UpdateSession_Request* Arena::CreateMaybeMessage< ::CGameNotifications_UpdateSession_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_UpdateSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_UpdateSession_Response* Arena::CreateMaybeMessage< ::CGameNotifications_UpdateSession_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_UpdateSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_EnumerateSessions_Request* Arena::CreateMaybeMessage< ::CGameNotifications_EnumerateSessions_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_EnumerateSessions_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_Session* Arena::CreateMaybeMessage< ::CGameNotifications_Session >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_Session >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_EnumerateSessions_Response* Arena::CreateMaybeMessage< ::CGameNotifications_EnumerateSessions_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_EnumerateSessions_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_GetSessionDetails_Request_RequestedSession* Arena::CreateMaybeMessage< ::CGameNotifications_GetSessionDetails_Request_RequestedSession >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_GetSessionDetails_Request_RequestedSession >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_GetSessionDetails_Request* Arena::CreateMaybeMessage< ::CGameNotifications_GetSessionDetails_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_GetSessionDetails_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_GetSessionDetails_Response* Arena::CreateMaybeMessage< ::CGameNotifications_GetSessionDetails_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_GetSessionDetails_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::GameNotificationSettings* Arena::CreateMaybeMessage< ::GameNotificationSettings >(Arena* arena) {
  return Arena::CreateMessageInternal< ::GameNotificationSettings >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_UpdateNotificationSettings_Request* Arena::CreateMaybeMessage< ::CGameNotifications_UpdateNotificationSettings_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_UpdateNotificationSettings_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_UpdateNotificationSettings_Response* Arena::CreateMaybeMessage< ::CGameNotifications_UpdateNotificationSettings_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_UpdateNotificationSettings_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_OnNotificationsRequested_Notification* Arena::CreateMaybeMessage< ::CGameNotifications_OnNotificationsRequested_Notification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_OnNotificationsRequested_Notification >(arena);
}
template<> PROTOBUF_NOINLINE ::CGameNotifications_OnUserStatusChanged_Notification* Arena::CreateMaybeMessage< ::CGameNotifications_OnUserStatusChanged_Notification >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGameNotifications_OnUserStatusChanged_Notification >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
