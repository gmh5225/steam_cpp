// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_clientserver_gameservers.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5fgameservers_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5fgameservers_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "steammessages_base.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fclientserver_5fgameservers_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fclientserver_5fgameservers_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[17]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fclientserver_5fgameservers_2eproto;
class CMsgClientGMSServerQuery;
struct CMsgClientGMSServerQueryDefaultTypeInternal;
extern CMsgClientGMSServerQueryDefaultTypeInternal _CMsgClientGMSServerQuery_default_instance_;
class CMsgGMSClientServerQueryResponse;
struct CMsgGMSClientServerQueryResponseDefaultTypeInternal;
extern CMsgGMSClientServerQueryResponseDefaultTypeInternal _CMsgGMSClientServerQueryResponse_default_instance_;
class CMsgGMSClientServerQueryResponse_Server;
struct CMsgGMSClientServerQueryResponse_ServerDefaultTypeInternal;
extern CMsgGMSClientServerQueryResponse_ServerDefaultTypeInternal _CMsgGMSClientServerQueryResponse_Server_default_instance_;
class CMsgGSAssociateWithClan;
struct CMsgGSAssociateWithClanDefaultTypeInternal;
extern CMsgGSAssociateWithClanDefaultTypeInternal _CMsgGSAssociateWithClan_default_instance_;
class CMsgGSAssociateWithClanResponse;
struct CMsgGSAssociateWithClanResponseDefaultTypeInternal;
extern CMsgGSAssociateWithClanResponseDefaultTypeInternal _CMsgGSAssociateWithClanResponse_default_instance_;
class CMsgGSComputeNewPlayerCompatibility;
struct CMsgGSComputeNewPlayerCompatibilityDefaultTypeInternal;
extern CMsgGSComputeNewPlayerCompatibilityDefaultTypeInternal _CMsgGSComputeNewPlayerCompatibility_default_instance_;
class CMsgGSComputeNewPlayerCompatibilityResponse;
struct CMsgGSComputeNewPlayerCompatibilityResponseDefaultTypeInternal;
extern CMsgGSComputeNewPlayerCompatibilityResponseDefaultTypeInternal _CMsgGSComputeNewPlayerCompatibilityResponse_default_instance_;
class CMsgGSDisconnectNotice;
struct CMsgGSDisconnectNoticeDefaultTypeInternal;
extern CMsgGSDisconnectNoticeDefaultTypeInternal _CMsgGSDisconnectNotice_default_instance_;
class CMsgGSPlayerList;
struct CMsgGSPlayerListDefaultTypeInternal;
extern CMsgGSPlayerListDefaultTypeInternal _CMsgGSPlayerList_default_instance_;
class CMsgGSPlayerList_Player;
struct CMsgGSPlayerList_PlayerDefaultTypeInternal;
extern CMsgGSPlayerList_PlayerDefaultTypeInternal _CMsgGSPlayerList_Player_default_instance_;
class CMsgGSServerType;
struct CMsgGSServerTypeDefaultTypeInternal;
extern CMsgGSServerTypeDefaultTypeInternal _CMsgGSServerType_default_instance_;
class CMsgGSStatusReply;
struct CMsgGSStatusReplyDefaultTypeInternal;
extern CMsgGSStatusReplyDefaultTypeInternal _CMsgGSStatusReply_default_instance_;
class CMsgGSUserPlaying;
struct CMsgGSUserPlayingDefaultTypeInternal;
extern CMsgGSUserPlayingDefaultTypeInternal _CMsgGSUserPlaying_default_instance_;
class CMsgGameServerData;
struct CMsgGameServerDataDefaultTypeInternal;
extern CMsgGameServerDataDefaultTypeInternal _CMsgGameServerData_default_instance_;
class CMsgGameServerData_Player;
struct CMsgGameServerData_PlayerDefaultTypeInternal;
extern CMsgGameServerData_PlayerDefaultTypeInternal _CMsgGameServerData_Player_default_instance_;
class CMsgGameServerOutOfDate;
struct CMsgGameServerOutOfDateDefaultTypeInternal;
extern CMsgGameServerOutOfDateDefaultTypeInternal _CMsgGameServerOutOfDate_default_instance_;
class CMsgGameServerRemove;
struct CMsgGameServerRemoveDefaultTypeInternal;
extern CMsgGameServerRemoveDefaultTypeInternal _CMsgGameServerRemove_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgClientGMSServerQuery* Arena::CreateMaybeMessage<::CMsgClientGMSServerQuery>(Arena*);
template<> ::CMsgGMSClientServerQueryResponse* Arena::CreateMaybeMessage<::CMsgGMSClientServerQueryResponse>(Arena*);
template<> ::CMsgGMSClientServerQueryResponse_Server* Arena::CreateMaybeMessage<::CMsgGMSClientServerQueryResponse_Server>(Arena*);
template<> ::CMsgGSAssociateWithClan* Arena::CreateMaybeMessage<::CMsgGSAssociateWithClan>(Arena*);
template<> ::CMsgGSAssociateWithClanResponse* Arena::CreateMaybeMessage<::CMsgGSAssociateWithClanResponse>(Arena*);
template<> ::CMsgGSComputeNewPlayerCompatibility* Arena::CreateMaybeMessage<::CMsgGSComputeNewPlayerCompatibility>(Arena*);
template<> ::CMsgGSComputeNewPlayerCompatibilityResponse* Arena::CreateMaybeMessage<::CMsgGSComputeNewPlayerCompatibilityResponse>(Arena*);
template<> ::CMsgGSDisconnectNotice* Arena::CreateMaybeMessage<::CMsgGSDisconnectNotice>(Arena*);
template<> ::CMsgGSPlayerList* Arena::CreateMaybeMessage<::CMsgGSPlayerList>(Arena*);
template<> ::CMsgGSPlayerList_Player* Arena::CreateMaybeMessage<::CMsgGSPlayerList_Player>(Arena*);
template<> ::CMsgGSServerType* Arena::CreateMaybeMessage<::CMsgGSServerType>(Arena*);
template<> ::CMsgGSStatusReply* Arena::CreateMaybeMessage<::CMsgGSStatusReply>(Arena*);
template<> ::CMsgGSUserPlaying* Arena::CreateMaybeMessage<::CMsgGSUserPlaying>(Arena*);
template<> ::CMsgGameServerData* Arena::CreateMaybeMessage<::CMsgGameServerData>(Arena*);
template<> ::CMsgGameServerData_Player* Arena::CreateMaybeMessage<::CMsgGameServerData_Player>(Arena*);
template<> ::CMsgGameServerOutOfDate* Arena::CreateMaybeMessage<::CMsgGameServerOutOfDate>(Arena*);
template<> ::CMsgGameServerRemove* Arena::CreateMaybeMessage<::CMsgGameServerRemove>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgGMSClientServerQueryResponse_EFlags : int {
  CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_HasPassword = 1,
  CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_Secure = 2
};
bool CMsgGMSClientServerQueryResponse_EFlags_IsValid(int value);
constexpr CMsgGMSClientServerQueryResponse_EFlags CMsgGMSClientServerQueryResponse_EFlags_EFlags_MIN = CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_HasPassword;
constexpr CMsgGMSClientServerQueryResponse_EFlags CMsgGMSClientServerQueryResponse_EFlags_EFlags_MAX = CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_Secure;
constexpr int CMsgGMSClientServerQueryResponse_EFlags_EFlags_ARRAYSIZE = CMsgGMSClientServerQueryResponse_EFlags_EFlags_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgGMSClientServerQueryResponse_EFlags_descriptor();
template<typename T>
inline const std::string& CMsgGMSClientServerQueryResponse_EFlags_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgGMSClientServerQueryResponse_EFlags>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgGMSClientServerQueryResponse_EFlags_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgGMSClientServerQueryResponse_EFlags_descriptor(), enum_t_value);
}
inline bool CMsgGMSClientServerQueryResponse_EFlags_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgGMSClientServerQueryResponse_EFlags* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgGMSClientServerQueryResponse_EFlags>(
    CMsgGMSClientServerQueryResponse_EFlags_descriptor(), name, value);
}
// ===================================================================

class CMsgGSServerType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSServerType) */ {
 public:
  inline CMsgGSServerType() : CMsgGSServerType(nullptr) {}
  ~CMsgGSServerType() override;
  explicit constexpr CMsgGSServerType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSServerType(const CMsgGSServerType& from);
  CMsgGSServerType(CMsgGSServerType&& from) noexcept
    : CMsgGSServerType() {
    *this = ::std::move(from);
  }

  inline CMsgGSServerType& operator=(const CMsgGSServerType& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSServerType& operator=(CMsgGSServerType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSServerType& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSServerType* internal_default_instance() {
    return reinterpret_cast<const CMsgGSServerType*>(
               &_CMsgGSServerType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgGSServerType& a, CMsgGSServerType& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSServerType* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSServerType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSServerType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSServerType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSServerType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSServerType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSServerType* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSServerType";
  }
  protected:
  explicit CMsgGSServerType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameDirFieldNumber = 5,
    kGameVersionFieldNumber = 6,
    kSdrLogonFieldNumber = 8,
    kAppIdServedFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kDeprecatedGameIpAddressFieldNumber = 3,
    kGamePortFieldNumber = 4,
    kGameQueryPortFieldNumber = 7,
    kFakeIpFieldNumber = 9,
    kGamePortLocalFieldNumber = 10,
  };
  // optional string game_dir = 5;
  bool has_game_dir() const;
  private:
  bool _internal_has_game_dir() const;
  public:
  void clear_game_dir();
  const std::string& game_dir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_dir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_dir();
  PROTOBUF_NODISCARD std::string* release_game_dir();
  void set_allocated_game_dir(std::string* game_dir);
  private:
  const std::string& _internal_game_dir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_dir(const std::string& value);
  std::string* _internal_mutable_game_dir();
  public:

  // optional string game_version = 6;
  bool has_game_version() const;
  private:
  bool _internal_has_game_version() const;
  public:
  void clear_game_version();
  const std::string& game_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_version();
  PROTOBUF_NODISCARD std::string* release_game_version();
  void set_allocated_game_version(std::string* game_version);
  private:
  const std::string& _internal_game_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_version(const std::string& value);
  std::string* _internal_mutable_game_version();
  public:

  // optional bytes sdr_logon = 8;
  bool has_sdr_logon() const;
  private:
  bool _internal_has_sdr_logon() const;
  public:
  void clear_sdr_logon();
  const std::string& sdr_logon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdr_logon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdr_logon();
  PROTOBUF_NODISCARD std::string* release_sdr_logon();
  void set_allocated_sdr_logon(std::string* sdr_logon);
  private:
  const std::string& _internal_sdr_logon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdr_logon(const std::string& value);
  std::string* _internal_mutable_sdr_logon();
  public:

  // optional uint32 app_id_served = 1;
  bool has_app_id_served() const;
  private:
  bool _internal_has_app_id_served() const;
  public:
  void clear_app_id_served();
  uint32_t app_id_served() const;
  void set_app_id_served(uint32_t value);
  private:
  uint32_t _internal_app_id_served() const;
  void _internal_set_app_id_served(uint32_t value);
  public:

  // optional uint32 flags = 2;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 deprecated_game_ip_address = 3;
  bool has_deprecated_game_ip_address() const;
  private:
  bool _internal_has_deprecated_game_ip_address() const;
  public:
  void clear_deprecated_game_ip_address();
  uint32_t deprecated_game_ip_address() const;
  void set_deprecated_game_ip_address(uint32_t value);
  private:
  uint32_t _internal_deprecated_game_ip_address() const;
  void _internal_set_deprecated_game_ip_address(uint32_t value);
  public:

  // optional uint32 game_port = 4;
  bool has_game_port() const;
  private:
  bool _internal_has_game_port() const;
  public:
  void clear_game_port();
  uint32_t game_port() const;
  void set_game_port(uint32_t value);
  private:
  uint32_t _internal_game_port() const;
  void _internal_set_game_port(uint32_t value);
  public:

  // optional uint32 game_query_port = 7;
  bool has_game_query_port() const;
  private:
  bool _internal_has_game_query_port() const;
  public:
  void clear_game_query_port();
  uint32_t game_query_port() const;
  void set_game_query_port(uint32_t value);
  private:
  uint32_t _internal_game_query_port() const;
  void _internal_set_game_query_port(uint32_t value);
  public:

  // optional fixed32 fake_ip = 9;
  bool has_fake_ip() const;
  private:
  bool _internal_has_fake_ip() const;
  public:
  void clear_fake_ip();
  uint32_t fake_ip() const;
  void set_fake_ip(uint32_t value);
  private:
  uint32_t _internal_fake_ip() const;
  void _internal_set_fake_ip(uint32_t value);
  public:

  // optional uint32 game_port_local = 10;
  bool has_game_port_local() const;
  private:
  bool _internal_has_game_port_local() const;
  public:
  void clear_game_port_local();
  uint32_t game_port_local() const;
  void set_game_port_local(uint32_t value);
  private:
  uint32_t _internal_game_port_local() const;
  void _internal_set_game_port_local(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSServerType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_dir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdr_logon_;
  uint32_t app_id_served_;
  uint32_t flags_;
  uint32_t deprecated_game_ip_address_;
  uint32_t game_port_;
  uint32_t game_query_port_;
  uint32_t fake_ip_;
  uint32_t game_port_local_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSStatusReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSStatusReply) */ {
 public:
  inline CMsgGSStatusReply() : CMsgGSStatusReply(nullptr) {}
  ~CMsgGSStatusReply() override;
  explicit constexpr CMsgGSStatusReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSStatusReply(const CMsgGSStatusReply& from);
  CMsgGSStatusReply(CMsgGSStatusReply&& from) noexcept
    : CMsgGSStatusReply() {
    *this = ::std::move(from);
  }

  inline CMsgGSStatusReply& operator=(const CMsgGSStatusReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSStatusReply& operator=(CMsgGSStatusReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSStatusReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSStatusReply* internal_default_instance() {
    return reinterpret_cast<const CMsgGSStatusReply*>(
               &_CMsgGSStatusReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgGSStatusReply& a, CMsgGSStatusReply& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSStatusReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSStatusReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSStatusReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSStatusReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSStatusReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSStatusReply& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSStatusReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSStatusReply";
  }
  protected:
  explicit CMsgGSStatusReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSecureFieldNumber = 1,
  };
  // optional bool is_secure = 1;
  bool has_is_secure() const;
  private:
  bool _internal_has_is_secure() const;
  public:
  void clear_is_secure();
  bool is_secure() const;
  void set_is_secure(bool value);
  private:
  bool _internal_is_secure() const;
  void _internal_set_is_secure(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSStatusReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool is_secure_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSPlayerList_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSPlayerList.Player) */ {
 public:
  inline CMsgGSPlayerList_Player() : CMsgGSPlayerList_Player(nullptr) {}
  ~CMsgGSPlayerList_Player() override;
  explicit constexpr CMsgGSPlayerList_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSPlayerList_Player(const CMsgGSPlayerList_Player& from);
  CMsgGSPlayerList_Player(CMsgGSPlayerList_Player&& from) noexcept
    : CMsgGSPlayerList_Player() {
    *this = ::std::move(from);
  }

  inline CMsgGSPlayerList_Player& operator=(const CMsgGSPlayerList_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSPlayerList_Player& operator=(CMsgGSPlayerList_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSPlayerList_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSPlayerList_Player* internal_default_instance() {
    return reinterpret_cast<const CMsgGSPlayerList_Player*>(
               &_CMsgGSPlayerList_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgGSPlayerList_Player& a, CMsgGSPlayerList_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSPlayerList_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSPlayerList_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSPlayerList_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSPlayerList_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSPlayerList_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSPlayerList_Player& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSPlayerList_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSPlayerList.Player";
  }
  protected:
  explicit CMsgGSPlayerList_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kPublicIpFieldNumber = 4,
    kSteamIdFieldNumber = 1,
    kDeprecatedPublicIpFieldNumber = 2,
  };
  // optional bytes token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional .CMsgIPAddress public_ip = 4;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::CMsgIPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_public_ip();
  ::CMsgIPAddress* mutable_public_ip();
  void set_allocated_public_ip(::CMsgIPAddress* public_ip);
  private:
  const ::CMsgIPAddress& _internal_public_ip() const;
  ::CMsgIPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::CMsgIPAddress* public_ip);
  ::CMsgIPAddress* unsafe_arena_release_public_ip();

  // optional uint64 steam_id = 1;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // optional uint32 deprecated_public_ip = 2;
  bool has_deprecated_public_ip() const;
  private:
  bool _internal_has_deprecated_public_ip() const;
  public:
  void clear_deprecated_public_ip();
  uint32_t deprecated_public_ip() const;
  void set_deprecated_public_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_public_ip() const;
  void _internal_set_deprecated_public_ip(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSPlayerList.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::CMsgIPAddress* public_ip_;
  uint64_t steam_id_;
  uint32_t deprecated_public_ip_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSPlayerList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSPlayerList) */ {
 public:
  inline CMsgGSPlayerList() : CMsgGSPlayerList(nullptr) {}
  ~CMsgGSPlayerList() override;
  explicit constexpr CMsgGSPlayerList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSPlayerList(const CMsgGSPlayerList& from);
  CMsgGSPlayerList(CMsgGSPlayerList&& from) noexcept
    : CMsgGSPlayerList() {
    *this = ::std::move(from);
  }

  inline CMsgGSPlayerList& operator=(const CMsgGSPlayerList& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSPlayerList& operator=(CMsgGSPlayerList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSPlayerList& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSPlayerList* internal_default_instance() {
    return reinterpret_cast<const CMsgGSPlayerList*>(
               &_CMsgGSPlayerList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgGSPlayerList& a, CMsgGSPlayerList& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSPlayerList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSPlayerList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSPlayerList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSPlayerList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSPlayerList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSPlayerList& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSPlayerList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSPlayerList";
  }
  protected:
  explicit CMsgGSPlayerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgGSPlayerList_Player Player;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
  };
  // repeated .CMsgGSPlayerList.Player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::CMsgGSPlayerList_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGSPlayerList_Player >*
      mutable_players();
  private:
  const ::CMsgGSPlayerList_Player& _internal_players(int index) const;
  ::CMsgGSPlayerList_Player* _internal_add_players();
  public:
  const ::CMsgGSPlayerList_Player& players(int index) const;
  ::CMsgGSPlayerList_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGSPlayerList_Player >&
      players() const;

  // @@protoc_insertion_point(class_scope:CMsgGSPlayerList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGSPlayerList_Player > players_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSUserPlaying final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSUserPlaying) */ {
 public:
  inline CMsgGSUserPlaying() : CMsgGSUserPlaying(nullptr) {}
  ~CMsgGSUserPlaying() override;
  explicit constexpr CMsgGSUserPlaying(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSUserPlaying(const CMsgGSUserPlaying& from);
  CMsgGSUserPlaying(CMsgGSUserPlaying&& from) noexcept
    : CMsgGSUserPlaying() {
    *this = ::std::move(from);
  }

  inline CMsgGSUserPlaying& operator=(const CMsgGSUserPlaying& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSUserPlaying& operator=(CMsgGSUserPlaying&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSUserPlaying& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSUserPlaying* internal_default_instance() {
    return reinterpret_cast<const CMsgGSUserPlaying*>(
               &_CMsgGSUserPlaying_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgGSUserPlaying& a, CMsgGSUserPlaying& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSUserPlaying* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSUserPlaying* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSUserPlaying* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSUserPlaying>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSUserPlaying& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSUserPlaying& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSUserPlaying* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSUserPlaying";
  }
  protected:
  explicit CMsgGSUserPlaying(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 3,
    kPublicIpFieldNumber = 4,
    kSteamIdFieldNumber = 1,
    kDeprecatedPublicIpFieldNumber = 2,
  };
  // optional bytes token = 3;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional .CMsgIPAddress public_ip = 4;
  bool has_public_ip() const;
  private:
  bool _internal_has_public_ip() const;
  public:
  void clear_public_ip();
  const ::CMsgIPAddress& public_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_public_ip();
  ::CMsgIPAddress* mutable_public_ip();
  void set_allocated_public_ip(::CMsgIPAddress* public_ip);
  private:
  const ::CMsgIPAddress& _internal_public_ip() const;
  ::CMsgIPAddress* _internal_mutable_public_ip();
  public:
  void unsafe_arena_set_allocated_public_ip(
      ::CMsgIPAddress* public_ip);
  ::CMsgIPAddress* unsafe_arena_release_public_ip();

  // optional fixed64 steam_id = 1;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // optional uint32 deprecated_public_ip = 2;
  bool has_deprecated_public_ip() const;
  private:
  bool _internal_has_deprecated_public_ip() const;
  public:
  void clear_deprecated_public_ip();
  uint32_t deprecated_public_ip() const;
  void set_deprecated_public_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_public_ip() const;
  void _internal_set_deprecated_public_ip(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSUserPlaying)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::CMsgIPAddress* public_ip_;
  uint64_t steam_id_;
  uint32_t deprecated_public_ip_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSDisconnectNotice final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSDisconnectNotice) */ {
 public:
  inline CMsgGSDisconnectNotice() : CMsgGSDisconnectNotice(nullptr) {}
  ~CMsgGSDisconnectNotice() override;
  explicit constexpr CMsgGSDisconnectNotice(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSDisconnectNotice(const CMsgGSDisconnectNotice& from);
  CMsgGSDisconnectNotice(CMsgGSDisconnectNotice&& from) noexcept
    : CMsgGSDisconnectNotice() {
    *this = ::std::move(from);
  }

  inline CMsgGSDisconnectNotice& operator=(const CMsgGSDisconnectNotice& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSDisconnectNotice& operator=(CMsgGSDisconnectNotice&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSDisconnectNotice& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSDisconnectNotice* internal_default_instance() {
    return reinterpret_cast<const CMsgGSDisconnectNotice*>(
               &_CMsgGSDisconnectNotice_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgGSDisconnectNotice& a, CMsgGSDisconnectNotice& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSDisconnectNotice* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSDisconnectNotice* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSDisconnectNotice* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSDisconnectNotice>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSDisconnectNotice& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSDisconnectNotice& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSDisconnectNotice* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSDisconnectNotice";
  }
  protected:
  explicit CMsgGSDisconnectNotice(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdFieldNumber = 1,
  };
  // optional fixed64 steam_id = 1;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSDisconnectNotice)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGameServerData_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGameServerData.Player) */ {
 public:
  inline CMsgGameServerData_Player() : CMsgGameServerData_Player(nullptr) {}
  ~CMsgGameServerData_Player() override;
  explicit constexpr CMsgGameServerData_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGameServerData_Player(const CMsgGameServerData_Player& from);
  CMsgGameServerData_Player(CMsgGameServerData_Player&& from) noexcept
    : CMsgGameServerData_Player() {
    *this = ::std::move(from);
  }

  inline CMsgGameServerData_Player& operator=(const CMsgGameServerData_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGameServerData_Player& operator=(CMsgGameServerData_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGameServerData_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGameServerData_Player* internal_default_instance() {
    return reinterpret_cast<const CMsgGameServerData_Player*>(
               &_CMsgGameServerData_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgGameServerData_Player& a, CMsgGameServerData_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGameServerData_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGameServerData_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGameServerData_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGameServerData_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGameServerData_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGameServerData_Player& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGameServerData_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGameServerData.Player";
  }
  protected:
  explicit CMsgGameServerData_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdFieldNumber = 1,
  };
  // optional fixed64 steam_id = 1;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGameServerData.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGameServerData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGameServerData) */ {
 public:
  inline CMsgGameServerData() : CMsgGameServerData(nullptr) {}
  ~CMsgGameServerData() override;
  explicit constexpr CMsgGameServerData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGameServerData(const CMsgGameServerData& from);
  CMsgGameServerData(CMsgGameServerData&& from) noexcept
    : CMsgGameServerData() {
    *this = ::std::move(from);
  }

  inline CMsgGameServerData& operator=(const CMsgGameServerData& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGameServerData& operator=(CMsgGameServerData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGameServerData& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGameServerData* internal_default_instance() {
    return reinterpret_cast<const CMsgGameServerData*>(
               &_CMsgGameServerData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgGameServerData& a, CMsgGameServerData& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGameServerData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGameServerData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGameServerData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGameServerData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGameServerData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGameServerData& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGameServerData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGameServerData";
  }
  protected:
  explicit CMsgGameServerData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgGameServerData_Player Player;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 11,
    kGamedirFieldNumber = 7,
    kVersionFieldNumber = 8,
    kProductFieldNumber = 9,
    kRegionFieldNumber = 10,
    kOsFieldNumber = 17,
    kGameDataFieldNumber = 18,
    kGameTypeFieldNumber = 20,
    kMapFieldNumber = 21,
    kServerNameFieldNumber = 22,
    kSpectatorServerNameFieldNumber = 27,
    kGameDescriptionFieldNumber = 29,
    kSdrPingLocationFieldNumber = 30,
    kQueryPortFieldNumber = 3,
    kGamePortFieldNumber = 4,
    kSpectatorPortFieldNumber = 5,
    kAppIdFieldNumber = 6,
    kMaxPlayersFieldNumber = 12,
    kBotCountFieldNumber = 13,
    kPasswordFieldNumber = 14,
    kSecureFieldNumber = 15,
    kDedicatedFieldNumber = 16,
    kRevisionFieldNumber = 24,
    kFakeIpFieldNumber = 28,
  };
  // repeated .CMsgGameServerData.Player players = 11;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::CMsgGameServerData_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGameServerData_Player >*
      mutable_players();
  private:
  const ::CMsgGameServerData_Player& _internal_players(int index) const;
  ::CMsgGameServerData_Player* _internal_add_players();
  public:
  const ::CMsgGameServerData_Player& players(int index) const;
  ::CMsgGameServerData_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGameServerData_Player >&
      players() const;

  // optional string gamedir = 7;
  bool has_gamedir() const;
  private:
  bool _internal_has_gamedir() const;
  public:
  void clear_gamedir();
  const std::string& gamedir() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamedir(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamedir();
  PROTOBUF_NODISCARD std::string* release_gamedir();
  void set_allocated_gamedir(std::string* gamedir);
  private:
  const std::string& _internal_gamedir() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamedir(const std::string& value);
  std::string* _internal_mutable_gamedir();
  public:

  // optional string version = 8;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  const std::string& version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version();
  PROTOBUF_NODISCARD std::string* release_version();
  void set_allocated_version(std::string* version);
  private:
  const std::string& _internal_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version(const std::string& value);
  std::string* _internal_mutable_version();
  public:

  // optional string product = 9;
  bool has_product() const;
  private:
  bool _internal_has_product() const;
  public:
  void clear_product();
  const std::string& product() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_product(ArgT0&& arg0, ArgT... args);
  std::string* mutable_product();
  PROTOBUF_NODISCARD std::string* release_product();
  void set_allocated_product(std::string* product);
  private:
  const std::string& _internal_product() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_product(const std::string& value);
  std::string* _internal_mutable_product();
  public:

  // optional string region = 10;
  bool has_region() const;
  private:
  bool _internal_has_region() const;
  public:
  void clear_region();
  const std::string& region() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_region(ArgT0&& arg0, ArgT... args);
  std::string* mutable_region();
  PROTOBUF_NODISCARD std::string* release_region();
  void set_allocated_region(std::string* region);
  private:
  const std::string& _internal_region() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_region(const std::string& value);
  std::string* _internal_mutable_region();
  public:

  // optional string os = 17;
  bool has_os() const;
  private:
  bool _internal_has_os() const;
  public:
  void clear_os();
  const std::string& os() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_os(ArgT0&& arg0, ArgT... args);
  std::string* mutable_os();
  PROTOBUF_NODISCARD std::string* release_os();
  void set_allocated_os(std::string* os);
  private:
  const std::string& _internal_os() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_os(const std::string& value);
  std::string* _internal_mutable_os();
  public:

  // optional string game_data = 18;
  bool has_game_data() const;
  private:
  bool _internal_has_game_data() const;
  public:
  void clear_game_data();
  const std::string& game_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_data();
  PROTOBUF_NODISCARD std::string* release_game_data();
  void set_allocated_game_data(std::string* game_data);
  private:
  const std::string& _internal_game_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_data(const std::string& value);
  std::string* _internal_mutable_game_data();
  public:

  // optional string game_type = 20;
  bool has_game_type() const;
  private:
  bool _internal_has_game_type() const;
  public:
  void clear_game_type();
  const std::string& game_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_type();
  PROTOBUF_NODISCARD std::string* release_game_type();
  void set_allocated_game_type(std::string* game_type);
  private:
  const std::string& _internal_game_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_type(const std::string& value);
  std::string* _internal_mutable_game_type();
  public:

  // optional string map = 21;
  bool has_map() const;
  private:
  bool _internal_has_map() const;
  public:
  void clear_map();
  const std::string& map() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map();
  PROTOBUF_NODISCARD std::string* release_map();
  void set_allocated_map(std::string* map);
  private:
  const std::string& _internal_map() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map(const std::string& value);
  std::string* _internal_mutable_map();
  public:

  // optional string server_name = 22;
  bool has_server_name() const;
  private:
  bool _internal_has_server_name() const;
  public:
  void clear_server_name();
  const std::string& server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_server_name();
  PROTOBUF_NODISCARD std::string* release_server_name();
  void set_allocated_server_name(std::string* server_name);
  private:
  const std::string& _internal_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_server_name(const std::string& value);
  std::string* _internal_mutable_server_name();
  public:

  // optional string spectator_server_name = 27;
  bool has_spectator_server_name() const;
  private:
  bool _internal_has_spectator_server_name() const;
  public:
  void clear_spectator_server_name();
  const std::string& spectator_server_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spectator_server_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spectator_server_name();
  PROTOBUF_NODISCARD std::string* release_spectator_server_name();
  void set_allocated_spectator_server_name(std::string* spectator_server_name);
  private:
  const std::string& _internal_spectator_server_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spectator_server_name(const std::string& value);
  std::string* _internal_mutable_spectator_server_name();
  public:

  // optional string game_description = 29;
  bool has_game_description() const;
  private:
  bool _internal_has_game_description() const;
  public:
  void clear_game_description();
  const std::string& game_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_description();
  PROTOBUF_NODISCARD std::string* release_game_description();
  void set_allocated_game_description(std::string* game_description);
  private:
  const std::string& _internal_game_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_description(const std::string& value);
  std::string* _internal_mutable_game_description();
  public:

  // optional string sdr_ping_location = 30;
  bool has_sdr_ping_location() const;
  private:
  bool _internal_has_sdr_ping_location() const;
  public:
  void clear_sdr_ping_location();
  const std::string& sdr_ping_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdr_ping_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdr_ping_location();
  PROTOBUF_NODISCARD std::string* release_sdr_ping_location();
  void set_allocated_sdr_ping_location(std::string* sdr_ping_location);
  private:
  const std::string& _internal_sdr_ping_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdr_ping_location(const std::string& value);
  std::string* _internal_mutable_sdr_ping_location();
  public:

  // optional uint32 query_port = 3;
  bool has_query_port() const;
  private:
  bool _internal_has_query_port() const;
  public:
  void clear_query_port();
  uint32_t query_port() const;
  void set_query_port(uint32_t value);
  private:
  uint32_t _internal_query_port() const;
  void _internal_set_query_port(uint32_t value);
  public:

  // optional uint32 game_port = 4;
  bool has_game_port() const;
  private:
  bool _internal_has_game_port() const;
  public:
  void clear_game_port();
  uint32_t game_port() const;
  void set_game_port(uint32_t value);
  private:
  uint32_t _internal_game_port() const;
  void _internal_set_game_port(uint32_t value);
  public:

  // optional uint32 spectator_port = 5;
  bool has_spectator_port() const;
  private:
  bool _internal_has_spectator_port() const;
  public:
  void clear_spectator_port();
  uint32_t spectator_port() const;
  void set_spectator_port(uint32_t value);
  private:
  uint32_t _internal_spectator_port() const;
  void _internal_set_spectator_port(uint32_t value);
  public:

  // optional uint32 app_id = 6;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 max_players = 12;
  bool has_max_players() const;
  private:
  bool _internal_has_max_players() const;
  public:
  void clear_max_players();
  uint32_t max_players() const;
  void set_max_players(uint32_t value);
  private:
  uint32_t _internal_max_players() const;
  void _internal_set_max_players(uint32_t value);
  public:

  // optional uint32 bot_count = 13;
  bool has_bot_count() const;
  private:
  bool _internal_has_bot_count() const;
  public:
  void clear_bot_count();
  uint32_t bot_count() const;
  void set_bot_count(uint32_t value);
  private:
  uint32_t _internal_bot_count() const;
  void _internal_set_bot_count(uint32_t value);
  public:

  // optional bool password = 14;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  bool password() const;
  void set_password(bool value);
  private:
  bool _internal_password() const;
  void _internal_set_password(bool value);
  public:

  // optional bool secure = 15;
  bool has_secure() const;
  private:
  bool _internal_has_secure() const;
  public:
  void clear_secure();
  bool secure() const;
  void set_secure(bool value);
  private:
  bool _internal_secure() const;
  void _internal_set_secure(bool value);
  public:

  // optional bool dedicated = 16;
  bool has_dedicated() const;
  private:
  bool _internal_has_dedicated() const;
  public:
  void clear_dedicated();
  bool dedicated() const;
  void set_dedicated(bool value);
  private:
  bool _internal_dedicated() const;
  void _internal_set_dedicated(bool value);
  public:

  // optional uint32 revision = 24;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  uint32_t revision() const;
  void set_revision(uint32_t value);
  private:
  uint32_t _internal_revision() const;
  void _internal_set_revision(uint32_t value);
  public:

  // optional fixed32 fake_ip = 28;
  bool has_fake_ip() const;
  private:
  bool _internal_has_fake_ip() const;
  public:
  void clear_fake_ip();
  uint32_t fake_ip() const;
  void set_fake_ip(uint32_t value);
  private:
  uint32_t _internal_fake_ip() const;
  void _internal_set_fake_ip(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGameServerData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGameServerData_Player > players_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamedir_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr product_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr region_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr os_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr server_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spectator_server_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_description_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdr_ping_location_;
  uint32_t query_port_;
  uint32_t game_port_;
  uint32_t spectator_port_;
  uint32_t app_id_;
  uint32_t max_players_;
  uint32_t bot_count_;
  bool password_;
  bool secure_;
  bool dedicated_;
  uint32_t revision_;
  uint32_t fake_ip_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGameServerRemove final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGameServerRemove) */ {
 public:
  inline CMsgGameServerRemove() : CMsgGameServerRemove(nullptr) {}
  ~CMsgGameServerRemove() override;
  explicit constexpr CMsgGameServerRemove(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGameServerRemove(const CMsgGameServerRemove& from);
  CMsgGameServerRemove(CMsgGameServerRemove&& from) noexcept
    : CMsgGameServerRemove() {
    *this = ::std::move(from);
  }

  inline CMsgGameServerRemove& operator=(const CMsgGameServerRemove& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGameServerRemove& operator=(CMsgGameServerRemove&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGameServerRemove& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGameServerRemove* internal_default_instance() {
    return reinterpret_cast<const CMsgGameServerRemove*>(
               &_CMsgGameServerRemove_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgGameServerRemove& a, CMsgGameServerRemove& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGameServerRemove* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGameServerRemove* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGameServerRemove* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGameServerRemove>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGameServerRemove& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGameServerRemove& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGameServerRemove* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGameServerRemove";
  }
  protected:
  explicit CMsgGameServerRemove(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLegacySteamIdGsFieldNumber = 1,
    kLegacyQueryPortFieldNumber = 3,
  };
  // optional fixed64 legacy_steam_id_gs = 1;
  bool has_legacy_steam_id_gs() const;
  private:
  bool _internal_has_legacy_steam_id_gs() const;
  public:
  void clear_legacy_steam_id_gs();
  uint64_t legacy_steam_id_gs() const;
  void set_legacy_steam_id_gs(uint64_t value);
  private:
  uint64_t _internal_legacy_steam_id_gs() const;
  void _internal_set_legacy_steam_id_gs(uint64_t value);
  public:

  // optional uint32 legacy_query_port = 3;
  bool has_legacy_query_port() const;
  private:
  bool _internal_has_legacy_query_port() const;
  public:
  void clear_legacy_query_port();
  uint32_t legacy_query_port() const;
  void set_legacy_query_port(uint32_t value);
  private:
  uint32_t _internal_legacy_query_port() const;
  void _internal_set_legacy_query_port(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGameServerRemove)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t legacy_steam_id_gs_;
  uint32_t legacy_query_port_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgClientGMSServerQuery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgClientGMSServerQuery) */ {
 public:
  inline CMsgClientGMSServerQuery() : CMsgClientGMSServerQuery(nullptr) {}
  ~CMsgClientGMSServerQuery() override;
  explicit constexpr CMsgClientGMSServerQuery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgClientGMSServerQuery(const CMsgClientGMSServerQuery& from);
  CMsgClientGMSServerQuery(CMsgClientGMSServerQuery&& from) noexcept
    : CMsgClientGMSServerQuery() {
    *this = ::std::move(from);
  }

  inline CMsgClientGMSServerQuery& operator=(const CMsgClientGMSServerQuery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgClientGMSServerQuery& operator=(CMsgClientGMSServerQuery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgClientGMSServerQuery& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgClientGMSServerQuery* internal_default_instance() {
    return reinterpret_cast<const CMsgClientGMSServerQuery*>(
               &_CMsgClientGMSServerQuery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgClientGMSServerQuery& a, CMsgClientGMSServerQuery& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgClientGMSServerQuery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgClientGMSServerQuery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgClientGMSServerQuery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgClientGMSServerQuery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgClientGMSServerQuery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgClientGMSServerQuery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgClientGMSServerQuery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgClientGMSServerQuery";
  }
  protected:
  explicit CMsgClientGMSServerQuery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFilterTextFieldNumber = 4,
    kAppIdFieldNumber = 1,
    kGeoLocationIpFieldNumber = 2,
    kRegionCodeFieldNumber = 3,
    kMaxServersFieldNumber = 5,
  };
  // optional string filter_text = 4;
  bool has_filter_text() const;
  private:
  bool _internal_has_filter_text() const;
  public:
  void clear_filter_text();
  const std::string& filter_text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filter_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filter_text();
  PROTOBUF_NODISCARD std::string* release_filter_text();
  void set_allocated_filter_text(std::string* filter_text);
  private:
  const std::string& _internal_filter_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filter_text(const std::string& value);
  std::string* _internal_mutable_filter_text();
  public:

  // optional uint32 app_id = 1;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 geo_location_ip = 2;
  bool has_geo_location_ip() const;
  private:
  bool _internal_has_geo_location_ip() const;
  public:
  void clear_geo_location_ip();
  uint32_t geo_location_ip() const;
  void set_geo_location_ip(uint32_t value);
  private:
  uint32_t _internal_geo_location_ip() const;
  void _internal_set_geo_location_ip(uint32_t value);
  public:

  // optional uint32 region_code = 3;
  bool has_region_code() const;
  private:
  bool _internal_has_region_code() const;
  public:
  void clear_region_code();
  uint32_t region_code() const;
  void set_region_code(uint32_t value);
  private:
  uint32_t _internal_region_code() const;
  void _internal_set_region_code(uint32_t value);
  public:

  // optional uint32 max_servers = 5;
  bool has_max_servers() const;
  private:
  bool _internal_has_max_servers() const;
  public:
  void clear_max_servers();
  uint32_t max_servers() const;
  void set_max_servers(uint32_t value);
  private:
  uint32_t _internal_max_servers() const;
  void _internal_set_max_servers(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgClientGMSServerQuery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filter_text_;
  uint32_t app_id_;
  uint32_t geo_location_ip_;
  uint32_t region_code_;
  uint32_t max_servers_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGMSClientServerQueryResponse_Server final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGMSClientServerQueryResponse.Server) */ {
 public:
  inline CMsgGMSClientServerQueryResponse_Server() : CMsgGMSClientServerQueryResponse_Server(nullptr) {}
  ~CMsgGMSClientServerQueryResponse_Server() override;
  explicit constexpr CMsgGMSClientServerQueryResponse_Server(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGMSClientServerQueryResponse_Server(const CMsgGMSClientServerQueryResponse_Server& from);
  CMsgGMSClientServerQueryResponse_Server(CMsgGMSClientServerQueryResponse_Server&& from) noexcept
    : CMsgGMSClientServerQueryResponse_Server() {
    *this = ::std::move(from);
  }

  inline CMsgGMSClientServerQueryResponse_Server& operator=(const CMsgGMSClientServerQueryResponse_Server& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGMSClientServerQueryResponse_Server& operator=(CMsgGMSClientServerQueryResponse_Server&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGMSClientServerQueryResponse_Server& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGMSClientServerQueryResponse_Server* internal_default_instance() {
    return reinterpret_cast<const CMsgGMSClientServerQueryResponse_Server*>(
               &_CMsgGMSClientServerQueryResponse_Server_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgGMSClientServerQueryResponse_Server& a, CMsgGMSClientServerQueryResponse_Server& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGMSClientServerQueryResponse_Server* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGMSClientServerQueryResponse_Server* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGMSClientServerQueryResponse_Server* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGMSClientServerQueryResponse_Server>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGMSClientServerQueryResponse_Server& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGMSClientServerQueryResponse_Server& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGMSClientServerQueryResponse_Server* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGMSClientServerQueryResponse.Server";
  }
  protected:
  explicit CMsgGMSClientServerQueryResponse_Server(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGamedirStrFieldNumber = 16,
    kMapStrFieldNumber = 18,
    kNameStrFieldNumber = 20,
    kGameDescriptionStrFieldNumber = 22,
    kVersionStrFieldNumber = 24,
    kGametypeStrFieldNumber = 26,
    kSpectatorNameStrFieldNumber = 30,
    kSdrPingLocationFieldNumber = 32,
    kServerIpFieldNumber = 4,
    kDeprecatedServerIpFieldNumber = 1,
    kQueryPortFieldNumber = 2,
    kAuthPlayersFieldNumber = 3,
    kRevisionFieldNumber = 7,
    kSteamIdFieldNumber = 6,
    kPlayersFieldNumber = 8,
    kGamePortFieldNumber = 9,
    kSdrPopidFieldNumber = 10,
    kFlagsFieldNumber = 11,
    kAppIdFieldNumber = 12,
    kMaxPlayersFieldNumber = 13,
    kBotsFieldNumber = 14,
    kSpectatorPortFieldNumber = 15,
    kGamedirStrindexFieldNumber = 17,
    kMapStrindexFieldNumber = 19,
    kNameStrindexFieldNumber = 21,
    kGameDescriptionStrindexFieldNumber = 23,
    kVersionStrindexFieldNumber = 25,
    kGametypeStrindexFieldNumber = 27,
    kSpectatorNameStrindexFieldNumber = 31,
  };
  // optional string gamedir_str = 16;
  bool has_gamedir_str() const;
  private:
  bool _internal_has_gamedir_str() const;
  public:
  void clear_gamedir_str();
  const std::string& gamedir_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamedir_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamedir_str();
  PROTOBUF_NODISCARD std::string* release_gamedir_str();
  void set_allocated_gamedir_str(std::string* gamedir_str);
  private:
  const std::string& _internal_gamedir_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamedir_str(const std::string& value);
  std::string* _internal_mutable_gamedir_str();
  public:

  // optional string map_str = 18;
  bool has_map_str() const;
  private:
  bool _internal_has_map_str() const;
  public:
  void clear_map_str();
  const std::string& map_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_map_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_map_str();
  PROTOBUF_NODISCARD std::string* release_map_str();
  void set_allocated_map_str(std::string* map_str);
  private:
  const std::string& _internal_map_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_map_str(const std::string& value);
  std::string* _internal_mutable_map_str();
  public:

  // optional string name_str = 20;
  bool has_name_str() const;
  private:
  bool _internal_has_name_str() const;
  public:
  void clear_name_str();
  const std::string& name_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_str();
  PROTOBUF_NODISCARD std::string* release_name_str();
  void set_allocated_name_str(std::string* name_str);
  private:
  const std::string& _internal_name_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_str(const std::string& value);
  std::string* _internal_mutable_name_str();
  public:

  // optional string game_description_str = 22;
  bool has_game_description_str() const;
  private:
  bool _internal_has_game_description_str() const;
  public:
  void clear_game_description_str();
  const std::string& game_description_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_description_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_description_str();
  PROTOBUF_NODISCARD std::string* release_game_description_str();
  void set_allocated_game_description_str(std::string* game_description_str);
  private:
  const std::string& _internal_game_description_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_description_str(const std::string& value);
  std::string* _internal_mutable_game_description_str();
  public:

  // optional string version_str = 24;
  bool has_version_str() const;
  private:
  bool _internal_has_version_str() const;
  public:
  void clear_version_str();
  const std::string& version_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_version_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_version_str();
  PROTOBUF_NODISCARD std::string* release_version_str();
  void set_allocated_version_str(std::string* version_str);
  private:
  const std::string& _internal_version_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_version_str(const std::string& value);
  std::string* _internal_mutable_version_str();
  public:

  // optional string gametype_str = 26;
  bool has_gametype_str() const;
  private:
  bool _internal_has_gametype_str() const;
  public:
  void clear_gametype_str();
  const std::string& gametype_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gametype_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gametype_str();
  PROTOBUF_NODISCARD std::string* release_gametype_str();
  void set_allocated_gametype_str(std::string* gametype_str);
  private:
  const std::string& _internal_gametype_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gametype_str(const std::string& value);
  std::string* _internal_mutable_gametype_str();
  public:

  // optional string spectator_name_str = 30;
  bool has_spectator_name_str() const;
  private:
  bool _internal_has_spectator_name_str() const;
  public:
  void clear_spectator_name_str();
  const std::string& spectator_name_str() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_spectator_name_str(ArgT0&& arg0, ArgT... args);
  std::string* mutable_spectator_name_str();
  PROTOBUF_NODISCARD std::string* release_spectator_name_str();
  void set_allocated_spectator_name_str(std::string* spectator_name_str);
  private:
  const std::string& _internal_spectator_name_str() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_spectator_name_str(const std::string& value);
  std::string* _internal_mutable_spectator_name_str();
  public:

  // optional string sdr_ping_location = 32;
  bool has_sdr_ping_location() const;
  private:
  bool _internal_has_sdr_ping_location() const;
  public:
  void clear_sdr_ping_location();
  const std::string& sdr_ping_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdr_ping_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdr_ping_location();
  PROTOBUF_NODISCARD std::string* release_sdr_ping_location();
  void set_allocated_sdr_ping_location(std::string* sdr_ping_location);
  private:
  const std::string& _internal_sdr_ping_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdr_ping_location(const std::string& value);
  std::string* _internal_mutable_sdr_ping_location();
  public:

  // optional .CMsgIPAddress server_ip = 4;
  bool has_server_ip() const;
  private:
  bool _internal_has_server_ip() const;
  public:
  void clear_server_ip();
  const ::CMsgIPAddress& server_ip() const;
  PROTOBUF_NODISCARD ::CMsgIPAddress* release_server_ip();
  ::CMsgIPAddress* mutable_server_ip();
  void set_allocated_server_ip(::CMsgIPAddress* server_ip);
  private:
  const ::CMsgIPAddress& _internal_server_ip() const;
  ::CMsgIPAddress* _internal_mutable_server_ip();
  public:
  void unsafe_arena_set_allocated_server_ip(
      ::CMsgIPAddress* server_ip);
  ::CMsgIPAddress* unsafe_arena_release_server_ip();

  // optional uint32 deprecated_server_ip = 1;
  bool has_deprecated_server_ip() const;
  private:
  bool _internal_has_deprecated_server_ip() const;
  public:
  void clear_deprecated_server_ip();
  uint32_t deprecated_server_ip() const;
  void set_deprecated_server_ip(uint32_t value);
  private:
  uint32_t _internal_deprecated_server_ip() const;
  void _internal_set_deprecated_server_ip(uint32_t value);
  public:

  // optional uint32 query_port = 2;
  bool has_query_port() const;
  private:
  bool _internal_has_query_port() const;
  public:
  void clear_query_port();
  uint32_t query_port() const;
  void set_query_port(uint32_t value);
  private:
  uint32_t _internal_query_port() const;
  void _internal_set_query_port(uint32_t value);
  public:

  // optional uint32 auth_players = 3;
  bool has_auth_players() const;
  private:
  bool _internal_has_auth_players() const;
  public:
  void clear_auth_players();
  uint32_t auth_players() const;
  void set_auth_players(uint32_t value);
  private:
  uint32_t _internal_auth_players() const;
  void _internal_set_auth_players(uint32_t value);
  public:

  // optional uint32 revision = 7;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  uint32_t revision() const;
  void set_revision(uint32_t value);
  private:
  uint32_t _internal_revision() const;
  void _internal_set_revision(uint32_t value);
  public:

  // optional fixed64 steam_id = 6;
  bool has_steam_id() const;
  private:
  bool _internal_has_steam_id() const;
  public:
  void clear_steam_id();
  uint64_t steam_id() const;
  void set_steam_id(uint64_t value);
  private:
  uint64_t _internal_steam_id() const;
  void _internal_set_steam_id(uint64_t value);
  public:

  // optional uint32 players = 8;
  bool has_players() const;
  private:
  bool _internal_has_players() const;
  public:
  void clear_players();
  uint32_t players() const;
  void set_players(uint32_t value);
  private:
  uint32_t _internal_players() const;
  void _internal_set_players(uint32_t value);
  public:

  // optional uint32 game_port = 9;
  bool has_game_port() const;
  private:
  bool _internal_has_game_port() const;
  public:
  void clear_game_port();
  uint32_t game_port() const;
  void set_game_port(uint32_t value);
  private:
  uint32_t _internal_game_port() const;
  void _internal_set_game_port(uint32_t value);
  public:

  // optional fixed32 sdr_popid = 10;
  bool has_sdr_popid() const;
  private:
  bool _internal_has_sdr_popid() const;
  public:
  void clear_sdr_popid();
  uint32_t sdr_popid() const;
  void set_sdr_popid(uint32_t value);
  private:
  uint32_t _internal_sdr_popid() const;
  void _internal_set_sdr_popid(uint32_t value);
  public:

  // optional uint32 flags = 11;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 app_id = 12;
  bool has_app_id() const;
  private:
  bool _internal_has_app_id() const;
  public:
  void clear_app_id();
  uint32_t app_id() const;
  void set_app_id(uint32_t value);
  private:
  uint32_t _internal_app_id() const;
  void _internal_set_app_id(uint32_t value);
  public:

  // optional uint32 max_players = 13;
  bool has_max_players() const;
  private:
  bool _internal_has_max_players() const;
  public:
  void clear_max_players();
  uint32_t max_players() const;
  void set_max_players(uint32_t value);
  private:
  uint32_t _internal_max_players() const;
  void _internal_set_max_players(uint32_t value);
  public:

  // optional uint32 bots = 14;
  bool has_bots() const;
  private:
  bool _internal_has_bots() const;
  public:
  void clear_bots();
  uint32_t bots() const;
  void set_bots(uint32_t value);
  private:
  uint32_t _internal_bots() const;
  void _internal_set_bots(uint32_t value);
  public:

  // optional uint32 spectator_port = 15;
  bool has_spectator_port() const;
  private:
  bool _internal_has_spectator_port() const;
  public:
  void clear_spectator_port();
  uint32_t spectator_port() const;
  void set_spectator_port(uint32_t value);
  private:
  uint32_t _internal_spectator_port() const;
  void _internal_set_spectator_port(uint32_t value);
  public:

  // optional uint32 gamedir_strindex = 17;
  bool has_gamedir_strindex() const;
  private:
  bool _internal_has_gamedir_strindex() const;
  public:
  void clear_gamedir_strindex();
  uint32_t gamedir_strindex() const;
  void set_gamedir_strindex(uint32_t value);
  private:
  uint32_t _internal_gamedir_strindex() const;
  void _internal_set_gamedir_strindex(uint32_t value);
  public:

  // optional uint32 map_strindex = 19;
  bool has_map_strindex() const;
  private:
  bool _internal_has_map_strindex() const;
  public:
  void clear_map_strindex();
  uint32_t map_strindex() const;
  void set_map_strindex(uint32_t value);
  private:
  uint32_t _internal_map_strindex() const;
  void _internal_set_map_strindex(uint32_t value);
  public:

  // optional uint32 name_strindex = 21;
  bool has_name_strindex() const;
  private:
  bool _internal_has_name_strindex() const;
  public:
  void clear_name_strindex();
  uint32_t name_strindex() const;
  void set_name_strindex(uint32_t value);
  private:
  uint32_t _internal_name_strindex() const;
  void _internal_set_name_strindex(uint32_t value);
  public:

  // optional uint32 game_description_strindex = 23;
  bool has_game_description_strindex() const;
  private:
  bool _internal_has_game_description_strindex() const;
  public:
  void clear_game_description_strindex();
  uint32_t game_description_strindex() const;
  void set_game_description_strindex(uint32_t value);
  private:
  uint32_t _internal_game_description_strindex() const;
  void _internal_set_game_description_strindex(uint32_t value);
  public:

  // optional uint32 version_strindex = 25;
  bool has_version_strindex() const;
  private:
  bool _internal_has_version_strindex() const;
  public:
  void clear_version_strindex();
  uint32_t version_strindex() const;
  void set_version_strindex(uint32_t value);
  private:
  uint32_t _internal_version_strindex() const;
  void _internal_set_version_strindex(uint32_t value);
  public:

  // optional uint32 gametype_strindex = 27;
  bool has_gametype_strindex() const;
  private:
  bool _internal_has_gametype_strindex() const;
  public:
  void clear_gametype_strindex();
  uint32_t gametype_strindex() const;
  void set_gametype_strindex(uint32_t value);
  private:
  uint32_t _internal_gametype_strindex() const;
  void _internal_set_gametype_strindex(uint32_t value);
  public:

  // optional uint32 spectator_name_strindex = 31;
  bool has_spectator_name_strindex() const;
  private:
  bool _internal_has_spectator_name_strindex() const;
  public:
  void clear_spectator_name_strindex();
  uint32_t spectator_name_strindex() const;
  void set_spectator_name_strindex(uint32_t value);
  private:
  uint32_t _internal_spectator_name_strindex() const;
  void _internal_set_spectator_name_strindex(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGMSClientServerQueryResponse.Server)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamedir_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr map_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_description_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr version_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gametype_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr spectator_name_str_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdr_ping_location_;
  ::CMsgIPAddress* server_ip_;
  uint32_t deprecated_server_ip_;
  uint32_t query_port_;
  uint32_t auth_players_;
  uint32_t revision_;
  uint64_t steam_id_;
  uint32_t players_;
  uint32_t game_port_;
  uint32_t sdr_popid_;
  uint32_t flags_;
  uint32_t app_id_;
  uint32_t max_players_;
  uint32_t bots_;
  uint32_t spectator_port_;
  uint32_t gamedir_strindex_;
  uint32_t map_strindex_;
  uint32_t name_strindex_;
  uint32_t game_description_strindex_;
  uint32_t version_strindex_;
  uint32_t gametype_strindex_;
  uint32_t spectator_name_strindex_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGMSClientServerQueryResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGMSClientServerQueryResponse) */ {
 public:
  inline CMsgGMSClientServerQueryResponse() : CMsgGMSClientServerQueryResponse(nullptr) {}
  ~CMsgGMSClientServerQueryResponse() override;
  explicit constexpr CMsgGMSClientServerQueryResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGMSClientServerQueryResponse(const CMsgGMSClientServerQueryResponse& from);
  CMsgGMSClientServerQueryResponse(CMsgGMSClientServerQueryResponse&& from) noexcept
    : CMsgGMSClientServerQueryResponse() {
    *this = ::std::move(from);
  }

  inline CMsgGMSClientServerQueryResponse& operator=(const CMsgGMSClientServerQueryResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGMSClientServerQueryResponse& operator=(CMsgGMSClientServerQueryResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGMSClientServerQueryResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGMSClientServerQueryResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgGMSClientServerQueryResponse*>(
               &_CMsgGMSClientServerQueryResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgGMSClientServerQueryResponse& a, CMsgGMSClientServerQueryResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGMSClientServerQueryResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGMSClientServerQueryResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGMSClientServerQueryResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGMSClientServerQueryResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGMSClientServerQueryResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGMSClientServerQueryResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGMSClientServerQueryResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGMSClientServerQueryResponse";
  }
  protected:
  explicit CMsgGMSClientServerQueryResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgGMSClientServerQueryResponse_Server Server;

  typedef CMsgGMSClientServerQueryResponse_EFlags EFlags;
  static constexpr EFlags k_EFlag_HasPassword =
    CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_HasPassword;
  static constexpr EFlags k_EFlag_Secure =
    CMsgGMSClientServerQueryResponse_EFlags_k_EFlag_Secure;
  static inline bool EFlags_IsValid(int value) {
    return CMsgGMSClientServerQueryResponse_EFlags_IsValid(value);
  }
  static constexpr EFlags EFlags_MIN =
    CMsgGMSClientServerQueryResponse_EFlags_EFlags_MIN;
  static constexpr EFlags EFlags_MAX =
    CMsgGMSClientServerQueryResponse_EFlags_EFlags_MAX;
  static constexpr int EFlags_ARRAYSIZE =
    CMsgGMSClientServerQueryResponse_EFlags_EFlags_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EFlags_descriptor() {
    return CMsgGMSClientServerQueryResponse_EFlags_descriptor();
  }
  template<typename T>
  static inline const std::string& EFlags_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EFlags>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EFlags_Name.");
    return CMsgGMSClientServerQueryResponse_EFlags_Name(enum_t_value);
  }
  static inline bool EFlags_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EFlags* value) {
    return CMsgGMSClientServerQueryResponse_EFlags_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kServersFieldNumber = 1,
    kServerStringsFieldNumber = 4,
    kErrorFieldNumber = 2,
    kDefaultServerDataFieldNumber = 3,
  };
  // repeated .CMsgGMSClientServerQueryResponse.Server servers = 1;
  int servers_size() const;
  private:
  int _internal_servers_size() const;
  public:
  void clear_servers();
  ::CMsgGMSClientServerQueryResponse_Server* mutable_servers(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGMSClientServerQueryResponse_Server >*
      mutable_servers();
  private:
  const ::CMsgGMSClientServerQueryResponse_Server& _internal_servers(int index) const;
  ::CMsgGMSClientServerQueryResponse_Server* _internal_add_servers();
  public:
  const ::CMsgGMSClientServerQueryResponse_Server& servers(int index) const;
  ::CMsgGMSClientServerQueryResponse_Server* add_servers();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGMSClientServerQueryResponse_Server >&
      servers() const;

  // repeated string server_strings = 4;
  int server_strings_size() const;
  private:
  int _internal_server_strings_size() const;
  public:
  void clear_server_strings();
  const std::string& server_strings(int index) const;
  std::string* mutable_server_strings(int index);
  void set_server_strings(int index, const std::string& value);
  void set_server_strings(int index, std::string&& value);
  void set_server_strings(int index, const char* value);
  void set_server_strings(int index, const char* value, size_t size);
  std::string* add_server_strings();
  void add_server_strings(const std::string& value);
  void add_server_strings(std::string&& value);
  void add_server_strings(const char* value);
  void add_server_strings(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& server_strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_server_strings();
  private:
  const std::string& _internal_server_strings(int index) const;
  std::string* _internal_add_server_strings();
  public:

  // optional string error = 2;
  bool has_error() const;
  private:
  bool _internal_has_error() const;
  public:
  void clear_error();
  const std::string& error() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error();
  PROTOBUF_NODISCARD std::string* release_error();
  void set_allocated_error(std::string* error);
  private:
  const std::string& _internal_error() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error(const std::string& value);
  std::string* _internal_mutable_error();
  public:

  // optional .CMsgGMSClientServerQueryResponse.Server default_server_data = 3;
  bool has_default_server_data() const;
  private:
  bool _internal_has_default_server_data() const;
  public:
  void clear_default_server_data();
  const ::CMsgGMSClientServerQueryResponse_Server& default_server_data() const;
  PROTOBUF_NODISCARD ::CMsgGMSClientServerQueryResponse_Server* release_default_server_data();
  ::CMsgGMSClientServerQueryResponse_Server* mutable_default_server_data();
  void set_allocated_default_server_data(::CMsgGMSClientServerQueryResponse_Server* default_server_data);
  private:
  const ::CMsgGMSClientServerQueryResponse_Server& _internal_default_server_data() const;
  ::CMsgGMSClientServerQueryResponse_Server* _internal_mutable_default_server_data();
  public:
  void unsafe_arena_set_allocated_default_server_data(
      ::CMsgGMSClientServerQueryResponse_Server* default_server_data);
  ::CMsgGMSClientServerQueryResponse_Server* unsafe_arena_release_default_server_data();

  // @@protoc_insertion_point(class_scope:CMsgGMSClientServerQueryResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGMSClientServerQueryResponse_Server > servers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> server_strings_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_;
  ::CMsgGMSClientServerQueryResponse_Server* default_server_data_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGameServerOutOfDate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGameServerOutOfDate) */ {
 public:
  inline CMsgGameServerOutOfDate() : CMsgGameServerOutOfDate(nullptr) {}
  ~CMsgGameServerOutOfDate() override;
  explicit constexpr CMsgGameServerOutOfDate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGameServerOutOfDate(const CMsgGameServerOutOfDate& from);
  CMsgGameServerOutOfDate(CMsgGameServerOutOfDate&& from) noexcept
    : CMsgGameServerOutOfDate() {
    *this = ::std::move(from);
  }

  inline CMsgGameServerOutOfDate& operator=(const CMsgGameServerOutOfDate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGameServerOutOfDate& operator=(CMsgGameServerOutOfDate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGameServerOutOfDate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGameServerOutOfDate* internal_default_instance() {
    return reinterpret_cast<const CMsgGameServerOutOfDate*>(
               &_CMsgGameServerOutOfDate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgGameServerOutOfDate& a, CMsgGameServerOutOfDate& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGameServerOutOfDate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGameServerOutOfDate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGameServerOutOfDate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGameServerOutOfDate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGameServerOutOfDate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGameServerOutOfDate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGameServerOutOfDate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGameServerOutOfDate";
  }
  protected:
  explicit CMsgGameServerOutOfDate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 3,
    kSteamIdGsFieldNumber = 1,
    kRejectFieldNumber = 2,
  };
  // optional string message = 3;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional fixed64 steam_id_gs = 1;
  bool has_steam_id_gs() const;
  private:
  bool _internal_has_steam_id_gs() const;
  public:
  void clear_steam_id_gs();
  uint64_t steam_id_gs() const;
  void set_steam_id_gs(uint64_t value);
  private:
  uint64_t _internal_steam_id_gs() const;
  void _internal_set_steam_id_gs(uint64_t value);
  public:

  // optional bool reject = 2;
  bool has_reject() const;
  private:
  bool _internal_has_reject() const;
  public:
  void clear_reject();
  bool reject() const;
  void set_reject(bool value);
  private:
  bool _internal_reject() const;
  void _internal_set_reject(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGameServerOutOfDate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  uint64_t steam_id_gs_;
  bool reject_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSAssociateWithClan final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSAssociateWithClan) */ {
 public:
  inline CMsgGSAssociateWithClan() : CMsgGSAssociateWithClan(nullptr) {}
  ~CMsgGSAssociateWithClan() override;
  explicit constexpr CMsgGSAssociateWithClan(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSAssociateWithClan(const CMsgGSAssociateWithClan& from);
  CMsgGSAssociateWithClan(CMsgGSAssociateWithClan&& from) noexcept
    : CMsgGSAssociateWithClan() {
    *this = ::std::move(from);
  }

  inline CMsgGSAssociateWithClan& operator=(const CMsgGSAssociateWithClan& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSAssociateWithClan& operator=(CMsgGSAssociateWithClan&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSAssociateWithClan& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSAssociateWithClan* internal_default_instance() {
    return reinterpret_cast<const CMsgGSAssociateWithClan*>(
               &_CMsgGSAssociateWithClan_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgGSAssociateWithClan& a, CMsgGSAssociateWithClan& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSAssociateWithClan* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSAssociateWithClan* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSAssociateWithClan* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSAssociateWithClan>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSAssociateWithClan& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSAssociateWithClan& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSAssociateWithClan* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSAssociateWithClan";
  }
  protected:
  explicit CMsgGSAssociateWithClan(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdClanFieldNumber = 1,
  };
  // optional fixed64 steam_id_clan = 1;
  bool has_steam_id_clan() const;
  private:
  bool _internal_has_steam_id_clan() const;
  public:
  void clear_steam_id_clan();
  uint64_t steam_id_clan() const;
  void set_steam_id_clan(uint64_t value);
  private:
  uint64_t _internal_steam_id_clan() const;
  void _internal_set_steam_id_clan(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSAssociateWithClan)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_clan_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSAssociateWithClanResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSAssociateWithClanResponse) */ {
 public:
  inline CMsgGSAssociateWithClanResponse() : CMsgGSAssociateWithClanResponse(nullptr) {}
  ~CMsgGSAssociateWithClanResponse() override;
  explicit constexpr CMsgGSAssociateWithClanResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSAssociateWithClanResponse(const CMsgGSAssociateWithClanResponse& from);
  CMsgGSAssociateWithClanResponse(CMsgGSAssociateWithClanResponse&& from) noexcept
    : CMsgGSAssociateWithClanResponse() {
    *this = ::std::move(from);
  }

  inline CMsgGSAssociateWithClanResponse& operator=(const CMsgGSAssociateWithClanResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSAssociateWithClanResponse& operator=(CMsgGSAssociateWithClanResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSAssociateWithClanResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSAssociateWithClanResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgGSAssociateWithClanResponse*>(
               &_CMsgGSAssociateWithClanResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgGSAssociateWithClanResponse& a, CMsgGSAssociateWithClanResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSAssociateWithClanResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSAssociateWithClanResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSAssociateWithClanResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSAssociateWithClanResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSAssociateWithClanResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSAssociateWithClanResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSAssociateWithClanResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSAssociateWithClanResponse";
  }
  protected:
  explicit CMsgGSAssociateWithClanResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdClanFieldNumber = 1,
    kEresultFieldNumber = 2,
  };
  // optional fixed64 steam_id_clan = 1;
  bool has_steam_id_clan() const;
  private:
  bool _internal_has_steam_id_clan() const;
  public:
  void clear_steam_id_clan();
  uint64_t steam_id_clan() const;
  void set_steam_id_clan(uint64_t value);
  private:
  uint64_t _internal_steam_id_clan() const;
  void _internal_set_steam_id_clan(uint64_t value);
  public:

  // optional uint32 eresult = 2 [default = 2];
  bool has_eresult() const;
  private:
  bool _internal_has_eresult() const;
  public:
  void clear_eresult();
  uint32_t eresult() const;
  void set_eresult(uint32_t value);
  private:
  uint32_t _internal_eresult() const;
  void _internal_set_eresult(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSAssociateWithClanResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_clan_;
  uint32_t eresult_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSComputeNewPlayerCompatibility final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSComputeNewPlayerCompatibility) */ {
 public:
  inline CMsgGSComputeNewPlayerCompatibility() : CMsgGSComputeNewPlayerCompatibility(nullptr) {}
  ~CMsgGSComputeNewPlayerCompatibility() override;
  explicit constexpr CMsgGSComputeNewPlayerCompatibility(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSComputeNewPlayerCompatibility(const CMsgGSComputeNewPlayerCompatibility& from);
  CMsgGSComputeNewPlayerCompatibility(CMsgGSComputeNewPlayerCompatibility&& from) noexcept
    : CMsgGSComputeNewPlayerCompatibility() {
    *this = ::std::move(from);
  }

  inline CMsgGSComputeNewPlayerCompatibility& operator=(const CMsgGSComputeNewPlayerCompatibility& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSComputeNewPlayerCompatibility& operator=(CMsgGSComputeNewPlayerCompatibility&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSComputeNewPlayerCompatibility& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSComputeNewPlayerCompatibility* internal_default_instance() {
    return reinterpret_cast<const CMsgGSComputeNewPlayerCompatibility*>(
               &_CMsgGSComputeNewPlayerCompatibility_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgGSComputeNewPlayerCompatibility& a, CMsgGSComputeNewPlayerCompatibility& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSComputeNewPlayerCompatibility* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSComputeNewPlayerCompatibility* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSComputeNewPlayerCompatibility* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSComputeNewPlayerCompatibility>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSComputeNewPlayerCompatibility& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSComputeNewPlayerCompatibility& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSComputeNewPlayerCompatibility* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSComputeNewPlayerCompatibility";
  }
  protected:
  explicit CMsgGSComputeNewPlayerCompatibility(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdCandidateFieldNumber = 1,
  };
  // optional fixed64 steam_id_candidate = 1;
  bool has_steam_id_candidate() const;
  private:
  bool _internal_has_steam_id_candidate() const;
  public:
  void clear_steam_id_candidate();
  uint64_t steam_id_candidate() const;
  void set_steam_id_candidate(uint64_t value);
  private:
  uint64_t _internal_steam_id_candidate() const;
  void _internal_set_steam_id_candidate(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSComputeNewPlayerCompatibility)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_candidate_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// -------------------------------------------------------------------

class CMsgGSComputeNewPlayerCompatibilityResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgGSComputeNewPlayerCompatibilityResponse) */ {
 public:
  inline CMsgGSComputeNewPlayerCompatibilityResponse() : CMsgGSComputeNewPlayerCompatibilityResponse(nullptr) {}
  ~CMsgGSComputeNewPlayerCompatibilityResponse() override;
  explicit constexpr CMsgGSComputeNewPlayerCompatibilityResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgGSComputeNewPlayerCompatibilityResponse(const CMsgGSComputeNewPlayerCompatibilityResponse& from);
  CMsgGSComputeNewPlayerCompatibilityResponse(CMsgGSComputeNewPlayerCompatibilityResponse&& from) noexcept
    : CMsgGSComputeNewPlayerCompatibilityResponse() {
    *this = ::std::move(from);
  }

  inline CMsgGSComputeNewPlayerCompatibilityResponse& operator=(const CMsgGSComputeNewPlayerCompatibilityResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgGSComputeNewPlayerCompatibilityResponse& operator=(CMsgGSComputeNewPlayerCompatibilityResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgGSComputeNewPlayerCompatibilityResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgGSComputeNewPlayerCompatibilityResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgGSComputeNewPlayerCompatibilityResponse*>(
               &_CMsgGSComputeNewPlayerCompatibilityResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgGSComputeNewPlayerCompatibilityResponse& a, CMsgGSComputeNewPlayerCompatibilityResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgGSComputeNewPlayerCompatibilityResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgGSComputeNewPlayerCompatibilityResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgGSComputeNewPlayerCompatibilityResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgGSComputeNewPlayerCompatibilityResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgGSComputeNewPlayerCompatibilityResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgGSComputeNewPlayerCompatibilityResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgGSComputeNewPlayerCompatibilityResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgGSComputeNewPlayerCompatibilityResponse";
  }
  protected:
  explicit CMsgGSComputeNewPlayerCompatibilityResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamIdCandidateFieldNumber = 1,
    kIsClanMemberFieldNumber = 3,
    kCtDontLikeYouFieldNumber = 4,
    kCtYouDontLikeFieldNumber = 5,
    kCtClanmembersDontLikeYouFieldNumber = 6,
    kEresultFieldNumber = 2,
  };
  // optional fixed64 steam_id_candidate = 1;
  bool has_steam_id_candidate() const;
  private:
  bool _internal_has_steam_id_candidate() const;
  public:
  void clear_steam_id_candidate();
  uint64_t steam_id_candidate() const;
  void set_steam_id_candidate(uint64_t value);
  private:
  uint64_t _internal_steam_id_candidate() const;
  void _internal_set_steam_id_candidate(uint64_t value);
  public:

  // optional bool is_clan_member = 3;
  bool has_is_clan_member() const;
  private:
  bool _internal_has_is_clan_member() const;
  public:
  void clear_is_clan_member();
  bool is_clan_member() const;
  void set_is_clan_member(bool value);
  private:
  bool _internal_is_clan_member() const;
  void _internal_set_is_clan_member(bool value);
  public:

  // optional int32 ct_dont_like_you = 4;
  bool has_ct_dont_like_you() const;
  private:
  bool _internal_has_ct_dont_like_you() const;
  public:
  void clear_ct_dont_like_you();
  int32_t ct_dont_like_you() const;
  void set_ct_dont_like_you(int32_t value);
  private:
  int32_t _internal_ct_dont_like_you() const;
  void _internal_set_ct_dont_like_you(int32_t value);
  public:

  // optional int32 ct_you_dont_like = 5;
  bool has_ct_you_dont_like() const;
  private:
  bool _internal_has_ct_you_dont_like() const;
  public:
  void clear_ct_you_dont_like();
  int32_t ct_you_dont_like() const;
  void set_ct_you_dont_like(int32_t value);
  private:
  int32_t _internal_ct_you_dont_like() const;
  void _internal_set_ct_you_dont_like(int32_t value);
  public:

  // optional int32 ct_clanmembers_dont_like_you = 6;
  bool has_ct_clanmembers_dont_like_you() const;
  private:
  bool _internal_has_ct_clanmembers_dont_like_you() const;
  public:
  void clear_ct_clanmembers_dont_like_you();
  int32_t ct_clanmembers_dont_like_you() const;
  void set_ct_clanmembers_dont_like_you(int32_t value);
  private:
  int32_t _internal_ct_clanmembers_dont_like_you() const;
  void _internal_set_ct_clanmembers_dont_like_you(int32_t value);
  public:

  // optional uint32 eresult = 2 [default = 2];
  bool has_eresult() const;
  private:
  bool _internal_has_eresult() const;
  public:
  void clear_eresult();
  uint32_t eresult() const;
  void set_eresult(uint32_t value);
  private:
  uint32_t _internal_eresult() const;
  void _internal_set_eresult(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgGSComputeNewPlayerCompatibilityResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steam_id_candidate_;
  bool is_clan_member_;
  int32_t ct_dont_like_you_;
  int32_t ct_you_dont_like_;
  int32_t ct_clanmembers_dont_like_you_;
  uint32_t eresult_;
  friend struct ::TableStruct_steammessages_5fclientserver_5fgameservers_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgGSServerType

// optional uint32 app_id_served = 1;
inline bool CMsgGSServerType::_internal_has_app_id_served() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_app_id_served() const {
  return _internal_has_app_id_served();
}
inline void CMsgGSServerType::clear_app_id_served() {
  app_id_served_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgGSServerType::_internal_app_id_served() const {
  return app_id_served_;
}
inline uint32_t CMsgGSServerType::app_id_served() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.app_id_served)
  return _internal_app_id_served();
}
inline void CMsgGSServerType::_internal_set_app_id_served(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  app_id_served_ = value;
}
inline void CMsgGSServerType::set_app_id_served(uint32_t value) {
  _internal_set_app_id_served(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.app_id_served)
}

// optional uint32 flags = 2;
inline bool CMsgGSServerType::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_flags() const {
  return _internal_has_flags();
}
inline void CMsgGSServerType::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgGSServerType::_internal_flags() const {
  return flags_;
}
inline uint32_t CMsgGSServerType::flags() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.flags)
  return _internal_flags();
}
inline void CMsgGSServerType::_internal_set_flags(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  flags_ = value;
}
inline void CMsgGSServerType::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.flags)
}

// optional uint32 deprecated_game_ip_address = 3;
inline bool CMsgGSServerType::_internal_has_deprecated_game_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_deprecated_game_ip_address() const {
  return _internal_has_deprecated_game_ip_address();
}
inline void CMsgGSServerType::clear_deprecated_game_ip_address() {
  deprecated_game_ip_address_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgGSServerType::_internal_deprecated_game_ip_address() const {
  return deprecated_game_ip_address_;
}
inline uint32_t CMsgGSServerType::deprecated_game_ip_address() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.deprecated_game_ip_address)
  return _internal_deprecated_game_ip_address();
}
inline void CMsgGSServerType::_internal_set_deprecated_game_ip_address(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  deprecated_game_ip_address_ = value;
}
inline void CMsgGSServerType::set_deprecated_game_ip_address(uint32_t value) {
  _internal_set_deprecated_game_ip_address(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.deprecated_game_ip_address)
}

// optional uint32 game_port = 4;
inline bool CMsgGSServerType::_internal_has_game_port() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_game_port() const {
  return _internal_has_game_port();
}
inline void CMsgGSServerType::clear_game_port() {
  game_port_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgGSServerType::_internal_game_port() const {
  return game_port_;
}
inline uint32_t CMsgGSServerType::game_port() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.game_port)
  return _internal_game_port();
}
inline void CMsgGSServerType::_internal_set_game_port(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  game_port_ = value;
}
inline void CMsgGSServerType::set_game_port(uint32_t value) {
  _internal_set_game_port(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.game_port)
}

// optional string game_dir = 5;
inline bool CMsgGSServerType::_internal_has_game_dir() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_game_dir() const {
  return _internal_has_game_dir();
}
inline void CMsgGSServerType::clear_game_dir() {
  game_dir_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGSServerType::game_dir() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.game_dir)
  return _internal_game_dir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGSServerType::set_game_dir(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 game_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGSServerType.game_dir)
}
inline std::string* CMsgGSServerType::mutable_game_dir() {
  std::string* _s = _internal_mutable_game_dir();
  // @@protoc_insertion_point(field_mutable:CMsgGSServerType.game_dir)
  return _s;
}
inline const std::string& CMsgGSServerType::_internal_game_dir() const {
  return game_dir_.Get();
}
inline void CMsgGSServerType::_internal_set_game_dir(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_dir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::_internal_mutable_game_dir() {
  _has_bits_[0] |= 0x00000001u;
  return game_dir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::release_game_dir() {
  // @@protoc_insertion_point(field_release:CMsgGSServerType.game_dir)
  if (!_internal_has_game_dir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = game_dir_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_dir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGSServerType::set_allocated_game_dir(std::string* game_dir) {
  if (game_dir != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_dir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_dir,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_dir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_dir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGSServerType.game_dir)
}

// optional string game_version = 6;
inline bool CMsgGSServerType::_internal_has_game_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_game_version() const {
  return _internal_has_game_version();
}
inline void CMsgGSServerType::clear_game_version() {
  game_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgGSServerType::game_version() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.game_version)
  return _internal_game_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGSServerType::set_game_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 game_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGSServerType.game_version)
}
inline std::string* CMsgGSServerType::mutable_game_version() {
  std::string* _s = _internal_mutable_game_version();
  // @@protoc_insertion_point(field_mutable:CMsgGSServerType.game_version)
  return _s;
}
inline const std::string& CMsgGSServerType::_internal_game_version() const {
  return game_version_.Get();
}
inline void CMsgGSServerType::_internal_set_game_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::_internal_mutable_game_version() {
  _has_bits_[0] |= 0x00000002u;
  return game_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::release_game_version() {
  // @@protoc_insertion_point(field_release:CMsgGSServerType.game_version)
  if (!_internal_has_game_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = game_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGSServerType::set_allocated_game_version(std::string* game_version) {
  if (game_version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGSServerType.game_version)
}

// optional uint32 game_query_port = 7;
inline bool CMsgGSServerType::_internal_has_game_query_port() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_game_query_port() const {
  return _internal_has_game_query_port();
}
inline void CMsgGSServerType::clear_game_query_port() {
  game_query_port_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline uint32_t CMsgGSServerType::_internal_game_query_port() const {
  return game_query_port_;
}
inline uint32_t CMsgGSServerType::game_query_port() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.game_query_port)
  return _internal_game_query_port();
}
inline void CMsgGSServerType::_internal_set_game_query_port(uint32_t value) {
  _has_bits_[0] |= 0x00000080u;
  game_query_port_ = value;
}
inline void CMsgGSServerType::set_game_query_port(uint32_t value) {
  _internal_set_game_query_port(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.game_query_port)
}

// optional uint32 game_port_local = 10;
inline bool CMsgGSServerType::_internal_has_game_port_local() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_game_port_local() const {
  return _internal_has_game_port_local();
}
inline void CMsgGSServerType::clear_game_port_local() {
  game_port_local_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgGSServerType::_internal_game_port_local() const {
  return game_port_local_;
}
inline uint32_t CMsgGSServerType::game_port_local() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.game_port_local)
  return _internal_game_port_local();
}
inline void CMsgGSServerType::_internal_set_game_port_local(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  game_port_local_ = value;
}
inline void CMsgGSServerType::set_game_port_local(uint32_t value) {
  _internal_set_game_port_local(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.game_port_local)
}

// optional bytes sdr_logon = 8;
inline bool CMsgGSServerType::_internal_has_sdr_logon() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_sdr_logon() const {
  return _internal_has_sdr_logon();
}
inline void CMsgGSServerType::clear_sdr_logon() {
  sdr_logon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgGSServerType::sdr_logon() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.sdr_logon)
  return _internal_sdr_logon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGSServerType::set_sdr_logon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 sdr_logon_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGSServerType.sdr_logon)
}
inline std::string* CMsgGSServerType::mutable_sdr_logon() {
  std::string* _s = _internal_mutable_sdr_logon();
  // @@protoc_insertion_point(field_mutable:CMsgGSServerType.sdr_logon)
  return _s;
}
inline const std::string& CMsgGSServerType::_internal_sdr_logon() const {
  return sdr_logon_.Get();
}
inline void CMsgGSServerType::_internal_set_sdr_logon(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  sdr_logon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::_internal_mutable_sdr_logon() {
  _has_bits_[0] |= 0x00000004u;
  return sdr_logon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGSServerType::release_sdr_logon() {
  // @@protoc_insertion_point(field_release:CMsgGSServerType.sdr_logon)
  if (!_internal_has_sdr_logon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = sdr_logon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_logon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_logon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGSServerType::set_allocated_sdr_logon(std::string* sdr_logon) {
  if (sdr_logon != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  sdr_logon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdr_logon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_logon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_logon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGSServerType.sdr_logon)
}

// optional fixed32 fake_ip = 9;
inline bool CMsgGSServerType::_internal_has_fake_ip() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgGSServerType::has_fake_ip() const {
  return _internal_has_fake_ip();
}
inline void CMsgGSServerType::clear_fake_ip() {
  fake_ip_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgGSServerType::_internal_fake_ip() const {
  return fake_ip_;
}
inline uint32_t CMsgGSServerType::fake_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGSServerType.fake_ip)
  return _internal_fake_ip();
}
inline void CMsgGSServerType::_internal_set_fake_ip(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  fake_ip_ = value;
}
inline void CMsgGSServerType::set_fake_ip(uint32_t value) {
  _internal_set_fake_ip(value);
  // @@protoc_insertion_point(field_set:CMsgGSServerType.fake_ip)
}

// -------------------------------------------------------------------

// CMsgGSStatusReply

// optional bool is_secure = 1;
inline bool CMsgGSStatusReply::_internal_has_is_secure() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSStatusReply::has_is_secure() const {
  return _internal_has_is_secure();
}
inline void CMsgGSStatusReply::clear_is_secure() {
  is_secure_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CMsgGSStatusReply::_internal_is_secure() const {
  return is_secure_;
}
inline bool CMsgGSStatusReply::is_secure() const {
  // @@protoc_insertion_point(field_get:CMsgGSStatusReply.is_secure)
  return _internal_is_secure();
}
inline void CMsgGSStatusReply::_internal_set_is_secure(bool value) {
  _has_bits_[0] |= 0x00000001u;
  is_secure_ = value;
}
inline void CMsgGSStatusReply::set_is_secure(bool value) {
  _internal_set_is_secure(value);
  // @@protoc_insertion_point(field_set:CMsgGSStatusReply.is_secure)
}

// -------------------------------------------------------------------

// CMsgGSPlayerList_Player

// optional uint64 steam_id = 1;
inline bool CMsgGSPlayerList_Player::_internal_has_steam_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGSPlayerList_Player::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgGSPlayerList_Player::clear_steam_id() {
  steam_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgGSPlayerList_Player::_internal_steam_id() const {
  return steam_id_;
}
inline uint64_t CMsgGSPlayerList_Player::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgGSPlayerList.Player.steam_id)
  return _internal_steam_id();
}
inline void CMsgGSPlayerList_Player::_internal_set_steam_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steam_id_ = value;
}
inline void CMsgGSPlayerList_Player::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgGSPlayerList.Player.steam_id)
}

// optional uint32 deprecated_public_ip = 2;
inline bool CMsgGSPlayerList_Player::_internal_has_deprecated_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGSPlayerList_Player::has_deprecated_public_ip() const {
  return _internal_has_deprecated_public_ip();
}
inline void CMsgGSPlayerList_Player::clear_deprecated_public_ip() {
  deprecated_public_ip_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgGSPlayerList_Player::_internal_deprecated_public_ip() const {
  return deprecated_public_ip_;
}
inline uint32_t CMsgGSPlayerList_Player::deprecated_public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGSPlayerList.Player.deprecated_public_ip)
  return _internal_deprecated_public_ip();
}
inline void CMsgGSPlayerList_Player::_internal_set_deprecated_public_ip(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  deprecated_public_ip_ = value;
}
inline void CMsgGSPlayerList_Player::set_deprecated_public_ip(uint32_t value) {
  _internal_set_deprecated_public_ip(value);
  // @@protoc_insertion_point(field_set:CMsgGSPlayerList.Player.deprecated_public_ip)
}

// optional bytes token = 3;
inline bool CMsgGSPlayerList_Player::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSPlayerList_Player::has_token() const {
  return _internal_has_token();
}
inline void CMsgGSPlayerList_Player::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGSPlayerList_Player::token() const {
  // @@protoc_insertion_point(field_get:CMsgGSPlayerList.Player.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGSPlayerList_Player::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGSPlayerList.Player.token)
}
inline std::string* CMsgGSPlayerList_Player::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CMsgGSPlayerList.Player.token)
  return _s;
}
inline const std::string& CMsgGSPlayerList_Player::_internal_token() const {
  return token_.Get();
}
inline void CMsgGSPlayerList_Player::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGSPlayerList_Player::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGSPlayerList_Player::release_token() {
  // @@protoc_insertion_point(field_release:CMsgGSPlayerList.Player.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGSPlayerList_Player::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGSPlayerList.Player.token)
}

// optional .CMsgIPAddress public_ip = 4;
inline bool CMsgGSPlayerList_Player::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || public_ip_ != nullptr);
  return value;
}
inline bool CMsgGSPlayerList_Player::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgGSPlayerList_Player::_internal_public_ip() const {
  const ::CMsgIPAddress* p = public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgGSPlayerList_Player::public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGSPlayerList.Player.public_ip)
  return _internal_public_ip();
}
inline void CMsgGSPlayerList_Player::unsafe_arena_set_allocated_public_ip(
    ::CMsgIPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  public_ip_ = public_ip;
  if (public_ip) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgGSPlayerList.Player.public_ip)
}
inline ::CMsgIPAddress* CMsgGSPlayerList_Player::release_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgGSPlayerList_Player::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:CMsgGSPlayerList.Player.public_ip)
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgGSPlayerList_Player::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  if (public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    public_ip_ = p;
  }
  return public_ip_;
}
inline ::CMsgIPAddress* CMsgGSPlayerList_Player::mutable_public_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:CMsgGSPlayerList.Player.public_ip)
  return _msg;
}
inline void CMsgGSPlayerList_Player::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgGSPlayerList.Player.public_ip)
}

// -------------------------------------------------------------------

// CMsgGSPlayerList

// repeated .CMsgGSPlayerList.Player players = 1;
inline int CMsgGSPlayerList::_internal_players_size() const {
  return players_.size();
}
inline int CMsgGSPlayerList::players_size() const {
  return _internal_players_size();
}
inline void CMsgGSPlayerList::clear_players() {
  players_.Clear();
}
inline ::CMsgGSPlayerList_Player* CMsgGSPlayerList::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGSPlayerList.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGSPlayerList_Player >*
CMsgGSPlayerList::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGSPlayerList.players)
  return &players_;
}
inline const ::CMsgGSPlayerList_Player& CMsgGSPlayerList::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::CMsgGSPlayerList_Player& CMsgGSPlayerList::players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGSPlayerList.players)
  return _internal_players(index);
}
inline ::CMsgGSPlayerList_Player* CMsgGSPlayerList::_internal_add_players() {
  return players_.Add();
}
inline ::CMsgGSPlayerList_Player* CMsgGSPlayerList::add_players() {
  ::CMsgGSPlayerList_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:CMsgGSPlayerList.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGSPlayerList_Player >&
CMsgGSPlayerList::players() const {
  // @@protoc_insertion_point(field_list:CMsgGSPlayerList.players)
  return players_;
}

// -------------------------------------------------------------------

// CMsgGSUserPlaying

// optional fixed64 steam_id = 1;
inline bool CMsgGSUserPlaying::_internal_has_steam_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGSUserPlaying::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgGSUserPlaying::clear_steam_id() {
  steam_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgGSUserPlaying::_internal_steam_id() const {
  return steam_id_;
}
inline uint64_t CMsgGSUserPlaying::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgGSUserPlaying.steam_id)
  return _internal_steam_id();
}
inline void CMsgGSUserPlaying::_internal_set_steam_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steam_id_ = value;
}
inline void CMsgGSUserPlaying::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgGSUserPlaying.steam_id)
}

// optional uint32 deprecated_public_ip = 2;
inline bool CMsgGSUserPlaying::_internal_has_deprecated_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGSUserPlaying::has_deprecated_public_ip() const {
  return _internal_has_deprecated_public_ip();
}
inline void CMsgGSUserPlaying::clear_deprecated_public_ip() {
  deprecated_public_ip_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgGSUserPlaying::_internal_deprecated_public_ip() const {
  return deprecated_public_ip_;
}
inline uint32_t CMsgGSUserPlaying::deprecated_public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGSUserPlaying.deprecated_public_ip)
  return _internal_deprecated_public_ip();
}
inline void CMsgGSUserPlaying::_internal_set_deprecated_public_ip(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  deprecated_public_ip_ = value;
}
inline void CMsgGSUserPlaying::set_deprecated_public_ip(uint32_t value) {
  _internal_set_deprecated_public_ip(value);
  // @@protoc_insertion_point(field_set:CMsgGSUserPlaying.deprecated_public_ip)
}

// optional bytes token = 3;
inline bool CMsgGSUserPlaying::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSUserPlaying::has_token() const {
  return _internal_has_token();
}
inline void CMsgGSUserPlaying::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGSUserPlaying::token() const {
  // @@protoc_insertion_point(field_get:CMsgGSUserPlaying.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGSUserPlaying::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGSUserPlaying.token)
}
inline std::string* CMsgGSUserPlaying::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CMsgGSUserPlaying.token)
  return _s;
}
inline const std::string& CMsgGSUserPlaying::_internal_token() const {
  return token_.Get();
}
inline void CMsgGSUserPlaying::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGSUserPlaying::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGSUserPlaying::release_token() {
  // @@protoc_insertion_point(field_release:CMsgGSUserPlaying.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGSUserPlaying::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGSUserPlaying.token)
}

// optional .CMsgIPAddress public_ip = 4;
inline bool CMsgGSUserPlaying::_internal_has_public_ip() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || public_ip_ != nullptr);
  return value;
}
inline bool CMsgGSUserPlaying::has_public_ip() const {
  return _internal_has_public_ip();
}
inline const ::CMsgIPAddress& CMsgGSUserPlaying::_internal_public_ip() const {
  const ::CMsgIPAddress* p = public_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgGSUserPlaying::public_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGSUserPlaying.public_ip)
  return _internal_public_ip();
}
inline void CMsgGSUserPlaying::unsafe_arena_set_allocated_public_ip(
    ::CMsgIPAddress* public_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  public_ip_ = public_ip;
  if (public_ip) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgGSUserPlaying.public_ip)
}
inline ::CMsgIPAddress* CMsgGSUserPlaying::release_public_ip() {
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgGSUserPlaying::unsafe_arena_release_public_ip() {
  // @@protoc_insertion_point(field_release:CMsgGSUserPlaying.public_ip)
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgIPAddress* temp = public_ip_;
  public_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgGSUserPlaying::_internal_mutable_public_ip() {
  _has_bits_[0] |= 0x00000002u;
  if (public_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    public_ip_ = p;
  }
  return public_ip_;
}
inline ::CMsgIPAddress* CMsgGSUserPlaying::mutable_public_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_public_ip();
  // @@protoc_insertion_point(field_mutable:CMsgGSUserPlaying.public_ip)
  return _msg;
}
inline void CMsgGSUserPlaying::set_allocated_public_ip(::CMsgIPAddress* public_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip_);
  }
  if (public_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(public_ip));
    if (message_arena != submessage_arena) {
      public_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, public_ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_ = public_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgGSUserPlaying.public_ip)
}

// -------------------------------------------------------------------

// CMsgGSDisconnectNotice

// optional fixed64 steam_id = 1;
inline bool CMsgGSDisconnectNotice::_internal_has_steam_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSDisconnectNotice::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgGSDisconnectNotice::clear_steam_id() {
  steam_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGSDisconnectNotice::_internal_steam_id() const {
  return steam_id_;
}
inline uint64_t CMsgGSDisconnectNotice::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgGSDisconnectNotice.steam_id)
  return _internal_steam_id();
}
inline void CMsgGSDisconnectNotice::_internal_set_steam_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_ = value;
}
inline void CMsgGSDisconnectNotice::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgGSDisconnectNotice.steam_id)
}

// -------------------------------------------------------------------

// CMsgGameServerData_Player

// optional fixed64 steam_id = 1;
inline bool CMsgGameServerData_Player::_internal_has_steam_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGameServerData_Player::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgGameServerData_Player::clear_steam_id() {
  steam_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGameServerData_Player::_internal_steam_id() const {
  return steam_id_;
}
inline uint64_t CMsgGameServerData_Player::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.Player.steam_id)
  return _internal_steam_id();
}
inline void CMsgGameServerData_Player::_internal_set_steam_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_ = value;
}
inline void CMsgGameServerData_Player::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.Player.steam_id)
}

// -------------------------------------------------------------------

// CMsgGameServerData

// optional uint32 revision = 24;
inline bool CMsgGameServerData::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_revision() const {
  return _internal_has_revision();
}
inline void CMsgGameServerData::clear_revision() {
  revision_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CMsgGameServerData::_internal_revision() const {
  return revision_;
}
inline uint32_t CMsgGameServerData::revision() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.revision)
  return _internal_revision();
}
inline void CMsgGameServerData::_internal_set_revision(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  revision_ = value;
}
inline void CMsgGameServerData::set_revision(uint32_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.revision)
}

// optional uint32 query_port = 3;
inline bool CMsgGameServerData::_internal_has_query_port() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_query_port() const {
  return _internal_has_query_port();
}
inline void CMsgGameServerData::clear_query_port() {
  query_port_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgGameServerData::_internal_query_port() const {
  return query_port_;
}
inline uint32_t CMsgGameServerData::query_port() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.query_port)
  return _internal_query_port();
}
inline void CMsgGameServerData::_internal_set_query_port(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  query_port_ = value;
}
inline void CMsgGameServerData::set_query_port(uint32_t value) {
  _internal_set_query_port(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.query_port)
}

// optional uint32 game_port = 4;
inline bool CMsgGameServerData::_internal_has_game_port() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_game_port() const {
  return _internal_has_game_port();
}
inline void CMsgGameServerData::clear_game_port() {
  game_port_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CMsgGameServerData::_internal_game_port() const {
  return game_port_;
}
inline uint32_t CMsgGameServerData::game_port() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.game_port)
  return _internal_game_port();
}
inline void CMsgGameServerData::_internal_set_game_port(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  game_port_ = value;
}
inline void CMsgGameServerData::set_game_port(uint32_t value) {
  _internal_set_game_port(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.game_port)
}

// optional uint32 spectator_port = 5;
inline bool CMsgGameServerData::_internal_has_spectator_port() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_spectator_port() const {
  return _internal_has_spectator_port();
}
inline void CMsgGameServerData::clear_spectator_port() {
  spectator_port_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t CMsgGameServerData::_internal_spectator_port() const {
  return spectator_port_;
}
inline uint32_t CMsgGameServerData::spectator_port() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.spectator_port)
  return _internal_spectator_port();
}
inline void CMsgGameServerData::_internal_set_spectator_port(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  spectator_port_ = value;
}
inline void CMsgGameServerData::set_spectator_port(uint32_t value) {
  _internal_set_spectator_port(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.spectator_port)
}

// optional string server_name = 22;
inline bool CMsgGameServerData::_internal_has_server_name() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_server_name() const {
  return _internal_has_server_name();
}
inline void CMsgGameServerData::clear_server_name() {
  server_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000100u;
}
inline const std::string& CMsgGameServerData::server_name() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.server_name)
  return _internal_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_server_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000100u;
 server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.server_name)
}
inline std::string* CMsgGameServerData::mutable_server_name() {
  std::string* _s = _internal_mutable_server_name();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.server_name)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_server_name() const {
  return server_name_.Get();
}
inline void CMsgGameServerData::_internal_set_server_name(const std::string& value) {
  _has_bits_[0] |= 0x00000100u;
  server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_server_name() {
  _has_bits_[0] |= 0x00000100u;
  return server_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_server_name() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.server_name)
  if (!_internal_has_server_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000100u;
  auto* p = server_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_server_name(std::string* server_name) {
  if (server_name != nullptr) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  server_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), server_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (server_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    server_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.server_name)
}

// optional string game_description = 29;
inline bool CMsgGameServerData::_internal_has_game_description() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_game_description() const {
  return _internal_has_game_description();
}
inline void CMsgGameServerData::clear_game_description() {
  game_description_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000400u;
}
inline const std::string& CMsgGameServerData::game_description() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.game_description)
  return _internal_game_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_game_description(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000400u;
 game_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.game_description)
}
inline std::string* CMsgGameServerData::mutable_game_description() {
  std::string* _s = _internal_mutable_game_description();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.game_description)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_game_description() const {
  return game_description_.Get();
}
inline void CMsgGameServerData::_internal_set_game_description(const std::string& value) {
  _has_bits_[0] |= 0x00000400u;
  game_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_game_description() {
  _has_bits_[0] |= 0x00000400u;
  return game_description_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_game_description() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.game_description)
  if (!_internal_has_game_description()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000400u;
  auto* p = game_description_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_game_description(std::string* game_description) {
  if (game_description != nullptr) {
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  game_description_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_description,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_description_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.game_description)
}

// optional string spectator_server_name = 27;
inline bool CMsgGameServerData::_internal_has_spectator_server_name() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_spectator_server_name() const {
  return _internal_has_spectator_server_name();
}
inline void CMsgGameServerData::clear_spectator_server_name() {
  spectator_server_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000200u;
}
inline const std::string& CMsgGameServerData::spectator_server_name() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.spectator_server_name)
  return _internal_spectator_server_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_spectator_server_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000200u;
 spectator_server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.spectator_server_name)
}
inline std::string* CMsgGameServerData::mutable_spectator_server_name() {
  std::string* _s = _internal_mutable_spectator_server_name();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.spectator_server_name)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_spectator_server_name() const {
  return spectator_server_name_.Get();
}
inline void CMsgGameServerData::_internal_set_spectator_server_name(const std::string& value) {
  _has_bits_[0] |= 0x00000200u;
  spectator_server_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_spectator_server_name() {
  _has_bits_[0] |= 0x00000200u;
  return spectator_server_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_spectator_server_name() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.spectator_server_name)
  if (!_internal_has_spectator_server_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000200u;
  auto* p = spectator_server_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spectator_server_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    spectator_server_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_spectator_server_name(std::string* spectator_server_name) {
  if (spectator_server_name != nullptr) {
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  spectator_server_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spectator_server_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spectator_server_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    spectator_server_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.spectator_server_name)
}

// optional fixed32 fake_ip = 28;
inline bool CMsgGameServerData::_internal_has_fake_ip() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_fake_ip() const {
  return _internal_has_fake_ip();
}
inline void CMsgGameServerData::clear_fake_ip() {
  fake_ip_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline uint32_t CMsgGameServerData::_internal_fake_ip() const {
  return fake_ip_;
}
inline uint32_t CMsgGameServerData::fake_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.fake_ip)
  return _internal_fake_ip();
}
inline void CMsgGameServerData::_internal_set_fake_ip(uint32_t value) {
  _has_bits_[0] |= 0x00400000u;
  fake_ip_ = value;
}
inline void CMsgGameServerData::set_fake_ip(uint32_t value) {
  _internal_set_fake_ip(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.fake_ip)
}

// optional string sdr_ping_location = 30;
inline bool CMsgGameServerData::_internal_has_sdr_ping_location() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_sdr_ping_location() const {
  return _internal_has_sdr_ping_location();
}
inline void CMsgGameServerData::clear_sdr_ping_location() {
  sdr_ping_location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000800u;
}
inline const std::string& CMsgGameServerData::sdr_ping_location() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.sdr_ping_location)
  return _internal_sdr_ping_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_sdr_ping_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000800u;
 sdr_ping_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.sdr_ping_location)
}
inline std::string* CMsgGameServerData::mutable_sdr_ping_location() {
  std::string* _s = _internal_mutable_sdr_ping_location();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.sdr_ping_location)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_sdr_ping_location() const {
  return sdr_ping_location_.Get();
}
inline void CMsgGameServerData::_internal_set_sdr_ping_location(const std::string& value) {
  _has_bits_[0] |= 0x00000800u;
  sdr_ping_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_sdr_ping_location() {
  _has_bits_[0] |= 0x00000800u;
  return sdr_ping_location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_sdr_ping_location() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.sdr_ping_location)
  if (!_internal_has_sdr_ping_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000800u;
  auto* p = sdr_ping_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_ping_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_ping_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_sdr_ping_location(std::string* sdr_ping_location) {
  if (sdr_ping_location != nullptr) {
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  sdr_ping_location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdr_ping_location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_ping_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_ping_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.sdr_ping_location)
}

// optional uint32 app_id = 6;
inline bool CMsgGameServerData::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_app_id() const {
  return _internal_has_app_id();
}
inline void CMsgGameServerData::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CMsgGameServerData::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CMsgGameServerData::app_id() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.app_id)
  return _internal_app_id();
}
inline void CMsgGameServerData::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00008000u;
  app_id_ = value;
}
inline void CMsgGameServerData::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.app_id)
}

// optional string gamedir = 7;
inline bool CMsgGameServerData::_internal_has_gamedir() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_gamedir() const {
  return _internal_has_gamedir();
}
inline void CMsgGameServerData::clear_gamedir() {
  gamedir_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGameServerData::gamedir() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.gamedir)
  return _internal_gamedir();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_gamedir(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 gamedir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.gamedir)
}
inline std::string* CMsgGameServerData::mutable_gamedir() {
  std::string* _s = _internal_mutable_gamedir();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.gamedir)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_gamedir() const {
  return gamedir_.Get();
}
inline void CMsgGameServerData::_internal_set_gamedir(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamedir_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_gamedir() {
  _has_bits_[0] |= 0x00000001u;
  return gamedir_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_gamedir() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.gamedir)
  if (!_internal_has_gamedir()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = gamedir_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamedir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamedir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_gamedir(std::string* gamedir) {
  if (gamedir != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamedir_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamedir,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamedir_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamedir_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.gamedir)
}

// optional string version = 8;
inline bool CMsgGameServerData::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_version() const {
  return _internal_has_version();
}
inline void CMsgGameServerData::clear_version() {
  version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgGameServerData::version() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.version)
  return _internal_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.version)
}
inline std::string* CMsgGameServerData::mutable_version() {
  std::string* _s = _internal_mutable_version();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.version)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_version() const {
  return version_.Get();
}
inline void CMsgGameServerData::_internal_set_version(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_version() {
  _has_bits_[0] |= 0x00000002u;
  return version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_version() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.version)
  if (!_internal_has_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_version(std::string* version) {
  if (version != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.version)
}

// optional string product = 9;
inline bool CMsgGameServerData::_internal_has_product() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_product() const {
  return _internal_has_product();
}
inline void CMsgGameServerData::clear_product() {
  product_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgGameServerData::product() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.product)
  return _internal_product();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_product(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.product)
}
inline std::string* CMsgGameServerData::mutable_product() {
  std::string* _s = _internal_mutable_product();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.product)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_product() const {
  return product_.Get();
}
inline void CMsgGameServerData::_internal_set_product(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  product_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_product() {
  _has_bits_[0] |= 0x00000004u;
  return product_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_product() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.product)
  if (!_internal_has_product()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = product_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (product_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_product(std::string* product) {
  if (product != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  product_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), product,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (product_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    product_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.product)
}

// optional string region = 10;
inline bool CMsgGameServerData::_internal_has_region() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_region() const {
  return _internal_has_region();
}
inline void CMsgGameServerData::clear_region() {
  region_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgGameServerData::region() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.region)
  return _internal_region();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_region(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.region)
}
inline std::string* CMsgGameServerData::mutable_region() {
  std::string* _s = _internal_mutable_region();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.region)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_region() const {
  return region_.Get();
}
inline void CMsgGameServerData::_internal_set_region(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  region_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_region() {
  _has_bits_[0] |= 0x00000008u;
  return region_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_region() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.region)
  if (!_internal_has_region()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = region_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_region(std::string* region) {
  if (region != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  region_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), region,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (region_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    region_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.region)
}

// repeated .CMsgGameServerData.Player players = 11;
inline int CMsgGameServerData::_internal_players_size() const {
  return players_.size();
}
inline int CMsgGameServerData::players_size() const {
  return _internal_players_size();
}
inline void CMsgGameServerData::clear_players() {
  players_.Clear();
}
inline ::CMsgGameServerData_Player* CMsgGameServerData::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGameServerData_Player >*
CMsgGameServerData::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGameServerData.players)
  return &players_;
}
inline const ::CMsgGameServerData_Player& CMsgGameServerData::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::CMsgGameServerData_Player& CMsgGameServerData::players(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.players)
  return _internal_players(index);
}
inline ::CMsgGameServerData_Player* CMsgGameServerData::_internal_add_players() {
  return players_.Add();
}
inline ::CMsgGameServerData_Player* CMsgGameServerData::add_players() {
  ::CMsgGameServerData_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:CMsgGameServerData.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGameServerData_Player >&
CMsgGameServerData::players() const {
  // @@protoc_insertion_point(field_list:CMsgGameServerData.players)
  return players_;
}

// optional uint32 max_players = 12;
inline bool CMsgGameServerData::_internal_has_max_players() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_max_players() const {
  return _internal_has_max_players();
}
inline void CMsgGameServerData::clear_max_players() {
  max_players_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t CMsgGameServerData::_internal_max_players() const {
  return max_players_;
}
inline uint32_t CMsgGameServerData::max_players() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.max_players)
  return _internal_max_players();
}
inline void CMsgGameServerData::_internal_set_max_players(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  max_players_ = value;
}
inline void CMsgGameServerData::set_max_players(uint32_t value) {
  _internal_set_max_players(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.max_players)
}

// optional uint32 bot_count = 13;
inline bool CMsgGameServerData::_internal_has_bot_count() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_bot_count() const {
  return _internal_has_bot_count();
}
inline void CMsgGameServerData::clear_bot_count() {
  bot_count_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CMsgGameServerData::_internal_bot_count() const {
  return bot_count_;
}
inline uint32_t CMsgGameServerData::bot_count() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.bot_count)
  return _internal_bot_count();
}
inline void CMsgGameServerData::_internal_set_bot_count(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  bot_count_ = value;
}
inline void CMsgGameServerData::set_bot_count(uint32_t value) {
  _internal_set_bot_count(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.bot_count)
}

// optional bool password = 14;
inline bool CMsgGameServerData::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_password() const {
  return _internal_has_password();
}
inline void CMsgGameServerData::clear_password() {
  password_ = false;
  _has_bits_[0] &= ~0x00040000u;
}
inline bool CMsgGameServerData::_internal_password() const {
  return password_;
}
inline bool CMsgGameServerData::password() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.password)
  return _internal_password();
}
inline void CMsgGameServerData::_internal_set_password(bool value) {
  _has_bits_[0] |= 0x00040000u;
  password_ = value;
}
inline void CMsgGameServerData::set_password(bool value) {
  _internal_set_password(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.password)
}

// optional bool secure = 15;
inline bool CMsgGameServerData::_internal_has_secure() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_secure() const {
  return _internal_has_secure();
}
inline void CMsgGameServerData::clear_secure() {
  secure_ = false;
  _has_bits_[0] &= ~0x00080000u;
}
inline bool CMsgGameServerData::_internal_secure() const {
  return secure_;
}
inline bool CMsgGameServerData::secure() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.secure)
  return _internal_secure();
}
inline void CMsgGameServerData::_internal_set_secure(bool value) {
  _has_bits_[0] |= 0x00080000u;
  secure_ = value;
}
inline void CMsgGameServerData::set_secure(bool value) {
  _internal_set_secure(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.secure)
}

// optional bool dedicated = 16;
inline bool CMsgGameServerData::_internal_has_dedicated() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_dedicated() const {
  return _internal_has_dedicated();
}
inline void CMsgGameServerData::clear_dedicated() {
  dedicated_ = false;
  _has_bits_[0] &= ~0x00100000u;
}
inline bool CMsgGameServerData::_internal_dedicated() const {
  return dedicated_;
}
inline bool CMsgGameServerData::dedicated() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.dedicated)
  return _internal_dedicated();
}
inline void CMsgGameServerData::_internal_set_dedicated(bool value) {
  _has_bits_[0] |= 0x00100000u;
  dedicated_ = value;
}
inline void CMsgGameServerData::set_dedicated(bool value) {
  _internal_set_dedicated(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerData.dedicated)
}

// optional string os = 17;
inline bool CMsgGameServerData::_internal_has_os() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_os() const {
  return _internal_has_os();
}
inline void CMsgGameServerData::clear_os() {
  os_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgGameServerData::os() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.os)
  return _internal_os();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_os(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.os)
}
inline std::string* CMsgGameServerData::mutable_os() {
  std::string* _s = _internal_mutable_os();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.os)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_os() const {
  return os_.Get();
}
inline void CMsgGameServerData::_internal_set_os(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  os_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_os() {
  _has_bits_[0] |= 0x00000010u;
  return os_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_os() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.os)
  if (!_internal_has_os()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = os_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_os(std::string* os) {
  if (os != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  os_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), os,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (os_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    os_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.os)
}

// optional string game_data = 18;
inline bool CMsgGameServerData::_internal_has_game_data() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_game_data() const {
  return _internal_has_game_data();
}
inline void CMsgGameServerData::clear_game_data() {
  game_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CMsgGameServerData::game_data() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.game_data)
  return _internal_game_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_game_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 game_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.game_data)
}
inline std::string* CMsgGameServerData::mutable_game_data() {
  std::string* _s = _internal_mutable_game_data();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.game_data)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_game_data() const {
  return game_data_.Get();
}
inline void CMsgGameServerData::_internal_set_game_data(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  game_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_game_data() {
  _has_bits_[0] |= 0x00000020u;
  return game_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_game_data() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.game_data)
  if (!_internal_has_game_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = game_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_game_data(std::string* game_data) {
  if (game_data != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  game_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.game_data)
}

// optional string game_type = 20;
inline bool CMsgGameServerData::_internal_has_game_type() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_game_type() const {
  return _internal_has_game_type();
}
inline void CMsgGameServerData::clear_game_type() {
  game_type_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CMsgGameServerData::game_type() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.game_type)
  return _internal_game_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_game_type(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 game_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.game_type)
}
inline std::string* CMsgGameServerData::mutable_game_type() {
  std::string* _s = _internal_mutable_game_type();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.game_type)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_game_type() const {
  return game_type_.Get();
}
inline void CMsgGameServerData::_internal_set_game_type(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  game_type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_game_type() {
  _has_bits_[0] |= 0x00000040u;
  return game_type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_game_type() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.game_type)
  if (!_internal_has_game_type()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = game_type_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_game_type(std::string* game_type) {
  if (game_type != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  game_type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_type,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_type_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.game_type)
}

// optional string map = 21;
inline bool CMsgGameServerData::_internal_has_map() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgGameServerData::has_map() const {
  return _internal_has_map();
}
inline void CMsgGameServerData::clear_map() {
  map_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CMsgGameServerData::map() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerData.map)
  return _internal_map();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerData::set_map(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 map_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerData.map)
}
inline std::string* CMsgGameServerData::mutable_map() {
  std::string* _s = _internal_mutable_map();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerData.map)
  return _s;
}
inline const std::string& CMsgGameServerData::_internal_map() const {
  return map_.Get();
}
inline void CMsgGameServerData::_internal_set_map(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  map_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::_internal_mutable_map() {
  _has_bits_[0] |= 0x00000080u;
  return map_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerData::release_map() {
  // @@protoc_insertion_point(field_release:CMsgGameServerData.map)
  if (!_internal_has_map()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = map_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerData::set_allocated_map(std::string* map) {
  if (map != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  map_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerData.map)
}

// -------------------------------------------------------------------

// CMsgGameServerRemove

// optional fixed64 legacy_steam_id_gs = 1;
inline bool CMsgGameServerRemove::_internal_has_legacy_steam_id_gs() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGameServerRemove::has_legacy_steam_id_gs() const {
  return _internal_has_legacy_steam_id_gs();
}
inline void CMsgGameServerRemove::clear_legacy_steam_id_gs() {
  legacy_steam_id_gs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGameServerRemove::_internal_legacy_steam_id_gs() const {
  return legacy_steam_id_gs_;
}
inline uint64_t CMsgGameServerRemove::legacy_steam_id_gs() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerRemove.legacy_steam_id_gs)
  return _internal_legacy_steam_id_gs();
}
inline void CMsgGameServerRemove::_internal_set_legacy_steam_id_gs(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  legacy_steam_id_gs_ = value;
}
inline void CMsgGameServerRemove::set_legacy_steam_id_gs(uint64_t value) {
  _internal_set_legacy_steam_id_gs(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerRemove.legacy_steam_id_gs)
}

// optional uint32 legacy_query_port = 3;
inline bool CMsgGameServerRemove::_internal_has_legacy_query_port() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGameServerRemove::has_legacy_query_port() const {
  return _internal_has_legacy_query_port();
}
inline void CMsgGameServerRemove::clear_legacy_query_port() {
  legacy_query_port_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgGameServerRemove::_internal_legacy_query_port() const {
  return legacy_query_port_;
}
inline uint32_t CMsgGameServerRemove::legacy_query_port() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerRemove.legacy_query_port)
  return _internal_legacy_query_port();
}
inline void CMsgGameServerRemove::_internal_set_legacy_query_port(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  legacy_query_port_ = value;
}
inline void CMsgGameServerRemove::set_legacy_query_port(uint32_t value) {
  _internal_set_legacy_query_port(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerRemove.legacy_query_port)
}

// -------------------------------------------------------------------

// CMsgClientGMSServerQuery

// optional uint32 app_id = 1;
inline bool CMsgClientGMSServerQuery::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgClientGMSServerQuery::has_app_id() const {
  return _internal_has_app_id();
}
inline void CMsgClientGMSServerQuery::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgClientGMSServerQuery::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CMsgClientGMSServerQuery::app_id() const {
  // @@protoc_insertion_point(field_get:CMsgClientGMSServerQuery.app_id)
  return _internal_app_id();
}
inline void CMsgClientGMSServerQuery::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  app_id_ = value;
}
inline void CMsgClientGMSServerQuery::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CMsgClientGMSServerQuery.app_id)
}

// optional uint32 geo_location_ip = 2;
inline bool CMsgClientGMSServerQuery::_internal_has_geo_location_ip() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgClientGMSServerQuery::has_geo_location_ip() const {
  return _internal_has_geo_location_ip();
}
inline void CMsgClientGMSServerQuery::clear_geo_location_ip() {
  geo_location_ip_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CMsgClientGMSServerQuery::_internal_geo_location_ip() const {
  return geo_location_ip_;
}
inline uint32_t CMsgClientGMSServerQuery::geo_location_ip() const {
  // @@protoc_insertion_point(field_get:CMsgClientGMSServerQuery.geo_location_ip)
  return _internal_geo_location_ip();
}
inline void CMsgClientGMSServerQuery::_internal_set_geo_location_ip(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  geo_location_ip_ = value;
}
inline void CMsgClientGMSServerQuery::set_geo_location_ip(uint32_t value) {
  _internal_set_geo_location_ip(value);
  // @@protoc_insertion_point(field_set:CMsgClientGMSServerQuery.geo_location_ip)
}

// optional uint32 region_code = 3;
inline bool CMsgClientGMSServerQuery::_internal_has_region_code() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgClientGMSServerQuery::has_region_code() const {
  return _internal_has_region_code();
}
inline void CMsgClientGMSServerQuery::clear_region_code() {
  region_code_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgClientGMSServerQuery::_internal_region_code() const {
  return region_code_;
}
inline uint32_t CMsgClientGMSServerQuery::region_code() const {
  // @@protoc_insertion_point(field_get:CMsgClientGMSServerQuery.region_code)
  return _internal_region_code();
}
inline void CMsgClientGMSServerQuery::_internal_set_region_code(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  region_code_ = value;
}
inline void CMsgClientGMSServerQuery::set_region_code(uint32_t value) {
  _internal_set_region_code(value);
  // @@protoc_insertion_point(field_set:CMsgClientGMSServerQuery.region_code)
}

// optional string filter_text = 4;
inline bool CMsgClientGMSServerQuery::_internal_has_filter_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgClientGMSServerQuery::has_filter_text() const {
  return _internal_has_filter_text();
}
inline void CMsgClientGMSServerQuery::clear_filter_text() {
  filter_text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgClientGMSServerQuery::filter_text() const {
  // @@protoc_insertion_point(field_get:CMsgClientGMSServerQuery.filter_text)
  return _internal_filter_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgClientGMSServerQuery::set_filter_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 filter_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgClientGMSServerQuery.filter_text)
}
inline std::string* CMsgClientGMSServerQuery::mutable_filter_text() {
  std::string* _s = _internal_mutable_filter_text();
  // @@protoc_insertion_point(field_mutable:CMsgClientGMSServerQuery.filter_text)
  return _s;
}
inline const std::string& CMsgClientGMSServerQuery::_internal_filter_text() const {
  return filter_text_.Get();
}
inline void CMsgClientGMSServerQuery::_internal_set_filter_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  filter_text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgClientGMSServerQuery::_internal_mutable_filter_text() {
  _has_bits_[0] |= 0x00000001u;
  return filter_text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgClientGMSServerQuery::release_filter_text() {
  // @@protoc_insertion_point(field_release:CMsgClientGMSServerQuery.filter_text)
  if (!_internal_has_filter_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = filter_text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filter_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgClientGMSServerQuery::set_allocated_filter_text(std::string* filter_text) {
  if (filter_text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  filter_text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filter_text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filter_text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filter_text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgClientGMSServerQuery.filter_text)
}

// optional uint32 max_servers = 5;
inline bool CMsgClientGMSServerQuery::_internal_has_max_servers() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgClientGMSServerQuery::has_max_servers() const {
  return _internal_has_max_servers();
}
inline void CMsgClientGMSServerQuery::clear_max_servers() {
  max_servers_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgClientGMSServerQuery::_internal_max_servers() const {
  return max_servers_;
}
inline uint32_t CMsgClientGMSServerQuery::max_servers() const {
  // @@protoc_insertion_point(field_get:CMsgClientGMSServerQuery.max_servers)
  return _internal_max_servers();
}
inline void CMsgClientGMSServerQuery::_internal_set_max_servers(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  max_servers_ = value;
}
inline void CMsgClientGMSServerQuery::set_max_servers(uint32_t value) {
  _internal_set_max_servers(value);
  // @@protoc_insertion_point(field_set:CMsgClientGMSServerQuery.max_servers)
}

// -------------------------------------------------------------------

// CMsgGMSClientServerQueryResponse_Server

// optional uint32 deprecated_server_ip = 1;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_deprecated_server_ip() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_deprecated_server_ip() const {
  return _internal_has_deprecated_server_ip();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_deprecated_server_ip() {
  deprecated_server_ip_ = 0u;
  _has_bits_[0] &= ~0x00000200u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_deprecated_server_ip() const {
  return deprecated_server_ip_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::deprecated_server_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.deprecated_server_ip)
  return _internal_deprecated_server_ip();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_deprecated_server_ip(uint32_t value) {
  _has_bits_[0] |= 0x00000200u;
  deprecated_server_ip_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_deprecated_server_ip(uint32_t value) {
  _internal_set_deprecated_server_ip(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.deprecated_server_ip)
}

// optional uint32 query_port = 2;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_query_port() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_query_port() const {
  return _internal_has_query_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_query_port() {
  query_port_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_query_port() const {
  return query_port_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::query_port() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.query_port)
  return _internal_query_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_query_port(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  query_port_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_query_port(uint32_t value) {
  _internal_set_query_port(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.query_port)
}

// optional uint32 auth_players = 3;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_auth_players() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_auth_players() const {
  return _internal_has_auth_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_auth_players() {
  auth_players_ = 0u;
  _has_bits_[0] &= ~0x00000800u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_auth_players() const {
  return auth_players_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::auth_players() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.auth_players)
  return _internal_auth_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_auth_players(uint32_t value) {
  _has_bits_[0] |= 0x00000800u;
  auth_players_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_auth_players(uint32_t value) {
  _internal_set_auth_players(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.auth_players)
}

// optional .CMsgIPAddress server_ip = 4;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_server_ip() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || server_ip_ != nullptr);
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_server_ip() const {
  return _internal_has_server_ip();
}
inline const ::CMsgIPAddress& CMsgGMSClientServerQueryResponse_Server::_internal_server_ip() const {
  const ::CMsgIPAddress* p = server_ip_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgIPAddress&>(
      ::_CMsgIPAddress_default_instance_);
}
inline const ::CMsgIPAddress& CMsgGMSClientServerQueryResponse_Server::server_ip() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.server_ip)
  return _internal_server_ip();
}
inline void CMsgGMSClientServerQueryResponse_Server::unsafe_arena_set_allocated_server_ip(
    ::CMsgIPAddress* server_ip) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_ip_);
  }
  server_ip_ = server_ip;
  if (server_ip) {
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgGMSClientServerQueryResponse.Server.server_ip)
}
inline ::CMsgIPAddress* CMsgGMSClientServerQueryResponse_Server::release_server_ip() {
  _has_bits_[0] &= ~0x00000100u;
  ::CMsgIPAddress* temp = server_ip_;
  server_ip_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgIPAddress* CMsgGMSClientServerQueryResponse_Server::unsafe_arena_release_server_ip() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.server_ip)
  _has_bits_[0] &= ~0x00000100u;
  ::CMsgIPAddress* temp = server_ip_;
  server_ip_ = nullptr;
  return temp;
}
inline ::CMsgIPAddress* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_server_ip() {
  _has_bits_[0] |= 0x00000100u;
  if (server_ip_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgIPAddress>(GetArenaForAllocation());
    server_ip_ = p;
  }
  return server_ip_;
}
inline ::CMsgIPAddress* CMsgGMSClientServerQueryResponse_Server::mutable_server_ip() {
  ::CMsgIPAddress* _msg = _internal_mutable_server_ip();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.server_ip)
  return _msg;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_server_ip(::CMsgIPAddress* server_ip) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_ip_);
  }
  if (server_ip) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<
            ::PROTOBUF_NAMESPACE_ID::MessageLite>::GetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(server_ip));
    if (message_arena != submessage_arena) {
      server_ip = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, server_ip, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  server_ip_ = server_ip;
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.server_ip)
}

// optional fixed64 steam_id = 6;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_steam_id() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_steam_id() const {
  return _internal_has_steam_id();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_steam_id() {
  steam_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00002000u;
}
inline uint64_t CMsgGMSClientServerQueryResponse_Server::_internal_steam_id() const {
  return steam_id_;
}
inline uint64_t CMsgGMSClientServerQueryResponse_Server::steam_id() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.steam_id)
  return _internal_steam_id();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_steam_id(uint64_t value) {
  _has_bits_[0] |= 0x00002000u;
  steam_id_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_steam_id(uint64_t value) {
  _internal_set_steam_id(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.steam_id)
}

// optional uint32 revision = 7;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_revision() const {
  return _internal_has_revision();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_revision() {
  revision_ = 0u;
  _has_bits_[0] &= ~0x00001000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_revision() const {
  return revision_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::revision() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.revision)
  return _internal_revision();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_revision(uint32_t value) {
  _has_bits_[0] |= 0x00001000u;
  revision_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_revision(uint32_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.revision)
}

// optional uint32 players = 8;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_players() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_players() const {
  return _internal_has_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_players() {
  players_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_players() const {
  return players_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::players() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.players)
  return _internal_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_players(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  players_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_players(uint32_t value) {
  _internal_set_players(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.players)
}

// optional uint32 game_port = 9;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_game_port() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_game_port() const {
  return _internal_has_game_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_game_port() {
  game_port_ = 0u;
  _has_bits_[0] &= ~0x00008000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_game_port() const {
  return game_port_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::game_port() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.game_port)
  return _internal_game_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_game_port(uint32_t value) {
  _has_bits_[0] |= 0x00008000u;
  game_port_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_game_port(uint32_t value) {
  _internal_set_game_port(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.game_port)
}

// optional fixed32 sdr_popid = 10;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_sdr_popid() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_sdr_popid() const {
  return _internal_has_sdr_popid();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_sdr_popid() {
  sdr_popid_ = 0u;
  _has_bits_[0] &= ~0x00010000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_sdr_popid() const {
  return sdr_popid_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::sdr_popid() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.sdr_popid)
  return _internal_sdr_popid();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_sdr_popid(uint32_t value) {
  _has_bits_[0] |= 0x00010000u;
  sdr_popid_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_sdr_popid(uint32_t value) {
  _internal_set_sdr_popid(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.sdr_popid)
}

// optional string sdr_ping_location = 32;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_sdr_ping_location() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_sdr_ping_location() const {
  return _internal_has_sdr_ping_location();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_sdr_ping_location() {
  sdr_ping_location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000080u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::sdr_ping_location() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
  return _internal_sdr_ping_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_sdr_ping_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000080u;
 sdr_ping_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_sdr_ping_location() {
  std::string* _s = _internal_mutable_sdr_ping_location();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_sdr_ping_location() const {
  return sdr_ping_location_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_sdr_ping_location(const std::string& value) {
  _has_bits_[0] |= 0x00000080u;
  sdr_ping_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_sdr_ping_location() {
  _has_bits_[0] |= 0x00000080u;
  return sdr_ping_location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_sdr_ping_location() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
  if (!_internal_has_sdr_ping_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000080u;
  auto* p = sdr_ping_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_ping_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_ping_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_sdr_ping_location(std::string* sdr_ping_location) {
  if (sdr_ping_location != nullptr) {
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  sdr_ping_location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdr_ping_location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdr_ping_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdr_ping_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.sdr_ping_location)
}

// optional uint32 flags = 11;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_flags() const {
  return _internal_has_flags();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00020000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_flags() const {
  return flags_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::flags() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.flags)
  return _internal_flags();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_flags(uint32_t value) {
  _has_bits_[0] |= 0x00020000u;
  flags_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.flags)
}

// optional uint32 app_id = 12;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_app_id() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_app_id() const {
  return _internal_has_app_id();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_app_id() {
  app_id_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_app_id() const {
  return app_id_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::app_id() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.app_id)
  return _internal_app_id();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_app_id(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  app_id_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_app_id(uint32_t value) {
  _internal_set_app_id(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.app_id)
}

// optional uint32 max_players = 13;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_max_players() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_max_players() const {
  return _internal_has_max_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_max_players() {
  max_players_ = 0u;
  _has_bits_[0] &= ~0x00080000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_max_players() const {
  return max_players_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::max_players() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.max_players)
  return _internal_max_players();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_max_players(uint32_t value) {
  _has_bits_[0] |= 0x00080000u;
  max_players_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_max_players(uint32_t value) {
  _internal_set_max_players(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.max_players)
}

// optional uint32 bots = 14;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_bots() const {
  bool value = (_has_bits_[0] & 0x00100000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_bots() const {
  return _internal_has_bots();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_bots() {
  bots_ = 0u;
  _has_bits_[0] &= ~0x00100000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_bots() const {
  return bots_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::bots() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.bots)
  return _internal_bots();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_bots(uint32_t value) {
  _has_bits_[0] |= 0x00100000u;
  bots_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_bots(uint32_t value) {
  _internal_set_bots(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.bots)
}

// optional uint32 spectator_port = 15;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_spectator_port() const {
  bool value = (_has_bits_[0] & 0x00200000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_spectator_port() const {
  return _internal_has_spectator_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_spectator_port() {
  spectator_port_ = 0u;
  _has_bits_[0] &= ~0x00200000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_spectator_port() const {
  return spectator_port_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::spectator_port() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.spectator_port)
  return _internal_spectator_port();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_spectator_port(uint32_t value) {
  _has_bits_[0] |= 0x00200000u;
  spectator_port_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_spectator_port(uint32_t value) {
  _internal_set_spectator_port(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.spectator_port)
}

// optional string gamedir_str = 16;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_gamedir_str() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_gamedir_str() const {
  return _internal_has_gamedir_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_gamedir_str() {
  gamedir_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::gamedir_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
  return _internal_gamedir_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_gamedir_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 gamedir_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_gamedir_str() {
  std::string* _s = _internal_mutable_gamedir_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_gamedir_str() const {
  return gamedir_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_gamedir_str(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamedir_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_gamedir_str() {
  _has_bits_[0] |= 0x00000001u;
  return gamedir_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_gamedir_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
  if (!_internal_has_gamedir_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = gamedir_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamedir_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamedir_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_gamedir_str(std::string* gamedir_str) {
  if (gamedir_str != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamedir_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamedir_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamedir_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamedir_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.gamedir_str)
}

// optional uint32 gamedir_strindex = 17;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_gamedir_strindex() const {
  bool value = (_has_bits_[0] & 0x00400000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_gamedir_strindex() const {
  return _internal_has_gamedir_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_gamedir_strindex() {
  gamedir_strindex_ = 0u;
  _has_bits_[0] &= ~0x00400000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_gamedir_strindex() const {
  return gamedir_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::gamedir_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.gamedir_strindex)
  return _internal_gamedir_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_gamedir_strindex(uint32_t value) {
  _has_bits_[0] |= 0x00400000u;
  gamedir_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_gamedir_strindex(uint32_t value) {
  _internal_set_gamedir_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.gamedir_strindex)
}

// optional string map_str = 18;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_map_str() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_map_str() const {
  return _internal_has_map_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_map_str() {
  map_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::map_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.map_str)
  return _internal_map_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_map_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 map_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.map_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_map_str() {
  std::string* _s = _internal_mutable_map_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.map_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_map_str() const {
  return map_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_map_str(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  map_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_map_str() {
  _has_bits_[0] |= 0x00000002u;
  return map_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_map_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.map_str)
  if (!_internal_has_map_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = map_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_map_str(std::string* map_str) {
  if (map_str != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  map_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), map_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (map_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    map_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.map_str)
}

// optional uint32 map_strindex = 19;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_map_strindex() const {
  bool value = (_has_bits_[0] & 0x00800000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_map_strindex() const {
  return _internal_has_map_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_map_strindex() {
  map_strindex_ = 0u;
  _has_bits_[0] &= ~0x00800000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_map_strindex() const {
  return map_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::map_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.map_strindex)
  return _internal_map_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_map_strindex(uint32_t value) {
  _has_bits_[0] |= 0x00800000u;
  map_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_map_strindex(uint32_t value) {
  _internal_set_map_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.map_strindex)
}

// optional string name_str = 20;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_name_str() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_name_str() const {
  return _internal_has_name_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_name_str() {
  name_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::name_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.name_str)
  return _internal_name_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_name_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 name_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.name_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_name_str() {
  std::string* _s = _internal_mutable_name_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.name_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_name_str() const {
  return name_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_name_str(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  name_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_name_str() {
  _has_bits_[0] |= 0x00000004u;
  return name_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_name_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.name_str)
  if (!_internal_has_name_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = name_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_name_str(std::string* name_str) {
  if (name_str != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  name_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    name_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.name_str)
}

// optional uint32 name_strindex = 21;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_name_strindex() const {
  bool value = (_has_bits_[0] & 0x01000000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_name_strindex() const {
  return _internal_has_name_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_name_strindex() {
  name_strindex_ = 0u;
  _has_bits_[0] &= ~0x01000000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_name_strindex() const {
  return name_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::name_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.name_strindex)
  return _internal_name_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_name_strindex(uint32_t value) {
  _has_bits_[0] |= 0x01000000u;
  name_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_name_strindex(uint32_t value) {
  _internal_set_name_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.name_strindex)
}

// optional string game_description_str = 22;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_game_description_str() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_game_description_str() const {
  return _internal_has_game_description_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_game_description_str() {
  game_description_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::game_description_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.game_description_str)
  return _internal_game_description_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_game_description_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 game_description_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.game_description_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_game_description_str() {
  std::string* _s = _internal_mutable_game_description_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.game_description_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_game_description_str() const {
  return game_description_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_game_description_str(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  game_description_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_game_description_str() {
  _has_bits_[0] |= 0x00000008u;
  return game_description_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_game_description_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.game_description_str)
  if (!_internal_has_game_description_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = game_description_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_description_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_description_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_game_description_str(std::string* game_description_str) {
  if (game_description_str != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  game_description_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_description_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_description_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_description_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.game_description_str)
}

// optional uint32 game_description_strindex = 23;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_game_description_strindex() const {
  bool value = (_has_bits_[0] & 0x02000000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_game_description_strindex() const {
  return _internal_has_game_description_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_game_description_strindex() {
  game_description_strindex_ = 0u;
  _has_bits_[0] &= ~0x02000000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_game_description_strindex() const {
  return game_description_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::game_description_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.game_description_strindex)
  return _internal_game_description_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_game_description_strindex(uint32_t value) {
  _has_bits_[0] |= 0x02000000u;
  game_description_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_game_description_strindex(uint32_t value) {
  _internal_set_game_description_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.game_description_strindex)
}

// optional string version_str = 24;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_version_str() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_version_str() const {
  return _internal_has_version_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_version_str() {
  version_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::version_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.version_str)
  return _internal_version_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_version_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 version_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.version_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_version_str() {
  std::string* _s = _internal_mutable_version_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.version_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_version_str() const {
  return version_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_version_str(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  version_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_version_str() {
  _has_bits_[0] |= 0x00000010u;
  return version_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_version_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.version_str)
  if (!_internal_has_version_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = version_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_version_str(std::string* version_str) {
  if (version_str != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  version_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), version_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (version_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    version_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.version_str)
}

// optional uint32 version_strindex = 25;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_version_strindex() const {
  bool value = (_has_bits_[0] & 0x04000000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_version_strindex() const {
  return _internal_has_version_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_version_strindex() {
  version_strindex_ = 0u;
  _has_bits_[0] &= ~0x04000000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_version_strindex() const {
  return version_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::version_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.version_strindex)
  return _internal_version_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_version_strindex(uint32_t value) {
  _has_bits_[0] |= 0x04000000u;
  version_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_version_strindex(uint32_t value) {
  _internal_set_version_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.version_strindex)
}

// optional string gametype_str = 26;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_gametype_str() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_gametype_str() const {
  return _internal_has_gametype_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_gametype_str() {
  gametype_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000020u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::gametype_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.gametype_str)
  return _internal_gametype_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_gametype_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000020u;
 gametype_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.gametype_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_gametype_str() {
  std::string* _s = _internal_mutable_gametype_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.gametype_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_gametype_str() const {
  return gametype_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_gametype_str(const std::string& value) {
  _has_bits_[0] |= 0x00000020u;
  gametype_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_gametype_str() {
  _has_bits_[0] |= 0x00000020u;
  return gametype_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_gametype_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.gametype_str)
  if (!_internal_has_gametype_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000020u;
  auto* p = gametype_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gametype_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gametype_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_gametype_str(std::string* gametype_str) {
  if (gametype_str != nullptr) {
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  gametype_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gametype_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gametype_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gametype_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.gametype_str)
}

// optional uint32 gametype_strindex = 27;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_gametype_strindex() const {
  bool value = (_has_bits_[0] & 0x08000000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_gametype_strindex() const {
  return _internal_has_gametype_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_gametype_strindex() {
  gametype_strindex_ = 0u;
  _has_bits_[0] &= ~0x08000000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_gametype_strindex() const {
  return gametype_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::gametype_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.gametype_strindex)
  return _internal_gametype_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_gametype_strindex(uint32_t value) {
  _has_bits_[0] |= 0x08000000u;
  gametype_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_gametype_strindex(uint32_t value) {
  _internal_set_gametype_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.gametype_strindex)
}

// optional string spectator_name_str = 30;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_spectator_name_str() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_spectator_name_str() const {
  return _internal_has_spectator_name_str();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_spectator_name_str() {
  spectator_name_str_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000040u;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::spectator_name_str() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
  return _internal_spectator_name_str();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse_Server::set_spectator_name_str(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000040u;
 spectator_name_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::mutable_spectator_name_str() {
  std::string* _s = _internal_mutable_spectator_name_str();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse_Server::_internal_spectator_name_str() const {
  return spectator_name_str_.Get();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_spectator_name_str(const std::string& value) {
  _has_bits_[0] |= 0x00000040u;
  spectator_name_str_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::_internal_mutable_spectator_name_str() {
  _has_bits_[0] |= 0x00000040u;
  return spectator_name_str_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse_Server::release_spectator_name_str() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
  if (!_internal_has_spectator_name_str()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000040u;
  auto* p = spectator_name_str_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spectator_name_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    spectator_name_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_allocated_spectator_name_str(std::string* spectator_name_str) {
  if (spectator_name_str != nullptr) {
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  spectator_name_str_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), spectator_name_str,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (spectator_name_str_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    spectator_name_str_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.Server.spectator_name_str)
}

// optional uint32 spectator_name_strindex = 31;
inline bool CMsgGMSClientServerQueryResponse_Server::_internal_has_spectator_name_strindex() const {
  bool value = (_has_bits_[0] & 0x10000000u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse_Server::has_spectator_name_strindex() const {
  return _internal_has_spectator_name_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::clear_spectator_name_strindex() {
  spectator_name_strindex_ = 0u;
  _has_bits_[0] &= ~0x10000000u;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::_internal_spectator_name_strindex() const {
  return spectator_name_strindex_;
}
inline uint32_t CMsgGMSClientServerQueryResponse_Server::spectator_name_strindex() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.Server.spectator_name_strindex)
  return _internal_spectator_name_strindex();
}
inline void CMsgGMSClientServerQueryResponse_Server::_internal_set_spectator_name_strindex(uint32_t value) {
  _has_bits_[0] |= 0x10000000u;
  spectator_name_strindex_ = value;
}
inline void CMsgGMSClientServerQueryResponse_Server::set_spectator_name_strindex(uint32_t value) {
  _internal_set_spectator_name_strindex(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.Server.spectator_name_strindex)
}

// -------------------------------------------------------------------

// CMsgGMSClientServerQueryResponse

// repeated .CMsgGMSClientServerQueryResponse.Server servers = 1;
inline int CMsgGMSClientServerQueryResponse::_internal_servers_size() const {
  return servers_.size();
}
inline int CMsgGMSClientServerQueryResponse::servers_size() const {
  return _internal_servers_size();
}
inline void CMsgGMSClientServerQueryResponse::clear_servers() {
  servers_.Clear();
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::mutable_servers(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.servers)
  return servers_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGMSClientServerQueryResponse_Server >*
CMsgGMSClientServerQueryResponse::mutable_servers() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGMSClientServerQueryResponse.servers)
  return &servers_;
}
inline const ::CMsgGMSClientServerQueryResponse_Server& CMsgGMSClientServerQueryResponse::_internal_servers(int index) const {
  return servers_.Get(index);
}
inline const ::CMsgGMSClientServerQueryResponse_Server& CMsgGMSClientServerQueryResponse::servers(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.servers)
  return _internal_servers(index);
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::_internal_add_servers() {
  return servers_.Add();
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::add_servers() {
  ::CMsgGMSClientServerQueryResponse_Server* _add = _internal_add_servers();
  // @@protoc_insertion_point(field_add:CMsgGMSClientServerQueryResponse.servers)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgGMSClientServerQueryResponse_Server >&
CMsgGMSClientServerQueryResponse::servers() const {
  // @@protoc_insertion_point(field_list:CMsgGMSClientServerQueryResponse.servers)
  return servers_;
}

// optional string error = 2;
inline bool CMsgGMSClientServerQueryResponse::_internal_has_error() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGMSClientServerQueryResponse::has_error() const {
  return _internal_has_error();
}
inline void CMsgGMSClientServerQueryResponse::clear_error() {
  error_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGMSClientServerQueryResponse::error() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.error)
  return _internal_error();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGMSClientServerQueryResponse::set_error(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.error)
}
inline std::string* CMsgGMSClientServerQueryResponse::mutable_error() {
  std::string* _s = _internal_mutable_error();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.error)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse::_internal_error() const {
  return error_.Get();
}
inline void CMsgGMSClientServerQueryResponse::_internal_set_error(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  error_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse::_internal_mutable_error() {
  _has_bits_[0] |= 0x00000001u;
  return error_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGMSClientServerQueryResponse::release_error() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.error)
  if (!_internal_has_error()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = error_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGMSClientServerQueryResponse::set_allocated_error(std::string* error) {
  if (error != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  error_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (error_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    error_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.error)
}

// optional .CMsgGMSClientServerQueryResponse.Server default_server_data = 3;
inline bool CMsgGMSClientServerQueryResponse::_internal_has_default_server_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || default_server_data_ != nullptr);
  return value;
}
inline bool CMsgGMSClientServerQueryResponse::has_default_server_data() const {
  return _internal_has_default_server_data();
}
inline void CMsgGMSClientServerQueryResponse::clear_default_server_data() {
  if (default_server_data_ != nullptr) default_server_data_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CMsgGMSClientServerQueryResponse_Server& CMsgGMSClientServerQueryResponse::_internal_default_server_data() const {
  const ::CMsgGMSClientServerQueryResponse_Server* p = default_server_data_;
  return p != nullptr ? *p : reinterpret_cast<const ::CMsgGMSClientServerQueryResponse_Server&>(
      ::_CMsgGMSClientServerQueryResponse_Server_default_instance_);
}
inline const ::CMsgGMSClientServerQueryResponse_Server& CMsgGMSClientServerQueryResponse::default_server_data() const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.default_server_data)
  return _internal_default_server_data();
}
inline void CMsgGMSClientServerQueryResponse::unsafe_arena_set_allocated_default_server_data(
    ::CMsgGMSClientServerQueryResponse_Server* default_server_data) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(default_server_data_);
  }
  default_server_data_ = default_server_data;
  if (default_server_data) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CMsgGMSClientServerQueryResponse.default_server_data)
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::release_default_server_data() {
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgGMSClientServerQueryResponse_Server* temp = default_server_data_;
  default_server_data_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::unsafe_arena_release_default_server_data() {
  // @@protoc_insertion_point(field_release:CMsgGMSClientServerQueryResponse.default_server_data)
  _has_bits_[0] &= ~0x00000002u;
  ::CMsgGMSClientServerQueryResponse_Server* temp = default_server_data_;
  default_server_data_ = nullptr;
  return temp;
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::_internal_mutable_default_server_data() {
  _has_bits_[0] |= 0x00000002u;
  if (default_server_data_ == nullptr) {
    auto* p = CreateMaybeMessage<::CMsgGMSClientServerQueryResponse_Server>(GetArenaForAllocation());
    default_server_data_ = p;
  }
  return default_server_data_;
}
inline ::CMsgGMSClientServerQueryResponse_Server* CMsgGMSClientServerQueryResponse::mutable_default_server_data() {
  ::CMsgGMSClientServerQueryResponse_Server* _msg = _internal_mutable_default_server_data();
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.default_server_data)
  return _msg;
}
inline void CMsgGMSClientServerQueryResponse::set_allocated_default_server_data(::CMsgGMSClientServerQueryResponse_Server* default_server_data) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete default_server_data_;
  }
  if (default_server_data) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CMsgGMSClientServerQueryResponse_Server>::GetOwningArena(default_server_data);
    if (message_arena != submessage_arena) {
      default_server_data = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, default_server_data, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  default_server_data_ = default_server_data;
  // @@protoc_insertion_point(field_set_allocated:CMsgGMSClientServerQueryResponse.default_server_data)
}

// repeated string server_strings = 4;
inline int CMsgGMSClientServerQueryResponse::_internal_server_strings_size() const {
  return server_strings_.size();
}
inline int CMsgGMSClientServerQueryResponse::server_strings_size() const {
  return _internal_server_strings_size();
}
inline void CMsgGMSClientServerQueryResponse::clear_server_strings() {
  server_strings_.Clear();
}
inline std::string* CMsgGMSClientServerQueryResponse::add_server_strings() {
  std::string* _s = _internal_add_server_strings();
  // @@protoc_insertion_point(field_add_mutable:CMsgGMSClientServerQueryResponse.server_strings)
  return _s;
}
inline const std::string& CMsgGMSClientServerQueryResponse::_internal_server_strings(int index) const {
  return server_strings_.Get(index);
}
inline const std::string& CMsgGMSClientServerQueryResponse::server_strings(int index) const {
  // @@protoc_insertion_point(field_get:CMsgGMSClientServerQueryResponse.server_strings)
  return _internal_server_strings(index);
}
inline std::string* CMsgGMSClientServerQueryResponse::mutable_server_strings(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgGMSClientServerQueryResponse.server_strings)
  return server_strings_.Mutable(index);
}
inline void CMsgGMSClientServerQueryResponse::set_server_strings(int index, const std::string& value) {
  server_strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::set_server_strings(int index, std::string&& value) {
  server_strings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::set_server_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  server_strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::set_server_strings(int index, const char* value, size_t size) {
  server_strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgGMSClientServerQueryResponse.server_strings)
}
inline std::string* CMsgGMSClientServerQueryResponse::_internal_add_server_strings() {
  return server_strings_.Add();
}
inline void CMsgGMSClientServerQueryResponse::add_server_strings(const std::string& value) {
  server_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::add_server_strings(std::string&& value) {
  server_strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::add_server_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  server_strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CMsgGMSClientServerQueryResponse.server_strings)
}
inline void CMsgGMSClientServerQueryResponse::add_server_strings(const char* value, size_t size) {
  server_strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CMsgGMSClientServerQueryResponse.server_strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CMsgGMSClientServerQueryResponse::server_strings() const {
  // @@protoc_insertion_point(field_list:CMsgGMSClientServerQueryResponse.server_strings)
  return server_strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CMsgGMSClientServerQueryResponse::mutable_server_strings() {
  // @@protoc_insertion_point(field_mutable_list:CMsgGMSClientServerQueryResponse.server_strings)
  return &server_strings_;
}

// -------------------------------------------------------------------

// CMsgGameServerOutOfDate

// optional fixed64 steam_id_gs = 1;
inline bool CMsgGameServerOutOfDate::_internal_has_steam_id_gs() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGameServerOutOfDate::has_steam_id_gs() const {
  return _internal_has_steam_id_gs();
}
inline void CMsgGameServerOutOfDate::clear_steam_id_gs() {
  steam_id_gs_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CMsgGameServerOutOfDate::_internal_steam_id_gs() const {
  return steam_id_gs_;
}
inline uint64_t CMsgGameServerOutOfDate::steam_id_gs() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerOutOfDate.steam_id_gs)
  return _internal_steam_id_gs();
}
inline void CMsgGameServerOutOfDate::_internal_set_steam_id_gs(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steam_id_gs_ = value;
}
inline void CMsgGameServerOutOfDate::set_steam_id_gs(uint64_t value) {
  _internal_set_steam_id_gs(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerOutOfDate.steam_id_gs)
}

// optional bool reject = 2;
inline bool CMsgGameServerOutOfDate::_internal_has_reject() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGameServerOutOfDate::has_reject() const {
  return _internal_has_reject();
}
inline void CMsgGameServerOutOfDate::clear_reject() {
  reject_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgGameServerOutOfDate::_internal_reject() const {
  return reject_;
}
inline bool CMsgGameServerOutOfDate::reject() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerOutOfDate.reject)
  return _internal_reject();
}
inline void CMsgGameServerOutOfDate::_internal_set_reject(bool value) {
  _has_bits_[0] |= 0x00000004u;
  reject_ = value;
}
inline void CMsgGameServerOutOfDate::set_reject(bool value) {
  _internal_set_reject(value);
  // @@protoc_insertion_point(field_set:CMsgGameServerOutOfDate.reject)
}

// optional string message = 3;
inline bool CMsgGameServerOutOfDate::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGameServerOutOfDate::has_message() const {
  return _internal_has_message();
}
inline void CMsgGameServerOutOfDate::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgGameServerOutOfDate::message() const {
  // @@protoc_insertion_point(field_get:CMsgGameServerOutOfDate.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgGameServerOutOfDate::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgGameServerOutOfDate.message)
}
inline std::string* CMsgGameServerOutOfDate::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:CMsgGameServerOutOfDate.message)
  return _s;
}
inline const std::string& CMsgGameServerOutOfDate::_internal_message() const {
  return message_.Get();
}
inline void CMsgGameServerOutOfDate::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgGameServerOutOfDate::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgGameServerOutOfDate::release_message() {
  // @@protoc_insertion_point(field_release:CMsgGameServerOutOfDate.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgGameServerOutOfDate::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgGameServerOutOfDate.message)
}

// -------------------------------------------------------------------

// CMsgGSAssociateWithClan

// optional fixed64 steam_id_clan = 1;
inline bool CMsgGSAssociateWithClan::_internal_has_steam_id_clan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSAssociateWithClan::has_steam_id_clan() const {
  return _internal_has_steam_id_clan();
}
inline void CMsgGSAssociateWithClan::clear_steam_id_clan() {
  steam_id_clan_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGSAssociateWithClan::_internal_steam_id_clan() const {
  return steam_id_clan_;
}
inline uint64_t CMsgGSAssociateWithClan::steam_id_clan() const {
  // @@protoc_insertion_point(field_get:CMsgGSAssociateWithClan.steam_id_clan)
  return _internal_steam_id_clan();
}
inline void CMsgGSAssociateWithClan::_internal_set_steam_id_clan(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_clan_ = value;
}
inline void CMsgGSAssociateWithClan::set_steam_id_clan(uint64_t value) {
  _internal_set_steam_id_clan(value);
  // @@protoc_insertion_point(field_set:CMsgGSAssociateWithClan.steam_id_clan)
}

// -------------------------------------------------------------------

// CMsgGSAssociateWithClanResponse

// optional fixed64 steam_id_clan = 1;
inline bool CMsgGSAssociateWithClanResponse::_internal_has_steam_id_clan() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSAssociateWithClanResponse::has_steam_id_clan() const {
  return _internal_has_steam_id_clan();
}
inline void CMsgGSAssociateWithClanResponse::clear_steam_id_clan() {
  steam_id_clan_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGSAssociateWithClanResponse::_internal_steam_id_clan() const {
  return steam_id_clan_;
}
inline uint64_t CMsgGSAssociateWithClanResponse::steam_id_clan() const {
  // @@protoc_insertion_point(field_get:CMsgGSAssociateWithClanResponse.steam_id_clan)
  return _internal_steam_id_clan();
}
inline void CMsgGSAssociateWithClanResponse::_internal_set_steam_id_clan(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_clan_ = value;
}
inline void CMsgGSAssociateWithClanResponse::set_steam_id_clan(uint64_t value) {
  _internal_set_steam_id_clan(value);
  // @@protoc_insertion_point(field_set:CMsgGSAssociateWithClanResponse.steam_id_clan)
}

// optional uint32 eresult = 2 [default = 2];
inline bool CMsgGSAssociateWithClanResponse::_internal_has_eresult() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGSAssociateWithClanResponse::has_eresult() const {
  return _internal_has_eresult();
}
inline void CMsgGSAssociateWithClanResponse::clear_eresult() {
  eresult_ = 2u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgGSAssociateWithClanResponse::_internal_eresult() const {
  return eresult_;
}
inline uint32_t CMsgGSAssociateWithClanResponse::eresult() const {
  // @@protoc_insertion_point(field_get:CMsgGSAssociateWithClanResponse.eresult)
  return _internal_eresult();
}
inline void CMsgGSAssociateWithClanResponse::_internal_set_eresult(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  eresult_ = value;
}
inline void CMsgGSAssociateWithClanResponse::set_eresult(uint32_t value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:CMsgGSAssociateWithClanResponse.eresult)
}

// -------------------------------------------------------------------

// CMsgGSComputeNewPlayerCompatibility

// optional fixed64 steam_id_candidate = 1;
inline bool CMsgGSComputeNewPlayerCompatibility::_internal_has_steam_id_candidate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibility::has_steam_id_candidate() const {
  return _internal_has_steam_id_candidate();
}
inline void CMsgGSComputeNewPlayerCompatibility::clear_steam_id_candidate() {
  steam_id_candidate_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGSComputeNewPlayerCompatibility::_internal_steam_id_candidate() const {
  return steam_id_candidate_;
}
inline uint64_t CMsgGSComputeNewPlayerCompatibility::steam_id_candidate() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibility.steam_id_candidate)
  return _internal_steam_id_candidate();
}
inline void CMsgGSComputeNewPlayerCompatibility::_internal_set_steam_id_candidate(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_candidate_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibility::set_steam_id_candidate(uint64_t value) {
  _internal_set_steam_id_candidate(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibility.steam_id_candidate)
}

// -------------------------------------------------------------------

// CMsgGSComputeNewPlayerCompatibilityResponse

// optional fixed64 steam_id_candidate = 1;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_steam_id_candidate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_steam_id_candidate() const {
  return _internal_has_steam_id_candidate();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_steam_id_candidate() {
  steam_id_candidate_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgGSComputeNewPlayerCompatibilityResponse::_internal_steam_id_candidate() const {
  return steam_id_candidate_;
}
inline uint64_t CMsgGSComputeNewPlayerCompatibilityResponse::steam_id_candidate() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.steam_id_candidate)
  return _internal_steam_id_candidate();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_steam_id_candidate(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steam_id_candidate_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_steam_id_candidate(uint64_t value) {
  _internal_set_steam_id_candidate(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.steam_id_candidate)
}

// optional uint32 eresult = 2 [default = 2];
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_eresult() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_eresult() const {
  return _internal_has_eresult();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_eresult() {
  eresult_ = 2u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgGSComputeNewPlayerCompatibilityResponse::_internal_eresult() const {
  return eresult_;
}
inline uint32_t CMsgGSComputeNewPlayerCompatibilityResponse::eresult() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.eresult)
  return _internal_eresult();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_eresult(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  eresult_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_eresult(uint32_t value) {
  _internal_set_eresult(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.eresult)
}

// optional bool is_clan_member = 3;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_is_clan_member() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_is_clan_member() const {
  return _internal_has_is_clan_member();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_is_clan_member() {
  is_clan_member_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_is_clan_member() const {
  return is_clan_member_;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::is_clan_member() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.is_clan_member)
  return _internal_is_clan_member();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_is_clan_member(bool value) {
  _has_bits_[0] |= 0x00000002u;
  is_clan_member_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_is_clan_member(bool value) {
  _internal_set_is_clan_member(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.is_clan_member)
}

// optional int32 ct_dont_like_you = 4;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_ct_dont_like_you() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_dont_like_you() const {
  return _internal_has_ct_dont_like_you();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_dont_like_you() {
  ct_dont_like_you_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::_internal_ct_dont_like_you() const {
  return ct_dont_like_you_;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::ct_dont_like_you() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.ct_dont_like_you)
  return _internal_ct_dont_like_you();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_ct_dont_like_you(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  ct_dont_like_you_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_dont_like_you(int32_t value) {
  _internal_set_ct_dont_like_you(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.ct_dont_like_you)
}

// optional int32 ct_you_dont_like = 5;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_ct_you_dont_like() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_you_dont_like() const {
  return _internal_has_ct_you_dont_like();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_you_dont_like() {
  ct_you_dont_like_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::_internal_ct_you_dont_like() const {
  return ct_you_dont_like_;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::ct_you_dont_like() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.ct_you_dont_like)
  return _internal_ct_you_dont_like();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_ct_you_dont_like(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  ct_you_dont_like_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_you_dont_like(int32_t value) {
  _internal_set_ct_you_dont_like(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.ct_you_dont_like)
}

// optional int32 ct_clanmembers_dont_like_you = 6;
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::_internal_has_ct_clanmembers_dont_like_you() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgGSComputeNewPlayerCompatibilityResponse::has_ct_clanmembers_dont_like_you() const {
  return _internal_has_ct_clanmembers_dont_like_you();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::clear_ct_clanmembers_dont_like_you() {
  ct_clanmembers_dont_like_you_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::_internal_ct_clanmembers_dont_like_you() const {
  return ct_clanmembers_dont_like_you_;
}
inline int32_t CMsgGSComputeNewPlayerCompatibilityResponse::ct_clanmembers_dont_like_you() const {
  // @@protoc_insertion_point(field_get:CMsgGSComputeNewPlayerCompatibilityResponse.ct_clanmembers_dont_like_you)
  return _internal_ct_clanmembers_dont_like_you();
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::_internal_set_ct_clanmembers_dont_like_you(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  ct_clanmembers_dont_like_you_ = value;
}
inline void CMsgGSComputeNewPlayerCompatibilityResponse::set_ct_clanmembers_dont_like_you(int32_t value) {
  _internal_set_ct_clanmembers_dont_like_you(value);
  // @@protoc_insertion_point(field_set:CMsgGSComputeNewPlayerCompatibilityResponse.ct_clanmembers_dont_like_you)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgGMSClientServerQueryResponse_EFlags> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgGMSClientServerQueryResponse_EFlags>() {
  return ::CMsgGMSClientServerQueryResponse_EFlags_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fclientserver_5fgameservers_2eproto
