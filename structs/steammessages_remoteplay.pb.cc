// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_remoteplay.proto

#include "steammessages_remoteplay.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CDiscoveryPingRequest::CDiscoveryPingRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sequence_(0u)
  , packet_size_requested_(0u){}
struct CDiscoveryPingRequestDefaultTypeInternal {
  constexpr CDiscoveryPingRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDiscoveryPingRequestDefaultTypeInternal() {}
  union {
    CDiscoveryPingRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDiscoveryPingRequestDefaultTypeInternal _CDiscoveryPingRequest_default_instance_;
constexpr CDiscoveryPingResponse::CDiscoveryPingResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sequence_(0u)
  , packet_size_received_(0u){}
struct CDiscoveryPingResponseDefaultTypeInternal {
  constexpr CDiscoveryPingResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDiscoveryPingResponseDefaultTypeInternal() {}
  union {
    CDiscoveryPingResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDiscoveryPingResponseDefaultTypeInternal _CDiscoveryPingResponse_default_instance_;
constexpr CStreamingClientHandshakeInfo::CStreamingClientHandshakeInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : network_test_(0){}
struct CStreamingClientHandshakeInfoDefaultTypeInternal {
  constexpr CStreamingClientHandshakeInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingClientHandshakeInfoDefaultTypeInternal() {}
  union {
    CStreamingClientHandshakeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingClientHandshakeInfoDefaultTypeInternal _CStreamingClientHandshakeInfo_default_instance_;
constexpr CClientHandshakeMsg::CClientHandshakeMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : info_(nullptr){}
struct CClientHandshakeMsgDefaultTypeInternal {
  constexpr CClientHandshakeMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CClientHandshakeMsgDefaultTypeInternal() {}
  union {
    CClientHandshakeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CClientHandshakeMsgDefaultTypeInternal _CClientHandshakeMsg_default_instance_;
constexpr CStreamingServerHandshakeInfo::CStreamingServerHandshakeInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : mtu_(0){}
struct CStreamingServerHandshakeInfoDefaultTypeInternal {
  constexpr CStreamingServerHandshakeInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingServerHandshakeInfoDefaultTypeInternal() {}
  union {
    CStreamingServerHandshakeInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingServerHandshakeInfoDefaultTypeInternal _CStreamingServerHandshakeInfo_default_instance_;
constexpr CServerHandshakeMsg::CServerHandshakeMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : info_(nullptr){}
struct CServerHandshakeMsgDefaultTypeInternal {
  constexpr CServerHandshakeMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CServerHandshakeMsgDefaultTypeInternal() {}
  union {
    CServerHandshakeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CServerHandshakeMsgDefaultTypeInternal _CServerHandshakeMsg_default_instance_;
constexpr CAuthenticationRequestMsg::CAuthenticationRequestMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , steamid_(uint64_t{0u})
  , version_(0)
{}
struct CAuthenticationRequestMsgDefaultTypeInternal {
  constexpr CAuthenticationRequestMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationRequestMsgDefaultTypeInternal() {}
  union {
    CAuthenticationRequestMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationRequestMsgDefaultTypeInternal _CAuthenticationRequestMsg_default_instance_;
constexpr CAuthenticationResponseMsg::CAuthenticationResponseMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : result_(0)

  , version_(0)
{}
struct CAuthenticationResponseMsgDefaultTypeInternal {
  constexpr CAuthenticationResponseMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationResponseMsgDefaultTypeInternal() {}
  union {
    CAuthenticationResponseMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationResponseMsgDefaultTypeInternal _CAuthenticationResponseMsg_default_instance_;
constexpr CKeepAliveMsg::CKeepAliveMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CKeepAliveMsgDefaultTypeInternal {
  constexpr CKeepAliveMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CKeepAliveMsgDefaultTypeInternal() {}
  union {
    CKeepAliveMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CKeepAliveMsgDefaultTypeInternal _CKeepAliveMsg_default_instance_;
constexpr CStartNetworkTestMsg::CStartNetworkTestMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frames_(0u)
  , framerate_(0u)
  , bitrate_kbps_(0u)
  , burst_bitrate_kbps_(0u)
  , bandwidth_test_(false){}
struct CStartNetworkTestMsgDefaultTypeInternal {
  constexpr CStartNetworkTestMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStartNetworkTestMsgDefaultTypeInternal() {}
  union {
    CStartNetworkTestMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStartNetworkTestMsgDefaultTypeInternal _CStartNetworkTestMsg_default_instance_;
constexpr CStreamVideoMode::CStreamVideoMode(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(0u)
  , height_(0u)
  , refresh_rate_(0u)
  , refresh_rate_numerator_(0u)
  , refresh_rate_denominator_(0u){}
struct CStreamVideoModeDefaultTypeInternal {
  constexpr CStreamVideoModeDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamVideoModeDefaultTypeInternal() {}
  union {
    CStreamVideoMode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamVideoModeDefaultTypeInternal _CStreamVideoMode_default_instance_;
constexpr CStreamingClientCaps::CStreamingClientCaps(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supported_colorspaces_()
  , system_info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , maximum_decode_bitrate_kbps_(0)
  , maximum_burst_bitrate_kbps_(0)
  , system_can_suspend_(false)
  , supports_video_hevc_(false)
  , disable_steam_store_(false)
  , disable_client_cursor_(false)
  , disable_intel_hardware_encoding_(false)
  , disable_amd_hardware_encoding_(false)
  , disable_nvidia_hardware_encoding_(false)
  , has_on_screen_keyboard_(false)
  , form_factor_(0){}
struct CStreamingClientCapsDefaultTypeInternal {
  constexpr CStreamingClientCapsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingClientCapsDefaultTypeInternal() {}
  union {
    CStreamingClientCaps _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingClientCapsDefaultTypeInternal _CStreamingClientCaps_default_instance_;
constexpr CStreamingClientConfig::CStreamingClientConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_overlay_hotkey_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , maximum_resolution_x_(0u)
  , maximum_resolution_y_(0u)
  , maximum_framerate_numerator_(0u)
  , maximum_framerate_denominator_(0u)
  , enable_performance_overlay_(false)
  , enable_video_hevc_(false)
  , enable_microphone_streaming_(false)
  , enable_touch_controller_obsolete_(false)
  , p2p_scope_(0)

  , enable_audio_uncompressed_(false)
  , enable_performance_icons_(true)
  , quality_(2)

  , maximum_bitrate_kbps_(-1)
  , enable_hardware_decoding_(true)
  , enable_video_streaming_(true)
  , enable_audio_streaming_(true)
  , enable_input_streaming_(true)
  , audio_channels_(2){}
struct CStreamingClientConfigDefaultTypeInternal {
  constexpr CStreamingClientConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingClientConfigDefaultTypeInternal() {}
  union {
    CStreamingClientConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingClientConfigDefaultTypeInternal _CStreamingClientConfig_default_instance_;
constexpr CStreamingServerConfig::CStreamingServerConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : change_desktop_resolution_(false)
  , dynamically_adjust_resolution_(false)
  , enable_capture_nvfbc_(false)
  , enable_hardware_encoding_nvidia_(false)
  , enable_hardware_encoding_amd_(false)
  , enable_hardware_encoding_intel_(false)
  , enable_traffic_priority_(false)
  , software_encoding_threads_(0)
  , host_play_audio_(0)
{}
struct CStreamingServerConfigDefaultTypeInternal {
  constexpr CStreamingServerConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingServerConfigDefaultTypeInternal() {}
  union {
    CStreamingServerConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingServerConfigDefaultTypeInternal _CStreamingServerConfig_default_instance_;
constexpr CNegotiatedConfig::CNegotiatedConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : available_video_modes_()
  , selected_audio_codec_(0)

  , selected_video_codec_(0)

  , reliable_data_(false)
  , enable_remote_hid_(false)
  , enable_touch_input_(false)
  , disable_client_cursor_(false){}
struct CNegotiatedConfigDefaultTypeInternal {
  constexpr CNegotiatedConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CNegotiatedConfigDefaultTypeInternal() {}
  union {
    CNegotiatedConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CNegotiatedConfigDefaultTypeInternal _CNegotiatedConfig_default_instance_;
constexpr CNegotiationInitMsg::CNegotiationInitMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : supported_audio_codecs_()
  , supported_video_codecs_()
  , reliable_data_(false)
  , supports_remote_hid_(false)
  , supports_touch_input_(false){}
struct CNegotiationInitMsgDefaultTypeInternal {
  constexpr CNegotiationInitMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CNegotiationInitMsgDefaultTypeInternal() {}
  union {
    CNegotiationInitMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CNegotiationInitMsgDefaultTypeInternal _CNegotiationInitMsg_default_instance_;
constexpr CNegotiationSetConfigMsg::CNegotiationSetConfigMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr)
  , streaming_client_config_(nullptr)
  , streaming_client_caps_(nullptr){}
struct CNegotiationSetConfigMsgDefaultTypeInternal {
  constexpr CNegotiationSetConfigMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CNegotiationSetConfigMsgDefaultTypeInternal() {}
  union {
    CNegotiationSetConfigMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CNegotiationSetConfigMsgDefaultTypeInternal _CNegotiationSetConfigMsg_default_instance_;
constexpr CNegotiationCompleteMsg::CNegotiationCompleteMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CNegotiationCompleteMsgDefaultTypeInternal {
  constexpr CNegotiationCompleteMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CNegotiationCompleteMsgDefaultTypeInternal() {}
  union {
    CNegotiationCompleteMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CNegotiationCompleteMsgDefaultTypeInternal _CNegotiationCompleteMsg_default_instance_;
constexpr CStartAudioDataMsg::CStartAudioDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : codec_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , channel_(0u)
  , codec_(0)

  , frequency_(0u)
  , channels_(0u){}
struct CStartAudioDataMsgDefaultTypeInternal {
  constexpr CStartAudioDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStartAudioDataMsgDefaultTypeInternal() {}
  union {
    CStartAudioDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStartAudioDataMsgDefaultTypeInternal _CStartAudioDataMsg_default_instance_;
constexpr CStopAudioDataMsg::CStopAudioDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CStopAudioDataMsgDefaultTypeInternal {
  constexpr CStopAudioDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStopAudioDataMsgDefaultTypeInternal() {}
  union {
    CStopAudioDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStopAudioDataMsgDefaultTypeInternal _CStopAudioDataMsg_default_instance_;
constexpr CStartVideoDataMsg::CStartVideoDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : codec_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , channel_(0u)
  , codec_(0)

  , width_(0u)
  , height_(0u){}
struct CStartVideoDataMsgDefaultTypeInternal {
  constexpr CStartVideoDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStartVideoDataMsgDefaultTypeInternal() {}
  union {
    CStartVideoDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStartVideoDataMsgDefaultTypeInternal _CStartVideoDataMsg_default_instance_;
constexpr CStopVideoDataMsg::CStopVideoDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CStopVideoDataMsgDefaultTypeInternal {
  constexpr CStopVideoDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStopVideoDataMsgDefaultTypeInternal() {}
  union {
    CStopVideoDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStopVideoDataMsgDefaultTypeInternal _CStopVideoDataMsg_default_instance_;
constexpr CStartNeptuneDataMsg::CStartNeptuneDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : channel_(0u){}
struct CStartNeptuneDataMsgDefaultTypeInternal {
  constexpr CStartNeptuneDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStartNeptuneDataMsgDefaultTypeInternal() {}
  union {
    CStartNeptuneDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStartNeptuneDataMsgDefaultTypeInternal _CStartNeptuneDataMsg_default_instance_;
constexpr CStopNeptuneDataMsg::CStopNeptuneDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CStopNeptuneDataMsgDefaultTypeInternal {
  constexpr CStopNeptuneDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStopNeptuneDataMsgDefaultTypeInternal() {}
  union {
    CStopNeptuneDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStopNeptuneDataMsgDefaultTypeInternal _CStopNeptuneDataMsg_default_instance_;
constexpr CRecordedInput::CRecordedInput(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : timestamp_(0u)
  , type_(1)

  , _oneof_case_{}{}
struct CRecordedInputDefaultTypeInternal {
  constexpr CRecordedInputDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CRecordedInputDefaultTypeInternal() {}
  union {
    CRecordedInput _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CRecordedInputDefaultTypeInternal _CRecordedInput_default_instance_;
constexpr CRecordedInputStream::CRecordedInputStream(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_(){}
struct CRecordedInputStreamDefaultTypeInternal {
  constexpr CRecordedInputStreamDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CRecordedInputStreamDefaultTypeInternal() {}
  union {
    CRecordedInputStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CRecordedInputStreamDefaultTypeInternal _CRecordedInputStream_default_instance_;
constexpr CInputLatencyTestMsg::CInputLatencyTestMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , color_(0u){}
struct CInputLatencyTestMsgDefaultTypeInternal {
  constexpr CInputLatencyTestMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputLatencyTestMsgDefaultTypeInternal() {}
  union {
    CInputLatencyTestMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputLatencyTestMsgDefaultTypeInternal _CInputLatencyTestMsg_default_instance_;
constexpr CInputTouchFingerDownMsg::CInputTouchFingerDownMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fingerid_(uint64_t{0u})
  , input_mark_(0u)
  , x_normalized_(0)
  , y_normalized_(0){}
struct CInputTouchFingerDownMsgDefaultTypeInternal {
  constexpr CInputTouchFingerDownMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputTouchFingerDownMsgDefaultTypeInternal() {}
  union {
    CInputTouchFingerDownMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputTouchFingerDownMsgDefaultTypeInternal _CInputTouchFingerDownMsg_default_instance_;
constexpr CInputTouchFingerMotionMsg::CInputTouchFingerMotionMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fingerid_(uint64_t{0u})
  , input_mark_(0u)
  , x_normalized_(0)
  , y_normalized_(0){}
struct CInputTouchFingerMotionMsgDefaultTypeInternal {
  constexpr CInputTouchFingerMotionMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputTouchFingerMotionMsgDefaultTypeInternal() {}
  union {
    CInputTouchFingerMotionMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputTouchFingerMotionMsgDefaultTypeInternal _CInputTouchFingerMotionMsg_default_instance_;
constexpr CInputTouchFingerUpMsg::CInputTouchFingerUpMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : fingerid_(uint64_t{0u})
  , input_mark_(0u)
  , x_normalized_(0)
  , y_normalized_(0){}
struct CInputTouchFingerUpMsgDefaultTypeInternal {
  constexpr CInputTouchFingerUpMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputTouchFingerUpMsgDefaultTypeInternal() {}
  union {
    CInputTouchFingerUpMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputTouchFingerUpMsgDefaultTypeInternal _CInputTouchFingerUpMsg_default_instance_;
constexpr CInputMouseMotionMsg::CInputMouseMotionMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , x_normalized_(0)
  , y_normalized_(0)
  , dx_(0)
  , dy_(0){}
struct CInputMouseMotionMsgDefaultTypeInternal {
  constexpr CInputMouseMotionMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputMouseMotionMsgDefaultTypeInternal() {}
  union {
    CInputMouseMotionMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputMouseMotionMsgDefaultTypeInternal _CInputMouseMotionMsg_default_instance_;
constexpr CInputMouseWheelMsg::CInputMouseWheelMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , direction_(120)
{}
struct CInputMouseWheelMsgDefaultTypeInternal {
  constexpr CInputMouseWheelMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputMouseWheelMsgDefaultTypeInternal() {}
  union {
    CInputMouseWheelMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputMouseWheelMsgDefaultTypeInternal _CInputMouseWheelMsg_default_instance_;
constexpr CInputMouseDownMsg::CInputMouseDownMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , button_(1)
{}
struct CInputMouseDownMsgDefaultTypeInternal {
  constexpr CInputMouseDownMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputMouseDownMsgDefaultTypeInternal() {}
  union {
    CInputMouseDownMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputMouseDownMsgDefaultTypeInternal _CInputMouseDownMsg_default_instance_;
constexpr CInputMouseUpMsg::CInputMouseUpMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , button_(1)
{}
struct CInputMouseUpMsgDefaultTypeInternal {
  constexpr CInputMouseUpMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputMouseUpMsgDefaultTypeInternal() {}
  union {
    CInputMouseUpMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputMouseUpMsgDefaultTypeInternal _CInputMouseUpMsg_default_instance_;
constexpr CInputKeyDownMsg::CInputKeyDownMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , scancode_(0u){}
struct CInputKeyDownMsgDefaultTypeInternal {
  constexpr CInputKeyDownMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputKeyDownMsgDefaultTypeInternal() {}
  union {
    CInputKeyDownMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputKeyDownMsgDefaultTypeInternal _CInputKeyDownMsg_default_instance_;
constexpr CInputKeyUpMsg::CInputKeyUpMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : input_mark_(0u)
  , scancode_(0u){}
struct CInputKeyUpMsgDefaultTypeInternal {
  constexpr CInputKeyUpMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputKeyUpMsgDefaultTypeInternal() {}
  union {
    CInputKeyUpMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputKeyUpMsgDefaultTypeInternal _CInputKeyUpMsg_default_instance_;
constexpr CInputTextMsg::CInputTextMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : text_utf8_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , input_mark_(0u){}
struct CInputTextMsgDefaultTypeInternal {
  constexpr CInputTextMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CInputTextMsgDefaultTypeInternal() {}
  union {
    CInputTextMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CInputTextMsgDefaultTypeInternal _CInputTextMsg_default_instance_;
constexpr CSetTitleMsg::CSetTitleMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : text_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CSetTitleMsgDefaultTypeInternal {
  constexpr CSetTitleMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetTitleMsgDefaultTypeInternal() {}
  union {
    CSetTitleMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetTitleMsgDefaultTypeInternal _CSetTitleMsg_default_instance_;
constexpr CSetCaptureSizeMsg::CSetCaptureSizeMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : width_(0)
  , height_(0){}
struct CSetCaptureSizeMsgDefaultTypeInternal {
  constexpr CSetCaptureSizeMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetCaptureSizeMsgDefaultTypeInternal() {}
  union {
    CSetCaptureSizeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetCaptureSizeMsgDefaultTypeInternal _CSetCaptureSizeMsg_default_instance_;
constexpr CSetIconMsg::CSetIconMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : image_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , width_(0)
  , height_(0){}
struct CSetIconMsgDefaultTypeInternal {
  constexpr CSetIconMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetIconMsgDefaultTypeInternal() {}
  union {
    CSetIconMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetIconMsgDefaultTypeInternal _CSetIconMsg_default_instance_;
constexpr CSetFlashStateMsg::CSetFlashStateMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : flags_(0u)
  , count_(0u)
  , timeout_ms_(0u){}
struct CSetFlashStateMsgDefaultTypeInternal {
  constexpr CSetFlashStateMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetFlashStateMsgDefaultTypeInternal() {}
  union {
    CSetFlashStateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetFlashStateMsgDefaultTypeInternal _CSetFlashStateMsg_default_instance_;
constexpr CShowCursorMsg::CShowCursorMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : x_normalized_(0)
  , y_normalized_(0){}
struct CShowCursorMsgDefaultTypeInternal {
  constexpr CShowCursorMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CShowCursorMsgDefaultTypeInternal() {}
  union {
    CShowCursorMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CShowCursorMsgDefaultTypeInternal _CShowCursorMsg_default_instance_;
constexpr CHideCursorMsg::CHideCursorMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CHideCursorMsgDefaultTypeInternal {
  constexpr CHideCursorMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CHideCursorMsgDefaultTypeInternal() {}
  union {
    CHideCursorMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CHideCursorMsgDefaultTypeInternal _CHideCursorMsg_default_instance_;
constexpr CSetCursorMsg::CSetCursorMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cursor_id_(uint64_t{0u}){}
struct CSetCursorMsgDefaultTypeInternal {
  constexpr CSetCursorMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetCursorMsgDefaultTypeInternal() {}
  union {
    CSetCursorMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetCursorMsgDefaultTypeInternal _CSetCursorMsg_default_instance_;
constexpr CGetCursorImageMsg::CGetCursorImageMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cursor_id_(uint64_t{0u}){}
struct CGetCursorImageMsgDefaultTypeInternal {
  constexpr CGetCursorImageMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGetCursorImageMsgDefaultTypeInternal() {}
  union {
    CGetCursorImageMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGetCursorImageMsgDefaultTypeInternal _CGetCursorImageMsg_default_instance_;
constexpr CSetCursorImageMsg::CSetCursorImageMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : image_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cursor_id_(uint64_t{0u})
  , width_(0)
  , height_(0)
  , hot_x_(0)
  , hot_y_(0){}
struct CSetCursorImageMsgDefaultTypeInternal {
  constexpr CSetCursorImageMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetCursorImageMsgDefaultTypeInternal() {}
  union {
    CSetCursorImageMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetCursorImageMsgDefaultTypeInternal _CSetCursorImageMsg_default_instance_;
constexpr CVideoDecoderInfoMsg::CVideoDecoderInfoMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , threads_(0){}
struct CVideoDecoderInfoMsgDefaultTypeInternal {
  constexpr CVideoDecoderInfoMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVideoDecoderInfoMsgDefaultTypeInternal() {}
  union {
    CVideoDecoderInfoMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVideoDecoderInfoMsgDefaultTypeInternal _CVideoDecoderInfoMsg_default_instance_;
constexpr CVideoEncoderInfoMsg::CVideoEncoderInfoMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : info_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CVideoEncoderInfoMsgDefaultTypeInternal {
  constexpr CVideoEncoderInfoMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVideoEncoderInfoMsgDefaultTypeInternal() {}
  union {
    CVideoEncoderInfoMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVideoEncoderInfoMsgDefaultTypeInternal _CVideoEncoderInfoMsg_default_instance_;
constexpr CPauseMsg::CPauseMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CPauseMsgDefaultTypeInternal {
  constexpr CPauseMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CPauseMsgDefaultTypeInternal() {}
  union {
    CPauseMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CPauseMsgDefaultTypeInternal _CPauseMsg_default_instance_;
constexpr CResumeMsg::CResumeMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CResumeMsgDefaultTypeInternal {
  constexpr CResumeMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CResumeMsgDefaultTypeInternal() {}
  union {
    CResumeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CResumeMsgDefaultTypeInternal _CResumeMsg_default_instance_;
constexpr CEnableHighResCaptureMsg::CEnableHighResCaptureMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CEnableHighResCaptureMsgDefaultTypeInternal {
  constexpr CEnableHighResCaptureMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CEnableHighResCaptureMsgDefaultTypeInternal() {}
  union {
    CEnableHighResCaptureMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CEnableHighResCaptureMsgDefaultTypeInternal _CEnableHighResCaptureMsg_default_instance_;
constexpr CDisableHighResCaptureMsg::CDisableHighResCaptureMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CDisableHighResCaptureMsgDefaultTypeInternal {
  constexpr CDisableHighResCaptureMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDisableHighResCaptureMsgDefaultTypeInternal() {}
  union {
    CDisableHighResCaptureMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDisableHighResCaptureMsgDefaultTypeInternal _CDisableHighResCaptureMsg_default_instance_;
constexpr CEnableNeptuneDataMsg::CEnableNeptuneDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CEnableNeptuneDataMsgDefaultTypeInternal {
  constexpr CEnableNeptuneDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CEnableNeptuneDataMsgDefaultTypeInternal() {}
  union {
    CEnableNeptuneDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CEnableNeptuneDataMsgDefaultTypeInternal _CEnableNeptuneDataMsg_default_instance_;
constexpr CDisableNeptuneDataMsg::CDisableNeptuneDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CDisableNeptuneDataMsgDefaultTypeInternal {
  constexpr CDisableNeptuneDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDisableNeptuneDataMsgDefaultTypeInternal() {}
  union {
    CDisableNeptuneDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDisableNeptuneDataMsgDefaultTypeInternal _CDisableNeptuneDataMsg_default_instance_;
constexpr CPauseControllerInputMsg::CPauseControllerInputMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CPauseControllerInputMsgDefaultTypeInternal {
  constexpr CPauseControllerInputMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CPauseControllerInputMsgDefaultTypeInternal() {}
  union {
    CPauseControllerInputMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CPauseControllerInputMsgDefaultTypeInternal _CPauseControllerInputMsg_default_instance_;
constexpr CResumeControllerInputMsg::CResumeControllerInputMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CResumeControllerInputMsgDefaultTypeInternal {
  constexpr CResumeControllerInputMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CResumeControllerInputMsgDefaultTypeInternal() {}
  union {
    CResumeControllerInputMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CResumeControllerInputMsgDefaultTypeInternal _CResumeControllerInputMsg_default_instance_;
constexpr CToggleMagnificationMsg::CToggleMagnificationMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CToggleMagnificationMsgDefaultTypeInternal {
  constexpr CToggleMagnificationMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CToggleMagnificationMsgDefaultTypeInternal() {}
  union {
    CToggleMagnificationMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CToggleMagnificationMsgDefaultTypeInternal _CToggleMagnificationMsg_default_instance_;
constexpr CSetCapslockMsg::CSetCapslockMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : pressed_(false){}
struct CSetCapslockMsgDefaultTypeInternal {
  constexpr CSetCapslockMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetCapslockMsgDefaultTypeInternal() {}
  union {
    CSetCapslockMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetCapslockMsgDefaultTypeInternal _CSetCapslockMsg_default_instance_;
constexpr CStreamingKeymapEntry::CStreamingKeymapEntry(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : scancode_(0)
  , normal_keycode_(0)
  , shift_keycode_(0)
  , capslock_keycode_(0)
  , shift_capslock_keycode_(0)
  , altgr_keycode_(0)
  , altgr_shift_keycode_(0)
  , altgr_capslock_keycode_(0)
  , altgr_shift_capslock_keycode_(0){}
struct CStreamingKeymapEntryDefaultTypeInternal {
  constexpr CStreamingKeymapEntryDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingKeymapEntryDefaultTypeInternal() {}
  union {
    CStreamingKeymapEntry _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingKeymapEntryDefaultTypeInternal _CStreamingKeymapEntry_default_instance_;
constexpr CStreamingKeymap::CStreamingKeymap(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_(){}
struct CStreamingKeymapDefaultTypeInternal {
  constexpr CStreamingKeymapDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingKeymapDefaultTypeInternal() {}
  union {
    CStreamingKeymap _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingKeymapDefaultTypeInternal _CStreamingKeymap_default_instance_;
constexpr CSetKeymapMsg::CSetKeymapMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : keymap_(nullptr){}
struct CSetKeymapMsgDefaultTypeInternal {
  constexpr CSetKeymapMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetKeymapMsgDefaultTypeInternal() {}
  union {
    CSetKeymapMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetKeymapMsgDefaultTypeInternal _CSetKeymapMsg_default_instance_;
constexpr CStopRequest::CStopRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CStopRequestDefaultTypeInternal {
  constexpr CStopRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStopRequestDefaultTypeInternal() {}
  union {
    CStopRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStopRequestDefaultTypeInternal _CStopRequest_default_instance_;
constexpr CQuitRequest::CQuitRequest(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CQuitRequestDefaultTypeInternal {
  constexpr CQuitRequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CQuitRequestDefaultTypeInternal() {}
  union {
    CQuitRequest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CQuitRequestDefaultTypeInternal _CQuitRequest_default_instance_;
constexpr CDeleteCursorMsg::CDeleteCursorMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cursor_id_(uint64_t{0u}){}
struct CDeleteCursorMsgDefaultTypeInternal {
  constexpr CDeleteCursorMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDeleteCursorMsgDefaultTypeInternal() {}
  union {
    CDeleteCursorMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDeleteCursorMsgDefaultTypeInternal _CDeleteCursorMsg_default_instance_;
constexpr CSetStreamingClientConfig::CSetStreamingClientConfig(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : config_(nullptr){}
struct CSetStreamingClientConfigDefaultTypeInternal {
  constexpr CSetStreamingClientConfigDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetStreamingClientConfigDefaultTypeInternal() {}
  union {
    CSetStreamingClientConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetStreamingClientConfigDefaultTypeInternal _CSetStreamingClientConfig_default_instance_;
constexpr CSetQoSMsg::CSetQoSMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : use_qos_(false){}
struct CSetQoSMsgDefaultTypeInternal {
  constexpr CSetQoSMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetQoSMsgDefaultTypeInternal() {}
  union {
    CSetQoSMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetQoSMsgDefaultTypeInternal _CSetQoSMsg_default_instance_;
constexpr CSetTargetFramerateMsg::CSetTargetFramerateMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : framerate_(0u)
  , reasons_(0u)
  , framerate_numerator_(0u)
  , framerate_denominator_(0u){}
struct CSetTargetFramerateMsgDefaultTypeInternal {
  constexpr CSetTargetFramerateMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetTargetFramerateMsgDefaultTypeInternal() {}
  union {
    CSetTargetFramerateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetTargetFramerateMsgDefaultTypeInternal _CSetTargetFramerateMsg_default_instance_;
constexpr CSetTargetBitrateMsg::CSetTargetBitrateMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : bitrate_(0){}
struct CSetTargetBitrateMsgDefaultTypeInternal {
  constexpr CSetTargetBitrateMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetTargetBitrateMsgDefaultTypeInternal() {}
  union {
    CSetTargetBitrateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetTargetBitrateMsgDefaultTypeInternal _CSetTargetBitrateMsg_default_instance_;
constexpr COverlayEnabledMsg::COverlayEnabledMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enabled_(false){}
struct COverlayEnabledMsgDefaultTypeInternal {
  constexpr COverlayEnabledMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~COverlayEnabledMsgDefaultTypeInternal() {}
  union {
    COverlayEnabledMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT COverlayEnabledMsgDefaultTypeInternal _COverlayEnabledMsg_default_instance_;
constexpr CSetGammaRampMsg::CSetGammaRampMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : gamma_ramp_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CSetGammaRampMsgDefaultTypeInternal {
  constexpr CSetGammaRampMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetGammaRampMsgDefaultTypeInternal() {}
  union {
    CSetGammaRampMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetGammaRampMsgDefaultTypeInternal _CSetGammaRampMsg_default_instance_;
constexpr CSetActivityMsg::CSetActivityMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : game_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , gameid_(uint64_t{0u})
  , appid_(0u)
  , activity_(1)
{}
struct CSetActivityMsgDefaultTypeInternal {
  constexpr CSetActivityMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetActivityMsgDefaultTypeInternal() {}
  union {
    CSetActivityMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetActivityMsgDefaultTypeInternal _CSetActivityMsg_default_instance_;
constexpr CSystemSuspendMsg::CSystemSuspendMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CSystemSuspendMsgDefaultTypeInternal {
  constexpr CSystemSuspendMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSystemSuspendMsgDefaultTypeInternal() {}
  union {
    CSystemSuspendMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSystemSuspendMsgDefaultTypeInternal _CSystemSuspendMsg_default_instance_;
constexpr CVirtualHereRequestMsg::CVirtualHereRequestMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hostname_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CVirtualHereRequestMsgDefaultTypeInternal {
  constexpr CVirtualHereRequestMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVirtualHereRequestMsgDefaultTypeInternal() {}
  union {
    CVirtualHereRequestMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVirtualHereRequestMsgDefaultTypeInternal _CVirtualHereRequestMsg_default_instance_;
constexpr CVirtualHereReadyMsg::CVirtualHereReadyMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : licensed_device_count_(0u){}
struct CVirtualHereReadyMsgDefaultTypeInternal {
  constexpr CVirtualHereReadyMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVirtualHereReadyMsgDefaultTypeInternal() {}
  union {
    CVirtualHereReadyMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVirtualHereReadyMsgDefaultTypeInternal _CVirtualHereReadyMsg_default_instance_;
constexpr CVirtualHereShareDeviceMsg::CVirtualHereShareDeviceMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_address_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CVirtualHereShareDeviceMsgDefaultTypeInternal {
  constexpr CVirtualHereShareDeviceMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVirtualHereShareDeviceMsgDefaultTypeInternal() {}
  union {
    CVirtualHereShareDeviceMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVirtualHereShareDeviceMsgDefaultTypeInternal _CVirtualHereShareDeviceMsg_default_instance_;
constexpr CSetSpectatorModeMsg::CSetSpectatorModeMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : enabled_(false){}
struct CSetSpectatorModeMsgDefaultTypeInternal {
  constexpr CSetSpectatorModeMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetSpectatorModeMsgDefaultTypeInternal() {}
  union {
    CSetSpectatorModeMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetSpectatorModeMsgDefaultTypeInternal _CSetSpectatorModeMsg_default_instance_;
constexpr CRemoteHIDMsg::CRemoteHIDMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , active_input_(false){}
struct CRemoteHIDMsgDefaultTypeInternal {
  constexpr CRemoteHIDMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CRemoteHIDMsgDefaultTypeInternal() {}
  union {
    CRemoteHIDMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CRemoteHIDMsgDefaultTypeInternal _CRemoteHIDMsg_default_instance_;
constexpr CTouchConfigActiveMsg::CTouchConfigActiveMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , revision_(0u)
  , creator_(uint64_t{0u}){}
struct CTouchConfigActiveMsgDefaultTypeInternal {
  constexpr CTouchConfigActiveMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTouchConfigActiveMsgDefaultTypeInternal() {}
  union {
    CTouchConfigActiveMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTouchConfigActiveMsgDefaultTypeInternal _CTouchConfigActiveMsg_default_instance_;
constexpr CGetTouchConfigDataMsg::CGetTouchConfigDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u){}
struct CGetTouchConfigDataMsgDefaultTypeInternal {
  constexpr CGetTouchConfigDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGetTouchConfigDataMsgDefaultTypeInternal() {}
  union {
    CGetTouchConfigDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGetTouchConfigDataMsgDefaultTypeInternal _CGetTouchConfigDataMsg_default_instance_;
constexpr CSetTouchConfigDataMsg::CSetTouchConfigDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , layout_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , revision_(0u)
  , creator_(uint64_t{0u}){}
struct CSetTouchConfigDataMsgDefaultTypeInternal {
  constexpr CSetTouchConfigDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetTouchConfigDataMsgDefaultTypeInternal() {}
  union {
    CSetTouchConfigDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetTouchConfigDataMsgDefaultTypeInternal _CSetTouchConfigDataMsg_default_instance_;
constexpr CSaveTouchConfigLayoutMsg::CSaveTouchConfigLayoutMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : layout_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u){}
struct CSaveTouchConfigLayoutMsgDefaultTypeInternal {
  constexpr CSaveTouchConfigLayoutMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSaveTouchConfigLayoutMsgDefaultTypeInternal() {}
  union {
    CSaveTouchConfigLayoutMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSaveTouchConfigLayoutMsgDefaultTypeInternal _CSaveTouchConfigLayoutMsg_default_instance_;
constexpr CTouchActionSetActiveMsg::CTouchActionSetActiveMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , actionset_id_(0){}
struct CTouchActionSetActiveMsgDefaultTypeInternal {
  constexpr CTouchActionSetActiveMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTouchActionSetActiveMsgDefaultTypeInternal() {}
  union {
    CTouchActionSetActiveMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTouchActionSetActiveMsgDefaultTypeInternal _CTouchActionSetActiveMsg_default_instance_;
constexpr CTouchActionSetLayerAddedMsg::CTouchActionSetLayerAddedMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , actionset_id_(0){}
struct CTouchActionSetLayerAddedMsgDefaultTypeInternal {
  constexpr CTouchActionSetLayerAddedMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTouchActionSetLayerAddedMsgDefaultTypeInternal() {}
  union {
    CTouchActionSetLayerAddedMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTouchActionSetLayerAddedMsgDefaultTypeInternal _CTouchActionSetLayerAddedMsg_default_instance_;
constexpr CTouchActionSetLayerRemovedMsg::CTouchActionSetLayerRemovedMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , actionset_id_(0){}
struct CTouchActionSetLayerRemovedMsgDefaultTypeInternal {
  constexpr CTouchActionSetLayerRemovedMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTouchActionSetLayerRemovedMsgDefaultTypeInternal() {}
  union {
    CTouchActionSetLayerRemovedMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTouchActionSetLayerRemovedMsgDefaultTypeInternal _CTouchActionSetLayerRemovedMsg_default_instance_;
constexpr CGetTouchIconDataMsg::CGetTouchIconDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : icon_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u){}
struct CGetTouchIconDataMsgDefaultTypeInternal {
  constexpr CGetTouchIconDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CGetTouchIconDataMsgDefaultTypeInternal() {}
  union {
    CGetTouchIconDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CGetTouchIconDataMsgDefaultTypeInternal _CGetTouchIconDataMsg_default_instance_;
constexpr CSetTouchIconDataMsg::CSetTouchIconDataMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : icon_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u){}
struct CSetTouchIconDataMsgDefaultTypeInternal {
  constexpr CSetTouchIconDataMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetTouchIconDataMsgDefaultTypeInternal() {}
  union {
    CSetTouchIconDataMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetTouchIconDataMsgDefaultTypeInternal _CSetTouchIconDataMsg_default_instance_;
constexpr CRemotePlayTogetherGroupUpdateMsg_Player::CRemotePlayTogetherGroupUpdateMsg_Player(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_slots_()
  , avatar_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , accountid_(0u)
  , guestid_(0u)
  , keyboard_enabled_(false)
  , mouse_enabled_(false)
  , controller_enabled_(false){}
struct CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal {
  constexpr CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal() {}
  union {
    CRemotePlayTogetherGroupUpdateMsg_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal _CRemotePlayTogetherGroupUpdateMsg_Player_default_instance_;
constexpr CRemotePlayTogetherGroupUpdateMsg::CRemotePlayTogetherGroupUpdateMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : players_()
  , miniprofile_location_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , game_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , avatar_location_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , player_index_(0){}
struct CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal {
  constexpr CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal() {}
  union {
    CRemotePlayTogetherGroupUpdateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal _CRemotePlayTogetherGroupUpdateMsg_default_instance_;
constexpr CSetInputTemporarilyDisabledMsg::CSetInputTemporarilyDisabledMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : disabled_(false){}
struct CSetInputTemporarilyDisabledMsgDefaultTypeInternal {
  constexpr CSetInputTemporarilyDisabledMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetInputTemporarilyDisabledMsgDefaultTypeInternal() {}
  union {
    CSetInputTemporarilyDisabledMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetInputTemporarilyDisabledMsgDefaultTypeInternal _CSetInputTemporarilyDisabledMsg_default_instance_;
constexpr CSetQualityOverrideMsg::CSetQualityOverrideMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0){}
struct CSetQualityOverrideMsgDefaultTypeInternal {
  constexpr CSetQualityOverrideMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetQualityOverrideMsgDefaultTypeInternal() {}
  union {
    CSetQualityOverrideMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetQualityOverrideMsgDefaultTypeInternal _CSetQualityOverrideMsg_default_instance_;
constexpr CSetBitrateOverrideMsg::CSetBitrateOverrideMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : value_(0){}
struct CSetBitrateOverrideMsgDefaultTypeInternal {
  constexpr CSetBitrateOverrideMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSetBitrateOverrideMsgDefaultTypeInternal() {}
  union {
    CSetBitrateOverrideMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSetBitrateOverrideMsgDefaultTypeInternal _CSetBitrateOverrideMsg_default_instance_;
constexpr CShowOnScreenKeyboardMsg::CShowOnScreenKeyboardMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CShowOnScreenKeyboardMsgDefaultTypeInternal {
  constexpr CShowOnScreenKeyboardMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CShowOnScreenKeyboardMsgDefaultTypeInternal() {}
  union {
    CShowOnScreenKeyboardMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CShowOnScreenKeyboardMsgDefaultTypeInternal _CShowOnScreenKeyboardMsg_default_instance_;
constexpr CControllerPersonalizationUpdateMsg::CControllerPersonalizationUpdateMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : controller_path_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controller_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , reverse_diamond_button_layout_(false){}
struct CControllerPersonalizationUpdateMsgDefaultTypeInternal {
  constexpr CControllerPersonalizationUpdateMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerPersonalizationUpdateMsgDefaultTypeInternal() {}
  union {
    CControllerPersonalizationUpdateMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerPersonalizationUpdateMsgDefaultTypeInternal _CControllerPersonalizationUpdateMsg_default_instance_;
constexpr CStreamDataLostMsg::CStreamDataLostMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : packets_(){}
struct CStreamDataLostMsgDefaultTypeInternal {
  constexpr CStreamDataLostMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamDataLostMsgDefaultTypeInternal() {}
  union {
    CStreamDataLostMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamDataLostMsgDefaultTypeInternal _CStreamDataLostMsg_default_instance_;
constexpr CAudioFormat::CAudioFormat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : format_(0)

  , frequency_(0u)
  , channels_(0u){}
struct CAudioFormatDefaultTypeInternal {
  constexpr CAudioFormatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAudioFormatDefaultTypeInternal() {}
  union {
    CAudioFormat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAudioFormatDefaultTypeInternal _CAudioFormat_default_instance_;
constexpr CVideoFormat::CVideoFormat(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : format_(0)

  , width_(0u)
  , height_(0u){}
struct CVideoFormatDefaultTypeInternal {
  constexpr CVideoFormatDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CVideoFormatDefaultTypeInternal() {}
  union {
    CVideoFormat _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CVideoFormatDefaultTypeInternal _CVideoFormat_default_instance_;
constexpr CFrameEvent::CFrameEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : event_id_(0)

  , timestamp_(0u){}
struct CFrameEventDefaultTypeInternal {
  constexpr CFrameEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CFrameEventDefaultTypeInternal() {}
  union {
    CFrameEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CFrameEventDefaultTypeInternal _CFrameEvent_default_instance_;
constexpr CFrameStats::CFrameStats(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : events_()
  , frame_id_(0u)
  , input_mark_(0u)
  , result_(0)

  , frame_start_delta_(0)
  , frame_display_delta_(0)
  , ping_time_(0)
  , server_bitrate_(0)
  , client_bitrate_(0)
  , link_bandwidth_(0)
  , packet_loss_(0)
  , frame_size_(0u){}
struct CFrameStatsDefaultTypeInternal {
  constexpr CFrameStatsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CFrameStatsDefaultTypeInternal() {}
  union {
    CFrameStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CFrameStatsDefaultTypeInternal _CFrameStats_default_instance_;
constexpr CFrameStatAccumulatedValue::CFrameStatAccumulatedValue(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stat_type_(0)

  , count_(0)
  , average_(0)
  , stddev_(0){}
struct CFrameStatAccumulatedValueDefaultTypeInternal {
  constexpr CFrameStatAccumulatedValueDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CFrameStatAccumulatedValueDefaultTypeInternal() {}
  union {
    CFrameStatAccumulatedValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CFrameStatAccumulatedValueDefaultTypeInternal _CFrameStatAccumulatedValue_default_instance_;
constexpr CFrameStatsListMsg::CFrameStatsListMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : stats_()
  , accumulated_stats_()
  , data_type_(0)

  , latest_frame_id_(0){}
struct CFrameStatsListMsgDefaultTypeInternal {
  constexpr CFrameStatsListMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CFrameStatsListMsgDefaultTypeInternal() {}
  union {
    CFrameStatsListMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CFrameStatsListMsgDefaultTypeInternal _CFrameStatsListMsg_default_instance_;
constexpr CStreamingSessionStats::CStreamingSessionStats(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : frame_loss_percentage_(0)
  , average_network_time_ms_(0)
  , stddev_network_time_ms_(0){}
struct CStreamingSessionStatsDefaultTypeInternal {
  constexpr CStreamingSessionStatsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CStreamingSessionStatsDefaultTypeInternal() {}
  union {
    CStreamingSessionStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CStreamingSessionStatsDefaultTypeInternal _CStreamingSessionStats_default_instance_;
constexpr CDebugDumpMsg::CDebugDumpMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : screenshot_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CDebugDumpMsgDefaultTypeInternal {
  constexpr CDebugDumpMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CDebugDumpMsgDefaultTypeInternal() {}
  union {
    CDebugDumpMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CDebugDumpMsgDefaultTypeInternal _CDebugDumpMsg_default_instance_;
constexpr CLogMsg::CLogMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0){}
struct CLogMsgDefaultTypeInternal {
  constexpr CLogMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CLogMsgDefaultTypeInternal() {}
  union {
    CLogMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CLogMsgDefaultTypeInternal _CLogMsg_default_instance_;
constexpr CLogUploadMsg::CLogUploadMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , type_(0)
{}
struct CLogUploadMsgDefaultTypeInternal {
  constexpr CLogUploadMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CLogUploadMsgDefaultTypeInternal() {}
  union {
    CLogUploadMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CLogUploadMsgDefaultTypeInternal _CLogUploadMsg_default_instance_;
constexpr CTransportSignalMsg_WebRTCMessage_Candidate::CTransportSignalMsg_WebRTCMessage_Candidate(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sdp_mid_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , candidate_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , sdp_mline_index_(0){}
struct CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal {
  constexpr CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal() {}
  union {
    CTransportSignalMsg_WebRTCMessage_Candidate _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal _CTransportSignalMsg_WebRTCMessage_Candidate_default_instance_;
constexpr CTransportSignalMsg_WebRTCMessage::CTransportSignalMsg_WebRTCMessage(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : _oneof_case_{}{}
struct CTransportSignalMsg_WebRTCMessageDefaultTypeInternal {
  constexpr CTransportSignalMsg_WebRTCMessageDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTransportSignalMsg_WebRTCMessageDefaultTypeInternal() {}
  union {
    CTransportSignalMsg_WebRTCMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTransportSignalMsg_WebRTCMessageDefaultTypeInternal _CTransportSignalMsg_WebRTCMessage_default_instance_;
constexpr CTransportSignalMsg::CTransportSignalMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : sdr_()
  , webrtc_(nullptr){}
struct CTransportSignalMsgDefaultTypeInternal {
  constexpr CTransportSignalMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CTransportSignalMsgDefaultTypeInternal() {}
  union {
    CTransportSignalMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CTransportSignalMsgDefaultTypeInternal _CTransportSignalMsg_default_instance_;
constexpr CControllerConfigMsg_ControllerConfigResponse::CControllerConfigMsg_ControllerConfigResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controllerdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , controllertype_(0u)
  , selectionorder_(0u)
  , actionblock_(false){}
struct CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal {
  constexpr CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal() {}
  union {
    CControllerConfigMsg_ControllerConfigResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal _CControllerConfigMsg_ControllerConfigResponse_default_instance_;
constexpr CControllerConfigMsg_ControllerPersonalizationResponse::CControllerConfigMsg_ControllerPersonalizationResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : personalizationdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal {
  constexpr CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal() {}
  union {
    CControllerConfigMsg_ControllerPersonalizationResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal _CControllerConfigMsg_ControllerPersonalizationResponse_default_instance_;
constexpr CControllerConfigMsg_ControllerActiveConfigChangeResponse::CControllerConfigMsg_ControllerActiveConfigChangeResponse(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controllerdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controllertype_(0u)
  , selectionorder_(0u){}
struct CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal {
  constexpr CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal() {}
  union {
    CControllerConfigMsg_ControllerActiveConfigChangeResponse _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal _CControllerConfigMsg_ControllerActiveConfigChangeResponse_default_instance_;
constexpr CControllerConfigMsg_ControllerActiveConfigMsg::CControllerConfigMsg_ControllerActiveConfigMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configurl_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , controllerdata_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u)
  , controllertype_(0u){}
struct CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal {
  constexpr CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal() {}
  union {
    CControllerConfigMsg_ControllerActiveConfigMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal _CControllerConfigMsg_ControllerActiveConfigMsg_default_instance_;
constexpr CControllerConfigMsg::CControllerConfigMsg(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : configresponse_()
  , controllerpath_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , personalizationresponse_(nullptr)
  , activeconfigchangemsg_(nullptr)
  , type_(0)

  , appid_(0u){}
struct CControllerConfigMsgDefaultTypeInternal {
  constexpr CControllerConfigMsgDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CControllerConfigMsgDefaultTypeInternal() {}
  union {
    CControllerConfigMsg _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CControllerConfigMsgDefaultTypeInternal _CControllerConfigMsg_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fremoteplay_2eproto[112];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[26];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_steammessages_5fremoteplay_2eproto = nullptr;

const uint32_t TableStruct_steammessages_5fremoteplay_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingRequest, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingRequest, sequence_),
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingRequest, packet_size_requested_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingResponse, sequence_),
  PROTOBUF_FIELD_OFFSET(::CDiscoveryPingResponse, packet_size_received_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CStreamingClientHandshakeInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientHandshakeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingClientHandshakeInfo, network_test_),
  0,
  PROTOBUF_FIELD_OFFSET(::CClientHandshakeMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CClientHandshakeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CClientHandshakeMsg, info_),
  0,
  PROTOBUF_FIELD_OFFSET(::CStreamingServerHandshakeInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerHandshakeInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingServerHandshakeInfo, mtu_),
  0,
  PROTOBUF_FIELD_OFFSET(::CServerHandshakeMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CServerHandshakeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CServerHandshakeMsg, info_),
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthenticationRequestMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationRequestMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationRequestMsg, token_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationRequestMsg, version_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationRequestMsg, steamid_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::CAuthenticationResponseMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationResponseMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationResponseMsg, result_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationResponseMsg, version_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CKeepAliveMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, frames_),
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, framerate_),
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, bitrate_kbps_),
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, burst_bitrate_kbps_),
  PROTOBUF_FIELD_OFFSET(::CStartNetworkTestMsg, bandwidth_test_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, width_),
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, height_),
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, refresh_rate_),
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, refresh_rate_numerator_),
  PROTOBUF_FIELD_OFFSET(::CStreamVideoMode, refresh_rate_denominator_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, system_info_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, system_can_suspend_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, maximum_decode_bitrate_kbps_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, maximum_burst_bitrate_kbps_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, supports_video_hevc_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, disable_steam_store_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, disable_client_cursor_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, disable_intel_hardware_encoding_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, disable_amd_hardware_encoding_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, disable_nvidia_hardware_encoding_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, form_factor_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, has_on_screen_keyboard_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientCaps, supported_colorspaces_),
  0,
  3,
  1,
  2,
  4,
  5,
  6,
  7,
  8,
  9,
  11,
  10,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, quality_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, maximum_resolution_x_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, maximum_resolution_y_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, maximum_framerate_numerator_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, maximum_framerate_denominator_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, maximum_bitrate_kbps_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_hardware_decoding_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_performance_overlay_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_video_streaming_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_audio_streaming_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_input_streaming_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, audio_channels_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_video_hevc_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_performance_icons_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_microphone_streaming_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, controller_overlay_hotkey_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_touch_controller_obsolete_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, p2p_scope_),
  PROTOBUF_FIELD_OFFSET(::CStreamingClientConfig, enable_audio_uncompressed_),
  12,
  1,
  2,
  3,
  4,
  13,
  14,
  5,
  15,
  16,
  17,
  18,
  6,
  11,
  7,
  0,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, change_desktop_resolution_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, dynamically_adjust_resolution_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, enable_capture_nvfbc_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, enable_hardware_encoding_nvidia_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, enable_hardware_encoding_amd_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, enable_hardware_encoding_intel_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, software_encoding_threads_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, enable_traffic_priority_),
  PROTOBUF_FIELD_OFFSET(::CStreamingServerConfig, host_play_audio_),
  0,
  1,
  2,
  3,
  4,
  5,
  7,
  6,
  8,
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, reliable_data_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, selected_audio_codec_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, selected_video_codec_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, available_video_modes_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, enable_remote_hid_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, enable_touch_input_),
  PROTOBUF_FIELD_OFFSET(::CNegotiatedConfig, disable_client_cursor_),
  2,
  0,
  1,
  ~0u,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, reliable_data_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, supported_audio_codecs_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, supported_video_codecs_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, supports_remote_hid_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationInitMsg, supports_touch_input_),
  0,
  ~0u,
  ~0u,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CNegotiationSetConfigMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationSetConfigMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CNegotiationSetConfigMsg, config_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationSetConfigMsg, streaming_client_config_),
  PROTOBUF_FIELD_OFFSET(::CNegotiationSetConfigMsg, streaming_client_caps_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CNegotiationCompleteMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, channel_),
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, codec_),
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, codec_data_),
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, frequency_),
  PROTOBUF_FIELD_OFFSET(::CStartAudioDataMsg, channels_),
  1,
  2,
  0,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStopAudioDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, channel_),
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, codec_),
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, codec_data_),
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, width_),
  PROTOBUF_FIELD_OFFSET(::CStartVideoDataMsg, height_),
  1,
  2,
  0,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStopVideoDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartNeptuneDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStartNeptuneDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStartNeptuneDataMsg, channel_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStopNeptuneDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, type_),
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, timestamp_),
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CRecordedInput, data_),
  1,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CRecordedInputStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRecordedInputStream, entries_),
  PROTOBUF_FIELD_OFFSET(::CInputLatencyTestMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputLatencyTestMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputLatencyTestMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputLatencyTestMsg, color_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, fingerid_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, x_normalized_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerDownMsg, y_normalized_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, fingerid_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, x_normalized_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerMotionMsg, y_normalized_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, fingerid_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, x_normalized_),
  PROTOBUF_FIELD_OFFSET(::CInputTouchFingerUpMsg, y_normalized_),
  1,
  0,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, x_normalized_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, y_normalized_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, dx_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseMotionMsg, dy_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CInputMouseWheelMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseWheelMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputMouseWheelMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseWheelMsg, direction_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputMouseDownMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseDownMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputMouseDownMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseDownMsg, button_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputMouseUpMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseUpMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputMouseUpMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputMouseUpMsg, button_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputKeyDownMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputKeyDownMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputKeyDownMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputKeyDownMsg, scancode_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputKeyUpMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputKeyUpMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputKeyUpMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputKeyUpMsg, scancode_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CInputTextMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CInputTextMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CInputTextMsg, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CInputTextMsg, text_utf8_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSetTitleMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetTitleMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetTitleMsg, text_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetCaptureSizeMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetCaptureSizeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCaptureSizeMsg, width_),
  PROTOBUF_FIELD_OFFSET(::CSetCaptureSizeMsg, height_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSetIconMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetIconMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetIconMsg, width_),
  PROTOBUF_FIELD_OFFSET(::CSetIconMsg, height_),
  PROTOBUF_FIELD_OFFSET(::CSetIconMsg, image_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSetFlashStateMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetFlashStateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetFlashStateMsg, flags_),
  PROTOBUF_FIELD_OFFSET(::CSetFlashStateMsg, count_),
  PROTOBUF_FIELD_OFFSET(::CSetFlashStateMsg, timeout_ms_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CShowCursorMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CShowCursorMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CShowCursorMsg, x_normalized_),
  PROTOBUF_FIELD_OFFSET(::CShowCursorMsg, y_normalized_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CHideCursorMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCursorMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCursorMsg, cursor_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CGetCursorImageMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGetCursorImageMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGetCursorImageMsg, cursor_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, cursor_id_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, width_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, height_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, hot_x_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, hot_y_),
  PROTOBUF_FIELD_OFFSET(::CSetCursorImageMsg, image_),
  1,
  2,
  3,
  4,
  5,
  0,
  PROTOBUF_FIELD_OFFSET(::CVideoDecoderInfoMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVideoDecoderInfoMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVideoDecoderInfoMsg, info_),
  PROTOBUF_FIELD_OFFSET(::CVideoDecoderInfoMsg, threads_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CVideoEncoderInfoMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVideoEncoderInfoMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVideoEncoderInfoMsg, info_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CPauseMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CResumeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CEnableHighResCaptureMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDisableHighResCaptureMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CEnableNeptuneDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CDisableNeptuneDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CPauseControllerInputMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CResumeControllerInputMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CToggleMagnificationMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCapslockMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetCapslockMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetCapslockMsg, pressed_),
  0,
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, scancode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, normal_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, shift_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, capslock_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, shift_capslock_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, altgr_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, altgr_shift_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, altgr_capslock_keycode_),
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymapEntry, altgr_shift_capslock_keycode_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymap, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingKeymap, entries_),
  PROTOBUF_FIELD_OFFSET(::CSetKeymapMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetKeymapMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetKeymapMsg, keymap_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStopRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CQuitRequest, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDeleteCursorMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDeleteCursorMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDeleteCursorMsg, cursor_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetStreamingClientConfig, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetStreamingClientConfig, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetStreamingClientConfig, config_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetQoSMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetQoSMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetQoSMsg, use_qos_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, framerate_),
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, reasons_),
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, framerate_numerator_),
  PROTOBUF_FIELD_OFFSET(::CSetTargetFramerateMsg, framerate_denominator_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSetTargetBitrateMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetTargetBitrateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetTargetBitrateMsg, bitrate_),
  0,
  PROTOBUF_FIELD_OFFSET(::COverlayEnabledMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::COverlayEnabledMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::COverlayEnabledMsg, enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetGammaRampMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetGammaRampMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetGammaRampMsg, gamma_ramp_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, activity_),
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, gameid_),
  PROTOBUF_FIELD_OFFSET(::CSetActivityMsg, game_name_),
  3,
  2,
  1,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSystemSuspendMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVirtualHereRequestMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVirtualHereRequestMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVirtualHereRequestMsg, hostname_),
  0,
  PROTOBUF_FIELD_OFFSET(::CVirtualHereReadyMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVirtualHereReadyMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVirtualHereReadyMsg, licensed_device_count_),
  0,
  PROTOBUF_FIELD_OFFSET(::CVirtualHereShareDeviceMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVirtualHereShareDeviceMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVirtualHereShareDeviceMsg, device_address_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetSpectatorModeMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetSpectatorModeMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetSpectatorModeMsg, enabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CRemoteHIDMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CRemoteHIDMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRemoteHIDMsg, data_),
  PROTOBUF_FIELD_OFFSET(::CRemoteHIDMsg, active_input_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CTouchConfigActiveMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTouchConfigActiveMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTouchConfigActiveMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CTouchConfigActiveMsg, revision_),
  PROTOBUF_FIELD_OFFSET(::CTouchConfigActiveMsg, creator_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CGetTouchConfigDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGetTouchConfigDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGetTouchConfigDataMsg, appid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, revision_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, data_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, layout_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchConfigDataMsg, creator_),
  2,
  3,
  0,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CSaveTouchConfigLayoutMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSaveTouchConfigLayoutMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSaveTouchConfigLayoutMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CSaveTouchConfigLayoutMsg, layout_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetActiveMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetActiveMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetActiveMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetActiveMsg, actionset_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerAddedMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerAddedMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerAddedMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerAddedMsg, actionset_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerRemovedMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerRemovedMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerRemovedMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CTouchActionSetLayerRemovedMsg, actionset_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CGetTouchIconDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CGetTouchIconDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CGetTouchIconDataMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CGetTouchIconDataMsg, icon_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSetTouchIconDataMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchIconDataMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetTouchIconDataMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchIconDataMsg, icon_),
  PROTOBUF_FIELD_OFFSET(::CSetTouchIconDataMsg, data_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, accountid_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, guestid_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, keyboard_enabled_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, mouse_enabled_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, controller_enabled_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, controller_slots_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg_Player, avatar_hash_),
  1,
  2,
  3,
  4,
  5,
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, players_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, player_index_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, miniprofile_location_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, game_name_),
  PROTOBUF_FIELD_OFFSET(::CRemotePlayTogetherGroupUpdateMsg, avatar_location_),
  ~0u,
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSetInputTemporarilyDisabledMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetInputTemporarilyDisabledMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetInputTemporarilyDisabledMsg, disabled_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetQualityOverrideMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetQualityOverrideMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetQualityOverrideMsg, value_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSetBitrateOverrideMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSetBitrateOverrideMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSetBitrateOverrideMsg, value_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CShowOnScreenKeyboardMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerPersonalizationUpdateMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerPersonalizationUpdateMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerPersonalizationUpdateMsg, controller_path_),
  PROTOBUF_FIELD_OFFSET(::CControllerPersonalizationUpdateMsg, controller_name_),
  PROTOBUF_FIELD_OFFSET(::CControllerPersonalizationUpdateMsg, reverse_diamond_button_layout_),
  0,
  1,
  2,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CStreamDataLostMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamDataLostMsg, packets_),
  PROTOBUF_FIELD_OFFSET(::CAudioFormat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAudioFormat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAudioFormat, format_),
  PROTOBUF_FIELD_OFFSET(::CAudioFormat, frequency_),
  PROTOBUF_FIELD_OFFSET(::CAudioFormat, channels_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CVideoFormat, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CVideoFormat, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CVideoFormat, format_),
  PROTOBUF_FIELD_OFFSET(::CVideoFormat, width_),
  PROTOBUF_FIELD_OFFSET(::CVideoFormat, height_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CFrameEvent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CFrameEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CFrameEvent, event_id_),
  PROTOBUF_FIELD_OFFSET(::CFrameEvent, timestamp_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CFrameStats, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CFrameStats, frame_id_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, input_mark_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, events_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, result_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, frame_start_delta_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, frame_display_delta_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, ping_time_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, server_bitrate_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, client_bitrate_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, link_bandwidth_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, packet_loss_),
  PROTOBUF_FIELD_OFFSET(::CFrameStats, frame_size_),
  0,
  1,
  ~0u,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, stat_type_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, count_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, average_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatAccumulatedValue, stddev_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, data_type_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, stats_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, accumulated_stats_),
  PROTOBUF_FIELD_OFFSET(::CFrameStatsListMsg, latest_frame_id_),
  0,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::CStreamingSessionStats, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CStreamingSessionStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CStreamingSessionStats, frame_loss_percentage_),
  PROTOBUF_FIELD_OFFSET(::CStreamingSessionStats, average_network_time_ms_),
  PROTOBUF_FIELD_OFFSET(::CStreamingSessionStats, stddev_network_time_ms_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CDebugDumpMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CDebugDumpMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CDebugDumpMsg, screenshot_),
  0,
  PROTOBUF_FIELD_OFFSET(::CLogMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CLogMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CLogMsg, type_),
  PROTOBUF_FIELD_OFFSET(::CLogMsg, message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CLogUploadMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CLogUploadMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CLogUploadMsg, type_),
  PROTOBUF_FIELD_OFFSET(::CLogUploadMsg, data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage_Candidate, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage_Candidate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage_Candidate, sdp_mid_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage_Candidate, sdp_mline_index_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage_Candidate, candidate_),
  0,
  2,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  ::PROTOBUF_NAMESPACE_ID::internal::kInvalidFieldOffsetTag,
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg_WebRTCMessage, msg_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg, webrtc_),
  PROTOBUF_FIELD_OFFSET(::CTransportSignalMsg, sdr_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, appid_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, configurl_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, controllertype_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, controllerdata_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, selectionorder_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerConfigResponse, actionblock_),
  2,
  0,
  3,
  1,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerPersonalizationResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerPersonalizationResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerPersonalizationResponse, personalizationdata_),
  0,
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, configurl_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, controllertype_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, controllerdata_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigChangeResponse, selectionorder_),
  0,
  2,
  1,
  3,
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, configurl_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, controllertype_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg_ControllerActiveConfigMsg, controllerdata_),
  2,
  0,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, type_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, controllerpath_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, appid_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, personalizationresponse_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, configresponse_),
  PROTOBUF_FIELD_OFFSET(::CControllerConfigMsg, activeconfigchangemsg_),
  3,
  0,
  4,
  1,
  ~0u,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CDiscoveryPingRequest)},
  { 10, 18, -1, sizeof(::CDiscoveryPingResponse)},
  { 20, 27, -1, sizeof(::CStreamingClientHandshakeInfo)},
  { 28, 35, -1, sizeof(::CClientHandshakeMsg)},
  { 36, 43, -1, sizeof(::CStreamingServerHandshakeInfo)},
  { 44, 51, -1, sizeof(::CServerHandshakeMsg)},
  { 52, 61, -1, sizeof(::CAuthenticationRequestMsg)},
  { 64, 72, -1, sizeof(::CAuthenticationResponseMsg)},
  { 74, -1, -1, sizeof(::CKeepAliveMsg)},
  { 80, 91, -1, sizeof(::CStartNetworkTestMsg)},
  { 96, 107, -1, sizeof(::CStreamVideoMode)},
  { 112, 131, -1, sizeof(::CStreamingClientCaps)},
  { 144, 169, -1, sizeof(::CStreamingClientConfig)},
  { 188, 203, -1, sizeof(::CStreamingServerConfig)},
  { 212, 225, -1, sizeof(::CNegotiatedConfig)},
  { 232, 243, -1, sizeof(::CNegotiationInitMsg)},
  { 248, 257, -1, sizeof(::CNegotiationSetConfigMsg)},
  { 260, -1, -1, sizeof(::CNegotiationCompleteMsg)},
  { 266, 277, -1, sizeof(::CStartAudioDataMsg)},
  { 282, -1, -1, sizeof(::CStopAudioDataMsg)},
  { 288, 299, -1, sizeof(::CStartVideoDataMsg)},
  { 304, -1, -1, sizeof(::CStopVideoDataMsg)},
  { 310, 317, -1, sizeof(::CStartNeptuneDataMsg)},
  { 318, -1, -1, sizeof(::CStopNeptuneDataMsg)},
  { 324, 344, -1, sizeof(::CRecordedInput)},
  { 357, -1, -1, sizeof(::CRecordedInputStream)},
  { 364, 372, -1, sizeof(::CInputLatencyTestMsg)},
  { 374, 384, -1, sizeof(::CInputTouchFingerDownMsg)},
  { 388, 398, -1, sizeof(::CInputTouchFingerMotionMsg)},
  { 402, 412, -1, sizeof(::CInputTouchFingerUpMsg)},
  { 416, 427, -1, sizeof(::CInputMouseMotionMsg)},
  { 432, 440, -1, sizeof(::CInputMouseWheelMsg)},
  { 442, 450, -1, sizeof(::CInputMouseDownMsg)},
  { 452, 460, -1, sizeof(::CInputMouseUpMsg)},
  { 462, 470, -1, sizeof(::CInputKeyDownMsg)},
  { 472, 480, -1, sizeof(::CInputKeyUpMsg)},
  { 482, 490, -1, sizeof(::CInputTextMsg)},
  { 492, 499, -1, sizeof(::CSetTitleMsg)},
  { 500, 508, -1, sizeof(::CSetCaptureSizeMsg)},
  { 510, 519, -1, sizeof(::CSetIconMsg)},
  { 522, 531, -1, sizeof(::CSetFlashStateMsg)},
  { 534, 542, -1, sizeof(::CShowCursorMsg)},
  { 544, -1, -1, sizeof(::CHideCursorMsg)},
  { 550, 557, -1, sizeof(::CSetCursorMsg)},
  { 558, 565, -1, sizeof(::CGetCursorImageMsg)},
  { 566, 578, -1, sizeof(::CSetCursorImageMsg)},
  { 584, 592, -1, sizeof(::CVideoDecoderInfoMsg)},
  { 594, 601, -1, sizeof(::CVideoEncoderInfoMsg)},
  { 602, -1, -1, sizeof(::CPauseMsg)},
  { 608, -1, -1, sizeof(::CResumeMsg)},
  { 614, -1, -1, sizeof(::CEnableHighResCaptureMsg)},
  { 620, -1, -1, sizeof(::CDisableHighResCaptureMsg)},
  { 626, -1, -1, sizeof(::CEnableNeptuneDataMsg)},
  { 632, -1, -1, sizeof(::CDisableNeptuneDataMsg)},
  { 638, -1, -1, sizeof(::CPauseControllerInputMsg)},
  { 644, -1, -1, sizeof(::CResumeControllerInputMsg)},
  { 650, -1, -1, sizeof(::CToggleMagnificationMsg)},
  { 656, 663, -1, sizeof(::CSetCapslockMsg)},
  { 664, 679, -1, sizeof(::CStreamingKeymapEntry)},
  { 688, -1, -1, sizeof(::CStreamingKeymap)},
  { 695, 702, -1, sizeof(::CSetKeymapMsg)},
  { 703, -1, -1, sizeof(::CStopRequest)},
  { 709, -1, -1, sizeof(::CQuitRequest)},
  { 715, 722, -1, sizeof(::CDeleteCursorMsg)},
  { 723, 730, -1, sizeof(::CSetStreamingClientConfig)},
  { 731, 738, -1, sizeof(::CSetQoSMsg)},
  { 739, 749, -1, sizeof(::CSetTargetFramerateMsg)},
  { 753, 760, -1, sizeof(::CSetTargetBitrateMsg)},
  { 761, 768, -1, sizeof(::COverlayEnabledMsg)},
  { 769, 776, -1, sizeof(::CSetGammaRampMsg)},
  { 777, 787, -1, sizeof(::CSetActivityMsg)},
  { 791, -1, -1, sizeof(::CSystemSuspendMsg)},
  { 797, 804, -1, sizeof(::CVirtualHereRequestMsg)},
  { 805, 812, -1, sizeof(::CVirtualHereReadyMsg)},
  { 813, 820, -1, sizeof(::CVirtualHereShareDeviceMsg)},
  { 821, 828, -1, sizeof(::CSetSpectatorModeMsg)},
  { 829, 837, -1, sizeof(::CRemoteHIDMsg)},
  { 839, 848, -1, sizeof(::CTouchConfigActiveMsg)},
  { 851, 858, -1, sizeof(::CGetTouchConfigDataMsg)},
  { 859, 870, -1, sizeof(::CSetTouchConfigDataMsg)},
  { 875, 883, -1, sizeof(::CSaveTouchConfigLayoutMsg)},
  { 885, 893, -1, sizeof(::CTouchActionSetActiveMsg)},
  { 895, 903, -1, sizeof(::CTouchActionSetLayerAddedMsg)},
  { 905, 913, -1, sizeof(::CTouchActionSetLayerRemovedMsg)},
  { 915, 923, -1, sizeof(::CGetTouchIconDataMsg)},
  { 925, 934, -1, sizeof(::CSetTouchIconDataMsg)},
  { 937, 950, -1, sizeof(::CRemotePlayTogetherGroupUpdateMsg_Player)},
  { 957, 968, -1, sizeof(::CRemotePlayTogetherGroupUpdateMsg)},
  { 973, 980, -1, sizeof(::CSetInputTemporarilyDisabledMsg)},
  { 981, 988, -1, sizeof(::CSetQualityOverrideMsg)},
  { 989, 996, -1, sizeof(::CSetBitrateOverrideMsg)},
  { 997, -1, -1, sizeof(::CShowOnScreenKeyboardMsg)},
  { 1003, 1012, -1, sizeof(::CControllerPersonalizationUpdateMsg)},
  { 1015, -1, -1, sizeof(::CStreamDataLostMsg)},
  { 1022, 1031, -1, sizeof(::CAudioFormat)},
  { 1034, 1043, -1, sizeof(::CVideoFormat)},
  { 1046, 1054, -1, sizeof(::CFrameEvent)},
  { 1056, 1074, -1, sizeof(::CFrameStats)},
  { 1086, 1096, -1, sizeof(::CFrameStatAccumulatedValue)},
  { 1100, 1110, -1, sizeof(::CFrameStatsListMsg)},
  { 1114, 1123, -1, sizeof(::CStreamingSessionStats)},
  { 1126, 1133, -1, sizeof(::CDebugDumpMsg)},
  { 1134, 1142, -1, sizeof(::CLogMsg)},
  { 1144, 1152, -1, sizeof(::CLogUploadMsg)},
  { 1154, 1163, -1, sizeof(::CTransportSignalMsg_WebRTCMessage_Candidate)},
  { 1166, -1, -1, sizeof(::CTransportSignalMsg_WebRTCMessage)},
  { 1177, 1185, -1, sizeof(::CTransportSignalMsg)},
  { 1187, 1199, -1, sizeof(::CControllerConfigMsg_ControllerConfigResponse)},
  { 1205, 1212, -1, sizeof(::CControllerConfigMsg_ControllerPersonalizationResponse)},
  { 1213, 1223, -1, sizeof(::CControllerConfigMsg_ControllerActiveConfigChangeResponse)},
  { 1227, 1237, -1, sizeof(::CControllerConfigMsg_ControllerActiveConfigMsg)},
  { 1241, 1253, -1, sizeof(::CControllerConfigMsg)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDiscoveryPingRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDiscoveryPingResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingClientHandshakeInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CClientHandshakeMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingServerHandshakeInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CServerHandshakeMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationRequestMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationResponseMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CKeepAliveMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStartNetworkTestMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamVideoMode_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingClientCaps_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingClientConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingServerConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CNegotiatedConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CNegotiationInitMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CNegotiationSetConfigMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CNegotiationCompleteMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStartAudioDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStopAudioDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStartVideoDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStopVideoDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStartNeptuneDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStopNeptuneDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CRecordedInput_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CRecordedInputStream_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputLatencyTestMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputTouchFingerDownMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputTouchFingerMotionMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputTouchFingerUpMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputMouseMotionMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputMouseWheelMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputMouseDownMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputMouseUpMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputKeyDownMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputKeyUpMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CInputTextMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetTitleMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetCaptureSizeMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetIconMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetFlashStateMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CShowCursorMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CHideCursorMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetCursorMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGetCursorImageMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetCursorImageMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVideoDecoderInfoMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVideoEncoderInfoMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CPauseMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CResumeMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CEnableHighResCaptureMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDisableHighResCaptureMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CEnableNeptuneDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDisableNeptuneDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CPauseControllerInputMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CResumeControllerInputMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CToggleMagnificationMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetCapslockMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingKeymapEntry_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingKeymap_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetKeymapMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStopRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CQuitRequest_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDeleteCursorMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetStreamingClientConfig_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetQoSMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetTargetFramerateMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetTargetBitrateMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_COverlayEnabledMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetGammaRampMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetActivityMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSystemSuspendMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVirtualHereRequestMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVirtualHereReadyMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVirtualHereShareDeviceMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetSpectatorModeMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CRemoteHIDMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTouchConfigActiveMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGetTouchConfigDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetTouchConfigDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSaveTouchConfigLayoutMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTouchActionSetActiveMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTouchActionSetLayerAddedMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTouchActionSetLayerRemovedMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CGetTouchIconDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetTouchIconDataMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CRemotePlayTogetherGroupUpdateMsg_Player_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CRemotePlayTogetherGroupUpdateMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetInputTemporarilyDisabledMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetQualityOverrideMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSetBitrateOverrideMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CShowOnScreenKeyboardMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerPersonalizationUpdateMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamDataLostMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAudioFormat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CVideoFormat_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CFrameEvent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CFrameStats_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CFrameStatAccumulatedValue_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CFrameStatsListMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CStreamingSessionStats_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CDebugDumpMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CLogMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CLogUploadMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTransportSignalMsg_WebRTCMessage_Candidate_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTransportSignalMsg_WebRTCMessage_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CTransportSignalMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerConfigMsg_ControllerConfigResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerConfigMsg_ControllerPersonalizationResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerConfigMsg_ControllerActiveConfigChangeResponse_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerConfigMsg_ControllerActiveConfigMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CControllerConfigMsg_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fremoteplay_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\036steammessages_remoteplay.proto\"H\n\025CDis"
  "coveryPingRequest\022\020\n\010sequence\030\001 \001(\r\022\035\n\025p"
  "acket_size_requested\030\002 \001(\r\"H\n\026CDiscovery"
  "PingResponse\022\020\n\010sequence\030\001 \001(\r\022\034\n\024packet"
  "_size_received\030\002 \001(\r\"5\n\035CStreamingClient"
  "HandshakeInfo\022\024\n\014network_test\030\002 \001(\005\"C\n\023C"
  "ClientHandshakeMsg\022,\n\004info\030\001 \002(\0132\036.CStre"
  "amingClientHandshakeInfo\",\n\035CStreamingSe"
  "rverHandshakeInfo\022\013\n\003mtu\030\001 \001(\005\"C\n\023CServe"
  "rHandshakeMsg\022,\n\004info\030\001 \002(\0132\036.CStreaming"
  "ServerHandshakeInfo\"s\n\031CAuthenticationRe"
  "questMsg\022\r\n\005token\030\001 \001(\014\0226\n\007version\030\002 \001(\016"
  "2\017.EStreamVersion:\024k_EStreamVersionNone\022"
  "\017\n\007steamid\030\003 \001(\004\"\324\001\n\032CAuthenticationResp"
  "onseMsg\022K\n\006result\030\001 \001(\01620.CAuthenticatio"
  "nResponseMsg.AuthenticationResult:\tSUCCE"
  "EDED\0226\n\007version\030\002 \001(\0162\017.EStreamVersion:\024"
  "k_EStreamVersionNone\"1\n\024AuthenticationRe"
  "sult\022\r\n\tSUCCEEDED\020\000\022\n\n\006FAILED\020\001\"\017\n\rCKeep"
  "AliveMsg\"\203\001\n\024CStartNetworkTestMsg\022\016\n\006fra"
  "mes\030\001 \001(\r\022\021\n\tframerate\030\002 \001(\r\022\024\n\014bitrate_"
  "kbps\030\003 \001(\r\022\032\n\022burst_bitrate_kbps\030\004 \001(\r\022\026"
  "\n\016bandwidth_test\030\005 \001(\010\"\211\001\n\020CStreamVideoM"
  "ode\022\r\n\005width\030\001 \002(\r\022\016\n\006height\030\002 \002(\r\022\024\n\014re"
  "fresh_rate\030\003 \001(\r\022\036\n\026refresh_rate_numerat"
  "or\030\004 \001(\r\022 \n\030refresh_rate_denominator\030\005 \001"
  "(\r\"\313\003\n\024CStreamingClientCaps\022\023\n\013system_in"
  "fo\030\001 \001(\t\022\032\n\022system_can_suspend\030\002 \001(\010\022#\n\033"
  "maximum_decode_bitrate_kbps\030\003 \001(\005\022\"\n\032max"
  "imum_burst_bitrate_kbps\030\004 \001(\005\022\033\n\023support"
  "s_video_hevc\030\005 \001(\010\022\033\n\023disable_steam_stor"
  "e\030\006 \001(\010\022\035\n\025disable_client_cursor\030\007 \001(\010\022\'"
  "\n\037disable_intel_hardware_encoding\030\010 \001(\010\022"
  "%\n\035disable_amd_hardware_encoding\030\t \001(\010\022("
  "\n disable_nvidia_hardware_encoding\030\n \001(\010"
  "\022\023\n\013form_factor\030\013 \001(\005\022\036\n\026has_on_screen_k"
  "eyboard\030\014 \001(\010\0221\n\025supported_colorspaces\030\r"
  " \003(\0162\022.EStreamColorspace\"\235\006\n\026CStreamingC"
  "lientConfig\022D\n\007quality\030\001 \001(\0162\031.EStreamQu"
  "alityPreference:\030k_EStreamQualityBalance"
  "d\022\034\n\024maximum_resolution_x\030\002 \001(\r\022\034\n\024maxim"
  "um_resolution_y\030\003 \001(\r\022#\n\033maximum_framera"
  "te_numerator\030\004 \001(\r\022%\n\035maximum_framerate_"
  "denominator\030\005 \001(\r\022 \n\024maximum_bitrate_kbp"
  "s\030\006 \001(\005:\002-1\022&\n\030enable_hardware_decoding\030"
  "\007 \001(\010:\004true\022)\n\032enable_performance_overla"
  "y\030\010 \001(\010:\005false\022$\n\026enable_video_streaming"
  "\030\t \001(\010:\004true\022$\n\026enable_audio_streaming\030\n"
  " \001(\010:\004true\022$\n\026enable_input_streaming\030\013 \001"
  "(\010:\004true\022\031\n\016audio_channels\030\014 \001(\005:\0012\022 \n\021e"
  "nable_video_hevc\030\r \001(\010:\005false\022&\n\030enable_"
  "performance_icons\030\016 \001(\010:\004true\022*\n\033enable_"
  "microphone_streaming\030\017 \001(\010:\005false\022!\n\031con"
  "troller_overlay_hotkey\030\020 \001(\t\022/\n enable_t"
  "ouch_controller_OBSOLETE\030\021 \001(\010:\005false\022\?\n"
  "\tp2p_scope\030\023 \001(\0162\020.EStreamP2PScope:\032k_ES"
  "treamP2PScopeAutomatic\022(\n\031enable_audio_u"
  "ncompressed\030\024 \001(\010:\005false\"\224\003\n\026CStreamingS"
  "erverConfig\022!\n\031change_desktop_resolution"
  "\030\001 \001(\010\022%\n\035dynamically_adjust_resolution\030"
  "\002 \001(\010\022\034\n\024enable_capture_nvfbc\030\003 \001(\010\022\'\n\037e"
  "nable_hardware_encoding_nvidia\030\004 \001(\010\022$\n\034"
  "enable_hardware_encoding_amd\030\005 \001(\010\022&\n\036en"
  "able_hardware_encoding_intel\030\006 \001(\010\022!\n\031so"
  "ftware_encoding_threads\030\007 \001(\005\022\037\n\027enable_"
  "traffic_priority\030\010 \001(\010\022W\n\017host_play_audi"
  "o\030\t \001(\0162\037.EStreamHostPlayAudioPreference"
  ":\035k_EStreamHostPlayAudioDefault\"\310\002\n\021CNeg"
  "otiatedConfig\022\025\n\rreliable_data\030\001 \001(\010\022I\n\024"
  "selected_audio_codec\030\002 \001(\0162\022.EStreamAudi"
  "oCodec:\027k_EStreamAudioCodecNone\022I\n\024selec"
  "ted_video_codec\030\003 \001(\0162\022.EStreamVideoCode"
  "c:\027k_EStreamVideoCodecNone\0220\n\025available_"
  "video_modes\030\004 \003(\0132\021.CStreamVideoMode\022\031\n\021"
  "enable_remote_hid\030\005 \001(\010\022\032\n\022enable_touch_"
  "input\030\006 \001(\010\022\035\n\025disable_client_cursor\030\007 \001"
  "(\010\"\317\001\n\023CNegotiationInitMsg\022\025\n\rreliable_d"
  "ata\030\001 \001(\010\0222\n\026supported_audio_codecs\030\002 \003("
  "\0162\022.EStreamAudioCodec\0222\n\026supported_video"
  "_codecs\030\003 \003(\0162\022.EStreamVideoCodec\022\033\n\023sup"
  "ports_remote_hid\030\004 \001(\010\022\034\n\024supports_touch"
  "_input\030\005 \001(\010\"\256\001\n\030CNegotiationSetConfigMs"
  "g\022\"\n\006config\030\001 \002(\0132\022.CNegotiatedConfig\0228\n"
  "\027streaming_client_config\030\002 \001(\0132\027.CStream"
  "ingClientConfig\0224\n\025streaming_client_caps"
  "\030\003 \001(\0132\025.CStreamingClientCaps\"\031\n\027CNegoti"
  "ationCompleteMsg\"\232\001\n\022CStartAudioDataMsg\022"
  "\017\n\007channel\030\002 \002(\r\022:\n\005codec\030\003 \001(\0162\022.EStrea"
  "mAudioCodec:\027k_EStreamAudioCodecNone\022\022\n\n"
  "codec_data\030\004 \001(\014\022\021\n\tfrequency\030\005 \001(\r\022\020\n\010c"
  "hannels\030\006 \001(\r\"\023\n\021CStopAudioDataMsg\"\224\001\n\022C"
  "StartVideoDataMsg\022\017\n\007channel\030\001 \002(\r\022:\n\005co"
  "dec\030\002 \001(\0162\022.EStreamVideoCodec:\027k_EStream"
  "VideoCodecNone\022\022\n\ncodec_data\030\003 \001(\014\022\r\n\005wi"
  "dth\030\004 \001(\r\022\016\n\006height\030\005 \001(\r\"\023\n\021CStopVideoD"
  "ataMsg\"\'\n\024CStartNeptuneDataMsg\022\017\n\007channe"
  "l\030\001 \002(\r\"\025\n\023CStopNeptuneDataMsg\"\305\004\n\016CReco"
  "rdedInput\022K\n\004type\030\001 \001(\0162\026.EStreamControl"
  "Message:%k_EStreamControlAuthenticationR"
  "equest\022\021\n\ttimestamp\030\002 \001(\r\0220\n\013finger_down"
  "\030\003 \001(\0132\031.CInputTouchFingerDownMsgH\000\0224\n\rf"
  "inger_motion\030\004 \001(\0132\033.CInputTouchFingerMo"
  "tionMsgH\000\022,\n\tfinger_up\030\005 \001(\0132\027.CInputTou"
  "chFingerUpMsgH\000\022-\n\014mouse_motion\030\006 \001(\0132\025."
  "CInputMouseMotionMsgH\000\022+\n\013mouse_wheel\030\007 "
  "\001(\0132\024.CInputMouseWheelMsgH\000\022)\n\nmouse_dow"
  "n\030\010 \001(\0132\023.CInputMouseDownMsgH\000\022%\n\010mouse_"
  "up\030\t \001(\0132\021.CInputMouseUpMsgH\000\022%\n\010key_dow"
  "n\030\n \001(\0132\021.CInputKeyDownMsgH\000\022!\n\006key_up\030\013"
  " \001(\0132\017.CInputKeyUpMsgH\000\022\036\n\004text\030\014 \001(\0132\016."
  "CInputTextMsgH\000\022\035\n\003hid\030\r \001(\0132\016.CRemoteHI"
  "DMsgH\000B\006\n\004data\"8\n\024CRecordedInputStream\022 "
  "\n\007entries\030\001 \003(\0132\017.CRecordedInput\"9\n\024CInp"
  "utLatencyTestMsg\022\022\n\ninput_mark\030\001 \002(\r\022\r\n\005"
  "color\030\002 \001(\r\"l\n\030CInputTouchFingerDownMsg\022"
  "\022\n\ninput_mark\030\001 \001(\r\022\020\n\010fingerid\030\002 \001(\004\022\024\n"
  "\014x_normalized\030\003 \001(\002\022\024\n\014y_normalized\030\004 \001("
  "\002\"n\n\032CInputTouchFingerMotionMsg\022\022\n\ninput"
  "_mark\030\001 \001(\r\022\020\n\010fingerid\030\002 \001(\004\022\024\n\014x_norma"
  "lized\030\003 \001(\002\022\024\n\014y_normalized\030\004 \001(\002\"j\n\026CIn"
  "putTouchFingerUpMsg\022\022\n\ninput_mark\030\001 \001(\r\022"
  "\020\n\010fingerid\030\002 \001(\004\022\024\n\014x_normalized\030\003 \001(\002\022"
  "\024\n\014y_normalized\030\004 \001(\002\"n\n\024CInputMouseMoti"
  "onMsg\022\022\n\ninput_mark\030\001 \001(\r\022\024\n\014x_normalize"
  "d\030\002 \001(\002\022\024\n\014y_normalized\030\003 \001(\002\022\n\n\002dx\030\004 \001("
  "\005\022\n\n\002dy\030\005 \001(\005\"p\n\023CInputMouseWheelMsg\022\022\n\n"
  "input_mark\030\001 \001(\r\022E\n\tdirection\030\002 \002(\0162\033.ES"
  "treamMouseWheelDirection:\025k_EStreamMouse"
  "WheelUp\"g\n\022CInputMouseDownMsg\022\022\n\ninput_m"
  "ark\030\001 \001(\r\022=\n\006button\030\002 \002(\0162\023.EStreamMouse"
  "Button:\030k_EStreamMouseButtonLeft\"e\n\020CInp"
  "utMouseUpMsg\022\022\n\ninput_mark\030\001 \001(\r\022=\n\006butt"
  "on\030\002 \002(\0162\023.EStreamMouseButton:\030k_EStream"
  "MouseButtonLeft\"8\n\020CInputKeyDownMsg\022\022\n\ni"
  "nput_mark\030\001 \001(\r\022\020\n\010scancode\030\002 \002(\r\"6\n\016CIn"
  "putKeyUpMsg\022\022\n\ninput_mark\030\001 \001(\r\022\020\n\010scanc"
  "ode\030\002 \002(\r\"6\n\rCInputTextMsg\022\022\n\ninput_mark"
  "\030\001 \001(\r\022\021\n\ttext_utf8\030\002 \002(\t\"\034\n\014CSetTitleMs"
  "g\022\014\n\004text\030\001 \001(\t\"3\n\022CSetCaptureSizeMsg\022\r\n"
  "\005width\030\001 \001(\005\022\016\n\006height\030\002 \001(\005\";\n\013CSetIcon"
  "Msg\022\r\n\005width\030\001 \001(\005\022\016\n\006height\030\002 \001(\005\022\r\n\005im"
  "age\030\003 \001(\014\"E\n\021CSetFlashStateMsg\022\r\n\005flags\030"
  "\001 \001(\r\022\r\n\005count\030\002 \001(\r\022\022\n\ntimeout_ms\030\003 \001(\r"
  "\"<\n\016CShowCursorMsg\022\024\n\014x_normalized\030\001 \001(\002"
  "\022\024\n\014y_normalized\030\002 \001(\002\"\020\n\016CHideCursorMsg"
  "\"\"\n\rCSetCursorMsg\022\021\n\tcursor_id\030\001 \002(\004\"\'\n\022"
  "CGetCursorImageMsg\022\021\n\tcursor_id\030\001 \002(\004\"s\n"
  "\022CSetCursorImageMsg\022\021\n\tcursor_id\030\001 \002(\004\022\r"
  "\n\005width\030\002 \001(\005\022\016\n\006height\030\003 \001(\005\022\r\n\005hot_x\030\004"
  " \001(\005\022\r\n\005hot_y\030\005 \001(\005\022\r\n\005image\030\006 \001(\014\"5\n\024CV"
  "ideoDecoderInfoMsg\022\014\n\004info\030\001 \001(\t\022\017\n\007thre"
  "ads\030\002 \001(\005\"$\n\024CVideoEncoderInfoMsg\022\014\n\004inf"
  "o\030\001 \001(\t\"\013\n\tCPauseMsg\"\014\n\nCResumeMsg\"\032\n\030CE"
  "nableHighResCaptureMsg\"\033\n\031CDisableHighRe"
  "sCaptureMsg\"\027\n\025CEnableNeptuneDataMsg\"\030\n\026"
  "CDisableNeptuneDataMsg\"\032\n\030CPauseControll"
  "erInputMsg\"\033\n\031CResumeControllerInputMsg\""
  "\031\n\027CToggleMagnificationMsg\"\"\n\017CSetCapslo"
  "ckMsg\022\017\n\007pressed\030\001 \001(\010\"\214\002\n\025CStreamingKey"
  "mapEntry\022\020\n\010scancode\030\001 \001(\005\022\026\n\016normal_key"
  "code\030\002 \001(\005\022\025\n\rshift_keycode\030\003 \001(\005\022\030\n\020cap"
  "slock_keycode\030\004 \001(\005\022\036\n\026shift_capslock_ke"
  "ycode\030\005 \001(\005\022\025\n\raltgr_keycode\030\006 \001(\005\022\033\n\023al"
  "tgr_shift_keycode\030\007 \001(\005\022\036\n\026altgr_capsloc"
  "k_keycode\030\010 \001(\005\022$\n\034altgr_shift_capslock_"
  "keycode\030\t \001(\005\";\n\020CStreamingKeymap\022\'\n\007ent"
  "ries\030\001 \003(\0132\026.CStreamingKeymapEntry\"2\n\rCS"
  "etKeymapMsg\022!\n\006keymap\030\001 \001(\0132\021.CStreaming"
  "Keymap\"\016\n\014CStopRequest\"\016\n\014CQuitRequest\"%"
  "\n\020CDeleteCursorMsg\022\021\n\tcursor_id\030\001 \002(\004\"D\n"
  "\031CSetStreamingClientConfig\022\'\n\006config\030\001 \002"
  "(\0132\027.CStreamingClientConfig\"\035\n\nCSetQoSMs"
  "g\022\017\n\007use_qos\030\001 \002(\010\"x\n\026CSetTargetFramerat"
  "eMsg\022\021\n\tframerate\030\001 \002(\r\022\017\n\007reasons\030\002 \001(\r"
  "\022\033\n\023framerate_numerator\030\003 \001(\r\022\035\n\025framera"
  "te_denominator\030\004 \001(\r\"\'\n\024CSetTargetBitrat"
  "eMsg\022\017\n\007bitrate\030\001 \002(\005\"%\n\022COverlayEnabled"
  "Msg\022\017\n\007enabled\030\001 \002(\010\"&\n\020CSetGammaRampMsg"
  "\022\022\n\ngamma_ramp\030\001 \001(\014\"~\n\017CSetActivityMsg\022"
  "9\n\010activity\030\001 \001(\0162\020.EStreamActivity:\025k_E"
  "StreamActivityIdle\022\r\n\005appid\030\002 \001(\r\022\016\n\006gam"
  "eid\030\003 \001(\004\022\021\n\tgame_name\030\004 \001(\t\"\023\n\021CSystemS"
  "uspendMsg\"*\n\026CVirtualHereRequestMsg\022\020\n\010h"
  "ostname\030\001 \001(\t\"5\n\024CVirtualHereReadyMsg\022\035\n"
  "\025licensed_device_count\030\001 \001(\r\"4\n\032CVirtual"
  "HereShareDeviceMsg\022\026\n\016device_address\030\001 \001"
  "(\t\"\'\n\024CSetSpectatorModeMsg\022\017\n\007enabled\030\001 "
  "\001(\010\"3\n\rCRemoteHIDMsg\022\014\n\004data\030\001 \001(\014\022\024\n\014ac"
  "tive_input\030\002 \001(\010\"I\n\025CTouchConfigActiveMs"
  "g\022\r\n\005appid\030\001 \001(\r\022\020\n\010revision\030\002 \001(\r\022\017\n\007cr"
  "eator\030\003 \001(\004\"\'\n\026CGetTouchConfigDataMsg\022\r\n"
  "\005appid\030\001 \001(\r\"h\n\026CSetTouchConfigDataMsg\022\r"
  "\n\005appid\030\001 \001(\r\022\020\n\010revision\030\002 \001(\r\022\014\n\004data\030"
  "\003 \001(\014\022\016\n\006layout\030\004 \001(\014\022\017\n\007creator\030\005 \001(\004\":"
  "\n\031CSaveTouchConfigLayoutMsg\022\r\n\005appid\030\001 \001"
  "(\r\022\016\n\006layout\030\004 \001(\014\"\?\n\030CTouchActionSetAct"
  "iveMsg\022\r\n\005appid\030\001 \001(\r\022\024\n\014actionset_id\030\002 "
  "\001(\005\"C\n\034CTouchActionSetLayerAddedMsg\022\r\n\005a"
  "ppid\030\001 \001(\r\022\024\n\014actionset_id\030\002 \001(\005\"E\n\036CTou"
  "chActionSetLayerRemovedMsg\022\r\n\005appid\030\001 \001("
  "\r\022\024\n\014actionset_id\030\002 \001(\005\"3\n\024CGetTouchIcon"
  "DataMsg\022\r\n\005appid\030\001 \001(\r\022\014\n\004icon\030\002 \001(\t\"A\n\024"
  "CSetTouchIconDataMsg\022\r\n\005appid\030\001 \001(\r\022\014\n\004i"
  "con\030\002 \001(\t\022\014\n\004data\030\003 \001(\014\"\352\002\n!CRemotePlayT"
  "ogetherGroupUpdateMsg\022:\n\007players\030\001 \003(\0132)"
  ".CRemotePlayTogetherGroupUpdateMsg.Playe"
  "r\022\024\n\014player_index\030\002 \001(\005\022\034\n\024miniprofile_l"
  "ocation\030\003 \001(\t\022\021\n\tgame_name\030\004 \001(\t\022\027\n\017avat"
  "ar_location\030\005 \001(\t\032\250\001\n\006Player\022\021\n\taccounti"
  "d\030\001 \001(\r\022\017\n\007guestid\030\002 \001(\r\022\030\n\020keyboard_ena"
  "bled\030\003 \001(\010\022\025\n\rmouse_enabled\030\004 \001(\010\022\032\n\022con"
  "troller_enabled\030\005 \001(\010\022\030\n\020controller_slot"
  "s\030\006 \003(\r\022\023\n\013avatar_hash\030\007 \001(\014\"3\n\037CSetInpu"
  "tTemporarilyDisabledMsg\022\020\n\010disabled\030\001 \001("
  "\010\"\'\n\026CSetQualityOverrideMsg\022\r\n\005value\030\001 \001"
  "(\005\"\'\n\026CSetBitrateOverrideMsg\022\r\n\005value\030\001 "
  "\001(\005\"\032\n\030CShowOnScreenKeyboardMsg\"~\n#CCont"
  "rollerPersonalizationUpdateMsg\022\027\n\017contro"
  "ller_path\030\001 \001(\t\022\027\n\017controller_name\030\002 \001(\t"
  "\022%\n\035reverse_diamond_button_layout\030\003 \001(\010\""
  "%\n\022CStreamDataLostMsg\022\017\n\007packets\030\001 \003(\r\"f"
  "\n\014CAudioFormat\0221\n\006format\030\001 \002(\0162\r.EAudioF"
  "ormat:\022k_EAudioFormatNone\022\021\n\tfrequency\030\002"
  " \001(\r\022\020\n\010channels\030\003 \001(\r\"`\n\014CVideoFormat\0221"
  "\n\006format\030\001 \002(\0162\r.EVideoFormat:\022k_EVideoF"
  "ormatNone\022\r\n\005width\030\002 \001(\r\022\016\n\006height\030\003 \001(\r"
  "\"`\n\013CFrameEvent\022>\n\010event_id\030\001 \002(\0162\022.EStr"
  "eamFrameEvent:\030k_EStreamInputEventStart\022"
  "\021\n\ttimestamp\030\002 \002(\r\"\317\002\n\013CFrameStats\022\020\n\010fr"
  "ame_id\030\001 \002(\r\022\022\n\ninput_mark\030\002 \001(\r\022\034\n\006even"
  "ts\030\003 \003(\0132\014.CFrameEvent\022@\n\006result\030\004 \002(\0162\023"
  ".EStreamFrameResult:\033k_EStreamFrameResul"
  "tPending\022\031\n\021frame_start_delta\030\005 \001(\002\022\033\n\023f"
  "rame_display_delta\030\006 \001(\002\022\021\n\tping_time\030\007 "
  "\001(\002\022\026\n\016server_bitrate\030\010 \001(\002\022\026\n\016client_bi"
  "trate\030\t \001(\002\022\026\n\016link_bandwidth\030\n \001(\002\022\023\n\013p"
  "acket_loss\030\013 \001(\002\022\022\n\nframe_size\030\014 \001(\r\"\210\001\n"
  "\032CFrameStatAccumulatedValue\022:\n\tstat_type"
  "\030\001 \002(\0162\026.EFrameAccumulatedStat:\017k_EFrame"
  "StatFPS\022\r\n\005count\030\002 \002(\005\022\017\n\007average\030\003 \002(\002\022"
  "\016\n\006stddev\030\004 \001(\002\"\301\001\n\022CFrameStatsListMsg\022="
  "\n\tdata_type\030\001 \002(\0162\023.EStreamingDataType:\025"
  "k_EStreamingAudioData\022\033\n\005stats\030\002 \003(\0132\014.C"
  "FrameStats\0226\n\021accumulated_stats\030\003 \003(\0132\033."
  "CFrameStatAccumulatedValue\022\027\n\017latest_fra"
  "me_id\030\004 \002(\005\"x\n\026CStreamingSessionStats\022\035\n"
  "\025frame_loss_percentage\030\001 \001(\002\022\037\n\027average_"
  "network_time_ms\030\002 \001(\002\022\036\n\026stddev_network_"
  "time_ms\030\003 \001(\002\"#\n\rCDebugDumpMsg\022\022\n\nscreen"
  "shot\030\001 \001(\014\"(\n\007CLogMsg\022\014\n\004type\030\001 \001(\005\022\017\n\007m"
  "essage\030\002 \001(\t\"P\n\rCLogUploadMsg\0221\n\004type\030\001 "
  "\001(\0162\r.ELogFileType:\024k_ELogFileSystemBoot"
  "\022\014\n\004data\030\003 \001(\014\"\263\002\n\023CTransportSignalMsg\0222"
  "\n\006webrtc\030\001 \001(\0132\".CTransportSignalMsg.Web"
  "RTCMessage\022\013\n\003sdr\030\002 \003(\014\032\332\001\n\rWebRTCMessag"
  "e\022\022\n\010greeting\030\001 \001(\010H\000\022\017\n\005offer\030\002 \001(\tH\000\022\020"
  "\n\006answer\030\003 \001(\tH\000\022A\n\tcandidate\030\004 \001(\0132,.CT"
  "ransportSignalMsg.WebRTCMessage.Candidat"
  "eH\000\032H\n\tCandidate\022\017\n\007sdp_mid\030\001 \001(\t\022\027\n\017sdp"
  "_mline_index\030\002 \001(\005\022\021\n\tcandidate\030\003 \001(\tB\005\n"
  "\003msg\"\336\006\n\024CControllerConfigMsg\022\\\n\004type\030\001 "
  "\002(\0162\033.EStreamControllerConfigMsg:1k_EStr"
  "eamControllerConfigMsg_RequestConfigsFor"
  "App\022\026\n\016controllerPath\030\002 \001(\t\022\r\n\005appid\030\003 \001"
  "(\r\022X\n\027personalizationResponse\030\004 \001(\01327.CC"
  "ontrollerConfigMsg.ControllerPersonaliza"
  "tionResponse\022F\n\016configResponse\030\006 \003(\0132..C"
  "ControllerConfigMsg.ControllerConfigResp"
  "onse\022N\n\025activeConfigChangeMsg\030\007 \001(\0132/.CC"
  "ontrollerConfigMsg.ControllerActiveConfi"
  "gMsg\032\231\001\n\030ControllerConfigResponse\022\r\n\005app"
  "id\030\001 \001(\r\022\021\n\tconfigURL\030\002 \001(\t\022\026\n\016controlle"
  "rType\030\003 \001(\r\022\026\n\016controllerData\030\004 \001(\t\022\026\n\016s"
  "electionOrder\030\005 \001(\r\022\023\n\013actionBlock\030\006 \001(\010"
  "\032@\n!ControllerPersonalizationResponse\022\033\n"
  "\023personalizationData\030\001 \001(\t\032\201\001\n$Controlle"
  "rActiveConfigChangeResponse\022\021\n\tconfigURL"
  "\030\002 \001(\t\022\026\n\016controllerType\030\003 \001(\r\022\026\n\016contro"
  "llerData\030\004 \001(\t\022\026\n\016selectionOrder\030\005 \001(\r\032m"
  "\n\031ControllerActiveConfigMsg\022\r\n\005appid\030\001 \001"
  "(\r\022\021\n\tconfigURL\030\002 \001(\t\022\026\n\016controllerType\030"
  "\003 \001(\r\022\026\n\016controllerData\030\004 \001(\t*\263\001\n\016EStrea"
  "mChannel\022$\n\027k_EStreamChannelInvalid\020\377\377\377\377"
  "\377\377\377\377\377\001\022\035\n\031k_EStreamChannelDiscovery\020\000\022\033\n"
  "\027k_EStreamChannelControl\020\001\022\031\n\025k_EStreamC"
  "hannelStats\020\002\022$\n k_EStreamChannelDataCha"
  "nnelStart\020\003*`\n\027EStreamDiscoveryMessage\022!"
  "\n\035k_EStreamDiscoveryPingRequest\020\001\022\"\n\036k_E"
  "StreamDiscoveryPingResponse\020\002*\333\036\n\025EStrea"
  "mControlMessage\022)\n%k_EStreamControlAuthe"
  "nticationRequest\020\001\022*\n&k_EStreamControlAu"
  "thenticationResponse\020\002\022#\n\037k_EStreamContr"
  "olNegotiationInit\020\003\022(\n$k_EStreamControlN"
  "egotiationSetConfig\020\004\022\'\n#k_EStreamContro"
  "lNegotiationComplete\020\005\022#\n\037k_EStreamContr"
  "olClientHandshake\020\006\022#\n\037k_EStreamControlS"
  "erverHandshake\020\007\022$\n k_EStreamControlStar"
  "tNetworkTest\020\010\022\035\n\031k_EStreamControlKeepAl"
  "ive\020\t\022\'\n#k_EStreamControl_LAST_SETUP_MES"
  "SAGE\020\017\022\"\n\036k_EStreamControlStartAudioData"
  "\0202\022!\n\035k_EStreamControlStopAudioData\0203\022\"\n"
  "\036k_EStreamControlStartVideoData\0204\022!\n\035k_E"
  "StreamControlStopVideoData\0205\022$\n k_EStrea"
  "mControlInputMouseMotion\0206\022#\n\037k_EStreamC"
  "ontrolInputMouseWheel\0207\022\"\n\036k_EStreamCont"
  "rolInputMouseDown\0208\022 \n\034k_EStreamControlI"
  "nputMouseUp\0209\022 \n\034k_EStreamControlInputKe"
  "yDown\020:\022\036\n\032k_EStreamControlInputKeyUp\020;\022"
  "1\n-k_EStreamControlInputGamepadAttached_"
  "OBSOLETE\020<\022.\n*k_EStreamControlInputGamep"
  "adEvent_OBSOLETE\020=\0221\n-k_EStreamControlIn"
  "putGamepadDetached_OBSOLETE\020>\022\036\n\032k_EStre"
  "amControlShowCursor\020\?\022\036\n\032k_EStreamContro"
  "lHideCursor\020@\022\035\n\031k_EStreamControlSetCurs"
  "or\020A\022\"\n\036k_EStreamControlGetCursorImage\020B"
  "\022\"\n\036k_EStreamControlSetCursorImage\020C\022 \n\034"
  "k_EStreamControlDeleteCursor\020D\022&\n\"k_EStr"
  "eamControlSetTargetFramerate\020E\022$\n k_EStr"
  "eamControlInputLatencyTest\020F\022*\n&k_EStrea"
  "mControlGamepadRumble_OBSOLETE\020G\022\"\n\036k_ES"
  "treamControlOverlayEnabled\020J\0224\n0k_EStrea"
  "mControlInputControllerAttached_OBSOLETE"
  "\020K\0221\n-k_EStreamControlInputControllerSta"
  "te_OBSOLETE\020L\022/\n+k_EStreamControlTrigger"
  "HapticPulse_OBSOLETE\020M\0224\n0k_EStreamContr"
  "olInputControllerDetached_OBSOLETE\020N\022$\n "
  "k_EStreamControlVideoDecoderInfo\020P\022\034\n\030k_"
  "EStreamControlSetTitle\020Q\022\033\n\027k_EStreamCon"
  "trolSetIcon\020R\022\037\n\033k_EStreamControlQuitReq"
  "uest\020S\022\032\n\026k_EStreamControlSetQoS\020W\022<\n8k_"
  "EStreamControlInputControllerWirelessPre"
  "sence_OBSOLETE\020X\022 \n\034k_EStreamControlSetG"
  "ammaRamp\020Y\022$\n k_EStreamControlVideoEncod"
  "erInfo\020Z\0224\n0k_EStreamControlInputControl"
  "lerStateHID_OBSOLETE\020]\022$\n k_EStreamContr"
  "olSetTargetBitrate\020^\0228\n4k_EStreamControl"
  "SetControllerPairingEnabled_OBSOLETE\020_\0227"
  "\n3k_EStreamControlSetControllerPairingRe"
  "sult_OBSOLETE\020`\0228\n4k_EStreamControlTrigg"
  "erControllerDisconnect_OBSOLETE\020a\022\037\n\033k_E"
  "StreamControlSetActivity\020b\022,\n(k_EStreamC"
  "ontrolSetStreamingClientConfig\020c\022!\n\035k_ES"
  "treamControlSystemSuspend\020d\0222\n.k_EStream"
  "ControlSetControllerSettings_OBSOLETE\020e\022"
  "&\n\"k_EStreamControlVirtualHereRequest\020f\022"
  "$\n k_EStreamControlVirtualHereReady\020g\022*\n"
  "&k_EStreamControlVirtualHereShareDevice\020"
  "h\022$\n k_EStreamControlSetSpectatorMode\020i\022"
  "\035\n\031k_EStreamControlRemoteHID\020j\022\'\n#k_EStr"
  "eamControlStartMicrophoneData\020k\022&\n\"k_ESt"
  "reamControlStopMicrophoneData\020l\022\035\n\031k_ESt"
  "reamControlInputText\020m\022%\n!k_EStreamContr"
  "olTouchConfigActive\020n\022&\n\"k_EStreamContro"
  "lGetTouchConfigData\020o\022&\n\"k_EStreamContro"
  "lSetTouchConfigData\020p\022)\n%k_EStreamContro"
  "lSaveTouchConfigLayout\020q\022(\n$k_EStreamCon"
  "trolTouchActionSetActive\020r\022$\n k_EStreamC"
  "ontrolGetTouchIconData\020s\022$\n k_EStreamCon"
  "trolSetTouchIconData\020t\022(\n$k_EStreamContr"
  "olInputTouchFingerDown\020u\022*\n&k_EStreamCon"
  "trolInputTouchFingerMotion\020v\022&\n\"k_EStrea"
  "mControlInputTouchFingerUp\020w\022\"\n\036k_EStrea"
  "mControlSetCaptureSize\020x\022!\n\035k_EStreamCon"
  "trolSetFlashState\020y\022\031\n\025k_EStreamControlP"
  "ause\020z\022\032\n\026k_EStreamControlResume\020{\022(\n$k_"
  "EStreamControlEnableHighResCapture\020|\022)\n%"
  "k_EStreamControlDisableHighResCapture\020}\022"
  "\'\n#k_EStreamControlToggleMagnification\020~"
  "\022\037\n\033k_EStreamControlSetCapslock\020\177\022\036\n\031k_E"
  "StreamControlSetKeymap\020\200\001\022 \n\033k_EStreamCo"
  "ntrolStopRequest\020\201\001\022-\n(k_EStreamControlT"
  "ouchActionSetLayerAdded\020\202\001\022/\n*k_EStreamC"
  "ontrolTouchActionSetLayerRemoved\020\203\001\0222\n-k"
  "_EStreamControlRemotePlayTogetherGroupUp"
  "date\020\204\001\0220\n+k_EStreamControlSetInputTempo"
  "rarilyDisabled\020\205\001\022\'\n\"k_EStreamControlSet"
  "QualityOverride\020\206\001\022\'\n\"k_EStreamControlSe"
  "tBitrateOverride\020\207\001\022)\n$k_EStreamControlS"
  "howOnScreenKeyboard\020\210\001\022(\n#k_EStreamContr"
  "olControllerConfigMsg\020\211\001\0224\n/k_EStreamCon"
  "trolControllerPersonalizationUpdate\020\212\001\022&"
  "\n!k_EStreamControlEnableNeptuneData\020\213\001\022\'"
  "\n\"k_EStreamControlDisableNeptuneData\020\214\001\022"
  "%\n k_EStreamControlStartNeptuneData\020\215\001\022$"
  "\n\037k_EStreamControlStopNeptuneData\020\216\001\022)\n$"
  "k_EStreamControlPauseControllerInput\020\217\001\022"
  "*\n%k_EStreamControlResumeControllerInput"
  "\020\220\001*G\n\016EStreamVersion\022\030\n\024k_EStreamVersio"
  "nNone\020\000\022\033\n\027k_EStreamVersionCurrent\020\001*\300\001\n"
  "\021EStreamAudioCodec\022\033\n\027k_EStreamAudioCode"
  "cNone\020\000\022\032\n\026k_EStreamAudioCodecRaw\020\001\022\035\n\031k"
  "_EStreamAudioCodecVorbis\020\002\022\033\n\027k_EStreamA"
  "udioCodecOpus\020\003\022\032\n\026k_EStreamAudioCodecMP"
  "3\020\004\022\032\n\026k_EStreamAudioCodecAAC\020\005*\372\001\n\021EStr"
  "eamVideoCodec\022\033\n\027k_EStreamVideoCodecNone"
  "\020\000\022\032\n\026k_EStreamVideoCodecRaw\020\001\022\032\n\026k_EStr"
  "eamVideoCodecVP8\020\002\022\032\n\026k_EStreamVideoCode"
  "cVP9\020\003\022\033\n\027k_EStreamVideoCodecH264\020\004\022\033\n\027k"
  "_EStreamVideoCodecHEVC\020\005\022\034\n\030k_EStreamVid"
  "eoCodecORBX1\020\006\022\034\n\030k_EStreamVideoCodecORB"
  "X2\020\007*\231\001\n\030EStreamQualityPreference\022&\n\031k_E"
  "StreamQualityAutomatic\020\377\377\377\377\377\377\377\377\377\001\022\030\n\024k_E"
  "StreamQualityFast\020\001\022\034\n\030k_EStreamQualityB"
  "alanced\020\002\022\035\n\031k_EStreamQualityBeautiful\020\003"
  "*X\n\016EStreamBitrate\022\'\n\032k_EStreamBitrateAu"
  "todetect\020\377\377\377\377\377\377\377\377\377\001\022\035\n\031k_EStreamBitrateU"
  "nlimited\020\000*\272\001\n\021EStreamColorspace\022\037\n\033k_ES"
  "treamColorspace_Unknown\020\000\022\035\n\031k_EStreamCo"
  "lorspace_BT601\020\001\022\"\n\036k_EStreamColorspace_"
  "BT601_Full\020\002\022\035\n\031k_EStreamColorspace_BT70"
  "9\020\003\022\"\n\036k_EStreamColorspace_BT709_Full\020\004*"
  "\252\001\n\017EStreamP2PScope\022\036\n\032k_EStreamP2PScope"
  "Automatic\020\000\022\035\n\031k_EStreamP2PScopeDisabled"
  "\020\001\022\033\n\027k_EStreamP2PScopeOnlyMe\020\002\022\034\n\030k_ESt"
  "reamP2PScopeFriends\020\003\022\035\n\031k_EStreamP2PSco"
  "peEveryone\020\004*e\n\036EStreamHostPlayAudioPref"
  "erence\022!\n\035k_EStreamHostPlayAudioDefault\020"
  "\000\022 \n\034k_EStreamHostPlayAudioAlways\020\001*\207\001\n\022"
  "EStreamingDataType\022\031\n\025k_EStreamingAudioD"
  "ata\020\000\022\031\n\025k_EStreamingVideoData\020\001\022\036\n\032k_ES"
  "treamingMicrophoneData\020\002\022\033\n\027k_EStreaming"
  "NeptuneData\020\003*\313\001\n\022EStreamMouseButton\022\034\n\030"
  "k_EStreamMouseButtonLeft\020\001\022\035\n\031k_EStreamM"
  "ouseButtonRight\020\002\022\036\n\032k_EStreamMouseButto"
  "nMiddle\020\020\022\032\n\026k_EStreamMouseButtonX1\020 \022\032\n"
  "\026k_EStreamMouseButtonX2\020@\022 \n\033k_EStreamMo"
  "useButtonUnknown\020\200 *\230\001\n\032EStreamMouseWhee"
  "lDirection\022\031\n\025k_EStreamMouseWheelUp\020x\022$\n"
  "\027k_EStreamMouseWheelDown\020\210\377\377\377\377\377\377\377\377\001\022\033\n\027k"
  "_EStreamMouseWheelLeft\020\003\022\034\n\030k_EStreamMou"
  "seWheelRight\020\004*\211\002\n\027EStreamFramerateLimit"
  "er\022!\n\035k_EStreamFramerateSlowCapture\020\001\022!\n"
  "\035k_EStreamFramerateSlowConvert\020\002\022 \n\034k_ES"
  "treamFramerateSlowEncode\020\004\022!\n\035k_EStreamF"
  "ramerateSlowNetwork\020\010\022 \n\034k_EStreamFramer"
  "ateSlowDecode\020\020\022\036\n\032k_EStreamFramerateSlo"
  "wGame\020 \022!\n\035k_EStreamFramerateSlowDisplay"
  "\020@*\245\001\n\017EStreamActivity\022\031\n\025k_EStreamActiv"
  "ityIdle\020\001\022\031\n\025k_EStreamActivityGame\020\002\022\034\n\030"
  "k_EStreamActivityDesktop\020\003\022\"\n\036k_EStreamA"
  "ctivitySecureDesktop\020\004\022\032\n\026k_EStreamActiv"
  "ityMusic\020\005*D\n\022EStreamDataMessage\022\027\n\023k_ES"
  "treamDataPacket\020\001\022\025\n\021k_EStreamDataLost\020\002"
  "*d\n\014EAudioFormat\022\026\n\022k_EAudioFormatNone\020\000"
  "\022#\n\037k_EAudioFormat16BitLittleEndian\020\001\022\027\n"
  "\023k_EAudioFormatFloat\020\002*W\n\014EVideoFormat\022\026"
  "\n\022k_EVideoFormatNone\020\000\022\026\n\022k_EVideoFormat"
  "YV12\020\001\022\027\n\023k_EVideoFormatAccel\020\002*\327\001\n\023EStr"
  "eamStatsMessage\022\035\n\031k_EStreamStatsFrameEv"
  "ents\020\001\022\033\n\027k_EStreamStatsDebugDump\020\002\022\034\n\030k"
  "_EStreamStatsLogMessage\020\003\022 \n\034k_EStreamSt"
  "atsLogUploadBegin\020\004\022\037\n\033k_EStreamStatsLog"
  "UploadData\020\005\022#\n\037k_EStreamStatsLogUploadC"
  "omplete\020\006*\205\005\n\021EStreamFrameEvent\022\034\n\030k_ESt"
  "reamInputEventStart\020\000\022\033\n\027k_EStreamInputE"
  "ventSend\020\001\022\033\n\027k_EStreamInputEventRecv\020\002\022"
  "\035\n\031k_EStreamInputEventQueued\020\003\022\036\n\032k_EStr"
  "eamInputEventHandled\020\004\022\034\n\030k_EStreamFrame"
  "EventStart\020\005\022#\n\037k_EStreamFrameEventCaptu"
  "reBegin\020\006\022!\n\035k_EStreamFrameEventCaptureE"
  "nd\020\007\022#\n\037k_EStreamFrameEventConvertBegin\020"
  "\010\022!\n\035k_EStreamFrameEventConvertEnd\020\t\022\"\n\036"
  "k_EStreamFrameEventEncodeBegin\020\n\022 \n\034k_ES"
  "treamFrameEventEncodeEnd\020\013\022\033\n\027k_EStreamF"
  "rameEventSend\020\014\022\033\n\027k_EStreamFrameEventRe"
  "cv\020\r\022\"\n\036k_EStreamFrameEventDecodeBegin\020\016"
  "\022 \n\034k_EStreamFrameEventDecodeEnd\020\017\022\"\n\036k_"
  "EStreamFrameEventUploadBegin\020\020\022 \n\034k_EStr"
  "eamFrameEventUploadEnd\020\021\022\037\n\033k_EStreamFra"
  "meEventComplete\020\022*\324\002\n\022EStreamFrameResult"
  "\022\037\n\033k_EStreamFrameResultPending\020\000\022!\n\035k_E"
  "StreamFrameResultDisplayed\020\001\022*\n&k_EStrea"
  "mFrameResultDroppedNetworkSlow\020\002\022*\n&k_ES"
  "treamFrameResultDroppedNetworkLost\020\003\022)\n%"
  "k_EStreamFrameResultDroppedDecodeSlow\020\004\022"
  ",\n(k_EStreamFrameResultDroppedDecodeCorr"
  "upt\020\005\022#\n\037k_EStreamFrameResultDroppedLate"
  "\020\006\022$\n k_EStreamFrameResultDroppedReset\020\007"
  "*\242\005\n\025EFrameAccumulatedStat\022\023\n\017k_EFrameSt"
  "atFPS\020\000\022!\n\035k_EFrameStatCaptureDurationMS"
  "\020\001\022!\n\035k_EFrameStatConvertDurationMS\020\002\022 \n"
  "\034k_EFrameStatEncodeDurationMS\020\003\022\037\n\033k_EFr"
  "ameStatSteamDurationMS\020\004\022 \n\034k_EFrameStat"
  "ServerDurationMS\020\005\022!\n\035k_EFrameStatNetwor"
  "kDurationMS\020\006\022 \n\034k_EFrameStatDecodeDurat"
  "ionMS\020\007\022!\n\035k_EFrameStatDisplayDurationMS"
  "\020\010\022 \n\034k_EFrameStatClientDurationMS\020\t\022\037\n\033"
  "k_EFrameStatFrameDurationMS\020\n\022\036\n\032k_EFram"
  "eStatInputLatencyMS\020\013\022\035\n\031k_EFrameStatGam"
  "eLatencyMS\020\014\022\"\n\036k_EFrameStatRoundTripLat"
  "encyMS\020\r\022\032\n\026k_EFrameStatPingTimeMS\020\016\022\'\n#"
  "k_EFrameStatServerBitrateKbitPerSec\020\017\022\'\n"
  "#k_EFrameStatClientBitrateKbitPerSec\020\020\022\'"
  "\n#k_EFrameStatLinkBandwidthKbitPerSec\020\021\022"
  "$\n k_EFrameStatPacketLossPercentage\020\022*^\n"
  "\014ELogFileType\022\030\n\024k_ELogFileSystemBoot\020\000\022"
  "\031\n\025k_ELogFileSystemReset\020\001\022\031\n\025k_ELogFile"
  "SystemDebug\020\002*\251\002\n\032EStreamControllerConfi"
  "gMsg\0225\n1k_EStreamControllerConfigMsg_Req"
  "uestConfigsForApp\020\000\022/\n+k_EStreamControll"
  "erConfigMsg_ConfigResponse\020\001\0228\n4k_EStrea"
  "mControllerConfigMsg_PersonalizationResp"
  "onse\020\002\0223\n/k_EStreamControllerConfigMsg_A"
  "ctiveConfigChange\020\003\0224\n0k_EStreamControll"
  "erConfigMsg_RequestActiveConfig\020\004B\005H\001\200\001\000"
  ;
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fremoteplay_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fremoteplay_2eproto = {
  false, false, 20200, descriptor_table_protodef_steammessages_5fremoteplay_2eproto, "steammessages_remoteplay.proto", 
  &descriptor_table_steammessages_5fremoteplay_2eproto_once, nullptr, 0, 112,
  schemas, file_default_instances, TableStruct_steammessages_5fremoteplay_2eproto::offsets,
  file_level_metadata_steammessages_5fremoteplay_2eproto, file_level_enum_descriptors_steammessages_5fremoteplay_2eproto, file_level_service_descriptors_steammessages_5fremoteplay_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fremoteplay_2eproto_getter() {
  return &descriptor_table_steammessages_5fremoteplay_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fremoteplay_2eproto(&descriptor_table_steammessages_5fremoteplay_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CAuthenticationResponseMsg_AuthenticationResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[0];
}
bool CAuthenticationResponseMsg_AuthenticationResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::SUCCEEDED;
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::FAILED;
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::AuthenticationResult_MIN;
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::AuthenticationResult_MAX;
constexpr int CAuthenticationResponseMsg::AuthenticationResult_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamChannel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[1];
}
bool EStreamChannel_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDiscoveryMessage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[2];
}
bool EStreamDiscoveryMessage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamControlMessage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[3];
}
bool EStreamControlMessage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 15:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 64:
    case 65:
    case 66:
    case 67:
    case 68:
    case 69:
    case 70:
    case 71:
    case 74:
    case 75:
    case 76:
    case 77:
    case 78:
    case 80:
    case 81:
    case 82:
    case 83:
    case 87:
    case 88:
    case 89:
    case 90:
    case 93:
    case 94:
    case 95:
    case 96:
    case 97:
    case 98:
    case 99:
    case 100:
    case 101:
    case 102:
    case 103:
    case 104:
    case 105:
    case 106:
    case 107:
    case 108:
    case 109:
    case 110:
    case 111:
    case 112:
    case 113:
    case 114:
    case 115:
    case 116:
    case 117:
    case 118:
    case 119:
    case 120:
    case 121:
    case 122:
    case 123:
    case 124:
    case 125:
    case 126:
    case 127:
    case 128:
    case 129:
    case 130:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
    case 138:
    case 139:
    case 140:
    case 141:
    case 142:
    case 143:
    case 144:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamVersion_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[4];
}
bool EStreamVersion_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamAudioCodec_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[5];
}
bool EStreamAudioCodec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamVideoCodec_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[6];
}
bool EStreamVideoCodec_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamQualityPreference_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[7];
}
bool EStreamQualityPreference_IsValid(int value) {
  switch (value) {
    case -1:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamBitrate_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[8];
}
bool EStreamBitrate_IsValid(int value) {
  switch (value) {
    case -1:
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamColorspace_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[9];
}
bool EStreamColorspace_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamP2PScope_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[10];
}
bool EStreamP2PScope_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamHostPlayAudioPreference_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[11];
}
bool EStreamHostPlayAudioPreference_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamingDataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[12];
}
bool EStreamingDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamMouseButton_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[13];
}
bool EStreamMouseButton_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 16:
    case 32:
    case 64:
    case 4096:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamMouseWheelDirection_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[14];
}
bool EStreamMouseWheelDirection_IsValid(int value) {
  switch (value) {
    case -120:
    case 3:
    case 4:
    case 120:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFramerateLimiter_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[15];
}
bool EStreamFramerateLimiter_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
    case 64:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamActivity_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[16];
}
bool EStreamActivity_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDataMessage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[17];
}
bool EStreamDataMessage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAudioFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[18];
}
bool EAudioFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EVideoFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[19];
}
bool EVideoFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamStatsMessage_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[20];
}
bool EStreamStatsMessage_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFrameEvent_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[21];
}
bool EStreamFrameEvent_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFrameResult_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[22];
}
bool EStreamFrameResult_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EFrameAccumulatedStat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[23];
}
bool EFrameAccumulatedStat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogFileType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[24];
}
bool ELogFileType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamControllerConfigMsg_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fremoteplay_2eproto);
  return file_level_enum_descriptors_steammessages_5fremoteplay_2eproto[25];
}
bool EStreamControllerConfigMsg_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CDiscoveryPingRequest::_Internal {
 public:
  using HasBits = decltype(std::declval<CDiscoveryPingRequest>()._has_bits_);
  static void set_has_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_size_requested(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDiscoveryPingRequest::CDiscoveryPingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDiscoveryPingRequest)
}
CDiscoveryPingRequest::CDiscoveryPingRequest(const CDiscoveryPingRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sequence_, &from.sequence_,
    static_cast<size_t>(reinterpret_cast<char*>(&packet_size_requested_) -
    reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_requested_));
  // @@protoc_insertion_point(copy_constructor:CDiscoveryPingRequest)
}

inline void CDiscoveryPingRequest::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sequence_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&packet_size_requested_) -
    reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_requested_));
}

CDiscoveryPingRequest::~CDiscoveryPingRequest() {
  // @@protoc_insertion_point(destructor:CDiscoveryPingRequest)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDiscoveryPingRequest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDiscoveryPingRequest::ArenaDtor(void* object) {
  CDiscoveryPingRequest* _this = reinterpret_cast< CDiscoveryPingRequest* >(object);
  (void)_this;
}
void CDiscoveryPingRequest::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDiscoveryPingRequest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDiscoveryPingRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:CDiscoveryPingRequest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sequence_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&packet_size_requested_) -
        reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_requested_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDiscoveryPingRequest::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sequence(&has_bits);
          sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 packet_size_requested = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packet_size_requested(&has_bits);
          packet_size_requested_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDiscoveryPingRequest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDiscoveryPingRequest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequence = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sequence(), target);
  }

  // optional uint32 packet_size_requested = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_packet_size_requested(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDiscoveryPingRequest)
  return target;
}

size_t CDiscoveryPingRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDiscoveryPingRequest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 sequence = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence());
    }

    // optional uint32 packet_size_requested = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_packet_size_requested());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDiscoveryPingRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDiscoveryPingRequest::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDiscoveryPingRequest::GetClassData() const { return &_class_data_; }

void CDiscoveryPingRequest::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDiscoveryPingRequest *>(to)->MergeFrom(
      static_cast<const CDiscoveryPingRequest &>(from));
}


void CDiscoveryPingRequest::MergeFrom(const CDiscoveryPingRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDiscoveryPingRequest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sequence_ = from.sequence_;
    }
    if (cached_has_bits & 0x00000002u) {
      packet_size_requested_ = from.packet_size_requested_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDiscoveryPingRequest::CopyFrom(const CDiscoveryPingRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDiscoveryPingRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDiscoveryPingRequest::IsInitialized() const {
  return true;
}

void CDiscoveryPingRequest::InternalSwap(CDiscoveryPingRequest* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDiscoveryPingRequest, packet_size_requested_)
      + sizeof(CDiscoveryPingRequest::packet_size_requested_)
      - PROTOBUF_FIELD_OFFSET(CDiscoveryPingRequest, sequence_)>(
          reinterpret_cast<char*>(&sequence_),
          reinterpret_cast<char*>(&other->sequence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDiscoveryPingRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[0]);
}

// ===================================================================

class CDiscoveryPingResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CDiscoveryPingResponse>()._has_bits_);
  static void set_has_sequence(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_packet_size_received(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CDiscoveryPingResponse::CDiscoveryPingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDiscoveryPingResponse)
}
CDiscoveryPingResponse::CDiscoveryPingResponse(const CDiscoveryPingResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&sequence_, &from.sequence_,
    static_cast<size_t>(reinterpret_cast<char*>(&packet_size_received_) -
    reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_received_));
  // @@protoc_insertion_point(copy_constructor:CDiscoveryPingResponse)
}

inline void CDiscoveryPingResponse::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&sequence_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&packet_size_received_) -
    reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_received_));
}

CDiscoveryPingResponse::~CDiscoveryPingResponse() {
  // @@protoc_insertion_point(destructor:CDiscoveryPingResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDiscoveryPingResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDiscoveryPingResponse::ArenaDtor(void* object) {
  CDiscoveryPingResponse* _this = reinterpret_cast< CDiscoveryPingResponse* >(object);
  (void)_this;
}
void CDiscoveryPingResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDiscoveryPingResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDiscoveryPingResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CDiscoveryPingResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&sequence_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&packet_size_received_) -
        reinterpret_cast<char*>(&sequence_)) + sizeof(packet_size_received_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDiscoveryPingResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 sequence = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sequence(&has_bits);
          sequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 packet_size_received = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_packet_size_received(&has_bits);
          packet_size_received_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDiscoveryPingResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDiscoveryPingResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 sequence = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_sequence(), target);
  }

  // optional uint32 packet_size_received = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_packet_size_received(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDiscoveryPingResponse)
  return target;
}

size_t CDiscoveryPingResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDiscoveryPingResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 sequence = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_sequence());
    }

    // optional uint32 packet_size_received = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_packet_size_received());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDiscoveryPingResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDiscoveryPingResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDiscoveryPingResponse::GetClassData() const { return &_class_data_; }

void CDiscoveryPingResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDiscoveryPingResponse *>(to)->MergeFrom(
      static_cast<const CDiscoveryPingResponse &>(from));
}


void CDiscoveryPingResponse::MergeFrom(const CDiscoveryPingResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDiscoveryPingResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sequence_ = from.sequence_;
    }
    if (cached_has_bits & 0x00000002u) {
      packet_size_received_ = from.packet_size_received_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDiscoveryPingResponse::CopyFrom(const CDiscoveryPingResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDiscoveryPingResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDiscoveryPingResponse::IsInitialized() const {
  return true;
}

void CDiscoveryPingResponse::InternalSwap(CDiscoveryPingResponse* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CDiscoveryPingResponse, packet_size_received_)
      + sizeof(CDiscoveryPingResponse::packet_size_received_)
      - PROTOBUF_FIELD_OFFSET(CDiscoveryPingResponse, sequence_)>(
          reinterpret_cast<char*>(&sequence_),
          reinterpret_cast<char*>(&other->sequence_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CDiscoveryPingResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[1]);
}

// ===================================================================

class CStreamingClientHandshakeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingClientHandshakeInfo>()._has_bits_);
  static void set_has_network_test(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CStreamingClientHandshakeInfo::CStreamingClientHandshakeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingClientHandshakeInfo)
}
CStreamingClientHandshakeInfo::CStreamingClientHandshakeInfo(const CStreamingClientHandshakeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  network_test_ = from.network_test_;
  // @@protoc_insertion_point(copy_constructor:CStreamingClientHandshakeInfo)
}

inline void CStreamingClientHandshakeInfo::SharedCtor() {
network_test_ = 0;
}

CStreamingClientHandshakeInfo::~CStreamingClientHandshakeInfo() {
  // @@protoc_insertion_point(destructor:CStreamingClientHandshakeInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingClientHandshakeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingClientHandshakeInfo::ArenaDtor(void* object) {
  CStreamingClientHandshakeInfo* _this = reinterpret_cast< CStreamingClientHandshakeInfo* >(object);
  (void)_this;
}
void CStreamingClientHandshakeInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingClientHandshakeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingClientHandshakeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingClientHandshakeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  network_test_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingClientHandshakeInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 network_test = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_network_test(&has_bits);
          network_test_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingClientHandshakeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingClientHandshakeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 network_test = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_network_test(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingClientHandshakeInfo)
  return target;
}

size_t CStreamingClientHandshakeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingClientHandshakeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 network_test = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_network_test());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingClientHandshakeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingClientHandshakeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingClientHandshakeInfo::GetClassData() const { return &_class_data_; }

void CStreamingClientHandshakeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingClientHandshakeInfo *>(to)->MergeFrom(
      static_cast<const CStreamingClientHandshakeInfo &>(from));
}


void CStreamingClientHandshakeInfo::MergeFrom(const CStreamingClientHandshakeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingClientHandshakeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_network_test()) {
    _internal_set_network_test(from._internal_network_test());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingClientHandshakeInfo::CopyFrom(const CStreamingClientHandshakeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingClientHandshakeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingClientHandshakeInfo::IsInitialized() const {
  return true;
}

void CStreamingClientHandshakeInfo::InternalSwap(CStreamingClientHandshakeInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(network_test_, other->network_test_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingClientHandshakeInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[2]);
}

// ===================================================================

class CClientHandshakeMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CClientHandshakeMsg>()._has_bits_);
  static const ::CStreamingClientHandshakeInfo& info(const CClientHandshakeMsg* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::CStreamingClientHandshakeInfo&
CClientHandshakeMsg::_Internal::info(const CClientHandshakeMsg* msg) {
  return *msg->info_;
}
CClientHandshakeMsg::CClientHandshakeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CClientHandshakeMsg)
}
CClientHandshakeMsg::CClientHandshakeMsg(const CClientHandshakeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::CStreamingClientHandshakeInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CClientHandshakeMsg)
}

inline void CClientHandshakeMsg::SharedCtor() {
info_ = nullptr;
}

CClientHandshakeMsg::~CClientHandshakeMsg() {
  // @@protoc_insertion_point(destructor:CClientHandshakeMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CClientHandshakeMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void CClientHandshakeMsg::ArenaDtor(void* object) {
  CClientHandshakeMsg* _this = reinterpret_cast< CClientHandshakeMsg* >(object);
  (void)_this;
}
void CClientHandshakeMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CClientHandshakeMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CClientHandshakeMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CClientHandshakeMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CClientHandshakeMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .CStreamingClientHandshakeInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CClientHandshakeMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CClientHandshakeMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CStreamingClientHandshakeInfo info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CClientHandshakeMsg)
  return target;
}

size_t CClientHandshakeMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CClientHandshakeMsg)
  size_t total_size = 0;

  // required .CStreamingClientHandshakeInfo info = 1;
  if (_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CClientHandshakeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CClientHandshakeMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CClientHandshakeMsg::GetClassData() const { return &_class_data_; }

void CClientHandshakeMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CClientHandshakeMsg *>(to)->MergeFrom(
      static_cast<const CClientHandshakeMsg &>(from));
}


void CClientHandshakeMsg::MergeFrom(const CClientHandshakeMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CClientHandshakeMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _internal_mutable_info()->::CStreamingClientHandshakeInfo::MergeFrom(from._internal_info());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CClientHandshakeMsg::CopyFrom(const CClientHandshakeMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CClientHandshakeMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CClientHandshakeMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CClientHandshakeMsg::InternalSwap(CClientHandshakeMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(info_, other->info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CClientHandshakeMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[3]);
}

// ===================================================================

class CStreamingServerHandshakeInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingServerHandshakeInfo>()._has_bits_);
  static void set_has_mtu(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CStreamingServerHandshakeInfo::CStreamingServerHandshakeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingServerHandshakeInfo)
}
CStreamingServerHandshakeInfo::CStreamingServerHandshakeInfo(const CStreamingServerHandshakeInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  mtu_ = from.mtu_;
  // @@protoc_insertion_point(copy_constructor:CStreamingServerHandshakeInfo)
}

inline void CStreamingServerHandshakeInfo::SharedCtor() {
mtu_ = 0;
}

CStreamingServerHandshakeInfo::~CStreamingServerHandshakeInfo() {
  // @@protoc_insertion_point(destructor:CStreamingServerHandshakeInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingServerHandshakeInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingServerHandshakeInfo::ArenaDtor(void* object) {
  CStreamingServerHandshakeInfo* _this = reinterpret_cast< CStreamingServerHandshakeInfo* >(object);
  (void)_this;
}
void CStreamingServerHandshakeInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingServerHandshakeInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingServerHandshakeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingServerHandshakeInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  mtu_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingServerHandshakeInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 mtu = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mtu(&has_bits);
          mtu_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingServerHandshakeInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingServerHandshakeInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 mtu = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_mtu(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingServerHandshakeInfo)
  return target;
}

size_t CStreamingServerHandshakeInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingServerHandshakeInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 mtu = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_mtu());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingServerHandshakeInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingServerHandshakeInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingServerHandshakeInfo::GetClassData() const { return &_class_data_; }

void CStreamingServerHandshakeInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingServerHandshakeInfo *>(to)->MergeFrom(
      static_cast<const CStreamingServerHandshakeInfo &>(from));
}


void CStreamingServerHandshakeInfo::MergeFrom(const CStreamingServerHandshakeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingServerHandshakeInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_mtu()) {
    _internal_set_mtu(from._internal_mtu());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingServerHandshakeInfo::CopyFrom(const CStreamingServerHandshakeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingServerHandshakeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingServerHandshakeInfo::IsInitialized() const {
  return true;
}

void CStreamingServerHandshakeInfo::InternalSwap(CStreamingServerHandshakeInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(mtu_, other->mtu_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingServerHandshakeInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[4]);
}

// ===================================================================

class CServerHandshakeMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CServerHandshakeMsg>()._has_bits_);
  static const ::CStreamingServerHandshakeInfo& info(const CServerHandshakeMsg* msg);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::CStreamingServerHandshakeInfo&
CServerHandshakeMsg::_Internal::info(const CServerHandshakeMsg* msg) {
  return *msg->info_;
}
CServerHandshakeMsg::CServerHandshakeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CServerHandshakeMsg)
}
CServerHandshakeMsg::CServerHandshakeMsg(const CServerHandshakeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_info()) {
    info_ = new ::CStreamingServerHandshakeInfo(*from.info_);
  } else {
    info_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CServerHandshakeMsg)
}

inline void CServerHandshakeMsg::SharedCtor() {
info_ = nullptr;
}

CServerHandshakeMsg::~CServerHandshakeMsg() {
  // @@protoc_insertion_point(destructor:CServerHandshakeMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CServerHandshakeMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete info_;
}

void CServerHandshakeMsg::ArenaDtor(void* object) {
  CServerHandshakeMsg* _this = reinterpret_cast< CServerHandshakeMsg* >(object);
  (void)_this;
}
void CServerHandshakeMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CServerHandshakeMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CServerHandshakeMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CServerHandshakeMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(info_ != nullptr);
    info_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CServerHandshakeMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .CStreamingServerHandshakeInfo info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CServerHandshakeMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CServerHandshakeMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CStreamingServerHandshakeInfo info = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::info(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CServerHandshakeMsg)
  return target;
}

size_t CServerHandshakeMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CServerHandshakeMsg)
  size_t total_size = 0;

  // required .CStreamingServerHandshakeInfo info = 1;
  if (_internal_has_info()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *info_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CServerHandshakeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CServerHandshakeMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CServerHandshakeMsg::GetClassData() const { return &_class_data_; }

void CServerHandshakeMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CServerHandshakeMsg *>(to)->MergeFrom(
      static_cast<const CServerHandshakeMsg &>(from));
}


void CServerHandshakeMsg::MergeFrom(const CServerHandshakeMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CServerHandshakeMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _internal_mutable_info()->::CStreamingServerHandshakeInfo::MergeFrom(from._internal_info());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CServerHandshakeMsg::CopyFrom(const CServerHandshakeMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CServerHandshakeMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CServerHandshakeMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CServerHandshakeMsg::InternalSwap(CServerHandshakeMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(info_, other->info_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CServerHandshakeMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[5]);
}

// ===================================================================

class CAuthenticationRequestMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationRequestMsg>()._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthenticationRequestMsg::CAuthenticationRequestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationRequestMsg)
}
CAuthenticationRequestMsg::CAuthenticationRequestMsg(const CAuthenticationRequestMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:CAuthenticationRequestMsg)
}

inline void CAuthenticationRequestMsg::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(version_));
}

CAuthenticationRequestMsg::~CAuthenticationRequestMsg() {
  // @@protoc_insertion_point(destructor:CAuthenticationRequestMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationRequestMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthenticationRequestMsg::ArenaDtor(void* object) {
  CAuthenticationRequestMsg* _this = reinterpret_cast< CAuthenticationRequestMsg* >(object);
  (void)_this;
}
void CAuthenticationRequestMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationRequestMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationRequestMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationRequestMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationRequestMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamVersion_IsValid(val))) {
            _internal_set_version(static_cast<::EStreamVersion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationRequestMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationRequestMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_version(), target);
  }

  // optional uint64 steamid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationRequestMsg)
  return target;
}

size_t CAuthenticationRequestMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationRequestMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional uint64 steamid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationRequestMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationRequestMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationRequestMsg::GetClassData() const { return &_class_data_; }

void CAuthenticationRequestMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationRequestMsg *>(to)->MergeFrom(
      static_cast<const CAuthenticationRequestMsg &>(from));
}


void CAuthenticationRequestMsg::MergeFrom(const CAuthenticationRequestMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationRequestMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationRequestMsg::CopyFrom(const CAuthenticationRequestMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationRequestMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationRequestMsg::IsInitialized() const {
  return true;
}

void CAuthenticationRequestMsg::InternalSwap(CAuthenticationRequestMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthenticationRequestMsg, version_)
      + sizeof(CAuthenticationRequestMsg::version_)
      - PROTOBUF_FIELD_OFFSET(CAuthenticationRequestMsg, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationRequestMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[6]);
}

// ===================================================================

class CAuthenticationResponseMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationResponseMsg>()._has_bits_);
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthenticationResponseMsg::CAuthenticationResponseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationResponseMsg)
}
CAuthenticationResponseMsg::CAuthenticationResponseMsg(const CAuthenticationResponseMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&result_, &from.result_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&result_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:CAuthenticationResponseMsg)
}

inline void CAuthenticationResponseMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&result_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&result_)) + sizeof(version_));
}

CAuthenticationResponseMsg::~CAuthenticationResponseMsg() {
  // @@protoc_insertion_point(destructor:CAuthenticationResponseMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationResponseMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationResponseMsg::ArenaDtor(void* object) {
  CAuthenticationResponseMsg* _this = reinterpret_cast< CAuthenticationResponseMsg* >(object);
  (void)_this;
}
void CAuthenticationResponseMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationResponseMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationResponseMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationResponseMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&result_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&result_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationResponseMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::CAuthenticationResponseMsg_AuthenticationResult_IsValid(val))) {
            _internal_set_result(static_cast<::CAuthenticationResponseMsg_AuthenticationResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamVersion_IsValid(val))) {
            _internal_set_version(static_cast<::EStreamVersion>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationResponseMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationResponseMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_result(), target);
  }

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationResponseMsg)
  return target;
}

size_t CAuthenticationResponseMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationResponseMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());
    }

    // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationResponseMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationResponseMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationResponseMsg::GetClassData() const { return &_class_data_; }

void CAuthenticationResponseMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationResponseMsg *>(to)->MergeFrom(
      static_cast<const CAuthenticationResponseMsg &>(from));
}


void CAuthenticationResponseMsg::MergeFrom(const CAuthenticationResponseMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationResponseMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      result_ = from.result_;
    }
    if (cached_has_bits & 0x00000002u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationResponseMsg::CopyFrom(const CAuthenticationResponseMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationResponseMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationResponseMsg::IsInitialized() const {
  return true;
}

void CAuthenticationResponseMsg::InternalSwap(CAuthenticationResponseMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthenticationResponseMsg, version_)
      + sizeof(CAuthenticationResponseMsg::version_)
      - PROTOBUF_FIELD_OFFSET(CAuthenticationResponseMsg, result_)>(
          reinterpret_cast<char*>(&result_),
          reinterpret_cast<char*>(&other->result_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationResponseMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[7]);
}

// ===================================================================

class CKeepAliveMsg::_Internal {
 public:
};

CKeepAliveMsg::CKeepAliveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CKeepAliveMsg)
}
CKeepAliveMsg::CKeepAliveMsg(const CKeepAliveMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CKeepAliveMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CKeepAliveMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CKeepAliveMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CKeepAliveMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[8]);
}

// ===================================================================

class CStartNetworkTestMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CStartNetworkTestMsg>()._has_bits_);
  static void set_has_frames(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_burst_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_bandwidth_test(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CStartNetworkTestMsg::CStartNetworkTestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStartNetworkTestMsg)
}
CStartNetworkTestMsg::CStartNetworkTestMsg(const CStartNetworkTestMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&frames_, &from.frames_,
    static_cast<size_t>(reinterpret_cast<char*>(&bandwidth_test_) -
    reinterpret_cast<char*>(&frames_)) + sizeof(bandwidth_test_));
  // @@protoc_insertion_point(copy_constructor:CStartNetworkTestMsg)
}

inline void CStartNetworkTestMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frames_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&bandwidth_test_) -
    reinterpret_cast<char*>(&frames_)) + sizeof(bandwidth_test_));
}

CStartNetworkTestMsg::~CStartNetworkTestMsg() {
  // @@protoc_insertion_point(destructor:CStartNetworkTestMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStartNetworkTestMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStartNetworkTestMsg::ArenaDtor(void* object) {
  CStartNetworkTestMsg* _this = reinterpret_cast< CStartNetworkTestMsg* >(object);
  (void)_this;
}
void CStartNetworkTestMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStartNetworkTestMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStartNetworkTestMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CStartNetworkTestMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&frames_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&bandwidth_test_) -
        reinterpret_cast<char*>(&frames_)) + sizeof(bandwidth_test_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStartNetworkTestMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 frames = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_frames(&has_bits);
          frames_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 framerate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_framerate(&has_bits);
          framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 bitrate_kbps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bitrate_kbps(&has_bits);
          bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 burst_bitrate_kbps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_burst_bitrate_kbps(&has_bits);
          burst_bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool bandwidth_test = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_bandwidth_test(&has_bits);
          bandwidth_test_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStartNetworkTestMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStartNetworkTestMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 frames = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_frames(), target);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_framerate(), target);
  }

  // optional uint32 bitrate_kbps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_bitrate_kbps(), target);
  }

  // optional uint32 burst_bitrate_kbps = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_burst_bitrate_kbps(), target);
  }

  // optional bool bandwidth_test = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_bandwidth_test(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStartNetworkTestMsg)
  return target;
}

size_t CStartNetworkTestMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStartNetworkTestMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 frames = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frames());
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate());
    }

    // optional uint32 bitrate_kbps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_bitrate_kbps());
    }

    // optional uint32 burst_bitrate_kbps = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_burst_bitrate_kbps());
    }

    // optional bool bandwidth_test = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStartNetworkTestMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStartNetworkTestMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStartNetworkTestMsg::GetClassData() const { return &_class_data_; }

void CStartNetworkTestMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStartNetworkTestMsg *>(to)->MergeFrom(
      static_cast<const CStartNetworkTestMsg &>(from));
}


void CStartNetworkTestMsg::MergeFrom(const CStartNetworkTestMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStartNetworkTestMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      frames_ = from.frames_;
    }
    if (cached_has_bits & 0x00000002u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000004u) {
      bitrate_kbps_ = from.bitrate_kbps_;
    }
    if (cached_has_bits & 0x00000008u) {
      burst_bitrate_kbps_ = from.burst_bitrate_kbps_;
    }
    if (cached_has_bits & 0x00000010u) {
      bandwidth_test_ = from.bandwidth_test_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStartNetworkTestMsg::CopyFrom(const CStartNetworkTestMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStartNetworkTestMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStartNetworkTestMsg::IsInitialized() const {
  return true;
}

void CStartNetworkTestMsg::InternalSwap(CStartNetworkTestMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStartNetworkTestMsg, bandwidth_test_)
      + sizeof(CStartNetworkTestMsg::bandwidth_test_)
      - PROTOBUF_FIELD_OFFSET(CStartNetworkTestMsg, frames_)>(
          reinterpret_cast<char*>(&frames_),
          reinterpret_cast<char*>(&other->frames_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStartNetworkTestMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[9]);
}

// ===================================================================

class CStreamVideoMode::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamVideoMode>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_refresh_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_refresh_rate_numerator(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_refresh_rate_denominator(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CStreamVideoMode::CStreamVideoMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamVideoMode)
}
CStreamVideoMode::CStreamVideoMode(const CStreamVideoMode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&refresh_rate_denominator_) -
    reinterpret_cast<char*>(&width_)) + sizeof(refresh_rate_denominator_));
  // @@protoc_insertion_point(copy_constructor:CStreamVideoMode)
}

inline void CStreamVideoMode::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&refresh_rate_denominator_) -
    reinterpret_cast<char*>(&width_)) + sizeof(refresh_rate_denominator_));
}

CStreamVideoMode::~CStreamVideoMode() {
  // @@protoc_insertion_point(destructor:CStreamVideoMode)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamVideoMode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamVideoMode::ArenaDtor(void* object) {
  CStreamVideoMode* _this = reinterpret_cast< CStreamVideoMode* >(object);
  (void)_this;
}
void CStreamVideoMode::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamVideoMode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamVideoMode::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamVideoMode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&refresh_rate_denominator_) -
        reinterpret_cast<char*>(&width_)) + sizeof(refresh_rate_denominator_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamVideoMode::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 refresh_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_refresh_rate(&has_bits);
          refresh_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 refresh_rate_numerator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_refresh_rate_numerator(&has_bits);
          refresh_rate_numerator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 refresh_rate_denominator = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_refresh_rate_denominator(&has_bits);
          refresh_rate_denominator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamVideoMode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamVideoMode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_width(), target);
  }

  // required uint32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_height(), target);
  }

  // optional uint32 refresh_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_refresh_rate(), target);
  }

  // optional uint32 refresh_rate_numerator = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_refresh_rate_numerator(), target);
  }

  // optional uint32 refresh_rate_denominator = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_refresh_rate_denominator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamVideoMode)
  return target;
}

size_t CStreamVideoMode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CStreamVideoMode)
  size_t total_size = 0;

  if (_internal_has_width()) {
    // required uint32 width = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
  }

  if (_internal_has_height()) {
    // required uint32 height = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
  }

  return total_size;
}
size_t CStreamVideoMode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamVideoMode)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 width = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_width());

    // required uint32 height = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_height());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001cu) {
    // optional uint32 refresh_rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_refresh_rate());
    }

    // optional uint32 refresh_rate_numerator = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_refresh_rate_numerator());
    }

    // optional uint32 refresh_rate_denominator = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_refresh_rate_denominator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamVideoMode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamVideoMode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamVideoMode::GetClassData() const { return &_class_data_; }

void CStreamVideoMode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamVideoMode *>(to)->MergeFrom(
      static_cast<const CStreamVideoMode &>(from));
}


void CStreamVideoMode::MergeFrom(const CStreamVideoMode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamVideoMode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000004u) {
      refresh_rate_ = from.refresh_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      refresh_rate_numerator_ = from.refresh_rate_numerator_;
    }
    if (cached_has_bits & 0x00000010u) {
      refresh_rate_denominator_ = from.refresh_rate_denominator_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamVideoMode::CopyFrom(const CStreamVideoMode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamVideoMode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamVideoMode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CStreamVideoMode::InternalSwap(CStreamVideoMode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamVideoMode, refresh_rate_denominator_)
      + sizeof(CStreamVideoMode::refresh_rate_denominator_)
      - PROTOBUF_FIELD_OFFSET(CStreamVideoMode, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamVideoMode::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[10]);
}

// ===================================================================

class CStreamingClientCaps::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingClientCaps>()._has_bits_);
  static void set_has_system_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_system_can_suspend(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_maximum_decode_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_maximum_burst_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_supports_video_hevc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_disable_steam_store(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_disable_client_cursor(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_disable_intel_hardware_encoding(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_disable_amd_hardware_encoding(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_disable_nvidia_hardware_encoding(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_form_factor(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_has_on_screen_keyboard(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CStreamingClientCaps::CStreamingClientCaps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  supported_colorspaces_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingClientCaps)
}
CStreamingClientCaps::CStreamingClientCaps(const CStreamingClientCaps& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      supported_colorspaces_(from.supported_colorspaces_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  system_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    system_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_system_info()) {
    system_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_system_info(), 
      GetArenaForAllocation());
  }
  ::memcpy(&maximum_decode_bitrate_kbps_, &from.maximum_decode_bitrate_kbps_,
    static_cast<size_t>(reinterpret_cast<char*>(&form_factor_) -
    reinterpret_cast<char*>(&maximum_decode_bitrate_kbps_)) + sizeof(form_factor_));
  // @@protoc_insertion_point(copy_constructor:CStreamingClientCaps)
}

inline void CStreamingClientCaps::SharedCtor() {
system_info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  system_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maximum_decode_bitrate_kbps_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&form_factor_) -
    reinterpret_cast<char*>(&maximum_decode_bitrate_kbps_)) + sizeof(form_factor_));
}

CStreamingClientCaps::~CStreamingClientCaps() {
  // @@protoc_insertion_point(destructor:CStreamingClientCaps)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingClientCaps::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  system_info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStreamingClientCaps::ArenaDtor(void* object) {
  CStreamingClientCaps* _this = reinterpret_cast< CStreamingClientCaps* >(object);
  (void)_this;
}
void CStreamingClientCaps::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingClientCaps::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingClientCaps::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingClientCaps)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_colorspaces_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    system_info_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&maximum_decode_bitrate_kbps_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disable_intel_hardware_encoding_) -
        reinterpret_cast<char*>(&maximum_decode_bitrate_kbps_)) + sizeof(disable_intel_hardware_encoding_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&disable_amd_hardware_encoding_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&form_factor_) -
        reinterpret_cast<char*>(&disable_amd_hardware_encoding_)) + sizeof(form_factor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingClientCaps::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string system_info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_system_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStreamingClientCaps.system_info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool system_can_suspend = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_system_can_suspend(&has_bits);
          system_can_suspend_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_decode_bitrate_kbps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_maximum_decode_bitrate_kbps(&has_bits);
          maximum_decode_bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_burst_bitrate_kbps = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_maximum_burst_bitrate_kbps(&has_bits);
          maximum_burst_bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_video_hevc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_supports_video_hevc(&has_bits);
          supports_video_hevc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_steam_store = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_disable_steam_store(&has_bits);
          disable_steam_store_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_client_cursor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_disable_client_cursor(&has_bits);
          disable_client_cursor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_intel_hardware_encoding = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_disable_intel_hardware_encoding(&has_bits);
          disable_intel_hardware_encoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_amd_hardware_encoding = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_disable_amd_hardware_encoding(&has_bits);
          disable_amd_hardware_encoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_nvidia_hardware_encoding = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_disable_nvidia_hardware_encoding(&has_bits);
          disable_nvidia_hardware_encoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 form_factor = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_form_factor(&has_bits);
          form_factor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool has_on_screen_keyboard = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_has_on_screen_keyboard(&has_bits);
          has_on_screen_keyboard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EStreamColorspace supported_colorspaces = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EStreamColorspace_IsValid(val))) {
              _internal_add_supported_colorspaces(static_cast<::EStreamColorspace>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(13, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_supported_colorspaces(), ptr, ctx, ::EStreamColorspace_IsValid, &_internal_metadata_, 13);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingClientCaps::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingClientCaps)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string system_info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_system_info().data(), static_cast<int>(this->_internal_system_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStreamingClientCaps.system_info");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_system_info(), target);
  }

  // optional bool system_can_suspend = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_system_can_suspend(), target);
  }

  // optional int32 maximum_decode_bitrate_kbps = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_maximum_decode_bitrate_kbps(), target);
  }

  // optional int32 maximum_burst_bitrate_kbps = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_maximum_burst_bitrate_kbps(), target);
  }

  // optional bool supports_video_hevc = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_supports_video_hevc(), target);
  }

  // optional bool disable_steam_store = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_disable_steam_store(), target);
  }

  // optional bool disable_client_cursor = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_disable_client_cursor(), target);
  }

  // optional bool disable_intel_hardware_encoding = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_disable_intel_hardware_encoding(), target);
  }

  // optional bool disable_amd_hardware_encoding = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_disable_amd_hardware_encoding(), target);
  }

  // optional bool disable_nvidia_hardware_encoding = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_disable_nvidia_hardware_encoding(), target);
  }

  // optional int32 form_factor = 11;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_form_factor(), target);
  }

  // optional bool has_on_screen_keyboard = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(12, this->_internal_has_on_screen_keyboard(), target);
  }

  // repeated .EStreamColorspace supported_colorspaces = 13;
  for (int i = 0, n = this->_internal_supported_colorspaces_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        13, this->_internal_supported_colorspaces(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingClientCaps)
  return target;
}

size_t CStreamingClientCaps::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingClientCaps)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EStreamColorspace supported_colorspaces = 13;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_colorspaces_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_colorspaces(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string system_info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_system_info());
    }

    // optional int32 maximum_decode_bitrate_kbps = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maximum_decode_bitrate_kbps());
    }

    // optional int32 maximum_burst_bitrate_kbps = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maximum_burst_bitrate_kbps());
    }

    // optional bool system_can_suspend = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool supports_video_hevc = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool disable_steam_store = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool disable_client_cursor = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool disable_intel_hardware_encoding = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional bool disable_amd_hardware_encoding = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool disable_nvidia_hardware_encoding = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool has_on_screen_keyboard = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 form_factor = 11;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_form_factor());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingClientCaps::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingClientCaps::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingClientCaps::GetClassData() const { return &_class_data_; }

void CStreamingClientCaps::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingClientCaps *>(to)->MergeFrom(
      static_cast<const CStreamingClientCaps &>(from));
}


void CStreamingClientCaps::MergeFrom(const CStreamingClientCaps& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingClientCaps)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_colorspaces_.MergeFrom(from.supported_colorspaces_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_system_info(from._internal_system_info());
    }
    if (cached_has_bits & 0x00000002u) {
      maximum_decode_bitrate_kbps_ = from.maximum_decode_bitrate_kbps_;
    }
    if (cached_has_bits & 0x00000004u) {
      maximum_burst_bitrate_kbps_ = from.maximum_burst_bitrate_kbps_;
    }
    if (cached_has_bits & 0x00000008u) {
      system_can_suspend_ = from.system_can_suspend_;
    }
    if (cached_has_bits & 0x00000010u) {
      supports_video_hevc_ = from.supports_video_hevc_;
    }
    if (cached_has_bits & 0x00000020u) {
      disable_steam_store_ = from.disable_steam_store_;
    }
    if (cached_has_bits & 0x00000040u) {
      disable_client_cursor_ = from.disable_client_cursor_;
    }
    if (cached_has_bits & 0x00000080u) {
      disable_intel_hardware_encoding_ = from.disable_intel_hardware_encoding_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      disable_amd_hardware_encoding_ = from.disable_amd_hardware_encoding_;
    }
    if (cached_has_bits & 0x00000200u) {
      disable_nvidia_hardware_encoding_ = from.disable_nvidia_hardware_encoding_;
    }
    if (cached_has_bits & 0x00000400u) {
      has_on_screen_keyboard_ = from.has_on_screen_keyboard_;
    }
    if (cached_has_bits & 0x00000800u) {
      form_factor_ = from.form_factor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingClientCaps::CopyFrom(const CStreamingClientCaps& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingClientCaps)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingClientCaps::IsInitialized() const {
  return true;
}

void CStreamingClientCaps::InternalSwap(CStreamingClientCaps* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_colorspaces_.InternalSwap(&other->supported_colorspaces_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &system_info_, lhs_arena,
      &other->system_info_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamingClientCaps, form_factor_)
      + sizeof(CStreamingClientCaps::form_factor_)
      - PROTOBUF_FIELD_OFFSET(CStreamingClientCaps, maximum_decode_bitrate_kbps_)>(
          reinterpret_cast<char*>(&maximum_decode_bitrate_kbps_),
          reinterpret_cast<char*>(&other->maximum_decode_bitrate_kbps_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingClientCaps::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[11]);
}

// ===================================================================

class CStreamingClientConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingClientConfig>()._has_bits_);
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_maximum_resolution_x(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_maximum_resolution_y(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_maximum_framerate_numerator(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_maximum_framerate_denominator(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_maximum_bitrate_kbps(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_enable_hardware_decoding(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_enable_performance_overlay(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_enable_video_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_enable_audio_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_enable_input_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_audio_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_enable_video_hevc(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_enable_performance_icons(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_enable_microphone_streaming(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_controller_overlay_hotkey(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_enable_touch_controller_obsolete(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_p2p_scope(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_enable_audio_uncompressed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

CStreamingClientConfig::CStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingClientConfig)
}
CStreamingClientConfig::CStreamingClientConfig(const CStreamingClientConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  controller_overlay_hotkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controller_overlay_hotkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_overlay_hotkey()) {
    controller_overlay_hotkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controller_overlay_hotkey(), 
      GetArenaForAllocation());
  }
  ::memcpy(&maximum_resolution_x_, &from.maximum_resolution_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&audio_channels_) -
    reinterpret_cast<char*>(&maximum_resolution_x_)) + sizeof(audio_channels_));
  // @@protoc_insertion_point(copy_constructor:CStreamingClientConfig)
}

inline void CStreamingClientConfig::SharedCtor() {
controller_overlay_hotkey_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controller_overlay_hotkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&maximum_resolution_x_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&enable_audio_uncompressed_) -
    reinterpret_cast<char*>(&maximum_resolution_x_)) + sizeof(enable_audio_uncompressed_));
enable_performance_icons_ = true;
quality_ = 2;
maximum_bitrate_kbps_ = -1;
enable_hardware_decoding_ = true;
enable_video_streaming_ = true;
enable_audio_streaming_ = true;
enable_input_streaming_ = true;
audio_channels_ = 2;
}

CStreamingClientConfig::~CStreamingClientConfig() {
  // @@protoc_insertion_point(destructor:CStreamingClientConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingClientConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  controller_overlay_hotkey_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStreamingClientConfig::ArenaDtor(void* object) {
  CStreamingClientConfig* _this = reinterpret_cast< CStreamingClientConfig* >(object);
  (void)_this;
}
void CStreamingClientConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingClientConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingClientConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingClientConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    controller_overlay_hotkey_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&maximum_resolution_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_microphone_streaming_) -
        reinterpret_cast<char*>(&maximum_resolution_x_)) + sizeof(enable_microphone_streaming_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&enable_touch_controller_obsolete_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&enable_audio_uncompressed_) -
        reinterpret_cast<char*>(&enable_touch_controller_obsolete_)) + sizeof(enable_audio_uncompressed_));
    enable_performance_icons_ = true;
    quality_ = 2;
    maximum_bitrate_kbps_ = -1;
    enable_hardware_decoding_ = true;
    enable_video_streaming_ = true;
  }
  if (cached_has_bits & 0x00070000u) {
    enable_audio_streaming_ = true;
    enable_input_streaming_ = true;
    audio_channels_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingClientConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamQualityPreference_IsValid(val))) {
            _internal_set_quality(static_cast<::EStreamQualityPreference>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maximum_resolution_x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_maximum_resolution_x(&has_bits);
          maximum_resolution_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maximum_resolution_y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_maximum_resolution_y(&has_bits);
          maximum_resolution_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maximum_framerate_numerator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_maximum_framerate_numerator(&has_bits);
          maximum_framerate_numerator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 maximum_framerate_denominator = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_maximum_framerate_denominator(&has_bits);
          maximum_framerate_denominator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 maximum_bitrate_kbps = 6 [default = -1];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_maximum_bitrate_kbps(&has_bits);
          maximum_bitrate_kbps_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_hardware_decoding = 7 [default = true];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_enable_hardware_decoding(&has_bits);
          enable_hardware_decoding_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_performance_overlay = 8 [default = false];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_enable_performance_overlay(&has_bits);
          enable_performance_overlay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_video_streaming = 9 [default = true];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_enable_video_streaming(&has_bits);
          enable_video_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_audio_streaming = 10 [default = true];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_enable_audio_streaming(&has_bits);
          enable_audio_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_input_streaming = 11 [default = true];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_enable_input_streaming(&has_bits);
          enable_input_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audio_channels = 12 [default = 2];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_audio_channels(&has_bits);
          audio_channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_video_hevc = 13 [default = false];
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_enable_video_hevc(&has_bits);
          enable_video_hevc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_performance_icons = 14 [default = true];
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_enable_performance_icons(&has_bits);
          enable_performance_icons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_microphone_streaming = 15 [default = false];
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_enable_microphone_streaming(&has_bits);
          enable_microphone_streaming_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controller_overlay_hotkey = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_controller_overlay_hotkey();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CStreamingClientConfig.controller_overlay_hotkey");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_touch_controller_OBSOLETE = 17 [default = false];
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_enable_touch_controller_obsolete(&has_bits);
          enable_touch_controller_obsolete_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamP2PScope p2p_scope = 19 [default = k_EStreamP2PScopeAutomatic];
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamP2PScope_IsValid(val))) {
            _internal_set_p2p_scope(static_cast<::EStreamP2PScope>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(19, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_audio_uncompressed = 20 [default = false];
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          _Internal::set_has_enable_audio_uncompressed(&has_bits);
          enable_audio_uncompressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingClientConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingClientConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_quality(), target);
  }

  // optional uint32 maximum_resolution_x = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_maximum_resolution_x(), target);
  }

  // optional uint32 maximum_resolution_y = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_maximum_resolution_y(), target);
  }

  // optional uint32 maximum_framerate_numerator = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_maximum_framerate_numerator(), target);
  }

  // optional uint32 maximum_framerate_denominator = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_maximum_framerate_denominator(), target);
  }

  // optional int32 maximum_bitrate_kbps = 6 [default = -1];
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_maximum_bitrate_kbps(), target);
  }

  // optional bool enable_hardware_decoding = 7 [default = true];
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_enable_hardware_decoding(), target);
  }

  // optional bool enable_performance_overlay = 8 [default = false];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_enable_performance_overlay(), target);
  }

  // optional bool enable_video_streaming = 9 [default = true];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(9, this->_internal_enable_video_streaming(), target);
  }

  // optional bool enable_audio_streaming = 10 [default = true];
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_enable_audio_streaming(), target);
  }

  // optional bool enable_input_streaming = 11 [default = true];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_enable_input_streaming(), target);
  }

  // optional int32 audio_channels = 12 [default = 2];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_audio_channels(), target);
  }

  // optional bool enable_video_hevc = 13 [default = false];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(13, this->_internal_enable_video_hevc(), target);
  }

  // optional bool enable_performance_icons = 14 [default = true];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_enable_performance_icons(), target);
  }

  // optional bool enable_microphone_streaming = 15 [default = false];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(15, this->_internal_enable_microphone_streaming(), target);
  }

  // optional string controller_overlay_hotkey = 16;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controller_overlay_hotkey().data(), static_cast<int>(this->_internal_controller_overlay_hotkey().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CStreamingClientConfig.controller_overlay_hotkey");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_controller_overlay_hotkey(), target);
  }

  // optional bool enable_touch_controller_OBSOLETE = 17 [default = false];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(17, this->_internal_enable_touch_controller_obsolete(), target);
  }

  // optional .EStreamP2PScope p2p_scope = 19 [default = k_EStreamP2PScopeAutomatic];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      19, this->_internal_p2p_scope(), target);
  }

  // optional bool enable_audio_uncompressed = 20 [default = false];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(20, this->_internal_enable_audio_uncompressed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingClientConfig)
  return target;
}

size_t CStreamingClientConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingClientConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string controller_overlay_hotkey = 16;
    if (cached_has_bits & 0x00000001u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_overlay_hotkey());
    }

    // optional uint32 maximum_resolution_x = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maximum_resolution_x());
    }

    // optional uint32 maximum_resolution_y = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maximum_resolution_y());
    }

    // optional uint32 maximum_framerate_numerator = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maximum_framerate_numerator());
    }

    // optional uint32 maximum_framerate_denominator = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_maximum_framerate_denominator());
    }

    // optional bool enable_performance_overlay = 8 [default = false];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool enable_video_hevc = 13 [default = false];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool enable_microphone_streaming = 15 [default = false];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool enable_touch_controller_OBSOLETE = 17 [default = false];
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 + 1;
    }

    // optional .EStreamP2PScope p2p_scope = 19 [default = k_EStreamP2PScopeAutomatic];
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_p2p_scope());
    }

    // optional bool enable_audio_uncompressed = 20 [default = false];
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 + 1;
    }

    // optional bool enable_performance_icons = 14 [default = true];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_quality());
    }

    // optional int32 maximum_bitrate_kbps = 6 [default = -1];
    if (cached_has_bits & 0x00002000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_maximum_bitrate_kbps());
    }

    // optional bool enable_hardware_decoding = 7 [default = true];
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 1;
    }

    // optional bool enable_video_streaming = 9 [default = true];
    if (cached_has_bits & 0x00008000u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional bool enable_audio_streaming = 10 [default = true];
    if (cached_has_bits & 0x00010000u) {
      total_size += 1 + 1;
    }

    // optional bool enable_input_streaming = 11 [default = true];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 1;
    }

    // optional int32 audio_channels = 12 [default = 2];
    if (cached_has_bits & 0x00040000u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_audio_channels());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingClientConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingClientConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingClientConfig::GetClassData() const { return &_class_data_; }

void CStreamingClientConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingClientConfig *>(to)->MergeFrom(
      static_cast<const CStreamingClientConfig &>(from));
}


void CStreamingClientConfig::MergeFrom(const CStreamingClientConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingClientConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_controller_overlay_hotkey(from._internal_controller_overlay_hotkey());
    }
    if (cached_has_bits & 0x00000002u) {
      maximum_resolution_x_ = from.maximum_resolution_x_;
    }
    if (cached_has_bits & 0x00000004u) {
      maximum_resolution_y_ = from.maximum_resolution_y_;
    }
    if (cached_has_bits & 0x00000008u) {
      maximum_framerate_numerator_ = from.maximum_framerate_numerator_;
    }
    if (cached_has_bits & 0x00000010u) {
      maximum_framerate_denominator_ = from.maximum_framerate_denominator_;
    }
    if (cached_has_bits & 0x00000020u) {
      enable_performance_overlay_ = from.enable_performance_overlay_;
    }
    if (cached_has_bits & 0x00000040u) {
      enable_video_hevc_ = from.enable_video_hevc_;
    }
    if (cached_has_bits & 0x00000080u) {
      enable_microphone_streaming_ = from.enable_microphone_streaming_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      enable_touch_controller_obsolete_ = from.enable_touch_controller_obsolete_;
    }
    if (cached_has_bits & 0x00000200u) {
      p2p_scope_ = from.p2p_scope_;
    }
    if (cached_has_bits & 0x00000400u) {
      enable_audio_uncompressed_ = from.enable_audio_uncompressed_;
    }
    if (cached_has_bits & 0x00000800u) {
      enable_performance_icons_ = from.enable_performance_icons_;
    }
    if (cached_has_bits & 0x00001000u) {
      quality_ = from.quality_;
    }
    if (cached_has_bits & 0x00002000u) {
      maximum_bitrate_kbps_ = from.maximum_bitrate_kbps_;
    }
    if (cached_has_bits & 0x00004000u) {
      enable_hardware_decoding_ = from.enable_hardware_decoding_;
    }
    if (cached_has_bits & 0x00008000u) {
      enable_video_streaming_ = from.enable_video_streaming_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      enable_audio_streaming_ = from.enable_audio_streaming_;
    }
    if (cached_has_bits & 0x00020000u) {
      enable_input_streaming_ = from.enable_input_streaming_;
    }
    if (cached_has_bits & 0x00040000u) {
      audio_channels_ = from.audio_channels_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingClientConfig::CopyFrom(const CStreamingClientConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingClientConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingClientConfig::IsInitialized() const {
  return true;
}

void CStreamingClientConfig::InternalSwap(CStreamingClientConfig* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controller_overlay_hotkey_, lhs_arena,
      &other->controller_overlay_hotkey_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamingClientConfig, enable_audio_uncompressed_)
      + sizeof(CStreamingClientConfig::enable_audio_uncompressed_)
      - PROTOBUF_FIELD_OFFSET(CStreamingClientConfig, maximum_resolution_x_)>(
          reinterpret_cast<char*>(&maximum_resolution_x_),
          reinterpret_cast<char*>(&other->maximum_resolution_x_));
  swap(enable_performance_icons_, other->enable_performance_icons_);
  swap(quality_, other->quality_);
  swap(maximum_bitrate_kbps_, other->maximum_bitrate_kbps_);
  swap(enable_hardware_decoding_, other->enable_hardware_decoding_);
  swap(enable_video_streaming_, other->enable_video_streaming_);
  swap(enable_audio_streaming_, other->enable_audio_streaming_);
  swap(enable_input_streaming_, other->enable_input_streaming_);
  swap(audio_channels_, other->audio_channels_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingClientConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[12]);
}

// ===================================================================

class CStreamingServerConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingServerConfig>()._has_bits_);
  static void set_has_change_desktop_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dynamically_adjust_resolution(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_capture_nvfbc(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_enable_hardware_encoding_nvidia(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_hardware_encoding_amd(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_enable_hardware_encoding_intel(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_software_encoding_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_enable_traffic_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_host_play_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CStreamingServerConfig::CStreamingServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingServerConfig)
}
CStreamingServerConfig::CStreamingServerConfig(const CStreamingServerConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&change_desktop_resolution_, &from.change_desktop_resolution_,
    static_cast<size_t>(reinterpret_cast<char*>(&host_play_audio_) -
    reinterpret_cast<char*>(&change_desktop_resolution_)) + sizeof(host_play_audio_));
  // @@protoc_insertion_point(copy_constructor:CStreamingServerConfig)
}

inline void CStreamingServerConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&change_desktop_resolution_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&host_play_audio_) -
    reinterpret_cast<char*>(&change_desktop_resolution_)) + sizeof(host_play_audio_));
}

CStreamingServerConfig::~CStreamingServerConfig() {
  // @@protoc_insertion_point(destructor:CStreamingServerConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingServerConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingServerConfig::ArenaDtor(void* object) {
  CStreamingServerConfig* _this = reinterpret_cast< CStreamingServerConfig* >(object);
  (void)_this;
}
void CStreamingServerConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingServerConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingServerConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingServerConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&change_desktop_resolution_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&software_encoding_threads_) -
        reinterpret_cast<char*>(&change_desktop_resolution_)) + sizeof(software_encoding_threads_));
  }
  host_play_audio_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingServerConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool change_desktop_resolution = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_change_desktop_resolution(&has_bits);
          change_desktop_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool dynamically_adjust_resolution = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_dynamically_adjust_resolution(&has_bits);
          dynamically_adjust_resolution_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_capture_nvfbc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_enable_capture_nvfbc(&has_bits);
          enable_capture_nvfbc_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_hardware_encoding_nvidia = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_enable_hardware_encoding_nvidia(&has_bits);
          enable_hardware_encoding_nvidia_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_hardware_encoding_amd = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_enable_hardware_encoding_amd(&has_bits);
          enable_hardware_encoding_amd_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_hardware_encoding_intel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enable_hardware_encoding_intel(&has_bits);
          enable_hardware_encoding_intel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 software_encoding_threads = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_software_encoding_threads(&has_bits);
          software_encoding_threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_traffic_priority = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_enable_traffic_priority(&has_bits);
          enable_traffic_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamHostPlayAudioPreference host_play_audio = 9 [default = k_EStreamHostPlayAudioDefault];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamHostPlayAudioPreference_IsValid(val))) {
            _internal_set_host_play_audio(static_cast<::EStreamHostPlayAudioPreference>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingServerConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingServerConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool change_desktop_resolution = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_change_desktop_resolution(), target);
  }

  // optional bool dynamically_adjust_resolution = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_dynamically_adjust_resolution(), target);
  }

  // optional bool enable_capture_nvfbc = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_enable_capture_nvfbc(), target);
  }

  // optional bool enable_hardware_encoding_nvidia = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_enable_hardware_encoding_nvidia(), target);
  }

  // optional bool enable_hardware_encoding_amd = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_hardware_encoding_amd(), target);
  }

  // optional bool enable_hardware_encoding_intel = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_hardware_encoding_intel(), target);
  }

  // optional int32 software_encoding_threads = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_software_encoding_threads(), target);
  }

  // optional bool enable_traffic_priority = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(8, this->_internal_enable_traffic_priority(), target);
  }

  // optional .EStreamHostPlayAudioPreference host_play_audio = 9 [default = k_EStreamHostPlayAudioDefault];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_host_play_audio(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingServerConfig)
  return target;
}

size_t CStreamingServerConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingServerConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool change_desktop_resolution = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool dynamically_adjust_resolution = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool enable_capture_nvfbc = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enable_hardware_encoding_nvidia = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool enable_hardware_encoding_amd = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool enable_hardware_encoding_intel = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

    // optional bool enable_traffic_priority = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 software_encoding_threads = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_software_encoding_threads());
    }

  }
  // optional .EStreamHostPlayAudioPreference host_play_audio = 9 [default = k_EStreamHostPlayAudioDefault];
  if (cached_has_bits & 0x00000100u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_host_play_audio());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingServerConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingServerConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingServerConfig::GetClassData() const { return &_class_data_; }

void CStreamingServerConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingServerConfig *>(to)->MergeFrom(
      static_cast<const CStreamingServerConfig &>(from));
}


void CStreamingServerConfig::MergeFrom(const CStreamingServerConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingServerConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      change_desktop_resolution_ = from.change_desktop_resolution_;
    }
    if (cached_has_bits & 0x00000002u) {
      dynamically_adjust_resolution_ = from.dynamically_adjust_resolution_;
    }
    if (cached_has_bits & 0x00000004u) {
      enable_capture_nvfbc_ = from.enable_capture_nvfbc_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_hardware_encoding_nvidia_ = from.enable_hardware_encoding_nvidia_;
    }
    if (cached_has_bits & 0x00000010u) {
      enable_hardware_encoding_amd_ = from.enable_hardware_encoding_amd_;
    }
    if (cached_has_bits & 0x00000020u) {
      enable_hardware_encoding_intel_ = from.enable_hardware_encoding_intel_;
    }
    if (cached_has_bits & 0x00000040u) {
      enable_traffic_priority_ = from.enable_traffic_priority_;
    }
    if (cached_has_bits & 0x00000080u) {
      software_encoding_threads_ = from.software_encoding_threads_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_host_play_audio(from._internal_host_play_audio());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingServerConfig::CopyFrom(const CStreamingServerConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingServerConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingServerConfig::IsInitialized() const {
  return true;
}

void CStreamingServerConfig::InternalSwap(CStreamingServerConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamingServerConfig, host_play_audio_)
      + sizeof(CStreamingServerConfig::host_play_audio_)
      - PROTOBUF_FIELD_OFFSET(CStreamingServerConfig, change_desktop_resolution_)>(
          reinterpret_cast<char*>(&change_desktop_resolution_),
          reinterpret_cast<char*>(&other->change_desktop_resolution_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingServerConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[13]);
}

// ===================================================================

class CNegotiatedConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CNegotiatedConfig>()._has_bits_);
  static void set_has_reliable_data(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_selected_audio_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_selected_video_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_enable_remote_hid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_enable_touch_input(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_disable_client_cursor(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CNegotiatedConfig::CNegotiatedConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  available_video_modes_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CNegotiatedConfig)
}
CNegotiatedConfig::CNegotiatedConfig(const CNegotiatedConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      available_video_modes_(from.available_video_modes_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&selected_audio_codec_, &from.selected_audio_codec_,
    static_cast<size_t>(reinterpret_cast<char*>(&disable_client_cursor_) -
    reinterpret_cast<char*>(&selected_audio_codec_)) + sizeof(disable_client_cursor_));
  // @@protoc_insertion_point(copy_constructor:CNegotiatedConfig)
}

inline void CNegotiatedConfig::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&selected_audio_codec_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&disable_client_cursor_) -
    reinterpret_cast<char*>(&selected_audio_codec_)) + sizeof(disable_client_cursor_));
}

CNegotiatedConfig::~CNegotiatedConfig() {
  // @@protoc_insertion_point(destructor:CNegotiatedConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CNegotiatedConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CNegotiatedConfig::ArenaDtor(void* object) {
  CNegotiatedConfig* _this = reinterpret_cast< CNegotiatedConfig* >(object);
  (void)_this;
}
void CNegotiatedConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CNegotiatedConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CNegotiatedConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:CNegotiatedConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  available_video_modes_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    ::memset(&selected_audio_codec_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&disable_client_cursor_) -
        reinterpret_cast<char*>(&selected_audio_codec_)) + sizeof(disable_client_cursor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNegotiatedConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable_data(&has_bits);
          reliable_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamAudioCodec_IsValid(val))) {
            _internal_set_selected_audio_codec(static_cast<::EStreamAudioCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamVideoCodec_IsValid(val))) {
            _internal_set_selected_video_codec(static_cast<::EStreamVideoCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CStreamVideoMode available_video_modes = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_available_video_modes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_remote_hid = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_enable_remote_hid(&has_bits);
          enable_remote_hid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool enable_touch_input = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_enable_touch_input(&has_bits);
          enable_touch_input_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool disable_client_cursor = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_disable_client_cursor(&has_bits);
          disable_client_cursor_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNegotiatedConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CNegotiatedConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool reliable_data = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable_data(), target);
  }

  // optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_selected_audio_codec(), target);
  }

  // optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_selected_video_codec(), target);
  }

  // repeated .CStreamVideoMode available_video_modes = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_available_video_modes_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_available_video_modes(i), target, stream);
  }

  // optional bool enable_remote_hid = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_enable_remote_hid(), target);
  }

  // optional bool enable_touch_input = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_enable_touch_input(), target);
  }

  // optional bool disable_client_cursor = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_disable_client_cursor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CNegotiatedConfig)
  return target;
}

size_t CNegotiatedConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CNegotiatedConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStreamVideoMode available_video_modes = 4;
  total_size += 1UL * this->_internal_available_video_modes_size();
  for (const auto& msg : this->available_video_modes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_selected_audio_codec());
    }

    // optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_selected_video_codec());
    }

    // optional bool reliable_data = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool enable_remote_hid = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool enable_touch_input = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool disable_client_cursor = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNegotiatedConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CNegotiatedConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNegotiatedConfig::GetClassData() const { return &_class_data_; }

void CNegotiatedConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CNegotiatedConfig *>(to)->MergeFrom(
      static_cast<const CNegotiatedConfig &>(from));
}


void CNegotiatedConfig::MergeFrom(const CNegotiatedConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CNegotiatedConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  available_video_modes_.MergeFrom(from.available_video_modes_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      selected_audio_codec_ = from.selected_audio_codec_;
    }
    if (cached_has_bits & 0x00000002u) {
      selected_video_codec_ = from.selected_video_codec_;
    }
    if (cached_has_bits & 0x00000004u) {
      reliable_data_ = from.reliable_data_;
    }
    if (cached_has_bits & 0x00000008u) {
      enable_remote_hid_ = from.enable_remote_hid_;
    }
    if (cached_has_bits & 0x00000010u) {
      enable_touch_input_ = from.enable_touch_input_;
    }
    if (cached_has_bits & 0x00000020u) {
      disable_client_cursor_ = from.disable_client_cursor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNegotiatedConfig::CopyFrom(const CNegotiatedConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CNegotiatedConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNegotiatedConfig::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(available_video_modes_))
    return false;
  return true;
}

void CNegotiatedConfig::InternalSwap(CNegotiatedConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  available_video_modes_.InternalSwap(&other->available_video_modes_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNegotiatedConfig, disable_client_cursor_)
      + sizeof(CNegotiatedConfig::disable_client_cursor_)
      - PROTOBUF_FIELD_OFFSET(CNegotiatedConfig, selected_audio_codec_)>(
          reinterpret_cast<char*>(&selected_audio_codec_),
          reinterpret_cast<char*>(&other->selected_audio_codec_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNegotiatedConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[14]);
}

// ===================================================================

class CNegotiationInitMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CNegotiationInitMsg>()._has_bits_);
  static void set_has_reliable_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_supports_remote_hid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_supports_touch_input(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CNegotiationInitMsg::CNegotiationInitMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  supported_audio_codecs_(arena),
  supported_video_codecs_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CNegotiationInitMsg)
}
CNegotiationInitMsg::CNegotiationInitMsg(const CNegotiationInitMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      supported_audio_codecs_(from.supported_audio_codecs_),
      supported_video_codecs_(from.supported_video_codecs_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&reliable_data_, &from.reliable_data_,
    static_cast<size_t>(reinterpret_cast<char*>(&supports_touch_input_) -
    reinterpret_cast<char*>(&reliable_data_)) + sizeof(supports_touch_input_));
  // @@protoc_insertion_point(copy_constructor:CNegotiationInitMsg)
}

inline void CNegotiationInitMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&reliable_data_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&supports_touch_input_) -
    reinterpret_cast<char*>(&reliable_data_)) + sizeof(supports_touch_input_));
}

CNegotiationInitMsg::~CNegotiationInitMsg() {
  // @@protoc_insertion_point(destructor:CNegotiationInitMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CNegotiationInitMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CNegotiationInitMsg::ArenaDtor(void* object) {
  CNegotiationInitMsg* _this = reinterpret_cast< CNegotiationInitMsg* >(object);
  (void)_this;
}
void CNegotiationInitMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CNegotiationInitMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CNegotiationInitMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CNegotiationInitMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  supported_audio_codecs_.Clear();
  supported_video_codecs_.Clear();
  ::memset(&reliable_data_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&supports_touch_input_) -
      reinterpret_cast<char*>(&reliable_data_)) + sizeof(supports_touch_input_));
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNegotiationInitMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable_data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable_data(&has_bits);
          reliable_data_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EStreamAudioCodec supported_audio_codecs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EStreamAudioCodec_IsValid(val))) {
              _internal_add_supported_audio_codecs(static_cast<::EStreamAudioCodec>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_supported_audio_codecs(), ptr, ctx, ::EStreamAudioCodec_IsValid, &_internal_metadata_, 2);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .EStreamVideoCodec supported_video_codecs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
            CHK_(ptr);
            if (PROTOBUF_PREDICT_TRUE(::EStreamVideoCodec_IsValid(val))) {
              _internal_add_supported_video_codecs(static_cast<::EStreamVideoCodec>(val));
            } else {
              ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
            }
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedEnumParser<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(_internal_mutable_supported_video_codecs(), ptr, ctx, ::EStreamVideoCodec_IsValid, &_internal_metadata_, 3);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_remote_hid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_supports_remote_hid(&has_bits);
          supports_remote_hid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool supports_touch_input = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_supports_touch_input(&has_bits);
          supports_touch_input_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNegotiationInitMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CNegotiationInitMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool reliable_data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable_data(), target);
  }

  // repeated .EStreamAudioCodec supported_audio_codecs = 2;
  for (int i = 0, n = this->_internal_supported_audio_codecs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        2, this->_internal_supported_audio_codecs(i), target);
  }

  // repeated .EStreamVideoCodec supported_video_codecs = 3;
  for (int i = 0, n = this->_internal_supported_video_codecs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
        3, this->_internal_supported_video_codecs(i), target);
  }

  // optional bool supports_remote_hid = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_supports_remote_hid(), target);
  }

  // optional bool supports_touch_input = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_supports_touch_input(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CNegotiationInitMsg)
  return target;
}

size_t CNegotiationInitMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CNegotiationInitMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .EStreamAudioCodec supported_audio_codecs = 2;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_audio_codecs_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_audio_codecs(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  // repeated .EStreamVideoCodec supported_video_codecs = 3;
  {
    size_t data_size = 0;
    unsigned int count = static_cast<unsigned int>(this->_internal_supported_video_codecs_size());for (unsigned int i = 0; i < count; i++) {
      data_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(
        this->_internal_supported_video_codecs(static_cast<int>(i)));
    }
    total_size += (1UL * count) + data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bool reliable_data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional bool supports_remote_hid = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool supports_touch_input = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNegotiationInitMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CNegotiationInitMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNegotiationInitMsg::GetClassData() const { return &_class_data_; }

void CNegotiationInitMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CNegotiationInitMsg *>(to)->MergeFrom(
      static_cast<const CNegotiationInitMsg &>(from));
}


void CNegotiationInitMsg::MergeFrom(const CNegotiationInitMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CNegotiationInitMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  supported_audio_codecs_.MergeFrom(from.supported_audio_codecs_);
  supported_video_codecs_.MergeFrom(from.supported_video_codecs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      reliable_data_ = from.reliable_data_;
    }
    if (cached_has_bits & 0x00000002u) {
      supports_remote_hid_ = from.supports_remote_hid_;
    }
    if (cached_has_bits & 0x00000004u) {
      supports_touch_input_ = from.supports_touch_input_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNegotiationInitMsg::CopyFrom(const CNegotiationInitMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CNegotiationInitMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNegotiationInitMsg::IsInitialized() const {
  return true;
}

void CNegotiationInitMsg::InternalSwap(CNegotiationInitMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  supported_audio_codecs_.InternalSwap(&other->supported_audio_codecs_);
  supported_video_codecs_.InternalSwap(&other->supported_video_codecs_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNegotiationInitMsg, supports_touch_input_)
      + sizeof(CNegotiationInitMsg::supports_touch_input_)
      - PROTOBUF_FIELD_OFFSET(CNegotiationInitMsg, reliable_data_)>(
          reinterpret_cast<char*>(&reliable_data_),
          reinterpret_cast<char*>(&other->reliable_data_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNegotiationInitMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[15]);
}

// ===================================================================

class CNegotiationSetConfigMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CNegotiationSetConfigMsg>()._has_bits_);
  static const ::CNegotiatedConfig& config(const CNegotiationSetConfigMsg* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CStreamingClientConfig& streaming_client_config(const CNegotiationSetConfigMsg* msg);
  static void set_has_streaming_client_config(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CStreamingClientCaps& streaming_client_caps(const CNegotiationSetConfigMsg* msg);
  static void set_has_streaming_client_caps(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::CNegotiatedConfig&
CNegotiationSetConfigMsg::_Internal::config(const CNegotiationSetConfigMsg* msg) {
  return *msg->config_;
}
const ::CStreamingClientConfig&
CNegotiationSetConfigMsg::_Internal::streaming_client_config(const CNegotiationSetConfigMsg* msg) {
  return *msg->streaming_client_config_;
}
const ::CStreamingClientCaps&
CNegotiationSetConfigMsg::_Internal::streaming_client_caps(const CNegotiationSetConfigMsg* msg) {
  return *msg->streaming_client_caps_;
}
CNegotiationSetConfigMsg::CNegotiationSetConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CNegotiationSetConfigMsg)
}
CNegotiationSetConfigMsg::CNegotiationSetConfigMsg(const CNegotiationSetConfigMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::CNegotiatedConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  if (from._internal_has_streaming_client_config()) {
    streaming_client_config_ = new ::CStreamingClientConfig(*from.streaming_client_config_);
  } else {
    streaming_client_config_ = nullptr;
  }
  if (from._internal_has_streaming_client_caps()) {
    streaming_client_caps_ = new ::CStreamingClientCaps(*from.streaming_client_caps_);
  } else {
    streaming_client_caps_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CNegotiationSetConfigMsg)
}

inline void CNegotiationSetConfigMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&config_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&streaming_client_caps_) -
    reinterpret_cast<char*>(&config_)) + sizeof(streaming_client_caps_));
}

CNegotiationSetConfigMsg::~CNegotiationSetConfigMsg() {
  // @@protoc_insertion_point(destructor:CNegotiationSetConfigMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CNegotiationSetConfigMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
  if (this != internal_default_instance()) delete streaming_client_config_;
  if (this != internal_default_instance()) delete streaming_client_caps_;
}

void CNegotiationSetConfigMsg::ArenaDtor(void* object) {
  CNegotiationSetConfigMsg* _this = reinterpret_cast< CNegotiationSetConfigMsg* >(object);
  (void)_this;
}
void CNegotiationSetConfigMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CNegotiationSetConfigMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CNegotiationSetConfigMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CNegotiationSetConfigMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(config_ != nullptr);
      config_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(streaming_client_config_ != nullptr);
      streaming_client_config_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(streaming_client_caps_ != nullptr);
      streaming_client_caps_->Clear();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CNegotiationSetConfigMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .CNegotiatedConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CStreamingClientConfig streaming_client_config = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_streaming_client_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CStreamingClientCaps streaming_client_caps = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_streaming_client_caps(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CNegotiationSetConfigMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CNegotiationSetConfigMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CNegotiatedConfig config = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  // optional .CStreamingClientConfig streaming_client_config = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::streaming_client_config(this), target, stream);
  }

  // optional .CStreamingClientCaps streaming_client_caps = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::streaming_client_caps(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CNegotiationSetConfigMsg)
  return target;
}

size_t CNegotiationSetConfigMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CNegotiationSetConfigMsg)
  size_t total_size = 0;

  // required .CNegotiatedConfig config = 1;
  if (_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional .CStreamingClientConfig streaming_client_config = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *streaming_client_config_);
    }

    // optional .CStreamingClientCaps streaming_client_caps = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *streaming_client_caps_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNegotiationSetConfigMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CNegotiationSetConfigMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNegotiationSetConfigMsg::GetClassData() const { return &_class_data_; }

void CNegotiationSetConfigMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CNegotiationSetConfigMsg *>(to)->MergeFrom(
      static_cast<const CNegotiationSetConfigMsg &>(from));
}


void CNegotiationSetConfigMsg::MergeFrom(const CNegotiationSetConfigMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CNegotiationSetConfigMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_config()->::CNegotiatedConfig::MergeFrom(from._internal_config());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_streaming_client_config()->::CStreamingClientConfig::MergeFrom(from._internal_streaming_client_config());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_streaming_client_caps()->::CStreamingClientCaps::MergeFrom(from._internal_streaming_client_caps());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CNegotiationSetConfigMsg::CopyFrom(const CNegotiationSetConfigMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CNegotiationSetConfigMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CNegotiationSetConfigMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_config()) {
    if (!config_->IsInitialized()) return false;
  }
  return true;
}

void CNegotiationSetConfigMsg::InternalSwap(CNegotiationSetConfigMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CNegotiationSetConfigMsg, streaming_client_caps_)
      + sizeof(CNegotiationSetConfigMsg::streaming_client_caps_)
      - PROTOBUF_FIELD_OFFSET(CNegotiationSetConfigMsg, config_)>(
          reinterpret_cast<char*>(&config_),
          reinterpret_cast<char*>(&other->config_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CNegotiationSetConfigMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[16]);
}

// ===================================================================

class CNegotiationCompleteMsg::_Internal {
 public:
};

CNegotiationCompleteMsg::CNegotiationCompleteMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CNegotiationCompleteMsg)
}
CNegotiationCompleteMsg::CNegotiationCompleteMsg(const CNegotiationCompleteMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CNegotiationCompleteMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CNegotiationCompleteMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CNegotiationCompleteMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CNegotiationCompleteMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[17]);
}

// ===================================================================

class CStartAudioDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CStartAudioDataMsg>()._has_bits_);
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_codec_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CStartAudioDataMsg::CStartAudioDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStartAudioDataMsg)
}
CStartAudioDataMsg::CStartAudioDataMsg(const CStartAudioDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  codec_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec_data()) {
    codec_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_codec_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&channel_, &from.channel_,
    static_cast<size_t>(reinterpret_cast<char*>(&channels_) -
    reinterpret_cast<char*>(&channel_)) + sizeof(channels_));
  // @@protoc_insertion_point(copy_constructor:CStartAudioDataMsg)
}

inline void CStartAudioDataMsg::SharedCtor() {
codec_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&channel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&channels_) -
    reinterpret_cast<char*>(&channel_)) + sizeof(channels_));
}

CStartAudioDataMsg::~CStartAudioDataMsg() {
  // @@protoc_insertion_point(destructor:CStartAudioDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStartAudioDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  codec_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStartAudioDataMsg::ArenaDtor(void* object) {
  CStartAudioDataMsg* _this = reinterpret_cast< CStartAudioDataMsg* >(object);
  (void)_this;
}
void CStartAudioDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStartAudioDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStartAudioDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CStartAudioDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    codec_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&channel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&channels_) -
        reinterpret_cast<char*>(&channel_)) + sizeof(channels_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStartAudioDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 channel = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_channel(&has_bits);
          channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamAudioCodec_IsValid(val))) {
            _internal_set_codec(static_cast<::EStreamAudioCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes codec_data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_codec_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 frequency = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 channels = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_channels(&has_bits);
          channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStartAudioDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStartAudioDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 channel = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_channel(), target);
  }

  // optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_codec(), target);
  }

  // optional bytes codec_data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_codec_data(), target);
  }

  // optional uint32 frequency = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_frequency(), target);
  }

  // optional uint32 channels = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStartAudioDataMsg)
  return target;
}

size_t CStartAudioDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStartAudioDataMsg)
  size_t total_size = 0;

  // required uint32 channel = 2;
  if (_internal_has_channel()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes codec_data = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_codec_data());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional uint32 frequency = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frequency());
    }

    // optional uint32 channels = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_channels());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStartAudioDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStartAudioDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStartAudioDataMsg::GetClassData() const { return &_class_data_; }

void CStartAudioDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStartAudioDataMsg *>(to)->MergeFrom(
      static_cast<const CStartAudioDataMsg &>(from));
}


void CStartAudioDataMsg::MergeFrom(const CStartAudioDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStartAudioDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_codec_data(from._internal_codec_data());
    }
    if (cached_has_bits & 0x00000002u) {
      channel_ = from.channel_;
    }
    if (cached_has_bits & 0x00000004u) {
      codec_ = from.codec_;
    }
    if (cached_has_bits & 0x00000008u) {
      frequency_ = from.frequency_;
    }
    if (cached_has_bits & 0x00000010u) {
      channels_ = from.channels_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStartAudioDataMsg::CopyFrom(const CStartAudioDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStartAudioDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStartAudioDataMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CStartAudioDataMsg::InternalSwap(CStartAudioDataMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &codec_data_, lhs_arena,
      &other->codec_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStartAudioDataMsg, channels_)
      + sizeof(CStartAudioDataMsg::channels_)
      - PROTOBUF_FIELD_OFFSET(CStartAudioDataMsg, channel_)>(
          reinterpret_cast<char*>(&channel_),
          reinterpret_cast<char*>(&other->channel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStartAudioDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[18]);
}

// ===================================================================

class CStopAudioDataMsg::_Internal {
 public:
};

CStopAudioDataMsg::CStopAudioDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CStopAudioDataMsg)
}
CStopAudioDataMsg::CStopAudioDataMsg(const CStopAudioDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStopAudioDataMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStopAudioDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStopAudioDataMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CStopAudioDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[19]);
}

// ===================================================================

class CStartVideoDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CStartVideoDataMsg>()._has_bits_);
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_codec_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CStartVideoDataMsg::CStartVideoDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStartVideoDataMsg)
}
CStartVideoDataMsg::CStartVideoDataMsg(const CStartVideoDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  codec_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec_data()) {
    codec_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_codec_data(), 
      GetArenaForAllocation());
  }
  ::memcpy(&channel_, &from.channel_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&channel_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CStartVideoDataMsg)
}

inline void CStartVideoDataMsg::SharedCtor() {
codec_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&channel_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&channel_)) + sizeof(height_));
}

CStartVideoDataMsg::~CStartVideoDataMsg() {
  // @@protoc_insertion_point(destructor:CStartVideoDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStartVideoDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  codec_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CStartVideoDataMsg::ArenaDtor(void* object) {
  CStartVideoDataMsg* _this = reinterpret_cast< CStartVideoDataMsg* >(object);
  (void)_this;
}
void CStartVideoDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStartVideoDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStartVideoDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CStartVideoDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    codec_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&channel_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&channel_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStartVideoDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 channel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel(&has_bits);
          channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamVideoCodec_IsValid(val))) {
            _internal_set_codec(static_cast<::EStreamVideoCodec>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes codec_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_codec_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 width = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStartVideoDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStartVideoDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 channel = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel(), target);
  }

  // optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_codec(), target);
  }

  // optional bytes codec_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_codec_data(), target);
  }

  // optional uint32 width = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_width(), target);
  }

  // optional uint32 height = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStartVideoDataMsg)
  return target;
}

size_t CStartVideoDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStartVideoDataMsg)
  size_t total_size = 0;

  // required uint32 channel = 1;
  if (_internal_has_channel()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes codec_data = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_codec_data());
  }

  if (cached_has_bits & 0x0000001cu) {
    // optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_codec());
    }

    // optional uint32 width = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStartVideoDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStartVideoDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStartVideoDataMsg::GetClassData() const { return &_class_data_; }

void CStartVideoDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStartVideoDataMsg *>(to)->MergeFrom(
      static_cast<const CStartVideoDataMsg &>(from));
}


void CStartVideoDataMsg::MergeFrom(const CStartVideoDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStartVideoDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_codec_data(from._internal_codec_data());
    }
    if (cached_has_bits & 0x00000002u) {
      channel_ = from.channel_;
    }
    if (cached_has_bits & 0x00000004u) {
      codec_ = from.codec_;
    }
    if (cached_has_bits & 0x00000008u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000010u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStartVideoDataMsg::CopyFrom(const CStartVideoDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStartVideoDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStartVideoDataMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CStartVideoDataMsg::InternalSwap(CStartVideoDataMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &codec_data_, lhs_arena,
      &other->codec_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStartVideoDataMsg, height_)
      + sizeof(CStartVideoDataMsg::height_)
      - PROTOBUF_FIELD_OFFSET(CStartVideoDataMsg, channel_)>(
          reinterpret_cast<char*>(&channel_),
          reinterpret_cast<char*>(&other->channel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStartVideoDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[20]);
}

// ===================================================================

class CStopVideoDataMsg::_Internal {
 public:
};

CStopVideoDataMsg::CStopVideoDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CStopVideoDataMsg)
}
CStopVideoDataMsg::CStopVideoDataMsg(const CStopVideoDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStopVideoDataMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStopVideoDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStopVideoDataMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CStopVideoDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[21]);
}

// ===================================================================

class CStartNeptuneDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CStartNeptuneDataMsg>()._has_bits_);
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CStartNeptuneDataMsg::CStartNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStartNeptuneDataMsg)
}
CStartNeptuneDataMsg::CStartNeptuneDataMsg(const CStartNeptuneDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  channel_ = from.channel_;
  // @@protoc_insertion_point(copy_constructor:CStartNeptuneDataMsg)
}

inline void CStartNeptuneDataMsg::SharedCtor() {
channel_ = 0u;
}

CStartNeptuneDataMsg::~CStartNeptuneDataMsg() {
  // @@protoc_insertion_point(destructor:CStartNeptuneDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStartNeptuneDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStartNeptuneDataMsg::ArenaDtor(void* object) {
  CStartNeptuneDataMsg* _this = reinterpret_cast< CStartNeptuneDataMsg* >(object);
  (void)_this;
}
void CStartNeptuneDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStartNeptuneDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStartNeptuneDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CStartNeptuneDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  channel_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStartNeptuneDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 channel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_channel(&has_bits);
          channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStartNeptuneDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStartNeptuneDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 channel = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStartNeptuneDataMsg)
  return target;
}

size_t CStartNeptuneDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStartNeptuneDataMsg)
  size_t total_size = 0;

  // required uint32 channel = 1;
  if (_internal_has_channel()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_channel());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStartNeptuneDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStartNeptuneDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStartNeptuneDataMsg::GetClassData() const { return &_class_data_; }

void CStartNeptuneDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStartNeptuneDataMsg *>(to)->MergeFrom(
      static_cast<const CStartNeptuneDataMsg &>(from));
}


void CStartNeptuneDataMsg::MergeFrom(const CStartNeptuneDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStartNeptuneDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_channel()) {
    _internal_set_channel(from._internal_channel());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStartNeptuneDataMsg::CopyFrom(const CStartNeptuneDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStartNeptuneDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStartNeptuneDataMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CStartNeptuneDataMsg::InternalSwap(CStartNeptuneDataMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(channel_, other->channel_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStartNeptuneDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[22]);
}

// ===================================================================

class CStopNeptuneDataMsg::_Internal {
 public:
};

CStopNeptuneDataMsg::CStopNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CStopNeptuneDataMsg)
}
CStopNeptuneDataMsg::CStopNeptuneDataMsg(const CStopNeptuneDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStopNeptuneDataMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStopNeptuneDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStopNeptuneDataMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CStopNeptuneDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[23]);
}

// ===================================================================

class CRecordedInput::_Internal {
 public:
  using HasBits = decltype(std::declval<CRecordedInput>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CInputTouchFingerDownMsg& finger_down(const CRecordedInput* msg);
  static const ::CInputTouchFingerMotionMsg& finger_motion(const CRecordedInput* msg);
  static const ::CInputTouchFingerUpMsg& finger_up(const CRecordedInput* msg);
  static const ::CInputMouseMotionMsg& mouse_motion(const CRecordedInput* msg);
  static const ::CInputMouseWheelMsg& mouse_wheel(const CRecordedInput* msg);
  static const ::CInputMouseDownMsg& mouse_down(const CRecordedInput* msg);
  static const ::CInputMouseUpMsg& mouse_up(const CRecordedInput* msg);
  static const ::CInputKeyDownMsg& key_down(const CRecordedInput* msg);
  static const ::CInputKeyUpMsg& key_up(const CRecordedInput* msg);
  static const ::CInputTextMsg& text(const CRecordedInput* msg);
  static const ::CRemoteHIDMsg& hid(const CRecordedInput* msg);
};

const ::CInputTouchFingerDownMsg&
CRecordedInput::_Internal::finger_down(const CRecordedInput* msg) {
  return *msg->data_.finger_down_;
}
const ::CInputTouchFingerMotionMsg&
CRecordedInput::_Internal::finger_motion(const CRecordedInput* msg) {
  return *msg->data_.finger_motion_;
}
const ::CInputTouchFingerUpMsg&
CRecordedInput::_Internal::finger_up(const CRecordedInput* msg) {
  return *msg->data_.finger_up_;
}
const ::CInputMouseMotionMsg&
CRecordedInput::_Internal::mouse_motion(const CRecordedInput* msg) {
  return *msg->data_.mouse_motion_;
}
const ::CInputMouseWheelMsg&
CRecordedInput::_Internal::mouse_wheel(const CRecordedInput* msg) {
  return *msg->data_.mouse_wheel_;
}
const ::CInputMouseDownMsg&
CRecordedInput::_Internal::mouse_down(const CRecordedInput* msg) {
  return *msg->data_.mouse_down_;
}
const ::CInputMouseUpMsg&
CRecordedInput::_Internal::mouse_up(const CRecordedInput* msg) {
  return *msg->data_.mouse_up_;
}
const ::CInputKeyDownMsg&
CRecordedInput::_Internal::key_down(const CRecordedInput* msg) {
  return *msg->data_.key_down_;
}
const ::CInputKeyUpMsg&
CRecordedInput::_Internal::key_up(const CRecordedInput* msg) {
  return *msg->data_.key_up_;
}
const ::CInputTextMsg&
CRecordedInput::_Internal::text(const CRecordedInput* msg) {
  return *msg->data_.text_;
}
const ::CRemoteHIDMsg&
CRecordedInput::_Internal::hid(const CRecordedInput* msg) {
  return *msg->data_.hid_;
}
void CRecordedInput::set_allocated_finger_down(::CInputTouchFingerDownMsg* finger_down) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (finger_down) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputTouchFingerDownMsg>::GetOwningArena(finger_down);
    if (message_arena != submessage_arena) {
      finger_down = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finger_down, submessage_arena);
    }
    set_has_finger_down();
    data_.finger_down_ = finger_down;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.finger_down)
}
void CRecordedInput::set_allocated_finger_motion(::CInputTouchFingerMotionMsg* finger_motion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (finger_motion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputTouchFingerMotionMsg>::GetOwningArena(finger_motion);
    if (message_arena != submessage_arena) {
      finger_motion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finger_motion, submessage_arena);
    }
    set_has_finger_motion();
    data_.finger_motion_ = finger_motion;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.finger_motion)
}
void CRecordedInput::set_allocated_finger_up(::CInputTouchFingerUpMsg* finger_up) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (finger_up) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputTouchFingerUpMsg>::GetOwningArena(finger_up);
    if (message_arena != submessage_arena) {
      finger_up = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, finger_up, submessage_arena);
    }
    set_has_finger_up();
    data_.finger_up_ = finger_up;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.finger_up)
}
void CRecordedInput::set_allocated_mouse_motion(::CInputMouseMotionMsg* mouse_motion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (mouse_motion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputMouseMotionMsg>::GetOwningArena(mouse_motion);
    if (message_arena != submessage_arena) {
      mouse_motion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_motion, submessage_arena);
    }
    set_has_mouse_motion();
    data_.mouse_motion_ = mouse_motion;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.mouse_motion)
}
void CRecordedInput::set_allocated_mouse_wheel(::CInputMouseWheelMsg* mouse_wheel) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (mouse_wheel) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputMouseWheelMsg>::GetOwningArena(mouse_wheel);
    if (message_arena != submessage_arena) {
      mouse_wheel = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_wheel, submessage_arena);
    }
    set_has_mouse_wheel();
    data_.mouse_wheel_ = mouse_wheel;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.mouse_wheel)
}
void CRecordedInput::set_allocated_mouse_down(::CInputMouseDownMsg* mouse_down) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (mouse_down) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputMouseDownMsg>::GetOwningArena(mouse_down);
    if (message_arena != submessage_arena) {
      mouse_down = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_down, submessage_arena);
    }
    set_has_mouse_down();
    data_.mouse_down_ = mouse_down;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.mouse_down)
}
void CRecordedInput::set_allocated_mouse_up(::CInputMouseUpMsg* mouse_up) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (mouse_up) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputMouseUpMsg>::GetOwningArena(mouse_up);
    if (message_arena != submessage_arena) {
      mouse_up = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mouse_up, submessage_arena);
    }
    set_has_mouse_up();
    data_.mouse_up_ = mouse_up;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.mouse_up)
}
void CRecordedInput::set_allocated_key_down(::CInputKeyDownMsg* key_down) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (key_down) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputKeyDownMsg>::GetOwningArena(key_down);
    if (message_arena != submessage_arena) {
      key_down = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_down, submessage_arena);
    }
    set_has_key_down();
    data_.key_down_ = key_down;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.key_down)
}
void CRecordedInput::set_allocated_key_up(::CInputKeyUpMsg* key_up) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (key_up) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputKeyUpMsg>::GetOwningArena(key_up);
    if (message_arena != submessage_arena) {
      key_up = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key_up, submessage_arena);
    }
    set_has_key_up();
    data_.key_up_ = key_up;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.key_up)
}
void CRecordedInput::set_allocated_text(::CInputTextMsg* text) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (text) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CInputTextMsg>::GetOwningArena(text);
    if (message_arena != submessage_arena) {
      text = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, text, submessage_arena);
    }
    set_has_text();
    data_.text_ = text;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.text)
}
void CRecordedInput::set_allocated_hid(::CRemoteHIDMsg* hid) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_data();
  if (hid) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CRemoteHIDMsg>::GetOwningArena(hid);
    if (message_arena != submessage_arena) {
      hid = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, hid, submessage_arena);
    }
    set_has_hid();
    data_.hid_ = hid;
  }
  // @@protoc_insertion_point(field_set_allocated:CRecordedInput.hid)
}
CRecordedInput::CRecordedInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CRecordedInput)
}
CRecordedInput::CRecordedInput(const CRecordedInput& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&timestamp_, &from.timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&timestamp_)) + sizeof(type_));
  clear_has_data();
  switch (from.data_case()) {
    case kFingerDown: {
      _internal_mutable_finger_down()->::CInputTouchFingerDownMsg::MergeFrom(from._internal_finger_down());
      break;
    }
    case kFingerMotion: {
      _internal_mutable_finger_motion()->::CInputTouchFingerMotionMsg::MergeFrom(from._internal_finger_motion());
      break;
    }
    case kFingerUp: {
      _internal_mutable_finger_up()->::CInputTouchFingerUpMsg::MergeFrom(from._internal_finger_up());
      break;
    }
    case kMouseMotion: {
      _internal_mutable_mouse_motion()->::CInputMouseMotionMsg::MergeFrom(from._internal_mouse_motion());
      break;
    }
    case kMouseWheel: {
      _internal_mutable_mouse_wheel()->::CInputMouseWheelMsg::MergeFrom(from._internal_mouse_wheel());
      break;
    }
    case kMouseDown: {
      _internal_mutable_mouse_down()->::CInputMouseDownMsg::MergeFrom(from._internal_mouse_down());
      break;
    }
    case kMouseUp: {
      _internal_mutable_mouse_up()->::CInputMouseUpMsg::MergeFrom(from._internal_mouse_up());
      break;
    }
    case kKeyDown: {
      _internal_mutable_key_down()->::CInputKeyDownMsg::MergeFrom(from._internal_key_down());
      break;
    }
    case kKeyUp: {
      _internal_mutable_key_up()->::CInputKeyUpMsg::MergeFrom(from._internal_key_up());
      break;
    }
    case kText: {
      _internal_mutable_text()->::CInputTextMsg::MergeFrom(from._internal_text());
      break;
    }
    case kHid: {
      _internal_mutable_hid()->::CRemoteHIDMsg::MergeFrom(from._internal_hid());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CRecordedInput)
}

inline void CRecordedInput::SharedCtor() {
timestamp_ = 0u;
type_ = 1;
clear_has_data();
}

CRecordedInput::~CRecordedInput() {
  // @@protoc_insertion_point(destructor:CRecordedInput)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CRecordedInput::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_data()) {
    clear_data();
  }
}

void CRecordedInput::ArenaDtor(void* object) {
  CRecordedInput* _this = reinterpret_cast< CRecordedInput* >(object);
  (void)_this;
}
void CRecordedInput::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CRecordedInput::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CRecordedInput::clear_data() {
// @@protoc_insertion_point(one_of_clear_start:CRecordedInput)
  switch (data_case()) {
    case kFingerDown: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.finger_down_;
      }
      break;
    }
    case kFingerMotion: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.finger_motion_;
      }
      break;
    }
    case kFingerUp: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.finger_up_;
      }
      break;
    }
    case kMouseMotion: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.mouse_motion_;
      }
      break;
    }
    case kMouseWheel: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.mouse_wheel_;
      }
      break;
    }
    case kMouseDown: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.mouse_down_;
      }
      break;
    }
    case kMouseUp: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.mouse_up_;
      }
      break;
    }
    case kKeyDown: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.key_down_;
      }
      break;
    }
    case kKeyUp: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.key_up_;
      }
      break;
    }
    case kText: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.text_;
      }
      break;
    }
    case kHid: {
      if (GetArenaForAllocation() == nullptr) {
        delete data_.hid_;
      }
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = DATA_NOT_SET;
}


void CRecordedInput::Clear() {
// @@protoc_insertion_point(message_clear_start:CRecordedInput)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    timestamp_ = 0u;
    type_ = 1;
  }
  clear_data();
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CRecordedInput::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EStreamControlMessage type = 1 [default = k_EStreamControlAuthenticationRequest];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamControlMessage_IsValid(val))) {
            _internal_set_type(static_cast<::EStreamControlMessage>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputTouchFingerDownMsg finger_down = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_finger_down(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputTouchFingerMotionMsg finger_motion = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_finger_motion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputTouchFingerUpMsg finger_up = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_finger_up(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputMouseMotionMsg mouse_motion = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_mouse_motion(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputMouseWheelMsg mouse_wheel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_mouse_wheel(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputMouseDownMsg mouse_down = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_mouse_down(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputMouseUpMsg mouse_up = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_mouse_up(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputKeyDownMsg key_down = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_down(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputKeyUpMsg key_up = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_key_up(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CInputTextMsg text = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_text(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CRemoteHIDMsg hid = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          ptr = ctx->ParseMessage(_internal_mutable_hid(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CRecordedInput::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CRecordedInput)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EStreamControlMessage type = 1 [default = k_EStreamControlAuthenticationRequest];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional uint32 timestamp = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp(), target);
  }

  switch (data_case()) {
    case kFingerDown: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          3, _Internal::finger_down(this), target, stream);
      break;
    }
    case kFingerMotion: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::finger_motion(this), target, stream);
      break;
    }
    case kFingerUp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          5, _Internal::finger_up(this), target, stream);
      break;
    }
    case kMouseMotion: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          6, _Internal::mouse_motion(this), target, stream);
      break;
    }
    case kMouseWheel: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          7, _Internal::mouse_wheel(this), target, stream);
      break;
    }
    case kMouseDown: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          8, _Internal::mouse_down(this), target, stream);
      break;
    }
    case kMouseUp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          9, _Internal::mouse_up(this), target, stream);
      break;
    }
    case kKeyDown: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          10, _Internal::key_down(this), target, stream);
      break;
    }
    case kKeyUp: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          11, _Internal::key_up(this), target, stream);
      break;
    }
    case kText: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          12, _Internal::text(this), target, stream);
      break;
    }
    case kHid: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          13, _Internal::hid(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CRecordedInput)
  return target;
}

size_t CRecordedInput::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CRecordedInput)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 timestamp = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
    }

    // optional .EStreamControlMessage type = 1 [default = k_EStreamControlAuthenticationRequest];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  switch (data_case()) {
    // .CInputTouchFingerDownMsg finger_down = 3;
    case kFingerDown: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.finger_down_);
      break;
    }
    // .CInputTouchFingerMotionMsg finger_motion = 4;
    case kFingerMotion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.finger_motion_);
      break;
    }
    // .CInputTouchFingerUpMsg finger_up = 5;
    case kFingerUp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.finger_up_);
      break;
    }
    // .CInputMouseMotionMsg mouse_motion = 6;
    case kMouseMotion: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.mouse_motion_);
      break;
    }
    // .CInputMouseWheelMsg mouse_wheel = 7;
    case kMouseWheel: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.mouse_wheel_);
      break;
    }
    // .CInputMouseDownMsg mouse_down = 8;
    case kMouseDown: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.mouse_down_);
      break;
    }
    // .CInputMouseUpMsg mouse_up = 9;
    case kMouseUp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.mouse_up_);
      break;
    }
    // .CInputKeyDownMsg key_down = 10;
    case kKeyDown: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.key_down_);
      break;
    }
    // .CInputKeyUpMsg key_up = 11;
    case kKeyUp: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.key_up_);
      break;
    }
    // .CInputTextMsg text = 12;
    case kText: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.text_);
      break;
    }
    // .CRemoteHIDMsg hid = 13;
    case kHid: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *data_.hid_);
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CRecordedInput::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CRecordedInput::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CRecordedInput::GetClassData() const { return &_class_data_; }

void CRecordedInput::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CRecordedInput *>(to)->MergeFrom(
      static_cast<const CRecordedInput &>(from));
}


void CRecordedInput::MergeFrom(const CRecordedInput& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CRecordedInput)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      timestamp_ = from.timestamp_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  switch (from.data_case()) {
    case kFingerDown: {
      _internal_mutable_finger_down()->::CInputTouchFingerDownMsg::MergeFrom(from._internal_finger_down());
      break;
    }
    case kFingerMotion: {
      _internal_mutable_finger_motion()->::CInputTouchFingerMotionMsg::MergeFrom(from._internal_finger_motion());
      break;
    }
    case kFingerUp: {
      _internal_mutable_finger_up()->::CInputTouchFingerUpMsg::MergeFrom(from._internal_finger_up());
      break;
    }
    case kMouseMotion: {
      _internal_mutable_mouse_motion()->::CInputMouseMotionMsg::MergeFrom(from._internal_mouse_motion());
      break;
    }
    case kMouseWheel: {
      _internal_mutable_mouse_wheel()->::CInputMouseWheelMsg::MergeFrom(from._internal_mouse_wheel());
      break;
    }
    case kMouseDown: {
      _internal_mutable_mouse_down()->::CInputMouseDownMsg::MergeFrom(from._internal_mouse_down());
      break;
    }
    case kMouseUp: {
      _internal_mutable_mouse_up()->::CInputMouseUpMsg::MergeFrom(from._internal_mouse_up());
      break;
    }
    case kKeyDown: {
      _internal_mutable_key_down()->::CInputKeyDownMsg::MergeFrom(from._internal_key_down());
      break;
    }
    case kKeyUp: {
      _internal_mutable_key_up()->::CInputKeyUpMsg::MergeFrom(from._internal_key_up());
      break;
    }
    case kText: {
      _internal_mutable_text()->::CInputTextMsg::MergeFrom(from._internal_text());
      break;
    }
    case kHid: {
      _internal_mutable_hid()->::CRemoteHIDMsg::MergeFrom(from._internal_hid());
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CRecordedInput::CopyFrom(const CRecordedInput& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CRecordedInput)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CRecordedInput::IsInitialized() const {
  switch (data_case()) {
    case kFingerDown: {
      break;
    }
    case kFingerMotion: {
      break;
    }
    case kFingerUp: {
      break;
    }
    case kMouseMotion: {
      break;
    }
    case kMouseWheel: {
      if (_internal_has_mouse_wheel()) {
        if (!data_.mouse_wheel_->IsInitialized()) return false;
      }
      break;
    }
    case kMouseDown: {
      if (_internal_has_mouse_down()) {
        if (!data_.mouse_down_->IsInitialized()) return false;
      }
      break;
    }
    case kMouseUp: {
      if (_internal_has_mouse_up()) {
        if (!data_.mouse_up_->IsInitialized()) return false;
      }
      break;
    }
    case kKeyDown: {
      if (_internal_has_key_down()) {
        if (!data_.key_down_->IsInitialized()) return false;
      }
      break;
    }
    case kKeyUp: {
      if (_internal_has_key_up()) {
        if (!data_.key_up_->IsInitialized()) return false;
      }
      break;
    }
    case kText: {
      if (_internal_has_text()) {
        if (!data_.text_->IsInitialized()) return false;
      }
      break;
    }
    case kHid: {
      break;
    }
    case DATA_NOT_SET: {
      break;
    }
  }
  return true;
}

void CRecordedInput::InternalSwap(CRecordedInput* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(timestamp_, other->timestamp_);
  swap(type_, other->type_);
  swap(data_, other->data_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CRecordedInput::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[24]);
}

// ===================================================================

class CRecordedInputStream::_Internal {
 public:
};

CRecordedInputStream::CRecordedInputStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CRecordedInputStream)
}
CRecordedInputStream::CRecordedInputStream(const CRecordedInputStream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CRecordedInputStream)
}

inline void CRecordedInputStream::SharedCtor() {
}

CRecordedInputStream::~CRecordedInputStream() {
  // @@protoc_insertion_point(destructor:CRecordedInputStream)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CRecordedInputStream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CRecordedInputStream::ArenaDtor(void* object) {
  CRecordedInputStream* _this = reinterpret_cast< CRecordedInputStream* >(object);
  (void)_this;
}
void CRecordedInputStream::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CRecordedInputStream::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CRecordedInputStream::Clear() {
// @@protoc_insertion_point(message_clear_start:CRecordedInputStream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CRecordedInputStream::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CRecordedInput entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CRecordedInputStream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CRecordedInputStream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CRecordedInput entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CRecordedInputStream)
  return target;
}

size_t CRecordedInputStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CRecordedInputStream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CRecordedInput entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CRecordedInputStream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CRecordedInputStream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CRecordedInputStream::GetClassData() const { return &_class_data_; }

void CRecordedInputStream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CRecordedInputStream *>(to)->MergeFrom(
      static_cast<const CRecordedInputStream &>(from));
}


void CRecordedInputStream::MergeFrom(const CRecordedInputStream& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CRecordedInputStream)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CRecordedInputStream::CopyFrom(const CRecordedInputStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CRecordedInputStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CRecordedInputStream::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(entries_))
    return false;
  return true;
}

void CRecordedInputStream::InternalSwap(CRecordedInputStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CRecordedInputStream::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[25]);
}

// ===================================================================

class CInputLatencyTestMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputLatencyTestMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CInputLatencyTestMsg::CInputLatencyTestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputLatencyTestMsg)
}
CInputLatencyTestMsg::CInputLatencyTestMsg(const CInputLatencyTestMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&color_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(color_));
  // @@protoc_insertion_point(copy_constructor:CInputLatencyTestMsg)
}

inline void CInputLatencyTestMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&input_mark_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&color_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(color_));
}

CInputLatencyTestMsg::~CInputLatencyTestMsg() {
  // @@protoc_insertion_point(destructor:CInputLatencyTestMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputLatencyTestMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputLatencyTestMsg::ArenaDtor(void* object) {
  CInputLatencyTestMsg* _this = reinterpret_cast< CInputLatencyTestMsg* >(object);
  (void)_this;
}
void CInputLatencyTestMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputLatencyTestMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputLatencyTestMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputLatencyTestMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&input_mark_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&color_) -
        reinterpret_cast<char*>(&input_mark_)) + sizeof(color_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputLatencyTestMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 color = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_color(&has_bits);
          color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputLatencyTestMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputLatencyTestMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // optional uint32 color = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_color(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputLatencyTestMsg)
  return target;
}

size_t CInputLatencyTestMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputLatencyTestMsg)
  size_t total_size = 0;

  // required uint32 input_mark = 1;
  if (_internal_has_input_mark()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 color = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_color());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputLatencyTestMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputLatencyTestMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputLatencyTestMsg::GetClassData() const { return &_class_data_; }

void CInputLatencyTestMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputLatencyTestMsg *>(to)->MergeFrom(
      static_cast<const CInputLatencyTestMsg &>(from));
}


void CInputLatencyTestMsg::MergeFrom(const CInputLatencyTestMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputLatencyTestMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      color_ = from.color_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputLatencyTestMsg::CopyFrom(const CInputLatencyTestMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputLatencyTestMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputLatencyTestMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputLatencyTestMsg::InternalSwap(CInputLatencyTestMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputLatencyTestMsg, color_)
      + sizeof(CInputLatencyTestMsg::color_)
      - PROTOBUF_FIELD_OFFSET(CInputLatencyTestMsg, input_mark_)>(
          reinterpret_cast<char*>(&input_mark_),
          reinterpret_cast<char*>(&other->input_mark_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputLatencyTestMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[26]);
}

// ===================================================================

class CInputTouchFingerDownMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputTouchFingerDownMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fingerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CInputTouchFingerDownMsg::CInputTouchFingerDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputTouchFingerDownMsg)
}
CInputTouchFingerDownMsg::CInputTouchFingerDownMsg(const CInputTouchFingerDownMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&fingerid_, &from.fingerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  // @@protoc_insertion_point(copy_constructor:CInputTouchFingerDownMsg)
}

inline void CInputTouchFingerDownMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fingerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
}

CInputTouchFingerDownMsg::~CInputTouchFingerDownMsg() {
  // @@protoc_insertion_point(destructor:CInputTouchFingerDownMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputTouchFingerDownMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputTouchFingerDownMsg::ArenaDtor(void* object) {
  CInputTouchFingerDownMsg* _this = reinterpret_cast< CInputTouchFingerDownMsg* >(object);
  (void)_this;
}
void CInputTouchFingerDownMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputTouchFingerDownMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputTouchFingerDownMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputTouchFingerDownMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&fingerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_normalized_) -
        reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputTouchFingerDownMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fingerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fingerid(&has_bits);
          fingerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x_normalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_x_normalized(&has_bits);
          x_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_normalized = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_y_normalized(&has_bits);
          y_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputTouchFingerDownMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputTouchFingerDownMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // optional uint64 fingerid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fingerid(), target);
  }

  // optional float x_normalized = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_x_normalized(), target);
  }

  // optional float y_normalized = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_y_normalized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputTouchFingerDownMsg)
  return target;
}

size_t CInputTouchFingerDownMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputTouchFingerDownMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 fingerid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fingerid());
    }

    // optional uint32 input_mark = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
    }

    // optional float x_normalized = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float y_normalized = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputTouchFingerDownMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputTouchFingerDownMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputTouchFingerDownMsg::GetClassData() const { return &_class_data_; }

void CInputTouchFingerDownMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputTouchFingerDownMsg *>(to)->MergeFrom(
      static_cast<const CInputTouchFingerDownMsg &>(from));
}


void CInputTouchFingerDownMsg::MergeFrom(const CInputTouchFingerDownMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputTouchFingerDownMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      fingerid_ = from.fingerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000004u) {
      x_normalized_ = from.x_normalized_;
    }
    if (cached_has_bits & 0x00000008u) {
      y_normalized_ = from.y_normalized_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputTouchFingerDownMsg::CopyFrom(const CInputTouchFingerDownMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputTouchFingerDownMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputTouchFingerDownMsg::IsInitialized() const {
  return true;
}

void CInputTouchFingerDownMsg::InternalSwap(CInputTouchFingerDownMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputTouchFingerDownMsg, y_normalized_)
      + sizeof(CInputTouchFingerDownMsg::y_normalized_)
      - PROTOBUF_FIELD_OFFSET(CInputTouchFingerDownMsg, fingerid_)>(
          reinterpret_cast<char*>(&fingerid_),
          reinterpret_cast<char*>(&other->fingerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputTouchFingerDownMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[27]);
}

// ===================================================================

class CInputTouchFingerMotionMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputTouchFingerMotionMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fingerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CInputTouchFingerMotionMsg::CInputTouchFingerMotionMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputTouchFingerMotionMsg)
}
CInputTouchFingerMotionMsg::CInputTouchFingerMotionMsg(const CInputTouchFingerMotionMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&fingerid_, &from.fingerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  // @@protoc_insertion_point(copy_constructor:CInputTouchFingerMotionMsg)
}

inline void CInputTouchFingerMotionMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fingerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
}

CInputTouchFingerMotionMsg::~CInputTouchFingerMotionMsg() {
  // @@protoc_insertion_point(destructor:CInputTouchFingerMotionMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputTouchFingerMotionMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputTouchFingerMotionMsg::ArenaDtor(void* object) {
  CInputTouchFingerMotionMsg* _this = reinterpret_cast< CInputTouchFingerMotionMsg* >(object);
  (void)_this;
}
void CInputTouchFingerMotionMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputTouchFingerMotionMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputTouchFingerMotionMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputTouchFingerMotionMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&fingerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_normalized_) -
        reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputTouchFingerMotionMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fingerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fingerid(&has_bits);
          fingerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x_normalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_x_normalized(&has_bits);
          x_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_normalized = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_y_normalized(&has_bits);
          y_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputTouchFingerMotionMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputTouchFingerMotionMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // optional uint64 fingerid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fingerid(), target);
  }

  // optional float x_normalized = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_x_normalized(), target);
  }

  // optional float y_normalized = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_y_normalized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputTouchFingerMotionMsg)
  return target;
}

size_t CInputTouchFingerMotionMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputTouchFingerMotionMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 fingerid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fingerid());
    }

    // optional uint32 input_mark = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
    }

    // optional float x_normalized = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float y_normalized = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputTouchFingerMotionMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputTouchFingerMotionMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputTouchFingerMotionMsg::GetClassData() const { return &_class_data_; }

void CInputTouchFingerMotionMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputTouchFingerMotionMsg *>(to)->MergeFrom(
      static_cast<const CInputTouchFingerMotionMsg &>(from));
}


void CInputTouchFingerMotionMsg::MergeFrom(const CInputTouchFingerMotionMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputTouchFingerMotionMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      fingerid_ = from.fingerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000004u) {
      x_normalized_ = from.x_normalized_;
    }
    if (cached_has_bits & 0x00000008u) {
      y_normalized_ = from.y_normalized_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputTouchFingerMotionMsg::CopyFrom(const CInputTouchFingerMotionMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputTouchFingerMotionMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputTouchFingerMotionMsg::IsInitialized() const {
  return true;
}

void CInputTouchFingerMotionMsg::InternalSwap(CInputTouchFingerMotionMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputTouchFingerMotionMsg, y_normalized_)
      + sizeof(CInputTouchFingerMotionMsg::y_normalized_)
      - PROTOBUF_FIELD_OFFSET(CInputTouchFingerMotionMsg, fingerid_)>(
          reinterpret_cast<char*>(&fingerid_),
          reinterpret_cast<char*>(&other->fingerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputTouchFingerMotionMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[28]);
}

// ===================================================================

class CInputTouchFingerUpMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputTouchFingerUpMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_fingerid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_y_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CInputTouchFingerUpMsg::CInputTouchFingerUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputTouchFingerUpMsg)
}
CInputTouchFingerUpMsg::CInputTouchFingerUpMsg(const CInputTouchFingerUpMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&fingerid_, &from.fingerid_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  // @@protoc_insertion_point(copy_constructor:CInputTouchFingerUpMsg)
}

inline void CInputTouchFingerUpMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&fingerid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
}

CInputTouchFingerUpMsg::~CInputTouchFingerUpMsg() {
  // @@protoc_insertion_point(destructor:CInputTouchFingerUpMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputTouchFingerUpMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputTouchFingerUpMsg::ArenaDtor(void* object) {
  CInputTouchFingerUpMsg* _this = reinterpret_cast< CInputTouchFingerUpMsg* >(object);
  (void)_this;
}
void CInputTouchFingerUpMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputTouchFingerUpMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputTouchFingerUpMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputTouchFingerUpMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&fingerid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_normalized_) -
        reinterpret_cast<char*>(&fingerid_)) + sizeof(y_normalized_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputTouchFingerUpMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 fingerid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_fingerid(&has_bits);
          fingerid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x_normalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_x_normalized(&has_bits);
          x_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_normalized = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_y_normalized(&has_bits);
          y_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputTouchFingerUpMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputTouchFingerUpMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // optional uint64 fingerid = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_fingerid(), target);
  }

  // optional float x_normalized = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_x_normalized(), target);
  }

  // optional float y_normalized = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_y_normalized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputTouchFingerUpMsg)
  return target;
}

size_t CInputTouchFingerUpMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputTouchFingerUpMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint64 fingerid = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_fingerid());
    }

    // optional uint32 input_mark = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
    }

    // optional float x_normalized = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float y_normalized = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputTouchFingerUpMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputTouchFingerUpMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputTouchFingerUpMsg::GetClassData() const { return &_class_data_; }

void CInputTouchFingerUpMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputTouchFingerUpMsg *>(to)->MergeFrom(
      static_cast<const CInputTouchFingerUpMsg &>(from));
}


void CInputTouchFingerUpMsg::MergeFrom(const CInputTouchFingerUpMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputTouchFingerUpMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      fingerid_ = from.fingerid_;
    }
    if (cached_has_bits & 0x00000002u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000004u) {
      x_normalized_ = from.x_normalized_;
    }
    if (cached_has_bits & 0x00000008u) {
      y_normalized_ = from.y_normalized_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputTouchFingerUpMsg::CopyFrom(const CInputTouchFingerUpMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputTouchFingerUpMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputTouchFingerUpMsg::IsInitialized() const {
  return true;
}

void CInputTouchFingerUpMsg::InternalSwap(CInputTouchFingerUpMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputTouchFingerUpMsg, y_normalized_)
      + sizeof(CInputTouchFingerUpMsg::y_normalized_)
      - PROTOBUF_FIELD_OFFSET(CInputTouchFingerUpMsg, fingerid_)>(
          reinterpret_cast<char*>(&fingerid_),
          reinterpret_cast<char*>(&other->fingerid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputTouchFingerUpMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[29]);
}

// ===================================================================

class CInputMouseMotionMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputMouseMotionMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_x_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_y_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_dx(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_dy(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CInputMouseMotionMsg::CInputMouseMotionMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputMouseMotionMsg)
}
CInputMouseMotionMsg::CInputMouseMotionMsg(const CInputMouseMotionMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&dy_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(dy_));
  // @@protoc_insertion_point(copy_constructor:CInputMouseMotionMsg)
}

inline void CInputMouseMotionMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&input_mark_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&dy_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(dy_));
}

CInputMouseMotionMsg::~CInputMouseMotionMsg() {
  // @@protoc_insertion_point(destructor:CInputMouseMotionMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputMouseMotionMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputMouseMotionMsg::ArenaDtor(void* object) {
  CInputMouseMotionMsg* _this = reinterpret_cast< CInputMouseMotionMsg* >(object);
  (void)_this;
}
void CInputMouseMotionMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputMouseMotionMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputMouseMotionMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputMouseMotionMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&input_mark_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&dy_) -
        reinterpret_cast<char*>(&input_mark_)) + sizeof(dy_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputMouseMotionMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float x_normalized = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_x_normalized(&has_bits);
          x_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_normalized = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_y_normalized(&has_bits);
          y_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dx = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_dx(&has_bits);
          dx_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dy = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_dy(&has_bits);
          dy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputMouseMotionMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputMouseMotionMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // optional float x_normalized = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_x_normalized(), target);
  }

  // optional float y_normalized = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_y_normalized(), target);
  }

  // optional int32 dx = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_dx(), target);
  }

  // optional int32 dy = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_dy(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputMouseMotionMsg)
  return target;
}

size_t CInputMouseMotionMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputMouseMotionMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 input_mark = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
    }

    // optional float x_normalized = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float y_normalized = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional int32 dx = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dx());
    }

    // optional int32 dy = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_dy());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputMouseMotionMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputMouseMotionMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputMouseMotionMsg::GetClassData() const { return &_class_data_; }

void CInputMouseMotionMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputMouseMotionMsg *>(to)->MergeFrom(
      static_cast<const CInputMouseMotionMsg &>(from));
}


void CInputMouseMotionMsg::MergeFrom(const CInputMouseMotionMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputMouseMotionMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      x_normalized_ = from.x_normalized_;
    }
    if (cached_has_bits & 0x00000004u) {
      y_normalized_ = from.y_normalized_;
    }
    if (cached_has_bits & 0x00000008u) {
      dx_ = from.dx_;
    }
    if (cached_has_bits & 0x00000010u) {
      dy_ = from.dy_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputMouseMotionMsg::CopyFrom(const CInputMouseMotionMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputMouseMotionMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputMouseMotionMsg::IsInitialized() const {
  return true;
}

void CInputMouseMotionMsg::InternalSwap(CInputMouseMotionMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputMouseMotionMsg, dy_)
      + sizeof(CInputMouseMotionMsg::dy_)
      - PROTOBUF_FIELD_OFFSET(CInputMouseMotionMsg, input_mark_)>(
          reinterpret_cast<char*>(&input_mark_),
          reinterpret_cast<char*>(&other->input_mark_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputMouseMotionMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[30]);
}

// ===================================================================

class CInputMouseWheelMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputMouseWheelMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CInputMouseWheelMsg::CInputMouseWheelMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputMouseWheelMsg)
}
CInputMouseWheelMsg::CInputMouseWheelMsg(const CInputMouseWheelMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&direction_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(direction_));
  // @@protoc_insertion_point(copy_constructor:CInputMouseWheelMsg)
}

inline void CInputMouseWheelMsg::SharedCtor() {
input_mark_ = 0u;
direction_ = 120;
}

CInputMouseWheelMsg::~CInputMouseWheelMsg() {
  // @@protoc_insertion_point(destructor:CInputMouseWheelMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputMouseWheelMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputMouseWheelMsg::ArenaDtor(void* object) {
  CInputMouseWheelMsg* _this = reinterpret_cast< CInputMouseWheelMsg* >(object);
  (void)_this;
}
void CInputMouseWheelMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputMouseWheelMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputMouseWheelMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputMouseWheelMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    input_mark_ = 0u;
    direction_ = 120;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputMouseWheelMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamMouseWheelDirection_IsValid(val))) {
            _internal_set_direction(static_cast<::EStreamMouseWheelDirection>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputMouseWheelMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputMouseWheelMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_direction(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputMouseWheelMsg)
  return target;
}

size_t CInputMouseWheelMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputMouseWheelMsg)
  size_t total_size = 0;

  // required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
  if (_internal_has_direction()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_direction());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputMouseWheelMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputMouseWheelMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputMouseWheelMsg::GetClassData() const { return &_class_data_; }

void CInputMouseWheelMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputMouseWheelMsg *>(to)->MergeFrom(
      static_cast<const CInputMouseWheelMsg &>(from));
}


void CInputMouseWheelMsg::MergeFrom(const CInputMouseWheelMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputMouseWheelMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      direction_ = from.direction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputMouseWheelMsg::CopyFrom(const CInputMouseWheelMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputMouseWheelMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputMouseWheelMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputMouseWheelMsg::InternalSwap(CInputMouseWheelMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(input_mark_, other->input_mark_);
  swap(direction_, other->direction_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputMouseWheelMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[31]);
}

// ===================================================================

class CInputMouseDownMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputMouseDownMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_button(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CInputMouseDownMsg::CInputMouseDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputMouseDownMsg)
}
CInputMouseDownMsg::CInputMouseDownMsg(const CInputMouseDownMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&button_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(button_));
  // @@protoc_insertion_point(copy_constructor:CInputMouseDownMsg)
}

inline void CInputMouseDownMsg::SharedCtor() {
input_mark_ = 0u;
button_ = 1;
}

CInputMouseDownMsg::~CInputMouseDownMsg() {
  // @@protoc_insertion_point(destructor:CInputMouseDownMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputMouseDownMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputMouseDownMsg::ArenaDtor(void* object) {
  CInputMouseDownMsg* _this = reinterpret_cast< CInputMouseDownMsg* >(object);
  (void)_this;
}
void CInputMouseDownMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputMouseDownMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputMouseDownMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputMouseDownMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    input_mark_ = 0u;
    button_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputMouseDownMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamMouseButton_IsValid(val))) {
            _internal_set_button(static_cast<::EStreamMouseButton>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputMouseDownMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputMouseDownMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_button(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputMouseDownMsg)
  return target;
}

size_t CInputMouseDownMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputMouseDownMsg)
  size_t total_size = 0;

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  if (_internal_has_button()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_button());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputMouseDownMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputMouseDownMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputMouseDownMsg::GetClassData() const { return &_class_data_; }

void CInputMouseDownMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputMouseDownMsg *>(to)->MergeFrom(
      static_cast<const CInputMouseDownMsg &>(from));
}


void CInputMouseDownMsg::MergeFrom(const CInputMouseDownMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputMouseDownMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      button_ = from.button_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputMouseDownMsg::CopyFrom(const CInputMouseDownMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputMouseDownMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputMouseDownMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputMouseDownMsg::InternalSwap(CInputMouseDownMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(input_mark_, other->input_mark_);
  swap(button_, other->button_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputMouseDownMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[32]);
}

// ===================================================================

class CInputMouseUpMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputMouseUpMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_button(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CInputMouseUpMsg::CInputMouseUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputMouseUpMsg)
}
CInputMouseUpMsg::CInputMouseUpMsg(const CInputMouseUpMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&button_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(button_));
  // @@protoc_insertion_point(copy_constructor:CInputMouseUpMsg)
}

inline void CInputMouseUpMsg::SharedCtor() {
input_mark_ = 0u;
button_ = 1;
}

CInputMouseUpMsg::~CInputMouseUpMsg() {
  // @@protoc_insertion_point(destructor:CInputMouseUpMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputMouseUpMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputMouseUpMsg::ArenaDtor(void* object) {
  CInputMouseUpMsg* _this = reinterpret_cast< CInputMouseUpMsg* >(object);
  (void)_this;
}
void CInputMouseUpMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputMouseUpMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputMouseUpMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputMouseUpMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    input_mark_ = 0u;
    button_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputMouseUpMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamMouseButton_IsValid(val))) {
            _internal_set_button(static_cast<::EStreamMouseButton>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputMouseUpMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputMouseUpMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_button(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputMouseUpMsg)
  return target;
}

size_t CInputMouseUpMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputMouseUpMsg)
  size_t total_size = 0;

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  if (_internal_has_button()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_button());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputMouseUpMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputMouseUpMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputMouseUpMsg::GetClassData() const { return &_class_data_; }

void CInputMouseUpMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputMouseUpMsg *>(to)->MergeFrom(
      static_cast<const CInputMouseUpMsg &>(from));
}


void CInputMouseUpMsg::MergeFrom(const CInputMouseUpMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputMouseUpMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      button_ = from.button_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputMouseUpMsg::CopyFrom(const CInputMouseUpMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputMouseUpMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputMouseUpMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputMouseUpMsg::InternalSwap(CInputMouseUpMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(input_mark_, other->input_mark_);
  swap(button_, other->button_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputMouseUpMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[33]);
}

// ===================================================================

class CInputKeyDownMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputKeyDownMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scancode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CInputKeyDownMsg::CInputKeyDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputKeyDownMsg)
}
CInputKeyDownMsg::CInputKeyDownMsg(const CInputKeyDownMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&scancode_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
  // @@protoc_insertion_point(copy_constructor:CInputKeyDownMsg)
}

inline void CInputKeyDownMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&input_mark_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scancode_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
}

CInputKeyDownMsg::~CInputKeyDownMsg() {
  // @@protoc_insertion_point(destructor:CInputKeyDownMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputKeyDownMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputKeyDownMsg::ArenaDtor(void* object) {
  CInputKeyDownMsg* _this = reinterpret_cast< CInputKeyDownMsg* >(object);
  (void)_this;
}
void CInputKeyDownMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputKeyDownMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputKeyDownMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputKeyDownMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&input_mark_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scancode_) -
        reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputKeyDownMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 scancode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_scancode(&has_bits);
          scancode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputKeyDownMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputKeyDownMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required uint32 scancode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_scancode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputKeyDownMsg)
  return target;
}

size_t CInputKeyDownMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputKeyDownMsg)
  size_t total_size = 0;

  // required uint32 scancode = 2;
  if (_internal_has_scancode()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_scancode());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputKeyDownMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputKeyDownMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputKeyDownMsg::GetClassData() const { return &_class_data_; }

void CInputKeyDownMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputKeyDownMsg *>(to)->MergeFrom(
      static_cast<const CInputKeyDownMsg &>(from));
}


void CInputKeyDownMsg::MergeFrom(const CInputKeyDownMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputKeyDownMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      scancode_ = from.scancode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputKeyDownMsg::CopyFrom(const CInputKeyDownMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputKeyDownMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputKeyDownMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputKeyDownMsg::InternalSwap(CInputKeyDownMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputKeyDownMsg, scancode_)
      + sizeof(CInputKeyDownMsg::scancode_)
      - PROTOBUF_FIELD_OFFSET(CInputKeyDownMsg, input_mark_)>(
          reinterpret_cast<char*>(&input_mark_),
          reinterpret_cast<char*>(&other->input_mark_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputKeyDownMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[34]);
}

// ===================================================================

class CInputKeyUpMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputKeyUpMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scancode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CInputKeyUpMsg::CInputKeyUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputKeyUpMsg)
}
CInputKeyUpMsg::CInputKeyUpMsg(const CInputKeyUpMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&input_mark_, &from.input_mark_,
    static_cast<size_t>(reinterpret_cast<char*>(&scancode_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
  // @@protoc_insertion_point(copy_constructor:CInputKeyUpMsg)
}

inline void CInputKeyUpMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&input_mark_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&scancode_) -
    reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
}

CInputKeyUpMsg::~CInputKeyUpMsg() {
  // @@protoc_insertion_point(destructor:CInputKeyUpMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputKeyUpMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CInputKeyUpMsg::ArenaDtor(void* object) {
  CInputKeyUpMsg* _this = reinterpret_cast< CInputKeyUpMsg* >(object);
  (void)_this;
}
void CInputKeyUpMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputKeyUpMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputKeyUpMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputKeyUpMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&input_mark_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&scancode_) -
        reinterpret_cast<char*>(&input_mark_)) + sizeof(scancode_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputKeyUpMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required uint32 scancode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_scancode(&has_bits);
          scancode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputKeyUpMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputKeyUpMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required uint32 scancode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_scancode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputKeyUpMsg)
  return target;
}

size_t CInputKeyUpMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputKeyUpMsg)
  size_t total_size = 0;

  // required uint32 scancode = 2;
  if (_internal_has_scancode()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_scancode());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputKeyUpMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputKeyUpMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputKeyUpMsg::GetClassData() const { return &_class_data_; }

void CInputKeyUpMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputKeyUpMsg *>(to)->MergeFrom(
      static_cast<const CInputKeyUpMsg &>(from));
}


void CInputKeyUpMsg::MergeFrom(const CInputKeyUpMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputKeyUpMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000002u) {
      scancode_ = from.scancode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputKeyUpMsg::CopyFrom(const CInputKeyUpMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputKeyUpMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputKeyUpMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputKeyUpMsg::InternalSwap(CInputKeyUpMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CInputKeyUpMsg, scancode_)
      + sizeof(CInputKeyUpMsg::scancode_)
      - PROTOBUF_FIELD_OFFSET(CInputKeyUpMsg, input_mark_)>(
          reinterpret_cast<char*>(&input_mark_),
          reinterpret_cast<char*>(&other->input_mark_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputKeyUpMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[35]);
}

// ===================================================================

class CInputTextMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CInputTextMsg>()._has_bits_);
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_text_utf8(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CInputTextMsg::CInputTextMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CInputTextMsg)
}
CInputTextMsg::CInputTextMsg(const CInputTextMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  text_utf8_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_utf8_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text_utf8()) {
    text_utf8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_text_utf8(), 
      GetArenaForAllocation());
  }
  input_mark_ = from.input_mark_;
  // @@protoc_insertion_point(copy_constructor:CInputTextMsg)
}

inline void CInputTextMsg::SharedCtor() {
text_utf8_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_utf8_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
input_mark_ = 0u;
}

CInputTextMsg::~CInputTextMsg() {
  // @@protoc_insertion_point(destructor:CInputTextMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CInputTextMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_utf8_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CInputTextMsg::ArenaDtor(void* object) {
  CInputTextMsg* _this = reinterpret_cast< CInputTextMsg* >(object);
  (void)_this;
}
void CInputTextMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CInputTextMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CInputTextMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CInputTextMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_utf8_.ClearNonDefaultToEmpty();
  }
  input_mark_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CInputTextMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 input_mark = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required string text_utf8 = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_text_utf8();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CInputTextMsg.text_utf8");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CInputTextMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CInputTextMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 input_mark = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_input_mark(), target);
  }

  // required string text_utf8 = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text_utf8().data(), static_cast<int>(this->_internal_text_utf8().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CInputTextMsg.text_utf8");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_text_utf8(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CInputTextMsg)
  return target;
}

size_t CInputTextMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CInputTextMsg)
  size_t total_size = 0;

  // required string text_utf8 = 2;
  if (_internal_has_text_utf8()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text_utf8());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 input_mark = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CInputTextMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CInputTextMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CInputTextMsg::GetClassData() const { return &_class_data_; }

void CInputTextMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CInputTextMsg *>(to)->MergeFrom(
      static_cast<const CInputTextMsg &>(from));
}


void CInputTextMsg::MergeFrom(const CInputTextMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CInputTextMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_text_utf8(from._internal_text_utf8());
    }
    if (cached_has_bits & 0x00000002u) {
      input_mark_ = from.input_mark_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CInputTextMsg::CopyFrom(const CInputTextMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CInputTextMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CInputTextMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CInputTextMsg::InternalSwap(CInputTextMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &text_utf8_, lhs_arena,
      &other->text_utf8_, rhs_arena
  );
  swap(input_mark_, other->input_mark_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CInputTextMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[36]);
}

// ===================================================================

class CSetTitleMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetTitleMsg>()._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetTitleMsg::CSetTitleMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetTitleMsg)
}
CSetTitleMsg::CSetTitleMsg(const CSetTitleMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_text(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSetTitleMsg)
}

inline void CSetTitleMsg::SharedCtor() {
text_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSetTitleMsg::~CSetTitleMsg() {
  // @@protoc_insertion_point(destructor:CSetTitleMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetTitleMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  text_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetTitleMsg::ArenaDtor(void* object) {
  CSetTitleMsg* _this = reinterpret_cast< CSetTitleMsg* >(object);
  (void)_this;
}
void CSetTitleMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetTitleMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetTitleMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetTitleMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    text_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetTitleMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSetTitleMsg.text");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetTitleMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetTitleMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSetTitleMsg.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetTitleMsg)
  return target;
}

size_t CSetTitleMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetTitleMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetTitleMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetTitleMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetTitleMsg::GetClassData() const { return &_class_data_; }

void CSetTitleMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetTitleMsg *>(to)->MergeFrom(
      static_cast<const CSetTitleMsg &>(from));
}


void CSetTitleMsg::MergeFrom(const CSetTitleMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetTitleMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text()) {
    _internal_set_text(from._internal_text());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetTitleMsg::CopyFrom(const CSetTitleMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetTitleMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetTitleMsg::IsInitialized() const {
  return true;
}

void CSetTitleMsg::InternalSwap(CSetTitleMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &text_, lhs_arena,
      &other->text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetTitleMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[37]);
}

// ===================================================================

class CSetCaptureSizeMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetCaptureSizeMsg>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSetCaptureSizeMsg::CSetCaptureSizeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetCaptureSizeMsg)
}
CSetCaptureSizeMsg::CSetCaptureSizeMsg(const CSetCaptureSizeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CSetCaptureSizeMsg)
}

inline void CSetCaptureSizeMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

CSetCaptureSizeMsg::~CSetCaptureSizeMsg() {
  // @@protoc_insertion_point(destructor:CSetCaptureSizeMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetCaptureSizeMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetCaptureSizeMsg::ArenaDtor(void* object) {
  CSetCaptureSizeMsg* _this = reinterpret_cast< CSetCaptureSizeMsg* >(object);
  (void)_this;
}
void CSetCaptureSizeMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetCaptureSizeMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetCaptureSizeMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetCaptureSizeMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetCaptureSizeMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetCaptureSizeMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetCaptureSizeMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetCaptureSizeMsg)
  return target;
}

size_t CSetCaptureSizeMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetCaptureSizeMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 width = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetCaptureSizeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetCaptureSizeMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetCaptureSizeMsg::GetClassData() const { return &_class_data_; }

void CSetCaptureSizeMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetCaptureSizeMsg *>(to)->MergeFrom(
      static_cast<const CSetCaptureSizeMsg &>(from));
}


void CSetCaptureSizeMsg::MergeFrom(const CSetCaptureSizeMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetCaptureSizeMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000002u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetCaptureSizeMsg::CopyFrom(const CSetCaptureSizeMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetCaptureSizeMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetCaptureSizeMsg::IsInitialized() const {
  return true;
}

void CSetCaptureSizeMsg::InternalSwap(CSetCaptureSizeMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetCaptureSizeMsg, height_)
      + sizeof(CSetCaptureSizeMsg::height_)
      - PROTOBUF_FIELD_OFFSET(CSetCaptureSizeMsg, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetCaptureSizeMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[38]);
}

// ===================================================================

class CSetIconMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetIconMsg>()._has_bits_);
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetIconMsg::CSetIconMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetIconMsg)
}
CSetIconMsg::CSetIconMsg(const CSetIconMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image(), 
      GetArenaForAllocation());
  }
  ::memcpy(&width_, &from.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CSetIconMsg)
}

inline void CSetIconMsg::SharedCtor() {
image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&width_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&width_)) + sizeof(height_));
}

CSetIconMsg::~CSetIconMsg() {
  // @@protoc_insertion_point(destructor:CSetIconMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetIconMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  image_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetIconMsg::ArenaDtor(void* object) {
  CSetIconMsg* _this = reinterpret_cast< CSetIconMsg* >(object);
  (void)_this;
}
void CSetIconMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetIconMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetIconMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetIconMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    image_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&width_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetIconMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 width = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_image();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetIconMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetIconMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 width = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_width(), target);
  }

  // optional int32 height = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_height(), target);
  }

  // optional bytes image = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_image(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetIconMsg)
  return target;
}

size_t CSetIconMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetIconMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes image = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_image());
    }

    // optional int32 width = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetIconMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetIconMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetIconMsg::GetClassData() const { return &_class_data_; }

void CSetIconMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetIconMsg *>(to)->MergeFrom(
      static_cast<const CSetIconMsg &>(from));
}


void CSetIconMsg::MergeFrom(const CSetIconMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetIconMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetIconMsg::CopyFrom(const CSetIconMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetIconMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetIconMsg::IsInitialized() const {
  return true;
}

void CSetIconMsg::InternalSwap(CSetIconMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_, lhs_arena,
      &other->image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetIconMsg, height_)
      + sizeof(CSetIconMsg::height_)
      - PROTOBUF_FIELD_OFFSET(CSetIconMsg, width_)>(
          reinterpret_cast<char*>(&width_),
          reinterpret_cast<char*>(&other->width_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetIconMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[39]);
}

// ===================================================================

class CSetFlashStateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetFlashStateMsg>()._has_bits_);
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timeout_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSetFlashStateMsg::CSetFlashStateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetFlashStateMsg)
}
CSetFlashStateMsg::CSetFlashStateMsg(const CSetFlashStateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&flags_, &from.flags_,
    static_cast<size_t>(reinterpret_cast<char*>(&timeout_ms_) -
    reinterpret_cast<char*>(&flags_)) + sizeof(timeout_ms_));
  // @@protoc_insertion_point(copy_constructor:CSetFlashStateMsg)
}

inline void CSetFlashStateMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&flags_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timeout_ms_) -
    reinterpret_cast<char*>(&flags_)) + sizeof(timeout_ms_));
}

CSetFlashStateMsg::~CSetFlashStateMsg() {
  // @@protoc_insertion_point(destructor:CSetFlashStateMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetFlashStateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetFlashStateMsg::ArenaDtor(void* object) {
  CSetFlashStateMsg* _this = reinterpret_cast< CSetFlashStateMsg* >(object);
  (void)_this;
}
void CSetFlashStateMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetFlashStateMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetFlashStateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetFlashStateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timeout_ms_) -
        reinterpret_cast<char*>(&flags_)) + sizeof(timeout_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetFlashStateMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 flags = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_flags(&has_bits);
          flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 timeout_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timeout_ms(&has_bits);
          timeout_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetFlashStateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetFlashStateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 flags = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_flags(), target);
  }

  // optional uint32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_count(), target);
  }

  // optional uint32 timeout_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_timeout_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetFlashStateMsg)
  return target;
}

size_t CSetFlashStateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetFlashStateMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 flags = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 count = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional uint32 timeout_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timeout_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetFlashStateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetFlashStateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetFlashStateMsg::GetClassData() const { return &_class_data_; }

void CSetFlashStateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetFlashStateMsg *>(to)->MergeFrom(
      static_cast<const CSetFlashStateMsg &>(from));
}


void CSetFlashStateMsg::MergeFrom(const CSetFlashStateMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetFlashStateMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      flags_ = from.flags_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000004u) {
      timeout_ms_ = from.timeout_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetFlashStateMsg::CopyFrom(const CSetFlashStateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetFlashStateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetFlashStateMsg::IsInitialized() const {
  return true;
}

void CSetFlashStateMsg::InternalSwap(CSetFlashStateMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetFlashStateMsg, timeout_ms_)
      + sizeof(CSetFlashStateMsg::timeout_ms_)
      - PROTOBUF_FIELD_OFFSET(CSetFlashStateMsg, flags_)>(
          reinterpret_cast<char*>(&flags_),
          reinterpret_cast<char*>(&other->flags_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetFlashStateMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[40]);
}

// ===================================================================

class CShowCursorMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CShowCursorMsg>()._has_bits_);
  static void set_has_x_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y_normalized(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CShowCursorMsg::CShowCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CShowCursorMsg)
}
CShowCursorMsg::CShowCursorMsg(const CShowCursorMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_normalized_, &from.x_normalized_,
    static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&x_normalized_)) + sizeof(y_normalized_));
  // @@protoc_insertion_point(copy_constructor:CShowCursorMsg)
}

inline void CShowCursorMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&x_normalized_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&y_normalized_) -
    reinterpret_cast<char*>(&x_normalized_)) + sizeof(y_normalized_));
}

CShowCursorMsg::~CShowCursorMsg() {
  // @@protoc_insertion_point(destructor:CShowCursorMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CShowCursorMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CShowCursorMsg::ArenaDtor(void* object) {
  CShowCursorMsg* _this = reinterpret_cast< CShowCursorMsg* >(object);
  (void)_this;
}
void CShowCursorMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CShowCursorMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CShowCursorMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CShowCursorMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&x_normalized_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&y_normalized_) -
        reinterpret_cast<char*>(&x_normalized_)) + sizeof(y_normalized_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CShowCursorMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float x_normalized = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_x_normalized(&has_bits);
          x_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float y_normalized = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_y_normalized(&has_bits);
          y_normalized_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CShowCursorMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CShowCursorMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float x_normalized = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_x_normalized(), target);
  }

  // optional float y_normalized = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_y_normalized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CShowCursorMsg)
  return target;
}

size_t CShowCursorMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CShowCursorMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional float x_normalized = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float y_normalized = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CShowCursorMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CShowCursorMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CShowCursorMsg::GetClassData() const { return &_class_data_; }

void CShowCursorMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CShowCursorMsg *>(to)->MergeFrom(
      static_cast<const CShowCursorMsg &>(from));
}


void CShowCursorMsg::MergeFrom(const CShowCursorMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CShowCursorMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      x_normalized_ = from.x_normalized_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_normalized_ = from.y_normalized_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CShowCursorMsg::CopyFrom(const CShowCursorMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CShowCursorMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CShowCursorMsg::IsInitialized() const {
  return true;
}

void CShowCursorMsg::InternalSwap(CShowCursorMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CShowCursorMsg, y_normalized_)
      + sizeof(CShowCursorMsg::y_normalized_)
      - PROTOBUF_FIELD_OFFSET(CShowCursorMsg, x_normalized_)>(
          reinterpret_cast<char*>(&x_normalized_),
          reinterpret_cast<char*>(&other->x_normalized_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CShowCursorMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[41]);
}

// ===================================================================

class CHideCursorMsg::_Internal {
 public:
};

CHideCursorMsg::CHideCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CHideCursorMsg)
}
CHideCursorMsg::CHideCursorMsg(const CHideCursorMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CHideCursorMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CHideCursorMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CHideCursorMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CHideCursorMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[42]);
}

// ===================================================================

class CSetCursorMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetCursorMsg>()._has_bits_);
  static void set_has_cursor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CSetCursorMsg::CSetCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetCursorMsg)
}
CSetCursorMsg::CSetCursorMsg(const CSetCursorMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cursor_id_ = from.cursor_id_;
  // @@protoc_insertion_point(copy_constructor:CSetCursorMsg)
}

inline void CSetCursorMsg::SharedCtor() {
cursor_id_ = uint64_t{0u};
}

CSetCursorMsg::~CSetCursorMsg() {
  // @@protoc_insertion_point(destructor:CSetCursorMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetCursorMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetCursorMsg::ArenaDtor(void* object) {
  CSetCursorMsg* _this = reinterpret_cast< CSetCursorMsg* >(object);
  (void)_this;
}
void CSetCursorMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetCursorMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetCursorMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetCursorMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cursor_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetCursorMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 cursor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cursor_id(&has_bits);
          cursor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetCursorMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetCursorMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 cursor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cursor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetCursorMsg)
  return target;
}

size_t CSetCursorMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetCursorMsg)
  size_t total_size = 0;

  // required uint64 cursor_id = 1;
  if (_internal_has_cursor_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_cursor_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetCursorMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetCursorMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetCursorMsg::GetClassData() const { return &_class_data_; }

void CSetCursorMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetCursorMsg *>(to)->MergeFrom(
      static_cast<const CSetCursorMsg &>(from));
}


void CSetCursorMsg::MergeFrom(const CSetCursorMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetCursorMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cursor_id()) {
    _internal_set_cursor_id(from._internal_cursor_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetCursorMsg::CopyFrom(const CSetCursorMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetCursorMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetCursorMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetCursorMsg::InternalSwap(CSetCursorMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(cursor_id_, other->cursor_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetCursorMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[43]);
}

// ===================================================================

class CGetCursorImageMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CGetCursorImageMsg>()._has_bits_);
  static void set_has_cursor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CGetCursorImageMsg::CGetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGetCursorImageMsg)
}
CGetCursorImageMsg::CGetCursorImageMsg(const CGetCursorImageMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cursor_id_ = from.cursor_id_;
  // @@protoc_insertion_point(copy_constructor:CGetCursorImageMsg)
}

inline void CGetCursorImageMsg::SharedCtor() {
cursor_id_ = uint64_t{0u};
}

CGetCursorImageMsg::~CGetCursorImageMsg() {
  // @@protoc_insertion_point(destructor:CGetCursorImageMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGetCursorImageMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGetCursorImageMsg::ArenaDtor(void* object) {
  CGetCursorImageMsg* _this = reinterpret_cast< CGetCursorImageMsg* >(object);
  (void)_this;
}
void CGetCursorImageMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGetCursorImageMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGetCursorImageMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CGetCursorImageMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cursor_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGetCursorImageMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 cursor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cursor_id(&has_bits);
          cursor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGetCursorImageMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGetCursorImageMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 cursor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cursor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGetCursorImageMsg)
  return target;
}

size_t CGetCursorImageMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGetCursorImageMsg)
  size_t total_size = 0;

  // required uint64 cursor_id = 1;
  if (_internal_has_cursor_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_cursor_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGetCursorImageMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGetCursorImageMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGetCursorImageMsg::GetClassData() const { return &_class_data_; }

void CGetCursorImageMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGetCursorImageMsg *>(to)->MergeFrom(
      static_cast<const CGetCursorImageMsg &>(from));
}


void CGetCursorImageMsg::MergeFrom(const CGetCursorImageMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGetCursorImageMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cursor_id()) {
    _internal_set_cursor_id(from._internal_cursor_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGetCursorImageMsg::CopyFrom(const CGetCursorImageMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGetCursorImageMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGetCursorImageMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CGetCursorImageMsg::InternalSwap(CGetCursorImageMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(cursor_id_, other->cursor_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGetCursorImageMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[44]);
}

// ===================================================================

class CSetCursorImageMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetCursorImageMsg>()._has_bits_);
  static void set_has_cursor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_hot_x(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hot_y(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_image(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

CSetCursorImageMsg::CSetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetCursorImageMsg)
}
CSetCursorImageMsg::CSetCursorImageMsg(const CSetCursorImageMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_image()) {
    image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_image(), 
      GetArenaForAllocation());
  }
  ::memcpy(&cursor_id_, &from.cursor_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&hot_y_) -
    reinterpret_cast<char*>(&cursor_id_)) + sizeof(hot_y_));
  // @@protoc_insertion_point(copy_constructor:CSetCursorImageMsg)
}

inline void CSetCursorImageMsg::SharedCtor() {
image_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cursor_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&hot_y_) -
    reinterpret_cast<char*>(&cursor_id_)) + sizeof(hot_y_));
}

CSetCursorImageMsg::~CSetCursorImageMsg() {
  // @@protoc_insertion_point(destructor:CSetCursorImageMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetCursorImageMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  image_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetCursorImageMsg::ArenaDtor(void* object) {
  CSetCursorImageMsg* _this = reinterpret_cast< CSetCursorImageMsg* >(object);
  (void)_this;
}
void CSetCursorImageMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetCursorImageMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetCursorImageMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetCursorImageMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    image_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&cursor_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&hot_y_) -
        reinterpret_cast<char*>(&cursor_id_)) + sizeof(hot_y_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetCursorImageMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 cursor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cursor_id(&has_bits);
          cursor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hot_x = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hot_x(&has_bits);
          hot_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 hot_y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_hot_y(&has_bits);
          hot_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes image = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_image();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetCursorImageMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetCursorImageMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 cursor_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cursor_id(), target);
  }

  // optional int32 width = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_width(), target);
  }

  // optional int32 height = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_height(), target);
  }

  // optional int32 hot_x = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_hot_x(), target);
  }

  // optional int32 hot_y = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_hot_y(), target);
  }

  // optional bytes image = 6;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_image(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetCursorImageMsg)
  return target;
}

size_t CSetCursorImageMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetCursorImageMsg)
  size_t total_size = 0;

  // required uint64 cursor_id = 1;
  if (_internal_has_cursor_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_cursor_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes image = 6;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_image());
  }

  if (cached_has_bits & 0x0000003cu) {
    // optional int32 width = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_width());
    }

    // optional int32 height = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_height());
    }

    // optional int32 hot_x = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_hot_x());
    }

    // optional int32 hot_y = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_hot_y());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetCursorImageMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetCursorImageMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetCursorImageMsg::GetClassData() const { return &_class_data_; }

void CSetCursorImageMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetCursorImageMsg *>(to)->MergeFrom(
      static_cast<const CSetCursorImageMsg &>(from));
}


void CSetCursorImageMsg::MergeFrom(const CSetCursorImageMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetCursorImageMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_image(from._internal_image());
    }
    if (cached_has_bits & 0x00000002u) {
      cursor_id_ = from.cursor_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000008u) {
      height_ = from.height_;
    }
    if (cached_has_bits & 0x00000010u) {
      hot_x_ = from.hot_x_;
    }
    if (cached_has_bits & 0x00000020u) {
      hot_y_ = from.hot_y_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetCursorImageMsg::CopyFrom(const CSetCursorImageMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetCursorImageMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetCursorImageMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetCursorImageMsg::InternalSwap(CSetCursorImageMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &image_, lhs_arena,
      &other->image_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetCursorImageMsg, hot_y_)
      + sizeof(CSetCursorImageMsg::hot_y_)
      - PROTOBUF_FIELD_OFFSET(CSetCursorImageMsg, cursor_id_)>(
          reinterpret_cast<char*>(&cursor_id_),
          reinterpret_cast<char*>(&other->cursor_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetCursorImageMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[45]);
}

// ===================================================================

class CVideoDecoderInfoMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CVideoDecoderInfoMsg>()._has_bits_);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_threads(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CVideoDecoderInfoMsg::CVideoDecoderInfoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVideoDecoderInfoMsg)
}
CVideoDecoderInfoMsg::CVideoDecoderInfoMsg(const CVideoDecoderInfoMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_info()) {
    info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_info(), 
      GetArenaForAllocation());
  }
  threads_ = from.threads_;
  // @@protoc_insertion_point(copy_constructor:CVideoDecoderInfoMsg)
}

inline void CVideoDecoderInfoMsg::SharedCtor() {
info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
threads_ = 0;
}

CVideoDecoderInfoMsg::~CVideoDecoderInfoMsg() {
  // @@protoc_insertion_point(destructor:CVideoDecoderInfoMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVideoDecoderInfoMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CVideoDecoderInfoMsg::ArenaDtor(void* object) {
  CVideoDecoderInfoMsg* _this = reinterpret_cast< CVideoDecoderInfoMsg* >(object);
  (void)_this;
}
void CVideoDecoderInfoMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVideoDecoderInfoMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVideoDecoderInfoMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CVideoDecoderInfoMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    info_.ClearNonDefaultToEmpty();
  }
  threads_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVideoDecoderInfoMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CVideoDecoderInfoMsg.info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 threads = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_threads(&has_bits);
          threads_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVideoDecoderInfoMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVideoDecoderInfoMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_info().data(), static_cast<int>(this->_internal_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CVideoDecoderInfoMsg.info");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_info(), target);
  }

  // optional int32 threads = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_threads(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVideoDecoderInfoMsg)
  return target;
}

size_t CVideoDecoderInfoMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVideoDecoderInfoMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string info = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_info());
    }

    // optional int32 threads = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_threads());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVideoDecoderInfoMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVideoDecoderInfoMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVideoDecoderInfoMsg::GetClassData() const { return &_class_data_; }

void CVideoDecoderInfoMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVideoDecoderInfoMsg *>(to)->MergeFrom(
      static_cast<const CVideoDecoderInfoMsg &>(from));
}


void CVideoDecoderInfoMsg::MergeFrom(const CVideoDecoderInfoMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVideoDecoderInfoMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_info(from._internal_info());
    }
    if (cached_has_bits & 0x00000002u) {
      threads_ = from.threads_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVideoDecoderInfoMsg::CopyFrom(const CVideoDecoderInfoMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVideoDecoderInfoMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVideoDecoderInfoMsg::IsInitialized() const {
  return true;
}

void CVideoDecoderInfoMsg::InternalSwap(CVideoDecoderInfoMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &info_, lhs_arena,
      &other->info_, rhs_arena
  );
  swap(threads_, other->threads_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CVideoDecoderInfoMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[46]);
}

// ===================================================================

class CVideoEncoderInfoMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CVideoEncoderInfoMsg>()._has_bits_);
  static void set_has_info(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CVideoEncoderInfoMsg::CVideoEncoderInfoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVideoEncoderInfoMsg)
}
CVideoEncoderInfoMsg::CVideoEncoderInfoMsg(const CVideoEncoderInfoMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_info()) {
    info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_info(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CVideoEncoderInfoMsg)
}

inline void CVideoEncoderInfoMsg::SharedCtor() {
info_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CVideoEncoderInfoMsg::~CVideoEncoderInfoMsg() {
  // @@protoc_insertion_point(destructor:CVideoEncoderInfoMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVideoEncoderInfoMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  info_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CVideoEncoderInfoMsg::ArenaDtor(void* object) {
  CVideoEncoderInfoMsg* _this = reinterpret_cast< CVideoEncoderInfoMsg* >(object);
  (void)_this;
}
void CVideoEncoderInfoMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVideoEncoderInfoMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVideoEncoderInfoMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CVideoEncoderInfoMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    info_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVideoEncoderInfoMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string info = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_info();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CVideoEncoderInfoMsg.info");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVideoEncoderInfoMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVideoEncoderInfoMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string info = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_info().data(), static_cast<int>(this->_internal_info().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CVideoEncoderInfoMsg.info");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_info(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVideoEncoderInfoMsg)
  return target;
}

size_t CVideoEncoderInfoMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVideoEncoderInfoMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string info = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_info());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVideoEncoderInfoMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVideoEncoderInfoMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVideoEncoderInfoMsg::GetClassData() const { return &_class_data_; }

void CVideoEncoderInfoMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVideoEncoderInfoMsg *>(to)->MergeFrom(
      static_cast<const CVideoEncoderInfoMsg &>(from));
}


void CVideoEncoderInfoMsg::MergeFrom(const CVideoEncoderInfoMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVideoEncoderInfoMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_info()) {
    _internal_set_info(from._internal_info());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVideoEncoderInfoMsg::CopyFrom(const CVideoEncoderInfoMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVideoEncoderInfoMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVideoEncoderInfoMsg::IsInitialized() const {
  return true;
}

void CVideoEncoderInfoMsg::InternalSwap(CVideoEncoderInfoMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &info_, lhs_arena,
      &other->info_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CVideoEncoderInfoMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[47]);
}

// ===================================================================

class CPauseMsg::_Internal {
 public:
};

CPauseMsg::CPauseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CPauseMsg)
}
CPauseMsg::CPauseMsg(const CPauseMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CPauseMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CPauseMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CPauseMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CPauseMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[48]);
}

// ===================================================================

class CResumeMsg::_Internal {
 public:
};

CResumeMsg::CResumeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CResumeMsg)
}
CResumeMsg::CResumeMsg(const CResumeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CResumeMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CResumeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CResumeMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CResumeMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[49]);
}

// ===================================================================

class CEnableHighResCaptureMsg::_Internal {
 public:
};

CEnableHighResCaptureMsg::CEnableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CEnableHighResCaptureMsg)
}
CEnableHighResCaptureMsg::CEnableHighResCaptureMsg(const CEnableHighResCaptureMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CEnableHighResCaptureMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CEnableHighResCaptureMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CEnableHighResCaptureMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CEnableHighResCaptureMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[50]);
}

// ===================================================================

class CDisableHighResCaptureMsg::_Internal {
 public:
};

CDisableHighResCaptureMsg::CDisableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDisableHighResCaptureMsg)
}
CDisableHighResCaptureMsg::CDisableHighResCaptureMsg(const CDisableHighResCaptureMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDisableHighResCaptureMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDisableHighResCaptureMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDisableHighResCaptureMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDisableHighResCaptureMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[51]);
}

// ===================================================================

class CEnableNeptuneDataMsg::_Internal {
 public:
};

CEnableNeptuneDataMsg::CEnableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CEnableNeptuneDataMsg)
}
CEnableNeptuneDataMsg::CEnableNeptuneDataMsg(const CEnableNeptuneDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CEnableNeptuneDataMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CEnableNeptuneDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CEnableNeptuneDataMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CEnableNeptuneDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[52]);
}

// ===================================================================

class CDisableNeptuneDataMsg::_Internal {
 public:
};

CDisableNeptuneDataMsg::CDisableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CDisableNeptuneDataMsg)
}
CDisableNeptuneDataMsg::CDisableNeptuneDataMsg(const CDisableNeptuneDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CDisableNeptuneDataMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDisableNeptuneDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDisableNeptuneDataMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CDisableNeptuneDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[53]);
}

// ===================================================================

class CPauseControllerInputMsg::_Internal {
 public:
};

CPauseControllerInputMsg::CPauseControllerInputMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CPauseControllerInputMsg)
}
CPauseControllerInputMsg::CPauseControllerInputMsg(const CPauseControllerInputMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CPauseControllerInputMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CPauseControllerInputMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CPauseControllerInputMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CPauseControllerInputMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[54]);
}

// ===================================================================

class CResumeControllerInputMsg::_Internal {
 public:
};

CResumeControllerInputMsg::CResumeControllerInputMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CResumeControllerInputMsg)
}
CResumeControllerInputMsg::CResumeControllerInputMsg(const CResumeControllerInputMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CResumeControllerInputMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CResumeControllerInputMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CResumeControllerInputMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CResumeControllerInputMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[55]);
}

// ===================================================================

class CToggleMagnificationMsg::_Internal {
 public:
};

CToggleMagnificationMsg::CToggleMagnificationMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CToggleMagnificationMsg)
}
CToggleMagnificationMsg::CToggleMagnificationMsg(const CToggleMagnificationMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CToggleMagnificationMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CToggleMagnificationMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CToggleMagnificationMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CToggleMagnificationMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[56]);
}

// ===================================================================

class CSetCapslockMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetCapslockMsg>()._has_bits_);
  static void set_has_pressed(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetCapslockMsg::CSetCapslockMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetCapslockMsg)
}
CSetCapslockMsg::CSetCapslockMsg(const CSetCapslockMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  pressed_ = from.pressed_;
  // @@protoc_insertion_point(copy_constructor:CSetCapslockMsg)
}

inline void CSetCapslockMsg::SharedCtor() {
pressed_ = false;
}

CSetCapslockMsg::~CSetCapslockMsg() {
  // @@protoc_insertion_point(destructor:CSetCapslockMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetCapslockMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetCapslockMsg::ArenaDtor(void* object) {
  CSetCapslockMsg* _this = reinterpret_cast< CSetCapslockMsg* >(object);
  (void)_this;
}
void CSetCapslockMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetCapslockMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetCapslockMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetCapslockMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  pressed_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetCapslockMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool pressed = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_pressed(&has_bits);
          pressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetCapslockMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetCapslockMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool pressed = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_pressed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetCapslockMsg)
  return target;
}

size_t CSetCapslockMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetCapslockMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool pressed = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetCapslockMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetCapslockMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetCapslockMsg::GetClassData() const { return &_class_data_; }

void CSetCapslockMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetCapslockMsg *>(to)->MergeFrom(
      static_cast<const CSetCapslockMsg &>(from));
}


void CSetCapslockMsg::MergeFrom(const CSetCapslockMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetCapslockMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_pressed()) {
    _internal_set_pressed(from._internal_pressed());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetCapslockMsg::CopyFrom(const CSetCapslockMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetCapslockMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetCapslockMsg::IsInitialized() const {
  return true;
}

void CSetCapslockMsg::InternalSwap(CSetCapslockMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(pressed_, other->pressed_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetCapslockMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[57]);
}

// ===================================================================

class CStreamingKeymapEntry::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingKeymapEntry>()._has_bits_);
  static void set_has_scancode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_normal_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_shift_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_capslock_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_shift_capslock_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_altgr_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_altgr_shift_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_altgr_capslock_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_altgr_shift_capslock_keycode(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CStreamingKeymapEntry::CStreamingKeymapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingKeymapEntry)
}
CStreamingKeymapEntry::CStreamingKeymapEntry(const CStreamingKeymapEntry& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&scancode_, &from.scancode_,
    static_cast<size_t>(reinterpret_cast<char*>(&altgr_shift_capslock_keycode_) -
    reinterpret_cast<char*>(&scancode_)) + sizeof(altgr_shift_capslock_keycode_));
  // @@protoc_insertion_point(copy_constructor:CStreamingKeymapEntry)
}

inline void CStreamingKeymapEntry::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&scancode_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&altgr_shift_capslock_keycode_) -
    reinterpret_cast<char*>(&scancode_)) + sizeof(altgr_shift_capslock_keycode_));
}

CStreamingKeymapEntry::~CStreamingKeymapEntry() {
  // @@protoc_insertion_point(destructor:CStreamingKeymapEntry)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingKeymapEntry::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingKeymapEntry::ArenaDtor(void* object) {
  CStreamingKeymapEntry* _this = reinterpret_cast< CStreamingKeymapEntry* >(object);
  (void)_this;
}
void CStreamingKeymapEntry::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingKeymapEntry::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingKeymapEntry::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingKeymapEntry)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&scancode_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&altgr_capslock_keycode_) -
        reinterpret_cast<char*>(&scancode_)) + sizeof(altgr_capslock_keycode_));
  }
  altgr_shift_capslock_keycode_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingKeymapEntry::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 scancode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_scancode(&has_bits);
          scancode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 normal_keycode = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_normal_keycode(&has_bits);
          normal_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 shift_keycode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_shift_keycode(&has_bits);
          shift_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 capslock_keycode = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_capslock_keycode(&has_bits);
          capslock_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 shift_capslock_keycode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_shift_capslock_keycode(&has_bits);
          shift_capslock_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 altgr_keycode = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_altgr_keycode(&has_bits);
          altgr_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 altgr_shift_keycode = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_altgr_shift_keycode(&has_bits);
          altgr_shift_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 altgr_capslock_keycode = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_altgr_capslock_keycode(&has_bits);
          altgr_capslock_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 altgr_shift_capslock_keycode = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_altgr_shift_capslock_keycode(&has_bits);
          altgr_shift_capslock_keycode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingKeymapEntry::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingKeymapEntry)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 scancode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_scancode(), target);
  }

  // optional int32 normal_keycode = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_normal_keycode(), target);
  }

  // optional int32 shift_keycode = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_shift_keycode(), target);
  }

  // optional int32 capslock_keycode = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_capslock_keycode(), target);
  }

  // optional int32 shift_capslock_keycode = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(5, this->_internal_shift_capslock_keycode(), target);
  }

  // optional int32 altgr_keycode = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_altgr_keycode(), target);
  }

  // optional int32 altgr_shift_keycode = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(7, this->_internal_altgr_shift_keycode(), target);
  }

  // optional int32 altgr_capslock_keycode = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_altgr_capslock_keycode(), target);
  }

  // optional int32 altgr_shift_capslock_keycode = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(9, this->_internal_altgr_shift_capslock_keycode(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingKeymapEntry)
  return target;
}

size_t CStreamingKeymapEntry::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingKeymapEntry)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 scancode = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_scancode());
    }

    // optional int32 normal_keycode = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_normal_keycode());
    }

    // optional int32 shift_keycode = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_shift_keycode());
    }

    // optional int32 capslock_keycode = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_capslock_keycode());
    }

    // optional int32 shift_capslock_keycode = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_shift_capslock_keycode());
    }

    // optional int32 altgr_keycode = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_altgr_keycode());
    }

    // optional int32 altgr_shift_keycode = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_altgr_shift_keycode());
    }

    // optional int32 altgr_capslock_keycode = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_altgr_capslock_keycode());
    }

  }
  // optional int32 altgr_shift_capslock_keycode = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_altgr_shift_capslock_keycode());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingKeymapEntry::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingKeymapEntry::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingKeymapEntry::GetClassData() const { return &_class_data_; }

void CStreamingKeymapEntry::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingKeymapEntry *>(to)->MergeFrom(
      static_cast<const CStreamingKeymapEntry &>(from));
}


void CStreamingKeymapEntry::MergeFrom(const CStreamingKeymapEntry& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingKeymapEntry)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      scancode_ = from.scancode_;
    }
    if (cached_has_bits & 0x00000002u) {
      normal_keycode_ = from.normal_keycode_;
    }
    if (cached_has_bits & 0x00000004u) {
      shift_keycode_ = from.shift_keycode_;
    }
    if (cached_has_bits & 0x00000008u) {
      capslock_keycode_ = from.capslock_keycode_;
    }
    if (cached_has_bits & 0x00000010u) {
      shift_capslock_keycode_ = from.shift_capslock_keycode_;
    }
    if (cached_has_bits & 0x00000020u) {
      altgr_keycode_ = from.altgr_keycode_;
    }
    if (cached_has_bits & 0x00000040u) {
      altgr_shift_keycode_ = from.altgr_shift_keycode_;
    }
    if (cached_has_bits & 0x00000080u) {
      altgr_capslock_keycode_ = from.altgr_capslock_keycode_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _internal_set_altgr_shift_capslock_keycode(from._internal_altgr_shift_capslock_keycode());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingKeymapEntry::CopyFrom(const CStreamingKeymapEntry& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingKeymapEntry)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingKeymapEntry::IsInitialized() const {
  return true;
}

void CStreamingKeymapEntry::InternalSwap(CStreamingKeymapEntry* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamingKeymapEntry, altgr_shift_capslock_keycode_)
      + sizeof(CStreamingKeymapEntry::altgr_shift_capslock_keycode_)
      - PROTOBUF_FIELD_OFFSET(CStreamingKeymapEntry, scancode_)>(
          reinterpret_cast<char*>(&scancode_),
          reinterpret_cast<char*>(&other->scancode_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingKeymapEntry::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[58]);
}

// ===================================================================

class CStreamingKeymap::_Internal {
 public:
};

CStreamingKeymap::CStreamingKeymap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingKeymap)
}
CStreamingKeymap::CStreamingKeymap(const CStreamingKeymap& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStreamingKeymap)
}

inline void CStreamingKeymap::SharedCtor() {
}

CStreamingKeymap::~CStreamingKeymap() {
  // @@protoc_insertion_point(destructor:CStreamingKeymap)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingKeymap::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingKeymap::ArenaDtor(void* object) {
  CStreamingKeymap* _this = reinterpret_cast< CStreamingKeymap* >(object);
  (void)_this;
}
void CStreamingKeymap::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingKeymap::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingKeymap::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingKeymap)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingKeymap::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CStreamingKeymapEntry entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingKeymap::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingKeymap)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CStreamingKeymapEntry entries = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingKeymap)
  return target;
}

size_t CStreamingKeymap::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingKeymap)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CStreamingKeymapEntry entries = 1;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingKeymap::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingKeymap::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingKeymap::GetClassData() const { return &_class_data_; }

void CStreamingKeymap::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingKeymap *>(to)->MergeFrom(
      static_cast<const CStreamingKeymap &>(from));
}


void CStreamingKeymap::MergeFrom(const CStreamingKeymap& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingKeymap)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingKeymap::CopyFrom(const CStreamingKeymap& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingKeymap)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingKeymap::IsInitialized() const {
  return true;
}

void CStreamingKeymap::InternalSwap(CStreamingKeymap* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingKeymap::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[59]);
}

// ===================================================================

class CSetKeymapMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetKeymapMsg>()._has_bits_);
  static const ::CStreamingKeymap& keymap(const CSetKeymapMsg* msg);
  static void set_has_keymap(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CStreamingKeymap&
CSetKeymapMsg::_Internal::keymap(const CSetKeymapMsg* msg) {
  return *msg->keymap_;
}
CSetKeymapMsg::CSetKeymapMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetKeymapMsg)
}
CSetKeymapMsg::CSetKeymapMsg(const CSetKeymapMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_keymap()) {
    keymap_ = new ::CStreamingKeymap(*from.keymap_);
  } else {
    keymap_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CSetKeymapMsg)
}

inline void CSetKeymapMsg::SharedCtor() {
keymap_ = nullptr;
}

CSetKeymapMsg::~CSetKeymapMsg() {
  // @@protoc_insertion_point(destructor:CSetKeymapMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetKeymapMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete keymap_;
}

void CSetKeymapMsg::ArenaDtor(void* object) {
  CSetKeymapMsg* _this = reinterpret_cast< CSetKeymapMsg* >(object);
  (void)_this;
}
void CSetKeymapMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetKeymapMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetKeymapMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetKeymapMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(keymap_ != nullptr);
    keymap_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetKeymapMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CStreamingKeymap keymap = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_keymap(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetKeymapMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetKeymapMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CStreamingKeymap keymap = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::keymap(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetKeymapMsg)
  return target;
}

size_t CSetKeymapMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetKeymapMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CStreamingKeymap keymap = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *keymap_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetKeymapMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetKeymapMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetKeymapMsg::GetClassData() const { return &_class_data_; }

void CSetKeymapMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetKeymapMsg *>(to)->MergeFrom(
      static_cast<const CSetKeymapMsg &>(from));
}


void CSetKeymapMsg::MergeFrom(const CSetKeymapMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetKeymapMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_keymap()) {
    _internal_mutable_keymap()->::CStreamingKeymap::MergeFrom(from._internal_keymap());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetKeymapMsg::CopyFrom(const CSetKeymapMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetKeymapMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetKeymapMsg::IsInitialized() const {
  return true;
}

void CSetKeymapMsg::InternalSwap(CSetKeymapMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(keymap_, other->keymap_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetKeymapMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[60]);
}

// ===================================================================

class CStopRequest::_Internal {
 public:
};

CStopRequest::CStopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CStopRequest)
}
CStopRequest::CStopRequest(const CStopRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStopRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStopRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStopRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CStopRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[61]);
}

// ===================================================================

class CQuitRequest::_Internal {
 public:
};

CQuitRequest::CQuitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CQuitRequest)
}
CQuitRequest::CQuitRequest(const CQuitRequest& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CQuitRequest)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CQuitRequest::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CQuitRequest::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CQuitRequest::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[62]);
}

// ===================================================================

class CDeleteCursorMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CDeleteCursorMsg>()._has_bits_);
  static void set_has_cursor_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CDeleteCursorMsg::CDeleteCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDeleteCursorMsg)
}
CDeleteCursorMsg::CDeleteCursorMsg(const CDeleteCursorMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cursor_id_ = from.cursor_id_;
  // @@protoc_insertion_point(copy_constructor:CDeleteCursorMsg)
}

inline void CDeleteCursorMsg::SharedCtor() {
cursor_id_ = uint64_t{0u};
}

CDeleteCursorMsg::~CDeleteCursorMsg() {
  // @@protoc_insertion_point(destructor:CDeleteCursorMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDeleteCursorMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CDeleteCursorMsg::ArenaDtor(void* object) {
  CDeleteCursorMsg* _this = reinterpret_cast< CDeleteCursorMsg* >(object);
  (void)_this;
}
void CDeleteCursorMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDeleteCursorMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDeleteCursorMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CDeleteCursorMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cursor_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDeleteCursorMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint64 cursor_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cursor_id(&has_bits);
          cursor_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDeleteCursorMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDeleteCursorMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 cursor_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_cursor_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDeleteCursorMsg)
  return target;
}

size_t CDeleteCursorMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDeleteCursorMsg)
  size_t total_size = 0;

  // required uint64 cursor_id = 1;
  if (_internal_has_cursor_id()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_cursor_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDeleteCursorMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDeleteCursorMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDeleteCursorMsg::GetClassData() const { return &_class_data_; }

void CDeleteCursorMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDeleteCursorMsg *>(to)->MergeFrom(
      static_cast<const CDeleteCursorMsg &>(from));
}


void CDeleteCursorMsg::MergeFrom(const CDeleteCursorMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDeleteCursorMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cursor_id()) {
    _internal_set_cursor_id(from._internal_cursor_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDeleteCursorMsg::CopyFrom(const CDeleteCursorMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDeleteCursorMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDeleteCursorMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CDeleteCursorMsg::InternalSwap(CDeleteCursorMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(cursor_id_, other->cursor_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CDeleteCursorMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[63]);
}

// ===================================================================

class CSetStreamingClientConfig::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetStreamingClientConfig>()._has_bits_);
  static const ::CStreamingClientConfig& config(const CSetStreamingClientConfig* msg);
  static void set_has_config(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

const ::CStreamingClientConfig&
CSetStreamingClientConfig::_Internal::config(const CSetStreamingClientConfig* msg) {
  return *msg->config_;
}
CSetStreamingClientConfig::CSetStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetStreamingClientConfig)
}
CSetStreamingClientConfig::CSetStreamingClientConfig(const CSetStreamingClientConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_config()) {
    config_ = new ::CStreamingClientConfig(*from.config_);
  } else {
    config_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CSetStreamingClientConfig)
}

inline void CSetStreamingClientConfig::SharedCtor() {
config_ = nullptr;
}

CSetStreamingClientConfig::~CSetStreamingClientConfig() {
  // @@protoc_insertion_point(destructor:CSetStreamingClientConfig)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetStreamingClientConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete config_;
}

void CSetStreamingClientConfig::ArenaDtor(void* object) {
  CSetStreamingClientConfig* _this = reinterpret_cast< CSetStreamingClientConfig* >(object);
  (void)_this;
}
void CSetStreamingClientConfig::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetStreamingClientConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetStreamingClientConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetStreamingClientConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(config_ != nullptr);
    config_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetStreamingClientConfig::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .CStreamingClientConfig config = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetStreamingClientConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetStreamingClientConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .CStreamingClientConfig config = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::config(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetStreamingClientConfig)
  return target;
}

size_t CSetStreamingClientConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetStreamingClientConfig)
  size_t total_size = 0;

  // required .CStreamingClientConfig config = 1;
  if (_internal_has_config()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *config_);
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetStreamingClientConfig::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetStreamingClientConfig::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetStreamingClientConfig::GetClassData() const { return &_class_data_; }

void CSetStreamingClientConfig::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetStreamingClientConfig *>(to)->MergeFrom(
      static_cast<const CSetStreamingClientConfig &>(from));
}


void CSetStreamingClientConfig::MergeFrom(const CSetStreamingClientConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetStreamingClientConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_config()) {
    _internal_mutable_config()->::CStreamingClientConfig::MergeFrom(from._internal_config());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetStreamingClientConfig::CopyFrom(const CSetStreamingClientConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetStreamingClientConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetStreamingClientConfig::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetStreamingClientConfig::InternalSwap(CSetStreamingClientConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(config_, other->config_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetStreamingClientConfig::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[64]);
}

// ===================================================================

class CSetQoSMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetQoSMsg>()._has_bits_);
  static void set_has_use_qos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CSetQoSMsg::CSetQoSMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetQoSMsg)
}
CSetQoSMsg::CSetQoSMsg(const CSetQoSMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  use_qos_ = from.use_qos_;
  // @@protoc_insertion_point(copy_constructor:CSetQoSMsg)
}

inline void CSetQoSMsg::SharedCtor() {
use_qos_ = false;
}

CSetQoSMsg::~CSetQoSMsg() {
  // @@protoc_insertion_point(destructor:CSetQoSMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetQoSMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetQoSMsg::ArenaDtor(void* object) {
  CSetQoSMsg* _this = reinterpret_cast< CSetQoSMsg* >(object);
  (void)_this;
}
void CSetQoSMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetQoSMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetQoSMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetQoSMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  use_qos_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetQoSMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool use_qos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_use_qos(&has_bits);
          use_qos_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetQoSMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetQoSMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool use_qos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_use_qos(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetQoSMsg)
  return target;
}

size_t CSetQoSMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetQoSMsg)
  size_t total_size = 0;

  // required bool use_qos = 1;
  if (_internal_has_use_qos()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetQoSMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetQoSMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetQoSMsg::GetClassData() const { return &_class_data_; }

void CSetQoSMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetQoSMsg *>(to)->MergeFrom(
      static_cast<const CSetQoSMsg &>(from));
}


void CSetQoSMsg::MergeFrom(const CSetQoSMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetQoSMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_use_qos()) {
    _internal_set_use_qos(from._internal_use_qos());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetQoSMsg::CopyFrom(const CSetQoSMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetQoSMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetQoSMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetQoSMsg::InternalSwap(CSetQoSMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(use_qos_, other->use_qos_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetQoSMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[65]);
}

// ===================================================================

class CSetTargetFramerateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetTargetFramerateMsg>()._has_bits_);
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reasons(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_framerate_numerator(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_framerate_denominator(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CSetTargetFramerateMsg::CSetTargetFramerateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetTargetFramerateMsg)
}
CSetTargetFramerateMsg::CSetTargetFramerateMsg(const CSetTargetFramerateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&framerate_, &from.framerate_,
    static_cast<size_t>(reinterpret_cast<char*>(&framerate_denominator_) -
    reinterpret_cast<char*>(&framerate_)) + sizeof(framerate_denominator_));
  // @@protoc_insertion_point(copy_constructor:CSetTargetFramerateMsg)
}

inline void CSetTargetFramerateMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&framerate_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&framerate_denominator_) -
    reinterpret_cast<char*>(&framerate_)) + sizeof(framerate_denominator_));
}

CSetTargetFramerateMsg::~CSetTargetFramerateMsg() {
  // @@protoc_insertion_point(destructor:CSetTargetFramerateMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetTargetFramerateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetTargetFramerateMsg::ArenaDtor(void* object) {
  CSetTargetFramerateMsg* _this = reinterpret_cast< CSetTargetFramerateMsg* >(object);
  (void)_this;
}
void CSetTargetFramerateMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetTargetFramerateMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetTargetFramerateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetTargetFramerateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&framerate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&framerate_denominator_) -
        reinterpret_cast<char*>(&framerate_)) + sizeof(framerate_denominator_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetTargetFramerateMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 framerate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_framerate(&has_bits);
          framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reasons = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_reasons(&has_bits);
          reasons_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 framerate_numerator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_framerate_numerator(&has_bits);
          framerate_numerator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 framerate_denominator = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_framerate_denominator(&has_bits);
          framerate_denominator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetTargetFramerateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetTargetFramerateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 framerate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_framerate(), target);
  }

  // optional uint32 reasons = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reasons(), target);
  }

  // optional uint32 framerate_numerator = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_framerate_numerator(), target);
  }

  // optional uint32 framerate_denominator = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_framerate_denominator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetTargetFramerateMsg)
  return target;
}

size_t CSetTargetFramerateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetTargetFramerateMsg)
  size_t total_size = 0;

  // required uint32 framerate = 1;
  if (_internal_has_framerate()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000eu) {
    // optional uint32 reasons = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_reasons());
    }

    // optional uint32 framerate_numerator = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate_numerator());
    }

    // optional uint32 framerate_denominator = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate_denominator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetTargetFramerateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetTargetFramerateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetTargetFramerateMsg::GetClassData() const { return &_class_data_; }

void CSetTargetFramerateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetTargetFramerateMsg *>(to)->MergeFrom(
      static_cast<const CSetTargetFramerateMsg &>(from));
}


void CSetTargetFramerateMsg::MergeFrom(const CSetTargetFramerateMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetTargetFramerateMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      framerate_ = from.framerate_;
    }
    if (cached_has_bits & 0x00000002u) {
      reasons_ = from.reasons_;
    }
    if (cached_has_bits & 0x00000004u) {
      framerate_numerator_ = from.framerate_numerator_;
    }
    if (cached_has_bits & 0x00000008u) {
      framerate_denominator_ = from.framerate_denominator_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetTargetFramerateMsg::CopyFrom(const CSetTargetFramerateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetTargetFramerateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetTargetFramerateMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetTargetFramerateMsg::InternalSwap(CSetTargetFramerateMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetTargetFramerateMsg, framerate_denominator_)
      + sizeof(CSetTargetFramerateMsg::framerate_denominator_)
      - PROTOBUF_FIELD_OFFSET(CSetTargetFramerateMsg, framerate_)>(
          reinterpret_cast<char*>(&framerate_),
          reinterpret_cast<char*>(&other->framerate_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetTargetFramerateMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[66]);
}

// ===================================================================

class CSetTargetBitrateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetTargetBitrateMsg>()._has_bits_);
  static void set_has_bitrate(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CSetTargetBitrateMsg::CSetTargetBitrateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetTargetBitrateMsg)
}
CSetTargetBitrateMsg::CSetTargetBitrateMsg(const CSetTargetBitrateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  bitrate_ = from.bitrate_;
  // @@protoc_insertion_point(copy_constructor:CSetTargetBitrateMsg)
}

inline void CSetTargetBitrateMsg::SharedCtor() {
bitrate_ = 0;
}

CSetTargetBitrateMsg::~CSetTargetBitrateMsg() {
  // @@protoc_insertion_point(destructor:CSetTargetBitrateMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetTargetBitrateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetTargetBitrateMsg::ArenaDtor(void* object) {
  CSetTargetBitrateMsg* _this = reinterpret_cast< CSetTargetBitrateMsg* >(object);
  (void)_this;
}
void CSetTargetBitrateMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetTargetBitrateMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetTargetBitrateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetTargetBitrateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  bitrate_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetTargetBitrateMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 bitrate = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_bitrate(&has_bits);
          bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetTargetBitrateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetTargetBitrateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required int32 bitrate = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_bitrate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetTargetBitrateMsg)
  return target;
}

size_t CSetTargetBitrateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetTargetBitrateMsg)
  size_t total_size = 0;

  // required int32 bitrate = 1;
  if (_internal_has_bitrate()) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_bitrate());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetTargetBitrateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetTargetBitrateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetTargetBitrateMsg::GetClassData() const { return &_class_data_; }

void CSetTargetBitrateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetTargetBitrateMsg *>(to)->MergeFrom(
      static_cast<const CSetTargetBitrateMsg &>(from));
}


void CSetTargetBitrateMsg::MergeFrom(const CSetTargetBitrateMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetTargetBitrateMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_bitrate()) {
    _internal_set_bitrate(from._internal_bitrate());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetTargetBitrateMsg::CopyFrom(const CSetTargetBitrateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetTargetBitrateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetTargetBitrateMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CSetTargetBitrateMsg::InternalSwap(CSetTargetBitrateMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bitrate_, other->bitrate_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetTargetBitrateMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[67]);
}

// ===================================================================

class COverlayEnabledMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<COverlayEnabledMsg>()._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

COverlayEnabledMsg::COverlayEnabledMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:COverlayEnabledMsg)
}
COverlayEnabledMsg::COverlayEnabledMsg(const COverlayEnabledMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enabled_ = from.enabled_;
  // @@protoc_insertion_point(copy_constructor:COverlayEnabledMsg)
}

inline void COverlayEnabledMsg::SharedCtor() {
enabled_ = false;
}

COverlayEnabledMsg::~COverlayEnabledMsg() {
  // @@protoc_insertion_point(destructor:COverlayEnabledMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void COverlayEnabledMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void COverlayEnabledMsg::ArenaDtor(void* object) {
  COverlayEnabledMsg* _this = reinterpret_cast< COverlayEnabledMsg* >(object);
  (void)_this;
}
void COverlayEnabledMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void COverlayEnabledMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void COverlayEnabledMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:COverlayEnabledMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* COverlayEnabledMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* COverlayEnabledMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:COverlayEnabledMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:COverlayEnabledMsg)
  return target;
}

size_t COverlayEnabledMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:COverlayEnabledMsg)
  size_t total_size = 0;

  // required bool enabled = 1;
  if (_internal_has_enabled()) {
    total_size += 1 + 1;
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData COverlayEnabledMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    COverlayEnabledMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*COverlayEnabledMsg::GetClassData() const { return &_class_data_; }

void COverlayEnabledMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<COverlayEnabledMsg *>(to)->MergeFrom(
      static_cast<const COverlayEnabledMsg &>(from));
}


void COverlayEnabledMsg::MergeFrom(const COverlayEnabledMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:COverlayEnabledMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _internal_set_enabled(from._internal_enabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void COverlayEnabledMsg::CopyFrom(const COverlayEnabledMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:COverlayEnabledMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool COverlayEnabledMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void COverlayEnabledMsg::InternalSwap(COverlayEnabledMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(enabled_, other->enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata COverlayEnabledMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[68]);
}

// ===================================================================

class CSetGammaRampMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetGammaRampMsg>()._has_bits_);
  static void set_has_gamma_ramp(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetGammaRampMsg::CSetGammaRampMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetGammaRampMsg)
}
CSetGammaRampMsg::CSetGammaRampMsg(const CSetGammaRampMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  gamma_ramp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    gamma_ramp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_gamma_ramp()) {
    gamma_ramp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_gamma_ramp(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSetGammaRampMsg)
}

inline void CSetGammaRampMsg::SharedCtor() {
gamma_ramp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  gamma_ramp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSetGammaRampMsg::~CSetGammaRampMsg() {
  // @@protoc_insertion_point(destructor:CSetGammaRampMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetGammaRampMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  gamma_ramp_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetGammaRampMsg::ArenaDtor(void* object) {
  CSetGammaRampMsg* _this = reinterpret_cast< CSetGammaRampMsg* >(object);
  (void)_this;
}
void CSetGammaRampMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetGammaRampMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetGammaRampMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetGammaRampMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    gamma_ramp_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetGammaRampMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes gamma_ramp = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_gamma_ramp();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetGammaRampMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetGammaRampMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes gamma_ramp = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_gamma_ramp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetGammaRampMsg)
  return target;
}

size_t CSetGammaRampMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetGammaRampMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes gamma_ramp = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_gamma_ramp());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetGammaRampMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetGammaRampMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetGammaRampMsg::GetClassData() const { return &_class_data_; }

void CSetGammaRampMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetGammaRampMsg *>(to)->MergeFrom(
      static_cast<const CSetGammaRampMsg &>(from));
}


void CSetGammaRampMsg::MergeFrom(const CSetGammaRampMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetGammaRampMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_gamma_ramp()) {
    _internal_set_gamma_ramp(from._internal_gamma_ramp());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetGammaRampMsg::CopyFrom(const CSetGammaRampMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetGammaRampMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetGammaRampMsg::IsInitialized() const {
  return true;
}

void CSetGammaRampMsg::InternalSwap(CSetGammaRampMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &gamma_ramp_, lhs_arena,
      &other->gamma_ramp_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetGammaRampMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[69]);
}

// ===================================================================

class CSetActivityMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetActivityMsg>()._has_bits_);
  static void set_has_activity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_gameid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_game_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetActivityMsg::CSetActivityMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetActivityMsg)
}
CSetActivityMsg::CSetActivityMsg(const CSetActivityMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  game_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_name()) {
    game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_game_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&gameid_, &from.gameid_,
    static_cast<size_t>(reinterpret_cast<char*>(&activity_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(activity_));
  // @@protoc_insertion_point(copy_constructor:CSetActivityMsg)
}

inline void CSetActivityMsg::SharedCtor() {
game_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&gameid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&gameid_)) + sizeof(appid_));
activity_ = 1;
}

CSetActivityMsg::~CSetActivityMsg() {
  // @@protoc_insertion_point(destructor:CSetActivityMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetActivityMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  game_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetActivityMsg::ArenaDtor(void* object) {
  CSetActivityMsg* _this = reinterpret_cast< CSetActivityMsg* >(object);
  (void)_this;
}
void CSetActivityMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetActivityMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetActivityMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetActivityMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    game_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&gameid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&gameid_)) + sizeof(appid_));
    activity_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetActivityMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamActivity_IsValid(val))) {
            _internal_set_activity(static_cast<::EStreamActivity>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 gameid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_gameid(&has_bits);
          gameid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string game_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_game_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSetActivityMsg.game_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetActivityMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetActivityMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_activity(), target);
  }

  // optional uint32 appid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  // optional uint64 gameid = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_gameid(), target);
  }

  // optional string game_name = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_name().data(), static_cast<int>(this->_internal_game_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSetActivityMsg.game_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_game_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetActivityMsg)
  return target;
}

size_t CSetActivityMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetActivityMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string game_name = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_name());
    }

    // optional uint64 gameid = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_gameid());
    }

    // optional uint32 appid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_activity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetActivityMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetActivityMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetActivityMsg::GetClassData() const { return &_class_data_; }

void CSetActivityMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetActivityMsg *>(to)->MergeFrom(
      static_cast<const CSetActivityMsg &>(from));
}


void CSetActivityMsg::MergeFrom(const CSetActivityMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetActivityMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_game_name(from._internal_game_name());
    }
    if (cached_has_bits & 0x00000002u) {
      gameid_ = from.gameid_;
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      activity_ = from.activity_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetActivityMsg::CopyFrom(const CSetActivityMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetActivityMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetActivityMsg::IsInitialized() const {
  return true;
}

void CSetActivityMsg::InternalSwap(CSetActivityMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &game_name_, lhs_arena,
      &other->game_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetActivityMsg, appid_)
      + sizeof(CSetActivityMsg::appid_)
      - PROTOBUF_FIELD_OFFSET(CSetActivityMsg, gameid_)>(
          reinterpret_cast<char*>(&gameid_),
          reinterpret_cast<char*>(&other->gameid_));
  swap(activity_, other->activity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetActivityMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[70]);
}

// ===================================================================

class CSystemSuspendMsg::_Internal {
 public:
};

CSystemSuspendMsg::CSystemSuspendMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CSystemSuspendMsg)
}
CSystemSuspendMsg::CSystemSuspendMsg(const CSystemSuspendMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSystemSuspendMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSystemSuspendMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSystemSuspendMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CSystemSuspendMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[71]);
}

// ===================================================================

class CVirtualHereRequestMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CVirtualHereRequestMsg>()._has_bits_);
  static void set_has_hostname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CVirtualHereRequestMsg::CVirtualHereRequestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVirtualHereRequestMsg)
}
CVirtualHereRequestMsg::CVirtualHereRequestMsg(const CVirtualHereRequestMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hostname()) {
    hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hostname(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CVirtualHereRequestMsg)
}

inline void CVirtualHereRequestMsg::SharedCtor() {
hostname_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CVirtualHereRequestMsg::~CVirtualHereRequestMsg() {
  // @@protoc_insertion_point(destructor:CVirtualHereRequestMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVirtualHereRequestMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hostname_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CVirtualHereRequestMsg::ArenaDtor(void* object) {
  CVirtualHereRequestMsg* _this = reinterpret_cast< CVirtualHereRequestMsg* >(object);
  (void)_this;
}
void CVirtualHereRequestMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVirtualHereRequestMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVirtualHereRequestMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CVirtualHereRequestMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    hostname_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVirtualHereRequestMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hostname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hostname();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CVirtualHereRequestMsg.hostname");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVirtualHereRequestMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVirtualHereRequestMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string hostname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hostname().data(), static_cast<int>(this->_internal_hostname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CVirtualHereRequestMsg.hostname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hostname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVirtualHereRequestMsg)
  return target;
}

size_t CVirtualHereRequestMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVirtualHereRequestMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string hostname = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_hostname());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVirtualHereRequestMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVirtualHereRequestMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVirtualHereRequestMsg::GetClassData() const { return &_class_data_; }

void CVirtualHereRequestMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVirtualHereRequestMsg *>(to)->MergeFrom(
      static_cast<const CVirtualHereRequestMsg &>(from));
}


void CVirtualHereRequestMsg::MergeFrom(const CVirtualHereRequestMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVirtualHereRequestMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_hostname()) {
    _internal_set_hostname(from._internal_hostname());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVirtualHereRequestMsg::CopyFrom(const CVirtualHereRequestMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVirtualHereRequestMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVirtualHereRequestMsg::IsInitialized() const {
  return true;
}

void CVirtualHereRequestMsg::InternalSwap(CVirtualHereRequestMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hostname_, lhs_arena,
      &other->hostname_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CVirtualHereRequestMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[72]);
}

// ===================================================================

class CVirtualHereReadyMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CVirtualHereReadyMsg>()._has_bits_);
  static void set_has_licensed_device_count(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CVirtualHereReadyMsg::CVirtualHereReadyMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVirtualHereReadyMsg)
}
CVirtualHereReadyMsg::CVirtualHereReadyMsg(const CVirtualHereReadyMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  licensed_device_count_ = from.licensed_device_count_;
  // @@protoc_insertion_point(copy_constructor:CVirtualHereReadyMsg)
}

inline void CVirtualHereReadyMsg::SharedCtor() {
licensed_device_count_ = 0u;
}

CVirtualHereReadyMsg::~CVirtualHereReadyMsg() {
  // @@protoc_insertion_point(destructor:CVirtualHereReadyMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVirtualHereReadyMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CVirtualHereReadyMsg::ArenaDtor(void* object) {
  CVirtualHereReadyMsg* _this = reinterpret_cast< CVirtualHereReadyMsg* >(object);
  (void)_this;
}
void CVirtualHereReadyMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVirtualHereReadyMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVirtualHereReadyMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CVirtualHereReadyMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  licensed_device_count_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVirtualHereReadyMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 licensed_device_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_licensed_device_count(&has_bits);
          licensed_device_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVirtualHereReadyMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVirtualHereReadyMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 licensed_device_count = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_licensed_device_count(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVirtualHereReadyMsg)
  return target;
}

size_t CVirtualHereReadyMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVirtualHereReadyMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 licensed_device_count = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_licensed_device_count());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVirtualHereReadyMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVirtualHereReadyMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVirtualHereReadyMsg::GetClassData() const { return &_class_data_; }

void CVirtualHereReadyMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVirtualHereReadyMsg *>(to)->MergeFrom(
      static_cast<const CVirtualHereReadyMsg &>(from));
}


void CVirtualHereReadyMsg::MergeFrom(const CVirtualHereReadyMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVirtualHereReadyMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_licensed_device_count()) {
    _internal_set_licensed_device_count(from._internal_licensed_device_count());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVirtualHereReadyMsg::CopyFrom(const CVirtualHereReadyMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVirtualHereReadyMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVirtualHereReadyMsg::IsInitialized() const {
  return true;
}

void CVirtualHereReadyMsg::InternalSwap(CVirtualHereReadyMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(licensed_device_count_, other->licensed_device_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CVirtualHereReadyMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[73]);
}

// ===================================================================

class CVirtualHereShareDeviceMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CVirtualHereShareDeviceMsg>()._has_bits_);
  static void set_has_device_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CVirtualHereShareDeviceMsg::CVirtualHereShareDeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVirtualHereShareDeviceMsg)
}
CVirtualHereShareDeviceMsg::CVirtualHereShareDeviceMsg(const CVirtualHereShareDeviceMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_address()) {
    device_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_address(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CVirtualHereShareDeviceMsg)
}

inline void CVirtualHereShareDeviceMsg::SharedCtor() {
device_address_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CVirtualHereShareDeviceMsg::~CVirtualHereShareDeviceMsg() {
  // @@protoc_insertion_point(destructor:CVirtualHereShareDeviceMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVirtualHereShareDeviceMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_address_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CVirtualHereShareDeviceMsg::ArenaDtor(void* object) {
  CVirtualHereShareDeviceMsg* _this = reinterpret_cast< CVirtualHereShareDeviceMsg* >(object);
  (void)_this;
}
void CVirtualHereShareDeviceMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVirtualHereShareDeviceMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVirtualHereShareDeviceMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CVirtualHereShareDeviceMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    device_address_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVirtualHereShareDeviceMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_address();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CVirtualHereShareDeviceMsg.device_address");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVirtualHereShareDeviceMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVirtualHereShareDeviceMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_address = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_address().data(), static_cast<int>(this->_internal_device_address().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CVirtualHereShareDeviceMsg.device_address");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_address(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVirtualHereShareDeviceMsg)
  return target;
}

size_t CVirtualHereShareDeviceMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVirtualHereShareDeviceMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string device_address = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_address());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVirtualHereShareDeviceMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVirtualHereShareDeviceMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVirtualHereShareDeviceMsg::GetClassData() const { return &_class_data_; }

void CVirtualHereShareDeviceMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVirtualHereShareDeviceMsg *>(to)->MergeFrom(
      static_cast<const CVirtualHereShareDeviceMsg &>(from));
}


void CVirtualHereShareDeviceMsg::MergeFrom(const CVirtualHereShareDeviceMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVirtualHereShareDeviceMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_device_address()) {
    _internal_set_device_address(from._internal_device_address());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVirtualHereShareDeviceMsg::CopyFrom(const CVirtualHereShareDeviceMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVirtualHereShareDeviceMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVirtualHereShareDeviceMsg::IsInitialized() const {
  return true;
}

void CVirtualHereShareDeviceMsg::InternalSwap(CVirtualHereShareDeviceMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_address_, lhs_arena,
      &other->device_address_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CVirtualHereShareDeviceMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[74]);
}

// ===================================================================

class CSetSpectatorModeMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetSpectatorModeMsg>()._has_bits_);
  static void set_has_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetSpectatorModeMsg::CSetSpectatorModeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetSpectatorModeMsg)
}
CSetSpectatorModeMsg::CSetSpectatorModeMsg(const CSetSpectatorModeMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  enabled_ = from.enabled_;
  // @@protoc_insertion_point(copy_constructor:CSetSpectatorModeMsg)
}

inline void CSetSpectatorModeMsg::SharedCtor() {
enabled_ = false;
}

CSetSpectatorModeMsg::~CSetSpectatorModeMsg() {
  // @@protoc_insertion_point(destructor:CSetSpectatorModeMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetSpectatorModeMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetSpectatorModeMsg::ArenaDtor(void* object) {
  CSetSpectatorModeMsg* _this = reinterpret_cast< CSetSpectatorModeMsg* >(object);
  (void)_this;
}
void CSetSpectatorModeMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetSpectatorModeMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetSpectatorModeMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetSpectatorModeMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetSpectatorModeMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool enabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_enabled(&has_bits);
          enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetSpectatorModeMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetSpectatorModeMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool enabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_enabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetSpectatorModeMsg)
  return target;
}

size_t CSetSpectatorModeMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetSpectatorModeMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool enabled = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetSpectatorModeMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetSpectatorModeMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetSpectatorModeMsg::GetClassData() const { return &_class_data_; }

void CSetSpectatorModeMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetSpectatorModeMsg *>(to)->MergeFrom(
      static_cast<const CSetSpectatorModeMsg &>(from));
}


void CSetSpectatorModeMsg::MergeFrom(const CSetSpectatorModeMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetSpectatorModeMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_enabled()) {
    _internal_set_enabled(from._internal_enabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetSpectatorModeMsg::CopyFrom(const CSetSpectatorModeMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetSpectatorModeMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetSpectatorModeMsg::IsInitialized() const {
  return true;
}

void CSetSpectatorModeMsg::InternalSwap(CSetSpectatorModeMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(enabled_, other->enabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetSpectatorModeMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[75]);
}

// ===================================================================

class CRemoteHIDMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CRemoteHIDMsg>()._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_active_input(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CRemoteHIDMsg::CRemoteHIDMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CRemoteHIDMsg)
}
CRemoteHIDMsg::CRemoteHIDMsg(const CRemoteHIDMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  active_input_ = from.active_input_;
  // @@protoc_insertion_point(copy_constructor:CRemoteHIDMsg)
}

inline void CRemoteHIDMsg::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
active_input_ = false;
}

CRemoteHIDMsg::~CRemoteHIDMsg() {
  // @@protoc_insertion_point(destructor:CRemoteHIDMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CRemoteHIDMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CRemoteHIDMsg::ArenaDtor(void* object) {
  CRemoteHIDMsg* _this = reinterpret_cast< CRemoteHIDMsg* >(object);
  (void)_this;
}
void CRemoteHIDMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CRemoteHIDMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CRemoteHIDMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CRemoteHIDMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  active_input_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CRemoteHIDMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool active_input = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_active_input(&has_bits);
          active_input_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CRemoteHIDMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CRemoteHIDMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  // optional bool active_input = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_active_input(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CRemoteHIDMsg)
  return target;
}

size_t CRemoteHIDMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CRemoteHIDMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bool active_input = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CRemoteHIDMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CRemoteHIDMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CRemoteHIDMsg::GetClassData() const { return &_class_data_; }

void CRemoteHIDMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CRemoteHIDMsg *>(to)->MergeFrom(
      static_cast<const CRemoteHIDMsg &>(from));
}


void CRemoteHIDMsg::MergeFrom(const CRemoteHIDMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CRemoteHIDMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      active_input_ = from.active_input_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CRemoteHIDMsg::CopyFrom(const CRemoteHIDMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CRemoteHIDMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CRemoteHIDMsg::IsInitialized() const {
  return true;
}

void CRemoteHIDMsg::InternalSwap(CRemoteHIDMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(active_input_, other->active_input_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CRemoteHIDMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[76]);
}

// ===================================================================

class CTouchConfigActiveMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CTouchConfigActiveMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_creator(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CTouchConfigActiveMsg::CTouchConfigActiveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTouchConfigActiveMsg)
}
CTouchConfigActiveMsg::CTouchConfigActiveMsg(const CTouchConfigActiveMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&creator_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
  // @@protoc_insertion_point(copy_constructor:CTouchConfigActiveMsg)
}

inline void CTouchConfigActiveMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&creator_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
}

CTouchConfigActiveMsg::~CTouchConfigActiveMsg() {
  // @@protoc_insertion_point(destructor:CTouchConfigActiveMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTouchConfigActiveMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CTouchConfigActiveMsg::ArenaDtor(void* object) {
  CTouchConfigActiveMsg* _this = reinterpret_cast< CTouchConfigActiveMsg* >(object);
  (void)_this;
}
void CTouchConfigActiveMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTouchConfigActiveMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTouchConfigActiveMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CTouchConfigActiveMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&creator_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTouchConfigActiveMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_revision(&has_bits);
          revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 creator = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_creator(&has_bits);
          creator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTouchConfigActiveMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTouchConfigActiveMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 revision = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_revision(), target);
  }

  // optional uint64 creator = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_creator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTouchConfigActiveMsg)
  return target;
}

size_t CTouchConfigActiveMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTouchConfigActiveMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 revision = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_revision());
    }

    // optional uint64 creator = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_creator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTouchConfigActiveMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTouchConfigActiveMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTouchConfigActiveMsg::GetClassData() const { return &_class_data_; }

void CTouchConfigActiveMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTouchConfigActiveMsg *>(to)->MergeFrom(
      static_cast<const CTouchConfigActiveMsg &>(from));
}


void CTouchConfigActiveMsg::MergeFrom(const CTouchConfigActiveMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTouchConfigActiveMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      revision_ = from.revision_;
    }
    if (cached_has_bits & 0x00000004u) {
      creator_ = from.creator_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTouchConfigActiveMsg::CopyFrom(const CTouchConfigActiveMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTouchConfigActiveMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTouchConfigActiveMsg::IsInitialized() const {
  return true;
}

void CTouchConfigActiveMsg::InternalSwap(CTouchConfigActiveMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTouchConfigActiveMsg, creator_)
      + sizeof(CTouchConfigActiveMsg::creator_)
      - PROTOBUF_FIELD_OFFSET(CTouchConfigActiveMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CTouchConfigActiveMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[77]);
}

// ===================================================================

class CGetTouchConfigDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CGetTouchConfigDataMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGetTouchConfigDataMsg::CGetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGetTouchConfigDataMsg)
}
CGetTouchConfigDataMsg::CGetTouchConfigDataMsg(const CGetTouchConfigDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CGetTouchConfigDataMsg)
}

inline void CGetTouchConfigDataMsg::SharedCtor() {
appid_ = 0u;
}

CGetTouchConfigDataMsg::~CGetTouchConfigDataMsg() {
  // @@protoc_insertion_point(destructor:CGetTouchConfigDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGetTouchConfigDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CGetTouchConfigDataMsg::ArenaDtor(void* object) {
  CGetTouchConfigDataMsg* _this = reinterpret_cast< CGetTouchConfigDataMsg* >(object);
  (void)_this;
}
void CGetTouchConfigDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGetTouchConfigDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGetTouchConfigDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CGetTouchConfigDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGetTouchConfigDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGetTouchConfigDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGetTouchConfigDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGetTouchConfigDataMsg)
  return target;
}

size_t CGetTouchConfigDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGetTouchConfigDataMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint32 appid = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGetTouchConfigDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGetTouchConfigDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGetTouchConfigDataMsg::GetClassData() const { return &_class_data_; }

void CGetTouchConfigDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGetTouchConfigDataMsg *>(to)->MergeFrom(
      static_cast<const CGetTouchConfigDataMsg &>(from));
}


void CGetTouchConfigDataMsg::MergeFrom(const CGetTouchConfigDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGetTouchConfigDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_appid()) {
    _internal_set_appid(from._internal_appid());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGetTouchConfigDataMsg::CopyFrom(const CGetTouchConfigDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGetTouchConfigDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGetTouchConfigDataMsg::IsInitialized() const {
  return true;
}

void CGetTouchConfigDataMsg::InternalSwap(CGetTouchConfigDataMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGetTouchConfigDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[78]);
}

// ===================================================================

class CSetTouchConfigDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetTouchConfigDataMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_revision(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_layout(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_creator(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CSetTouchConfigDataMsg::CSetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetTouchConfigDataMsg)
}
CSetTouchConfigDataMsg::CSetTouchConfigDataMsg(const CSetTouchConfigDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  layout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_layout()) {
    layout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_layout(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&creator_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
  // @@protoc_insertion_point(copy_constructor:CSetTouchConfigDataMsg)
}

inline void CSetTouchConfigDataMsg::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
layout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&creator_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
}

CSetTouchConfigDataMsg::~CSetTouchConfigDataMsg() {
  // @@protoc_insertion_point(destructor:CSetTouchConfigDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetTouchConfigDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  layout_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetTouchConfigDataMsg::ArenaDtor(void* object) {
  CSetTouchConfigDataMsg* _this = reinterpret_cast< CSetTouchConfigDataMsg* >(object);
  (void)_this;
}
void CSetTouchConfigDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetTouchConfigDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetTouchConfigDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetTouchConfigDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      layout_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&creator_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(creator_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetTouchConfigDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 revision = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_revision(&has_bits);
          revision_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes layout = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_layout();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 creator = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_creator(&has_bits);
          creator_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetTouchConfigDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetTouchConfigDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 revision = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_revision(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional bytes layout = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_layout(), target);
  }

  // optional uint64 creator = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_creator(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetTouchConfigDataMsg)
  return target;
}

size_t CSetTouchConfigDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetTouchConfigDataMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional bytes layout = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_layout());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 revision = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_revision());
    }

    // optional uint64 creator = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_creator());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetTouchConfigDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetTouchConfigDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetTouchConfigDataMsg::GetClassData() const { return &_class_data_; }

void CSetTouchConfigDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetTouchConfigDataMsg *>(to)->MergeFrom(
      static_cast<const CSetTouchConfigDataMsg &>(from));
}


void CSetTouchConfigDataMsg::MergeFrom(const CSetTouchConfigDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetTouchConfigDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_layout(from._internal_layout());
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      revision_ = from.revision_;
    }
    if (cached_has_bits & 0x00000010u) {
      creator_ = from.creator_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetTouchConfigDataMsg::CopyFrom(const CSetTouchConfigDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetTouchConfigDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetTouchConfigDataMsg::IsInitialized() const {
  return true;
}

void CSetTouchConfigDataMsg::InternalSwap(CSetTouchConfigDataMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &layout_, lhs_arena,
      &other->layout_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSetTouchConfigDataMsg, creator_)
      + sizeof(CSetTouchConfigDataMsg::creator_)
      - PROTOBUF_FIELD_OFFSET(CSetTouchConfigDataMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetTouchConfigDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[79]);
}

// ===================================================================

class CSaveTouchConfigLayoutMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSaveTouchConfigLayoutMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_layout(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSaveTouchConfigLayoutMsg::CSaveTouchConfigLayoutMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSaveTouchConfigLayoutMsg)
}
CSaveTouchConfigLayoutMsg::CSaveTouchConfigLayoutMsg(const CSaveTouchConfigLayoutMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  layout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_layout()) {
    layout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_layout(), 
      GetArenaForAllocation());
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CSaveTouchConfigLayoutMsg)
}

inline void CSaveTouchConfigLayoutMsg::SharedCtor() {
layout_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
appid_ = 0u;
}

CSaveTouchConfigLayoutMsg::~CSaveTouchConfigLayoutMsg() {
  // @@protoc_insertion_point(destructor:CSaveTouchConfigLayoutMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSaveTouchConfigLayoutMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  layout_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSaveTouchConfigLayoutMsg::ArenaDtor(void* object) {
  CSaveTouchConfigLayoutMsg* _this = reinterpret_cast< CSaveTouchConfigLayoutMsg* >(object);
  (void)_this;
}
void CSaveTouchConfigLayoutMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSaveTouchConfigLayoutMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSaveTouchConfigLayoutMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSaveTouchConfigLayoutMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    layout_.ClearNonDefaultToEmpty();
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSaveTouchConfigLayoutMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes layout = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_layout();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSaveTouchConfigLayoutMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSaveTouchConfigLayoutMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional bytes layout = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_layout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSaveTouchConfigLayoutMsg)
  return target;
}

size_t CSaveTouchConfigLayoutMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSaveTouchConfigLayoutMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes layout = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_layout());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSaveTouchConfigLayoutMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSaveTouchConfigLayoutMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSaveTouchConfigLayoutMsg::GetClassData() const { return &_class_data_; }

void CSaveTouchConfigLayoutMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSaveTouchConfigLayoutMsg *>(to)->MergeFrom(
      static_cast<const CSaveTouchConfigLayoutMsg &>(from));
}


void CSaveTouchConfigLayoutMsg::MergeFrom(const CSaveTouchConfigLayoutMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSaveTouchConfigLayoutMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_layout(from._internal_layout());
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSaveTouchConfigLayoutMsg::CopyFrom(const CSaveTouchConfigLayoutMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSaveTouchConfigLayoutMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSaveTouchConfigLayoutMsg::IsInitialized() const {
  return true;
}

void CSaveTouchConfigLayoutMsg::InternalSwap(CSaveTouchConfigLayoutMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &layout_, lhs_arena,
      &other->layout_, rhs_arena
  );
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSaveTouchConfigLayoutMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[80]);
}

// ===================================================================

class CTouchActionSetActiveMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CTouchActionSetActiveMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_actionset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CTouchActionSetActiveMsg::CTouchActionSetActiveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTouchActionSetActiveMsg)
}
CTouchActionSetActiveMsg::CTouchActionSetActiveMsg(const CTouchActionSetActiveMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  // @@protoc_insertion_point(copy_constructor:CTouchActionSetActiveMsg)
}

inline void CTouchActionSetActiveMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
}

CTouchActionSetActiveMsg::~CTouchActionSetActiveMsg() {
  // @@protoc_insertion_point(destructor:CTouchActionSetActiveMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTouchActionSetActiveMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CTouchActionSetActiveMsg::ArenaDtor(void* object) {
  CTouchActionSetActiveMsg* _this = reinterpret_cast< CTouchActionSetActiveMsg* >(object);
  (void)_this;
}
void CTouchActionSetActiveMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTouchActionSetActiveMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTouchActionSetActiveMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CTouchActionSetActiveMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&actionset_id_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTouchActionSetActiveMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 actionset_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_actionset_id(&has_bits);
          actionset_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTouchActionSetActiveMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTouchActionSetActiveMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional int32 actionset_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_actionset_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTouchActionSetActiveMsg)
  return target;
}

size_t CTouchActionSetActiveMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTouchActionSetActiveMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional int32 actionset_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_actionset_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTouchActionSetActiveMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTouchActionSetActiveMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTouchActionSetActiveMsg::GetClassData() const { return &_class_data_; }

void CTouchActionSetActiveMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTouchActionSetActiveMsg *>(to)->MergeFrom(
      static_cast<const CTouchActionSetActiveMsg &>(from));
}


void CTouchActionSetActiveMsg::MergeFrom(const CTouchActionSetActiveMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTouchActionSetActiveMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      actionset_id_ = from.actionset_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTouchActionSetActiveMsg::CopyFrom(const CTouchActionSetActiveMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTouchActionSetActiveMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTouchActionSetActiveMsg::IsInitialized() const {
  return true;
}

void CTouchActionSetActiveMsg::InternalSwap(CTouchActionSetActiveMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTouchActionSetActiveMsg, actionset_id_)
      + sizeof(CTouchActionSetActiveMsg::actionset_id_)
      - PROTOBUF_FIELD_OFFSET(CTouchActionSetActiveMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CTouchActionSetActiveMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[81]);
}

// ===================================================================

class CTouchActionSetLayerAddedMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CTouchActionSetLayerAddedMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_actionset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CTouchActionSetLayerAddedMsg::CTouchActionSetLayerAddedMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTouchActionSetLayerAddedMsg)
}
CTouchActionSetLayerAddedMsg::CTouchActionSetLayerAddedMsg(const CTouchActionSetLayerAddedMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  // @@protoc_insertion_point(copy_constructor:CTouchActionSetLayerAddedMsg)
}

inline void CTouchActionSetLayerAddedMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
}

CTouchActionSetLayerAddedMsg::~CTouchActionSetLayerAddedMsg() {
  // @@protoc_insertion_point(destructor:CTouchActionSetLayerAddedMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTouchActionSetLayerAddedMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CTouchActionSetLayerAddedMsg::ArenaDtor(void* object) {
  CTouchActionSetLayerAddedMsg* _this = reinterpret_cast< CTouchActionSetLayerAddedMsg* >(object);
  (void)_this;
}
void CTouchActionSetLayerAddedMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTouchActionSetLayerAddedMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTouchActionSetLayerAddedMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CTouchActionSetLayerAddedMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&actionset_id_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTouchActionSetLayerAddedMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 actionset_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_actionset_id(&has_bits);
          actionset_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTouchActionSetLayerAddedMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTouchActionSetLayerAddedMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional int32 actionset_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_actionset_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTouchActionSetLayerAddedMsg)
  return target;
}

size_t CTouchActionSetLayerAddedMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTouchActionSetLayerAddedMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional int32 actionset_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_actionset_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTouchActionSetLayerAddedMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTouchActionSetLayerAddedMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTouchActionSetLayerAddedMsg::GetClassData() const { return &_class_data_; }

void CTouchActionSetLayerAddedMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTouchActionSetLayerAddedMsg *>(to)->MergeFrom(
      static_cast<const CTouchActionSetLayerAddedMsg &>(from));
}


void CTouchActionSetLayerAddedMsg::MergeFrom(const CTouchActionSetLayerAddedMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTouchActionSetLayerAddedMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      actionset_id_ = from.actionset_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTouchActionSetLayerAddedMsg::CopyFrom(const CTouchActionSetLayerAddedMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTouchActionSetLayerAddedMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTouchActionSetLayerAddedMsg::IsInitialized() const {
  return true;
}

void CTouchActionSetLayerAddedMsg::InternalSwap(CTouchActionSetLayerAddedMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTouchActionSetLayerAddedMsg, actionset_id_)
      + sizeof(CTouchActionSetLayerAddedMsg::actionset_id_)
      - PROTOBUF_FIELD_OFFSET(CTouchActionSetLayerAddedMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CTouchActionSetLayerAddedMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[82]);
}

// ===================================================================

class CTouchActionSetLayerRemovedMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CTouchActionSetLayerRemovedMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_actionset_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CTouchActionSetLayerRemovedMsg::CTouchActionSetLayerRemovedMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTouchActionSetLayerRemovedMsg)
}
CTouchActionSetLayerRemovedMsg::CTouchActionSetLayerRemovedMsg(const CTouchActionSetLayerRemovedMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  // @@protoc_insertion_point(copy_constructor:CTouchActionSetLayerRemovedMsg)
}

inline void CTouchActionSetLayerRemovedMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&actionset_id_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
}

CTouchActionSetLayerRemovedMsg::~CTouchActionSetLayerRemovedMsg() {
  // @@protoc_insertion_point(destructor:CTouchActionSetLayerRemovedMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTouchActionSetLayerRemovedMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CTouchActionSetLayerRemovedMsg::ArenaDtor(void* object) {
  CTouchActionSetLayerRemovedMsg* _this = reinterpret_cast< CTouchActionSetLayerRemovedMsg* >(object);
  (void)_this;
}
void CTouchActionSetLayerRemovedMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTouchActionSetLayerRemovedMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTouchActionSetLayerRemovedMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CTouchActionSetLayerRemovedMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&actionset_id_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(actionset_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTouchActionSetLayerRemovedMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 actionset_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_actionset_id(&has_bits);
          actionset_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTouchActionSetLayerRemovedMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTouchActionSetLayerRemovedMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional int32 actionset_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_actionset_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTouchActionSetLayerRemovedMsg)
  return target;
}

size_t CTouchActionSetLayerRemovedMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTouchActionSetLayerRemovedMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional int32 actionset_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_actionset_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTouchActionSetLayerRemovedMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTouchActionSetLayerRemovedMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTouchActionSetLayerRemovedMsg::GetClassData() const { return &_class_data_; }

void CTouchActionSetLayerRemovedMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTouchActionSetLayerRemovedMsg *>(to)->MergeFrom(
      static_cast<const CTouchActionSetLayerRemovedMsg &>(from));
}


void CTouchActionSetLayerRemovedMsg::MergeFrom(const CTouchActionSetLayerRemovedMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTouchActionSetLayerRemovedMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      actionset_id_ = from.actionset_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTouchActionSetLayerRemovedMsg::CopyFrom(const CTouchActionSetLayerRemovedMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTouchActionSetLayerRemovedMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTouchActionSetLayerRemovedMsg::IsInitialized() const {
  return true;
}

void CTouchActionSetLayerRemovedMsg::InternalSwap(CTouchActionSetLayerRemovedMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CTouchActionSetLayerRemovedMsg, actionset_id_)
      + sizeof(CTouchActionSetLayerRemovedMsg::actionset_id_)
      - PROTOBUF_FIELD_OFFSET(CTouchActionSetLayerRemovedMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CTouchActionSetLayerRemovedMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[83]);
}

// ===================================================================

class CGetTouchIconDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CGetTouchIconDataMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CGetTouchIconDataMsg::CGetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CGetTouchIconDataMsg)
}
CGetTouchIconDataMsg::CGetTouchIconDataMsg(const CGetTouchIconDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_icon()) {
    icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_icon(), 
      GetArenaForAllocation());
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CGetTouchIconDataMsg)
}

inline void CGetTouchIconDataMsg::SharedCtor() {
icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
appid_ = 0u;
}

CGetTouchIconDataMsg::~CGetTouchIconDataMsg() {
  // @@protoc_insertion_point(destructor:CGetTouchIconDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CGetTouchIconDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  icon_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CGetTouchIconDataMsg::ArenaDtor(void* object) {
  CGetTouchIconDataMsg* _this = reinterpret_cast< CGetTouchIconDataMsg* >(object);
  (void)_this;
}
void CGetTouchIconDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CGetTouchIconDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CGetTouchIconDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CGetTouchIconDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    icon_.ClearNonDefaultToEmpty();
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CGetTouchIconDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string icon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_icon();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CGetTouchIconDataMsg.icon");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CGetTouchIconDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CGetTouchIconDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string icon = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CGetTouchIconDataMsg.icon");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_icon(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CGetTouchIconDataMsg)
  return target;
}

size_t CGetTouchIconDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CGetTouchIconDataMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string icon = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_icon());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CGetTouchIconDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CGetTouchIconDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CGetTouchIconDataMsg::GetClassData() const { return &_class_data_; }

void CGetTouchIconDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CGetTouchIconDataMsg *>(to)->MergeFrom(
      static_cast<const CGetTouchIconDataMsg &>(from));
}


void CGetTouchIconDataMsg::MergeFrom(const CGetTouchIconDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CGetTouchIconDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_icon(from._internal_icon());
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CGetTouchIconDataMsg::CopyFrom(const CGetTouchIconDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CGetTouchIconDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CGetTouchIconDataMsg::IsInitialized() const {
  return true;
}

void CGetTouchIconDataMsg::InternalSwap(CGetTouchIconDataMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &icon_, lhs_arena,
      &other->icon_, rhs_arena
  );
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CGetTouchIconDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[84]);
}

// ===================================================================

class CSetTouchIconDataMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetTouchIconDataMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_icon(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSetTouchIconDataMsg::CSetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetTouchIconDataMsg)
}
CSetTouchIconDataMsg::CSetTouchIconDataMsg(const CSetTouchIconDataMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_icon()) {
    icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_icon(), 
      GetArenaForAllocation());
  }
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CSetTouchIconDataMsg)
}

inline void CSetTouchIconDataMsg::SharedCtor() {
icon_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
appid_ = 0u;
}

CSetTouchIconDataMsg::~CSetTouchIconDataMsg() {
  // @@protoc_insertion_point(destructor:CSetTouchIconDataMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetTouchIconDataMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  icon_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CSetTouchIconDataMsg::ArenaDtor(void* object) {
  CSetTouchIconDataMsg* _this = reinterpret_cast< CSetTouchIconDataMsg* >(object);
  (void)_this;
}
void CSetTouchIconDataMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetTouchIconDataMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetTouchIconDataMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetTouchIconDataMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      icon_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      data_.ClearNonDefaultToEmpty();
    }
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetTouchIconDataMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string icon = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_icon();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSetTouchIconDataMsg.icon");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetTouchIconDataMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetTouchIconDataMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string icon = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_icon().data(), static_cast<int>(this->_internal_icon().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSetTouchIconDataMsg.icon");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_icon(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetTouchIconDataMsg)
  return target;
}

size_t CSetTouchIconDataMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetTouchIconDataMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string icon = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_icon());
    }

    // optional bytes data = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetTouchIconDataMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetTouchIconDataMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetTouchIconDataMsg::GetClassData() const { return &_class_data_; }

void CSetTouchIconDataMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetTouchIconDataMsg *>(to)->MergeFrom(
      static_cast<const CSetTouchIconDataMsg &>(from));
}


void CSetTouchIconDataMsg::MergeFrom(const CSetTouchIconDataMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetTouchIconDataMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_icon(from._internal_icon());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetTouchIconDataMsg::CopyFrom(const CSetTouchIconDataMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetTouchIconDataMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetTouchIconDataMsg::IsInitialized() const {
  return true;
}

void CSetTouchIconDataMsg::InternalSwap(CSetTouchIconDataMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &icon_, lhs_arena,
      &other->icon_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetTouchIconDataMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[85]);
}

// ===================================================================

class CRemotePlayTogetherGroupUpdateMsg_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CRemotePlayTogetherGroupUpdateMsg_Player>()._has_bits_);
  static void set_has_accountid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_guestid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_keyboard_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_mouse_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_controller_enabled(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_avatar_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CRemotePlayTogetherGroupUpdateMsg_Player::CRemotePlayTogetherGroupUpdateMsg_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  controller_slots_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CRemotePlayTogetherGroupUpdateMsg.Player)
}
CRemotePlayTogetherGroupUpdateMsg_Player::CRemotePlayTogetherGroupUpdateMsg_Player(const CRemotePlayTogetherGroupUpdateMsg_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      controller_slots_(from.controller_slots_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  avatar_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_hash()) {
    avatar_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&accountid_, &from.accountid_,
    static_cast<size_t>(reinterpret_cast<char*>(&controller_enabled_) -
    reinterpret_cast<char*>(&accountid_)) + sizeof(controller_enabled_));
  // @@protoc_insertion_point(copy_constructor:CRemotePlayTogetherGroupUpdateMsg.Player)
}

inline void CRemotePlayTogetherGroupUpdateMsg_Player::SharedCtor() {
avatar_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&accountid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controller_enabled_) -
    reinterpret_cast<char*>(&accountid_)) + sizeof(controller_enabled_));
}

CRemotePlayTogetherGroupUpdateMsg_Player::~CRemotePlayTogetherGroupUpdateMsg_Player() {
  // @@protoc_insertion_point(destructor:CRemotePlayTogetherGroupUpdateMsg.Player)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CRemotePlayTogetherGroupUpdateMsg_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  avatar_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CRemotePlayTogetherGroupUpdateMsg_Player::ArenaDtor(void* object) {
  CRemotePlayTogetherGroupUpdateMsg_Player* _this = reinterpret_cast< CRemotePlayTogetherGroupUpdateMsg_Player* >(object);
  (void)_this;
}
void CRemotePlayTogetherGroupUpdateMsg_Player::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CRemotePlayTogetherGroupUpdateMsg_Player::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CRemotePlayTogetherGroupUpdateMsg_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CRemotePlayTogetherGroupUpdateMsg.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  controller_slots_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    avatar_hash_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&accountid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&controller_enabled_) -
        reinterpret_cast<char*>(&accountid_)) + sizeof(controller_enabled_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CRemotePlayTogetherGroupUpdateMsg_Player::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 accountid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_accountid(&has_bits);
          accountid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 guestid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_guestid(&has_bits);
          guestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool keyboard_enabled = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_keyboard_enabled(&has_bits);
          keyboard_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool mouse_enabled = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_mouse_enabled(&has_bits);
          mouse_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool controller_enabled = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_controller_enabled(&has_bits);
          controller_enabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 controller_slots = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_controller_slots(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<48>(ptr));
        } else if (static_cast<uint8_t>(tag) == 50) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_controller_slots(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes avatar_hash = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_avatar_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CRemotePlayTogetherGroupUpdateMsg_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CRemotePlayTogetherGroupUpdateMsg.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 accountid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_accountid(), target);
  }

  // optional uint32 guestid = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_guestid(), target);
  }

  // optional bool keyboard_enabled = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_keyboard_enabled(), target);
  }

  // optional bool mouse_enabled = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(4, this->_internal_mouse_enabled(), target);
  }

  // optional bool controller_enabled = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_controller_enabled(), target);
  }

  // repeated uint32 controller_slots = 6;
  for (int i = 0, n = this->_internal_controller_slots_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_controller_slots(i), target);
  }

  // optional bytes avatar_hash = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_avatar_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CRemotePlayTogetherGroupUpdateMsg.Player)
  return target;
}

size_t CRemotePlayTogetherGroupUpdateMsg_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CRemotePlayTogetherGroupUpdateMsg.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 controller_slots = 6;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->controller_slots_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_controller_slots_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes avatar_hash = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_avatar_hash());
    }

    // optional uint32 accountid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_accountid());
    }

    // optional uint32 guestid = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_guestid());
    }

    // optional bool keyboard_enabled = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool mouse_enabled = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional bool controller_enabled = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CRemotePlayTogetherGroupUpdateMsg_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CRemotePlayTogetherGroupUpdateMsg_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CRemotePlayTogetherGroupUpdateMsg_Player::GetClassData() const { return &_class_data_; }

void CRemotePlayTogetherGroupUpdateMsg_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CRemotePlayTogetherGroupUpdateMsg_Player *>(to)->MergeFrom(
      static_cast<const CRemotePlayTogetherGroupUpdateMsg_Player &>(from));
}


void CRemotePlayTogetherGroupUpdateMsg_Player::MergeFrom(const CRemotePlayTogetherGroupUpdateMsg_Player& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CRemotePlayTogetherGroupUpdateMsg.Player)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  controller_slots_.MergeFrom(from.controller_slots_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_avatar_hash(from._internal_avatar_hash());
    }
    if (cached_has_bits & 0x00000002u) {
      accountid_ = from.accountid_;
    }
    if (cached_has_bits & 0x00000004u) {
      guestid_ = from.guestid_;
    }
    if (cached_has_bits & 0x00000008u) {
      keyboard_enabled_ = from.keyboard_enabled_;
    }
    if (cached_has_bits & 0x00000010u) {
      mouse_enabled_ = from.mouse_enabled_;
    }
    if (cached_has_bits & 0x00000020u) {
      controller_enabled_ = from.controller_enabled_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CRemotePlayTogetherGroupUpdateMsg_Player::CopyFrom(const CRemotePlayTogetherGroupUpdateMsg_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CRemotePlayTogetherGroupUpdateMsg.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CRemotePlayTogetherGroupUpdateMsg_Player::IsInitialized() const {
  return true;
}

void CRemotePlayTogetherGroupUpdateMsg_Player::InternalSwap(CRemotePlayTogetherGroupUpdateMsg_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  controller_slots_.InternalSwap(&other->controller_slots_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_hash_, lhs_arena,
      &other->avatar_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CRemotePlayTogetherGroupUpdateMsg_Player, controller_enabled_)
      + sizeof(CRemotePlayTogetherGroupUpdateMsg_Player::controller_enabled_)
      - PROTOBUF_FIELD_OFFSET(CRemotePlayTogetherGroupUpdateMsg_Player, accountid_)>(
          reinterpret_cast<char*>(&accountid_),
          reinterpret_cast<char*>(&other->accountid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CRemotePlayTogetherGroupUpdateMsg_Player::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[86]);
}

// ===================================================================

class CRemotePlayTogetherGroupUpdateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CRemotePlayTogetherGroupUpdateMsg>()._has_bits_);
  static void set_has_player_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_miniprofile_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_game_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_avatar_location(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CRemotePlayTogetherGroupUpdateMsg::CRemotePlayTogetherGroupUpdateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  players_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CRemotePlayTogetherGroupUpdateMsg)
}
CRemotePlayTogetherGroupUpdateMsg::CRemotePlayTogetherGroupUpdateMsg(const CRemotePlayTogetherGroupUpdateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      players_(from.players_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  miniprofile_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    miniprofile_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_miniprofile_location()) {
    miniprofile_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_miniprofile_location(), 
      GetArenaForAllocation());
  }
  game_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_name()) {
    game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_game_name(), 
      GetArenaForAllocation());
  }
  avatar_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    avatar_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_avatar_location()) {
    avatar_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_avatar_location(), 
      GetArenaForAllocation());
  }
  player_index_ = from.player_index_;
  // @@protoc_insertion_point(copy_constructor:CRemotePlayTogetherGroupUpdateMsg)
}

inline void CRemotePlayTogetherGroupUpdateMsg::SharedCtor() {
miniprofile_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  miniprofile_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
game_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
avatar_location_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  avatar_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
player_index_ = 0;
}

CRemotePlayTogetherGroupUpdateMsg::~CRemotePlayTogetherGroupUpdateMsg() {
  // @@protoc_insertion_point(destructor:CRemotePlayTogetherGroupUpdateMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CRemotePlayTogetherGroupUpdateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  miniprofile_location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  game_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  avatar_location_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CRemotePlayTogetherGroupUpdateMsg::ArenaDtor(void* object) {
  CRemotePlayTogetherGroupUpdateMsg* _this = reinterpret_cast< CRemotePlayTogetherGroupUpdateMsg* >(object);
  (void)_this;
}
void CRemotePlayTogetherGroupUpdateMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CRemotePlayTogetherGroupUpdateMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CRemotePlayTogetherGroupUpdateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CRemotePlayTogetherGroupUpdateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  players_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      miniprofile_location_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      game_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      avatar_location_.ClearNonDefaultToEmpty();
    }
  }
  player_index_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CRemotePlayTogetherGroupUpdateMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_player_index(&has_bits);
          player_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string miniprofile_location = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_miniprofile_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CRemotePlayTogetherGroupUpdateMsg.miniprofile_location");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string game_name = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_game_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CRemotePlayTogetherGroupUpdateMsg.game_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string avatar_location = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_avatar_location();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CRemotePlayTogetherGroupUpdateMsg.avatar_location");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CRemotePlayTogetherGroupUpdateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CRemotePlayTogetherGroupUpdateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_players_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_players(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 player_index = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_player_index(), target);
  }

  // optional string miniprofile_location = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_miniprofile_location().data(), static_cast<int>(this->_internal_miniprofile_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CRemotePlayTogetherGroupUpdateMsg.miniprofile_location");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_miniprofile_location(), target);
  }

  // optional string game_name = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_name().data(), static_cast<int>(this->_internal_game_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CRemotePlayTogetherGroupUpdateMsg.game_name");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_game_name(), target);
  }

  // optional string avatar_location = 5;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_avatar_location().data(), static_cast<int>(this->_internal_avatar_location().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CRemotePlayTogetherGroupUpdateMsg.avatar_location");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_avatar_location(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CRemotePlayTogetherGroupUpdateMsg)
  return target;
}

size_t CRemotePlayTogetherGroupUpdateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CRemotePlayTogetherGroupUpdateMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;
  total_size += 1UL * this->_internal_players_size();
  for (const auto& msg : this->players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string miniprofile_location = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_miniprofile_location());
    }

    // optional string game_name = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_name());
    }

    // optional string avatar_location = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_avatar_location());
    }

    // optional int32 player_index = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_player_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CRemotePlayTogetherGroupUpdateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CRemotePlayTogetherGroupUpdateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CRemotePlayTogetherGroupUpdateMsg::GetClassData() const { return &_class_data_; }

void CRemotePlayTogetherGroupUpdateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CRemotePlayTogetherGroupUpdateMsg *>(to)->MergeFrom(
      static_cast<const CRemotePlayTogetherGroupUpdateMsg &>(from));
}


void CRemotePlayTogetherGroupUpdateMsg::MergeFrom(const CRemotePlayTogetherGroupUpdateMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CRemotePlayTogetherGroupUpdateMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  players_.MergeFrom(from.players_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_miniprofile_location(from._internal_miniprofile_location());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_game_name(from._internal_game_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_avatar_location(from._internal_avatar_location());
    }
    if (cached_has_bits & 0x00000008u) {
      player_index_ = from.player_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CRemotePlayTogetherGroupUpdateMsg::CopyFrom(const CRemotePlayTogetherGroupUpdateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CRemotePlayTogetherGroupUpdateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CRemotePlayTogetherGroupUpdateMsg::IsInitialized() const {
  return true;
}

void CRemotePlayTogetherGroupUpdateMsg::InternalSwap(CRemotePlayTogetherGroupUpdateMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  players_.InternalSwap(&other->players_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &miniprofile_location_, lhs_arena,
      &other->miniprofile_location_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &game_name_, lhs_arena,
      &other->game_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &avatar_location_, lhs_arena,
      &other->avatar_location_, rhs_arena
  );
  swap(player_index_, other->player_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CRemotePlayTogetherGroupUpdateMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[87]);
}

// ===================================================================

class CSetInputTemporarilyDisabledMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetInputTemporarilyDisabledMsg>()._has_bits_);
  static void set_has_disabled(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetInputTemporarilyDisabledMsg::CSetInputTemporarilyDisabledMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetInputTemporarilyDisabledMsg)
}
CSetInputTemporarilyDisabledMsg::CSetInputTemporarilyDisabledMsg(const CSetInputTemporarilyDisabledMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  disabled_ = from.disabled_;
  // @@protoc_insertion_point(copy_constructor:CSetInputTemporarilyDisabledMsg)
}

inline void CSetInputTemporarilyDisabledMsg::SharedCtor() {
disabled_ = false;
}

CSetInputTemporarilyDisabledMsg::~CSetInputTemporarilyDisabledMsg() {
  // @@protoc_insertion_point(destructor:CSetInputTemporarilyDisabledMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetInputTemporarilyDisabledMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetInputTemporarilyDisabledMsg::ArenaDtor(void* object) {
  CSetInputTemporarilyDisabledMsg* _this = reinterpret_cast< CSetInputTemporarilyDisabledMsg* >(object);
  (void)_this;
}
void CSetInputTemporarilyDisabledMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetInputTemporarilyDisabledMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetInputTemporarilyDisabledMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetInputTemporarilyDisabledMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  disabled_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetInputTemporarilyDisabledMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool disabled = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_disabled(&has_bits);
          disabled_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetInputTemporarilyDisabledMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetInputTemporarilyDisabledMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool disabled = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_disabled(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetInputTemporarilyDisabledMsg)
  return target;
}

size_t CSetInputTemporarilyDisabledMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetInputTemporarilyDisabledMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool disabled = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetInputTemporarilyDisabledMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetInputTemporarilyDisabledMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetInputTemporarilyDisabledMsg::GetClassData() const { return &_class_data_; }

void CSetInputTemporarilyDisabledMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetInputTemporarilyDisabledMsg *>(to)->MergeFrom(
      static_cast<const CSetInputTemporarilyDisabledMsg &>(from));
}


void CSetInputTemporarilyDisabledMsg::MergeFrom(const CSetInputTemporarilyDisabledMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetInputTemporarilyDisabledMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_disabled()) {
    _internal_set_disabled(from._internal_disabled());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetInputTemporarilyDisabledMsg::CopyFrom(const CSetInputTemporarilyDisabledMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetInputTemporarilyDisabledMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetInputTemporarilyDisabledMsg::IsInitialized() const {
  return true;
}

void CSetInputTemporarilyDisabledMsg::InternalSwap(CSetInputTemporarilyDisabledMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(disabled_, other->disabled_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetInputTemporarilyDisabledMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[88]);
}

// ===================================================================

class CSetQualityOverrideMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetQualityOverrideMsg>()._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetQualityOverrideMsg::CSetQualityOverrideMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetQualityOverrideMsg)
}
CSetQualityOverrideMsg::CSetQualityOverrideMsg(const CSetQualityOverrideMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CSetQualityOverrideMsg)
}

inline void CSetQualityOverrideMsg::SharedCtor() {
value_ = 0;
}

CSetQualityOverrideMsg::~CSetQualityOverrideMsg() {
  // @@protoc_insertion_point(destructor:CSetQualityOverrideMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetQualityOverrideMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetQualityOverrideMsg::ArenaDtor(void* object) {
  CSetQualityOverrideMsg* _this = reinterpret_cast< CSetQualityOverrideMsg* >(object);
  (void)_this;
}
void CSetQualityOverrideMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetQualityOverrideMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetQualityOverrideMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetQualityOverrideMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetQualityOverrideMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetQualityOverrideMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetQualityOverrideMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetQualityOverrideMsg)
  return target;
}

size_t CSetQualityOverrideMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetQualityOverrideMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 value = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetQualityOverrideMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetQualityOverrideMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetQualityOverrideMsg::GetClassData() const { return &_class_data_; }

void CSetQualityOverrideMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetQualityOverrideMsg *>(to)->MergeFrom(
      static_cast<const CSetQualityOverrideMsg &>(from));
}


void CSetQualityOverrideMsg::MergeFrom(const CSetQualityOverrideMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetQualityOverrideMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetQualityOverrideMsg::CopyFrom(const CSetQualityOverrideMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetQualityOverrideMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetQualityOverrideMsg::IsInitialized() const {
  return true;
}

void CSetQualityOverrideMsg::InternalSwap(CSetQualityOverrideMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetQualityOverrideMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[89]);
}

// ===================================================================

class CSetBitrateOverrideMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CSetBitrateOverrideMsg>()._has_bits_);
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSetBitrateOverrideMsg::CSetBitrateOverrideMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSetBitrateOverrideMsg)
}
CSetBitrateOverrideMsg::CSetBitrateOverrideMsg(const CSetBitrateOverrideMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  value_ = from.value_;
  // @@protoc_insertion_point(copy_constructor:CSetBitrateOverrideMsg)
}

inline void CSetBitrateOverrideMsg::SharedCtor() {
value_ = 0;
}

CSetBitrateOverrideMsg::~CSetBitrateOverrideMsg() {
  // @@protoc_insertion_point(destructor:CSetBitrateOverrideMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSetBitrateOverrideMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSetBitrateOverrideMsg::ArenaDtor(void* object) {
  CSetBitrateOverrideMsg* _this = reinterpret_cast< CSetBitrateOverrideMsg* >(object);
  (void)_this;
}
void CSetBitrateOverrideMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSetBitrateOverrideMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSetBitrateOverrideMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CSetBitrateOverrideMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  value_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSetBitrateOverrideMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 value = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_value(&has_bits);
          value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSetBitrateOverrideMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSetBitrateOverrideMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 value = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSetBitrateOverrideMsg)
  return target;
}

size_t CSetBitrateOverrideMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSetBitrateOverrideMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 value = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_value());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSetBitrateOverrideMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSetBitrateOverrideMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSetBitrateOverrideMsg::GetClassData() const { return &_class_data_; }

void CSetBitrateOverrideMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSetBitrateOverrideMsg *>(to)->MergeFrom(
      static_cast<const CSetBitrateOverrideMsg &>(from));
}


void CSetBitrateOverrideMsg::MergeFrom(const CSetBitrateOverrideMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSetBitrateOverrideMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_value()) {
    _internal_set_value(from._internal_value());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSetBitrateOverrideMsg::CopyFrom(const CSetBitrateOverrideMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSetBitrateOverrideMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSetBitrateOverrideMsg::IsInitialized() const {
  return true;
}

void CSetBitrateOverrideMsg::InternalSwap(CSetBitrateOverrideMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(value_, other->value_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSetBitrateOverrideMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[90]);
}

// ===================================================================

class CShowOnScreenKeyboardMsg::_Internal {
 public:
};

CShowOnScreenKeyboardMsg::CShowOnScreenKeyboardMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CShowOnScreenKeyboardMsg)
}
CShowOnScreenKeyboardMsg::CShowOnScreenKeyboardMsg(const CShowOnScreenKeyboardMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CShowOnScreenKeyboardMsg)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CShowOnScreenKeyboardMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CShowOnScreenKeyboardMsg::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CShowOnScreenKeyboardMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[91]);
}

// ===================================================================

class CControllerPersonalizationUpdateMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerPersonalizationUpdateMsg>()._has_bits_);
  static void set_has_controller_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controller_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_reverse_diamond_button_layout(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CControllerPersonalizationUpdateMsg::CControllerPersonalizationUpdateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerPersonalizationUpdateMsg)
}
CControllerPersonalizationUpdateMsg::CControllerPersonalizationUpdateMsg(const CControllerPersonalizationUpdateMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  controller_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controller_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_path()) {
    controller_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controller_path(), 
      GetArenaForAllocation());
  }
  controller_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controller_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controller_name()) {
    controller_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controller_name(), 
      GetArenaForAllocation());
  }
  reverse_diamond_button_layout_ = from.reverse_diamond_button_layout_;
  // @@protoc_insertion_point(copy_constructor:CControllerPersonalizationUpdateMsg)
}

inline void CControllerPersonalizationUpdateMsg::SharedCtor() {
controller_path_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controller_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
controller_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controller_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
reverse_diamond_button_layout_ = false;
}

CControllerPersonalizationUpdateMsg::~CControllerPersonalizationUpdateMsg() {
  // @@protoc_insertion_point(destructor:CControllerPersonalizationUpdateMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerPersonalizationUpdateMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  controller_path_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  controller_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CControllerPersonalizationUpdateMsg::ArenaDtor(void* object) {
  CControllerPersonalizationUpdateMsg* _this = reinterpret_cast< CControllerPersonalizationUpdateMsg* >(object);
  (void)_this;
}
void CControllerPersonalizationUpdateMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerPersonalizationUpdateMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerPersonalizationUpdateMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerPersonalizationUpdateMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      controller_path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      controller_name_.ClearNonDefaultToEmpty();
    }
  }
  reverse_diamond_button_layout_ = false;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerPersonalizationUpdateMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string controller_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_controller_path();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerPersonalizationUpdateMsg.controller_path");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controller_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controller_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerPersonalizationUpdateMsg.controller_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool reverse_diamond_button_layout = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_reverse_diamond_button_layout(&has_bits);
          reverse_diamond_button_layout_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerPersonalizationUpdateMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerPersonalizationUpdateMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string controller_path = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controller_path().data(), static_cast<int>(this->_internal_controller_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerPersonalizationUpdateMsg.controller_path");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_controller_path(), target);
  }

  // optional string controller_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controller_name().data(), static_cast<int>(this->_internal_controller_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerPersonalizationUpdateMsg.controller_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controller_name(), target);
  }

  // optional bool reverse_diamond_button_layout = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(3, this->_internal_reverse_diamond_button_layout(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerPersonalizationUpdateMsg)
  return target;
}

size_t CControllerPersonalizationUpdateMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerPersonalizationUpdateMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string controller_path = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_path());
    }

    // optional string controller_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controller_name());
    }

    // optional bool reverse_diamond_button_layout = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerPersonalizationUpdateMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerPersonalizationUpdateMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerPersonalizationUpdateMsg::GetClassData() const { return &_class_data_; }

void CControllerPersonalizationUpdateMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerPersonalizationUpdateMsg *>(to)->MergeFrom(
      static_cast<const CControllerPersonalizationUpdateMsg &>(from));
}


void CControllerPersonalizationUpdateMsg::MergeFrom(const CControllerPersonalizationUpdateMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerPersonalizationUpdateMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_controller_path(from._internal_controller_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_controller_name(from._internal_controller_name());
    }
    if (cached_has_bits & 0x00000004u) {
      reverse_diamond_button_layout_ = from.reverse_diamond_button_layout_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerPersonalizationUpdateMsg::CopyFrom(const CControllerPersonalizationUpdateMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerPersonalizationUpdateMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerPersonalizationUpdateMsg::IsInitialized() const {
  return true;
}

void CControllerPersonalizationUpdateMsg::InternalSwap(CControllerPersonalizationUpdateMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controller_path_, lhs_arena,
      &other->controller_path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controller_name_, lhs_arena,
      &other->controller_name_, rhs_arena
  );
  swap(reverse_diamond_button_layout_, other->reverse_diamond_button_layout_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerPersonalizationUpdateMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[92]);
}

// ===================================================================

class CStreamDataLostMsg::_Internal {
 public:
};

CStreamDataLostMsg::CStreamDataLostMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  packets_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamDataLostMsg)
}
CStreamDataLostMsg::CStreamDataLostMsg(const CStreamDataLostMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      packets_(from.packets_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CStreamDataLostMsg)
}

inline void CStreamDataLostMsg::SharedCtor() {
}

CStreamDataLostMsg::~CStreamDataLostMsg() {
  // @@protoc_insertion_point(destructor:CStreamDataLostMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamDataLostMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamDataLostMsg::ArenaDtor(void* object) {
  CStreamDataLostMsg* _this = reinterpret_cast< CStreamDataLostMsg* >(object);
  (void)_this;
}
void CStreamDataLostMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamDataLostMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamDataLostMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamDataLostMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  packets_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamDataLostMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 packets = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_packets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_packets(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamDataLostMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamDataLostMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 packets = 1;
  for (int i = 0, n = this->_internal_packets_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_packets(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamDataLostMsg)
  return target;
}

size_t CStreamDataLostMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamDataLostMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 packets = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->packets_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_packets_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamDataLostMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamDataLostMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamDataLostMsg::GetClassData() const { return &_class_data_; }

void CStreamDataLostMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamDataLostMsg *>(to)->MergeFrom(
      static_cast<const CStreamDataLostMsg &>(from));
}


void CStreamDataLostMsg::MergeFrom(const CStreamDataLostMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamDataLostMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  packets_.MergeFrom(from.packets_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamDataLostMsg::CopyFrom(const CStreamDataLostMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamDataLostMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamDataLostMsg::IsInitialized() const {
  return true;
}

void CStreamDataLostMsg::InternalSwap(CStreamDataLostMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  packets_.InternalSwap(&other->packets_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamDataLostMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[93]);
}

// ===================================================================

class CAudioFormat::_Internal {
 public:
  using HasBits = decltype(std::declval<CAudioFormat>()._has_bits_);
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_frequency(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channels(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CAudioFormat::CAudioFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAudioFormat)
}
CAudioFormat::CAudioFormat(const CAudioFormat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&format_, &from.format_,
    static_cast<size_t>(reinterpret_cast<char*>(&channels_) -
    reinterpret_cast<char*>(&format_)) + sizeof(channels_));
  // @@protoc_insertion_point(copy_constructor:CAudioFormat)
}

inline void CAudioFormat::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&format_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&channels_) -
    reinterpret_cast<char*>(&format_)) + sizeof(channels_));
}

CAudioFormat::~CAudioFormat() {
  // @@protoc_insertion_point(destructor:CAudioFormat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAudioFormat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAudioFormat::ArenaDtor(void* object) {
  CAudioFormat* _this = reinterpret_cast< CAudioFormat* >(object);
  (void)_this;
}
void CAudioFormat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAudioFormat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAudioFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:CAudioFormat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&format_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&channels_) -
        reinterpret_cast<char*>(&format_)) + sizeof(channels_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAudioFormat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAudioFormat_IsValid(val))) {
            _internal_set_format(static_cast<::EAudioFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 frequency = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_frequency(&has_bits);
          frequency_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 channels = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_channels(&has_bits);
          channels_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAudioFormat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAudioFormat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_format(), target);
  }

  // optional uint32 frequency = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_frequency(), target);
  }

  // optional uint32 channels = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_channels(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAudioFormat)
  return target;
}

size_t CAudioFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAudioFormat)
  size_t total_size = 0;

  // required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
  if (_internal_has_format()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 frequency = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frequency());
    }

    // optional uint32 channels = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_channels());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAudioFormat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAudioFormat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAudioFormat::GetClassData() const { return &_class_data_; }

void CAudioFormat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAudioFormat *>(to)->MergeFrom(
      static_cast<const CAudioFormat &>(from));
}


void CAudioFormat::MergeFrom(const CAudioFormat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAudioFormat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      format_ = from.format_;
    }
    if (cached_has_bits & 0x00000002u) {
      frequency_ = from.frequency_;
    }
    if (cached_has_bits & 0x00000004u) {
      channels_ = from.channels_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAudioFormat::CopyFrom(const CAudioFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAudioFormat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAudioFormat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CAudioFormat::InternalSwap(CAudioFormat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAudioFormat, channels_)
      + sizeof(CAudioFormat::channels_)
      - PROTOBUF_FIELD_OFFSET(CAudioFormat, format_)>(
          reinterpret_cast<char*>(&format_),
          reinterpret_cast<char*>(&other->format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAudioFormat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[94]);
}

// ===================================================================

class CVideoFormat::_Internal {
 public:
  using HasBits = decltype(std::declval<CVideoFormat>()._has_bits_);
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CVideoFormat::CVideoFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CVideoFormat)
}
CVideoFormat::CVideoFormat(const CVideoFormat& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&format_, &from.format_,
    static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&format_)) + sizeof(height_));
  // @@protoc_insertion_point(copy_constructor:CVideoFormat)
}

inline void CVideoFormat::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&format_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&height_) -
    reinterpret_cast<char*>(&format_)) + sizeof(height_));
}

CVideoFormat::~CVideoFormat() {
  // @@protoc_insertion_point(destructor:CVideoFormat)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CVideoFormat::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CVideoFormat::ArenaDtor(void* object) {
  CVideoFormat* _this = reinterpret_cast< CVideoFormat* >(object);
  (void)_this;
}
void CVideoFormat::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CVideoFormat::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CVideoFormat::Clear() {
// @@protoc_insertion_point(message_clear_start:CVideoFormat)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&format_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&height_) -
        reinterpret_cast<char*>(&format_)) + sizeof(height_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CVideoFormat::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EVideoFormat_IsValid(val))) {
            _internal_set_format(static_cast<::EVideoFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional uint32 width = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_width(&has_bits);
          width_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_height(&has_bits);
          height_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CVideoFormat::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CVideoFormat)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_format(), target);
  }

  // optional uint32 width = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_width(), target);
  }

  // optional uint32 height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_height(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CVideoFormat)
  return target;
}

size_t CVideoFormat::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CVideoFormat)
  size_t total_size = 0;

  // required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
  if (_internal_has_format()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_format());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000006u) {
    // optional uint32 width = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_width());
    }

    // optional uint32 height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_height());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CVideoFormat::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CVideoFormat::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CVideoFormat::GetClassData() const { return &_class_data_; }

void CVideoFormat::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CVideoFormat *>(to)->MergeFrom(
      static_cast<const CVideoFormat &>(from));
}


void CVideoFormat::MergeFrom(const CVideoFormat& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CVideoFormat)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      format_ = from.format_;
    }
    if (cached_has_bits & 0x00000002u) {
      width_ = from.width_;
    }
    if (cached_has_bits & 0x00000004u) {
      height_ = from.height_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CVideoFormat::CopyFrom(const CVideoFormat& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CVideoFormat)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CVideoFormat::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CVideoFormat::InternalSwap(CVideoFormat* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CVideoFormat, height_)
      + sizeof(CVideoFormat::height_)
      - PROTOBUF_FIELD_OFFSET(CVideoFormat, format_)>(
          reinterpret_cast<char*>(&format_),
          reinterpret_cast<char*>(&other->format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CVideoFormat::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[95]);
}

// ===================================================================

class CFrameEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CFrameEvent>()._has_bits_);
  static void set_has_event_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CFrameEvent::CFrameEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CFrameEvent)
}
CFrameEvent::CFrameEvent(const CFrameEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&event_id_, &from.event_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&event_id_)) + sizeof(timestamp_));
  // @@protoc_insertion_point(copy_constructor:CFrameEvent)
}

inline void CFrameEvent::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&event_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&timestamp_) -
    reinterpret_cast<char*>(&event_id_)) + sizeof(timestamp_));
}

CFrameEvent::~CFrameEvent() {
  // @@protoc_insertion_point(destructor:CFrameEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CFrameEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CFrameEvent::ArenaDtor(void* object) {
  CFrameEvent* _this = reinterpret_cast< CFrameEvent* >(object);
  (void)_this;
}
void CFrameEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CFrameEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CFrameEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CFrameEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&event_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&timestamp_) -
        reinterpret_cast<char*>(&event_id_)) + sizeof(timestamp_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CFrameEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamFrameEvent_IsValid(val))) {
            _internal_set_event_id(static_cast<::EStreamFrameEvent>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required uint32 timestamp = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CFrameEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CFrameEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_event_id(), target);
  }

  // required uint32 timestamp = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CFrameEvent)
  return target;
}

size_t CFrameEvent::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CFrameEvent)
  size_t total_size = 0;

  if (_internal_has_event_id()) {
    // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_id());
  }

  if (_internal_has_timestamp()) {
    // required uint32 timestamp = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());
  }

  return total_size;
}
size_t CFrameEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CFrameEvent)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_event_id());

    // required uint32 timestamp = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_timestamp());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CFrameEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CFrameEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CFrameEvent::GetClassData() const { return &_class_data_; }

void CFrameEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CFrameEvent *>(to)->MergeFrom(
      static_cast<const CFrameEvent &>(from));
}


void CFrameEvent::MergeFrom(const CFrameEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CFrameEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      event_id_ = from.event_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CFrameEvent::CopyFrom(const CFrameEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CFrameEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CFrameEvent::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CFrameEvent::InternalSwap(CFrameEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CFrameEvent, timestamp_)
      + sizeof(CFrameEvent::timestamp_)
      - PROTOBUF_FIELD_OFFSET(CFrameEvent, event_id_)>(
          reinterpret_cast<char*>(&event_id_),
          reinterpret_cast<char*>(&other->event_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CFrameEvent::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[96]);
}

// ===================================================================

class CFrameStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CFrameStats>()._has_bits_);
  static void set_has_frame_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_input_mark(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_result(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_frame_start_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_frame_display_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ping_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_server_bitrate(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_client_bitrate(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_link_bandwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_packet_loss(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_frame_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000005) ^ 0x00000005) != 0;
  }
};

CFrameStats::CFrameStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  events_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CFrameStats)
}
CFrameStats::CFrameStats(const CFrameStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      events_(from.events_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&frame_id_, &from.frame_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&frame_size_) -
    reinterpret_cast<char*>(&frame_id_)) + sizeof(frame_size_));
  // @@protoc_insertion_point(copy_constructor:CFrameStats)
}

inline void CFrameStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frame_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&frame_size_) -
    reinterpret_cast<char*>(&frame_id_)) + sizeof(frame_size_));
}

CFrameStats::~CFrameStats() {
  // @@protoc_insertion_point(destructor:CFrameStats)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CFrameStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CFrameStats::ArenaDtor(void* object) {
  CFrameStats* _this = reinterpret_cast< CFrameStats* >(object);
  (void)_this;
}
void CFrameStats::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CFrameStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CFrameStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CFrameStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  events_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&frame_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_bitrate_) -
        reinterpret_cast<char*>(&frame_id_)) + sizeof(client_bitrate_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&link_bandwidth_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&frame_size_) -
        reinterpret_cast<char*>(&link_bandwidth_)) + sizeof(frame_size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CFrameStats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 frame_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_frame_id(&has_bits);
          frame_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 input_mark = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_input_mark(&has_bits);
          input_mark_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CFrameEvent events = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_events(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamFrameResult_IsValid(val))) {
            _internal_set_result(static_cast<::EStreamFrameResult>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional float frame_start_delta = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_frame_start_delta(&has_bits);
          frame_start_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float frame_display_delta = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_frame_display_delta(&has_bits);
          frame_display_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float ping_time = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_ping_time(&has_bits);
          ping_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float server_bitrate = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_server_bitrate(&has_bits);
          server_bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float client_bitrate = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_client_bitrate(&has_bits);
          client_bitrate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float link_bandwidth = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_link_bandwidth(&has_bits);
          link_bandwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float packet_loss = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 93)) {
          _Internal::set_has_packet_loss(&has_bits);
          packet_loss_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 frame_size = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_frame_size(&has_bits);
          frame_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CFrameStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CFrameStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 frame_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_frame_id(), target);
  }

  // optional uint32 input_mark = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_input_mark(), target);
  }

  // repeated .CFrameEvent events = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_events_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_events(i), target, stream);
  }

  // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_result(), target);
  }

  // optional float frame_start_delta = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_frame_start_delta(), target);
  }

  // optional float frame_display_delta = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(6, this->_internal_frame_display_delta(), target);
  }

  // optional float ping_time = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(7, this->_internal_ping_time(), target);
  }

  // optional float server_bitrate = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(8, this->_internal_server_bitrate(), target);
  }

  // optional float client_bitrate = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(9, this->_internal_client_bitrate(), target);
  }

  // optional float link_bandwidth = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(10, this->_internal_link_bandwidth(), target);
  }

  // optional float packet_loss = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(11, this->_internal_packet_loss(), target);
  }

  // optional uint32 frame_size = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->_internal_frame_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CFrameStats)
  return target;
}

size_t CFrameStats::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CFrameStats)
  size_t total_size = 0;

  if (_internal_has_frame_id()) {
    // required uint32 frame_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_id());
  }

  if (_internal_has_result()) {
    // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());
  }

  return total_size;
}
size_t CFrameStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CFrameStats)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000005) ^ 0x00000005) == 0) {  // All required fields are present.
    // required uint32 frame_id = 1;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_id());

    // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_result());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CFrameEvent events = 3;
  total_size += 1UL * this->_internal_events_size();
  for (const auto& msg : this->events_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional uint32 input_mark = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_input_mark());
  }

  if (cached_has_bits & 0x000000f8u) {
    // optional float frame_start_delta = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float frame_display_delta = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float ping_time = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float server_bitrate = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float client_bitrate = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float link_bandwidth = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional float packet_loss = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 frame_size = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_frame_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CFrameStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CFrameStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CFrameStats::GetClassData() const { return &_class_data_; }

void CFrameStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CFrameStats *>(to)->MergeFrom(
      static_cast<const CFrameStats &>(from));
}


void CFrameStats::MergeFrom(const CFrameStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CFrameStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  events_.MergeFrom(from.events_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      frame_id_ = from.frame_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      input_mark_ = from.input_mark_;
    }
    if (cached_has_bits & 0x00000004u) {
      result_ = from.result_;
    }
    if (cached_has_bits & 0x00000008u) {
      frame_start_delta_ = from.frame_start_delta_;
    }
    if (cached_has_bits & 0x00000010u) {
      frame_display_delta_ = from.frame_display_delta_;
    }
    if (cached_has_bits & 0x00000020u) {
      ping_time_ = from.ping_time_;
    }
    if (cached_has_bits & 0x00000040u) {
      server_bitrate_ = from.server_bitrate_;
    }
    if (cached_has_bits & 0x00000080u) {
      client_bitrate_ = from.client_bitrate_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      link_bandwidth_ = from.link_bandwidth_;
    }
    if (cached_has_bits & 0x00000200u) {
      packet_loss_ = from.packet_loss_;
    }
    if (cached_has_bits & 0x00000400u) {
      frame_size_ = from.frame_size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CFrameStats::CopyFrom(const CFrameStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CFrameStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CFrameStats::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(events_))
    return false;
  return true;
}

void CFrameStats::InternalSwap(CFrameStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  events_.InternalSwap(&other->events_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CFrameStats, frame_size_)
      + sizeof(CFrameStats::frame_size_)
      - PROTOBUF_FIELD_OFFSET(CFrameStats, frame_id_)>(
          reinterpret_cast<char*>(&frame_id_),
          reinterpret_cast<char*>(&other->frame_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CFrameStats::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[97]);
}

// ===================================================================

class CFrameStatAccumulatedValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CFrameStatAccumulatedValue>()._has_bits_);
  static void set_has_stat_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_average(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_stddev(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

CFrameStatAccumulatedValue::CFrameStatAccumulatedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CFrameStatAccumulatedValue)
}
CFrameStatAccumulatedValue::CFrameStatAccumulatedValue(const CFrameStatAccumulatedValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&stat_type_, &from.stat_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&stat_type_)) + sizeof(stddev_));
  // @@protoc_insertion_point(copy_constructor:CFrameStatAccumulatedValue)
}

inline void CFrameStatAccumulatedValue::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&stat_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stddev_) -
    reinterpret_cast<char*>(&stat_type_)) + sizeof(stddev_));
}

CFrameStatAccumulatedValue::~CFrameStatAccumulatedValue() {
  // @@protoc_insertion_point(destructor:CFrameStatAccumulatedValue)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CFrameStatAccumulatedValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CFrameStatAccumulatedValue::ArenaDtor(void* object) {
  CFrameStatAccumulatedValue* _this = reinterpret_cast< CFrameStatAccumulatedValue* >(object);
  (void)_this;
}
void CFrameStatAccumulatedValue::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CFrameStatAccumulatedValue::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CFrameStatAccumulatedValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CFrameStatAccumulatedValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&stat_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stddev_) -
        reinterpret_cast<char*>(&stat_type_)) + sizeof(stddev_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CFrameStatAccumulatedValue::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EFrameAccumulatedStat_IsValid(val))) {
            _internal_set_stat_type(static_cast<::EFrameAccumulatedStat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required int32 count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_count(&has_bits);
          count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required float average = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_average(&has_bits);
          average_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float stddev = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_stddev(&has_bits);
          stddev_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CFrameStatAccumulatedValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CFrameStatAccumulatedValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_stat_type(), target);
  }

  // required int32 count = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_count(), target);
  }

  // required float average = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_average(), target);
  }

  // optional float stddev = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_stddev(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CFrameStatAccumulatedValue)
  return target;
}

size_t CFrameStatAccumulatedValue::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CFrameStatAccumulatedValue)
  size_t total_size = 0;

  if (_internal_has_stat_type()) {
    // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_stat_type());
  }

  if (_internal_has_count()) {
    // required int32 count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_count());
  }

  if (_internal_has_average()) {
    // required float average = 3;
    total_size += 1 + 4;
  }

  return total_size;
}
size_t CFrameStatAccumulatedValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CFrameStatAccumulatedValue)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_stat_type());

    // required int32 count = 2;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_count());

    // required float average = 3;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional float stddev = 4;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000008u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CFrameStatAccumulatedValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CFrameStatAccumulatedValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CFrameStatAccumulatedValue::GetClassData() const { return &_class_data_; }

void CFrameStatAccumulatedValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CFrameStatAccumulatedValue *>(to)->MergeFrom(
      static_cast<const CFrameStatAccumulatedValue &>(from));
}


void CFrameStatAccumulatedValue::MergeFrom(const CFrameStatAccumulatedValue& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CFrameStatAccumulatedValue)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      stat_type_ = from.stat_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      count_ = from.count_;
    }
    if (cached_has_bits & 0x00000004u) {
      average_ = from.average_;
    }
    if (cached_has_bits & 0x00000008u) {
      stddev_ = from.stddev_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CFrameStatAccumulatedValue::CopyFrom(const CFrameStatAccumulatedValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CFrameStatAccumulatedValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CFrameStatAccumulatedValue::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CFrameStatAccumulatedValue::InternalSwap(CFrameStatAccumulatedValue* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CFrameStatAccumulatedValue, stddev_)
      + sizeof(CFrameStatAccumulatedValue::stddev_)
      - PROTOBUF_FIELD_OFFSET(CFrameStatAccumulatedValue, stat_type_)>(
          reinterpret_cast<char*>(&stat_type_),
          reinterpret_cast<char*>(&other->stat_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CFrameStatAccumulatedValue::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[98]);
}

// ===================================================================

class CFrameStatsListMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CFrameStatsListMsg>()._has_bits_);
  static void set_has_data_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_latest_frame_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

CFrameStatsListMsg::CFrameStatsListMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  stats_(arena),
  accumulated_stats_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CFrameStatsListMsg)
}
CFrameStatsListMsg::CFrameStatsListMsg(const CFrameStatsListMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      stats_(from.stats_),
      accumulated_stats_(from.accumulated_stats_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&data_type_, &from.data_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&latest_frame_id_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(latest_frame_id_));
  // @@protoc_insertion_point(copy_constructor:CFrameStatsListMsg)
}

inline void CFrameStatsListMsg::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&data_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&latest_frame_id_) -
    reinterpret_cast<char*>(&data_type_)) + sizeof(latest_frame_id_));
}

CFrameStatsListMsg::~CFrameStatsListMsg() {
  // @@protoc_insertion_point(destructor:CFrameStatsListMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CFrameStatsListMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CFrameStatsListMsg::ArenaDtor(void* object) {
  CFrameStatsListMsg* _this = reinterpret_cast< CFrameStatsListMsg* >(object);
  (void)_this;
}
void CFrameStatsListMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CFrameStatsListMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CFrameStatsListMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CFrameStatsListMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  stats_.Clear();
  accumulated_stats_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&data_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&latest_frame_id_) -
        reinterpret_cast<char*>(&data_type_)) + sizeof(latest_frame_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CFrameStatsListMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamingDataType_IsValid(val))) {
            _internal_set_data_type(static_cast<::EStreamingDataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .CFrameStats stats = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_accumulated_stats(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // required int32 latest_frame_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_latest_frame_id(&has_bits);
          latest_frame_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CFrameStatsListMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CFrameStatsListMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_data_type(), target);
  }

  // repeated .CFrameStats stats = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_stats_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_stats(i), target, stream);
  }

  // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_accumulated_stats_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_accumulated_stats(i), target, stream);
  }

  // required int32 latest_frame_id = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_latest_frame_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CFrameStatsListMsg)
  return target;
}

size_t CFrameStatsListMsg::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:CFrameStatsListMsg)
  size_t total_size = 0;

  if (_internal_has_data_type()) {
    // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());
  }

  if (_internal_has_latest_frame_id()) {
    // required int32 latest_frame_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_latest_frame_id());
  }

  return total_size;
}
size_t CFrameStatsListMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CFrameStatsListMsg)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_data_type());

    // required int32 latest_frame_id = 4;
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_latest_frame_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CFrameStats stats = 2;
  total_size += 1UL * this->_internal_stats_size();
  for (const auto& msg : this->stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
  total_size += 1UL * this->_internal_accumulated_stats_size();
  for (const auto& msg : this->accumulated_stats_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CFrameStatsListMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CFrameStatsListMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CFrameStatsListMsg::GetClassData() const { return &_class_data_; }

void CFrameStatsListMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CFrameStatsListMsg *>(to)->MergeFrom(
      static_cast<const CFrameStatsListMsg &>(from));
}


void CFrameStatsListMsg::MergeFrom(const CFrameStatsListMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CFrameStatsListMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  stats_.MergeFrom(from.stats_);
  accumulated_stats_.MergeFrom(from.accumulated_stats_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      data_type_ = from.data_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      latest_frame_id_ = from.latest_frame_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CFrameStatsListMsg::CopyFrom(const CFrameStatsListMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CFrameStatsListMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CFrameStatsListMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(stats_))
    return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(accumulated_stats_))
    return false;
  return true;
}

void CFrameStatsListMsg::InternalSwap(CFrameStatsListMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  stats_.InternalSwap(&other->stats_);
  accumulated_stats_.InternalSwap(&other->accumulated_stats_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CFrameStatsListMsg, latest_frame_id_)
      + sizeof(CFrameStatsListMsg::latest_frame_id_)
      - PROTOBUF_FIELD_OFFSET(CFrameStatsListMsg, data_type_)>(
          reinterpret_cast<char*>(&data_type_),
          reinterpret_cast<char*>(&other->data_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CFrameStatsListMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[99]);
}

// ===================================================================

class CStreamingSessionStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CStreamingSessionStats>()._has_bits_);
  static void set_has_frame_loss_percentage(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_average_network_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_stddev_network_time_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CStreamingSessionStats::CStreamingSessionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CStreamingSessionStats)
}
CStreamingSessionStats::CStreamingSessionStats(const CStreamingSessionStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&frame_loss_percentage_, &from.frame_loss_percentage_,
    static_cast<size_t>(reinterpret_cast<char*>(&stddev_network_time_ms_) -
    reinterpret_cast<char*>(&frame_loss_percentage_)) + sizeof(stddev_network_time_ms_));
  // @@protoc_insertion_point(copy_constructor:CStreamingSessionStats)
}

inline void CStreamingSessionStats::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&frame_loss_percentage_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&stddev_network_time_ms_) -
    reinterpret_cast<char*>(&frame_loss_percentage_)) + sizeof(stddev_network_time_ms_));
}

CStreamingSessionStats::~CStreamingSessionStats() {
  // @@protoc_insertion_point(destructor:CStreamingSessionStats)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CStreamingSessionStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CStreamingSessionStats::ArenaDtor(void* object) {
  CStreamingSessionStats* _this = reinterpret_cast< CStreamingSessionStats* >(object);
  (void)_this;
}
void CStreamingSessionStats::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CStreamingSessionStats::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CStreamingSessionStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CStreamingSessionStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&frame_loss_percentage_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&stddev_network_time_ms_) -
        reinterpret_cast<char*>(&frame_loss_percentage_)) + sizeof(stddev_network_time_ms_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CStreamingSessionStats::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float frame_loss_percentage = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_frame_loss_percentage(&has_bits);
          frame_loss_percentage_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float average_network_time_ms = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_average_network_time_ms(&has_bits);
          average_network_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float stddev_network_time_ms = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_stddev_network_time_ms(&has_bits);
          stddev_network_time_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CStreamingSessionStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CStreamingSessionStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional float frame_loss_percentage = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(1, this->_internal_frame_loss_percentage(), target);
  }

  // optional float average_network_time_ms = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(2, this->_internal_average_network_time_ms(), target);
  }

  // optional float stddev_network_time_ms = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_stddev_network_time_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CStreamingSessionStats)
  return target;
}

size_t CStreamingSessionStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CStreamingSessionStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional float frame_loss_percentage = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 4;
    }

    // optional float average_network_time_ms = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float stddev_network_time_ms = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CStreamingSessionStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CStreamingSessionStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CStreamingSessionStats::GetClassData() const { return &_class_data_; }

void CStreamingSessionStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CStreamingSessionStats *>(to)->MergeFrom(
      static_cast<const CStreamingSessionStats &>(from));
}


void CStreamingSessionStats::MergeFrom(const CStreamingSessionStats& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CStreamingSessionStats)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      frame_loss_percentage_ = from.frame_loss_percentage_;
    }
    if (cached_has_bits & 0x00000002u) {
      average_network_time_ms_ = from.average_network_time_ms_;
    }
    if (cached_has_bits & 0x00000004u) {
      stddev_network_time_ms_ = from.stddev_network_time_ms_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CStreamingSessionStats::CopyFrom(const CStreamingSessionStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CStreamingSessionStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CStreamingSessionStats::IsInitialized() const {
  return true;
}

void CStreamingSessionStats::InternalSwap(CStreamingSessionStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CStreamingSessionStats, stddev_network_time_ms_)
      + sizeof(CStreamingSessionStats::stddev_network_time_ms_)
      - PROTOBUF_FIELD_OFFSET(CStreamingSessionStats, frame_loss_percentage_)>(
          reinterpret_cast<char*>(&frame_loss_percentage_),
          reinterpret_cast<char*>(&other->frame_loss_percentage_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CStreamingSessionStats::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[100]);
}

// ===================================================================

class CDebugDumpMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CDebugDumpMsg>()._has_bits_);
  static void set_has_screenshot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CDebugDumpMsg::CDebugDumpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CDebugDumpMsg)
}
CDebugDumpMsg::CDebugDumpMsg(const CDebugDumpMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  screenshot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    screenshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_screenshot()) {
    screenshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_screenshot(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CDebugDumpMsg)
}

inline void CDebugDumpMsg::SharedCtor() {
screenshot_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  screenshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CDebugDumpMsg::~CDebugDumpMsg() {
  // @@protoc_insertion_point(destructor:CDebugDumpMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CDebugDumpMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  screenshot_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CDebugDumpMsg::ArenaDtor(void* object) {
  CDebugDumpMsg* _this = reinterpret_cast< CDebugDumpMsg* >(object);
  (void)_this;
}
void CDebugDumpMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CDebugDumpMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CDebugDumpMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CDebugDumpMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    screenshot_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CDebugDumpMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes screenshot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_screenshot();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CDebugDumpMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CDebugDumpMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bytes screenshot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_screenshot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CDebugDumpMsg)
  return target;
}

size_t CDebugDumpMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CDebugDumpMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes screenshot = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_screenshot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CDebugDumpMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CDebugDumpMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CDebugDumpMsg::GetClassData() const { return &_class_data_; }

void CDebugDumpMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CDebugDumpMsg *>(to)->MergeFrom(
      static_cast<const CDebugDumpMsg &>(from));
}


void CDebugDumpMsg::MergeFrom(const CDebugDumpMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CDebugDumpMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_screenshot()) {
    _internal_set_screenshot(from._internal_screenshot());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CDebugDumpMsg::CopyFrom(const CDebugDumpMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CDebugDumpMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CDebugDumpMsg::IsInitialized() const {
  return true;
}

void CDebugDumpMsg::InternalSwap(CDebugDumpMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &screenshot_, lhs_arena,
      &other->screenshot_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CDebugDumpMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[101]);
}

// ===================================================================

class CLogMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CLogMsg>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CLogMsg::CLogMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CLogMsg)
}
CLogMsg::CLogMsg(const CLogMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_message()) {
    message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_message(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:CLogMsg)
}

inline void CLogMsg::SharedCtor() {
message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = 0;
}

CLogMsg::~CLogMsg() {
  // @@protoc_insertion_point(destructor:CLogMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CLogMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CLogMsg::ArenaDtor(void* object) {
  CLogMsg* _this = reinterpret_cast< CLogMsg* >(object);
  (void)_this;
}
void CLogMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CLogMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CLogMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CLogMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    message_.ClearNonDefaultToEmpty();
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLogMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CLogMsg.message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLogMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CLogMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional string message = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_message().data(), static_cast<int>(this->_internal_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CLogMsg.message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CLogMsg)
  return target;
}

size_t CLogMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CLogMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string message = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_message());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLogMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CLogMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLogMsg::GetClassData() const { return &_class_data_; }

void CLogMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CLogMsg *>(to)->MergeFrom(
      static_cast<const CLogMsg &>(from));
}


void CLogMsg::MergeFrom(const CLogMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CLogMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_message(from._internal_message());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLogMsg::CopyFrom(const CLogMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CLogMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLogMsg::IsInitialized() const {
  return true;
}

void CLogMsg::InternalSwap(CLogMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &message_, lhs_arena,
      &other->message_, rhs_arena
  );
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CLogMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[102]);
}

// ===================================================================

class CLogUploadMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CLogUploadMsg>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CLogUploadMsg::CLogUploadMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CLogUploadMsg)
}
CLogUploadMsg::CLogUploadMsg(const CLogUploadMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_data(), 
      GetArenaForAllocation());
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:CLogUploadMsg)
}

inline void CLogUploadMsg::SharedCtor() {
data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
type_ = 0;
}

CLogUploadMsg::~CLogUploadMsg() {
  // @@protoc_insertion_point(destructor:CLogUploadMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CLogUploadMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CLogUploadMsg::ArenaDtor(void* object) {
  CLogUploadMsg* _this = reinterpret_cast< CLogUploadMsg* >(object);
  (void)_this;
}
void CLogUploadMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CLogUploadMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CLogUploadMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CLogUploadMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CLogUploadMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ELogFileType_IsValid(val))) {
            _internal_set_type(static_cast<::ELogFileType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CLogUploadMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CLogUploadMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CLogUploadMsg)
  return target;
}

size_t CLogUploadMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CLogUploadMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CLogUploadMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CLogUploadMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CLogUploadMsg::GetClassData() const { return &_class_data_; }

void CLogUploadMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CLogUploadMsg *>(to)->MergeFrom(
      static_cast<const CLogUploadMsg &>(from));
}


void CLogUploadMsg::MergeFrom(const CLogUploadMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CLogUploadMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      type_ = from.type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CLogUploadMsg::CopyFrom(const CLogUploadMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CLogUploadMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CLogUploadMsg::IsInitialized() const {
  return true;
}

void CLogUploadMsg::InternalSwap(CLogUploadMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &data_, lhs_arena,
      &other->data_, rhs_arena
  );
  swap(type_, other->type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CLogUploadMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[103]);
}

// ===================================================================

class CTransportSignalMsg_WebRTCMessage_Candidate::_Internal {
 public:
  using HasBits = decltype(std::declval<CTransportSignalMsg_WebRTCMessage_Candidate>()._has_bits_);
  static void set_has_sdp_mid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sdp_mline_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_candidate(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CTransportSignalMsg_WebRTCMessage_Candidate::CTransportSignalMsg_WebRTCMessage_Candidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTransportSignalMsg.WebRTCMessage.Candidate)
}
CTransportSignalMsg_WebRTCMessage_Candidate::CTransportSignalMsg_WebRTCMessage_Candidate(const CTransportSignalMsg_WebRTCMessage_Candidate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  sdp_mid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sdp_mid()) {
    sdp_mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_sdp_mid(), 
      GetArenaForAllocation());
  }
  candidate_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    candidate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_candidate()) {
    candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_candidate(), 
      GetArenaForAllocation());
  }
  sdp_mline_index_ = from.sdp_mline_index_;
  // @@protoc_insertion_point(copy_constructor:CTransportSignalMsg.WebRTCMessage.Candidate)
}

inline void CTransportSignalMsg_WebRTCMessage_Candidate::SharedCtor() {
sdp_mid_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
candidate_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  candidate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sdp_mline_index_ = 0;
}

CTransportSignalMsg_WebRTCMessage_Candidate::~CTransportSignalMsg_WebRTCMessage_Candidate() {
  // @@protoc_insertion_point(destructor:CTransportSignalMsg.WebRTCMessage.Candidate)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTransportSignalMsg_WebRTCMessage_Candidate::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  sdp_mid_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  candidate_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CTransportSignalMsg_WebRTCMessage_Candidate::ArenaDtor(void* object) {
  CTransportSignalMsg_WebRTCMessage_Candidate* _this = reinterpret_cast< CTransportSignalMsg_WebRTCMessage_Candidate* >(object);
  (void)_this;
}
void CTransportSignalMsg_WebRTCMessage_Candidate::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTransportSignalMsg_WebRTCMessage_Candidate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTransportSignalMsg_WebRTCMessage_Candidate::Clear() {
// @@protoc_insertion_point(message_clear_start:CTransportSignalMsg.WebRTCMessage.Candidate)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      sdp_mid_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      candidate_.ClearNonDefaultToEmpty();
    }
  }
  sdp_mline_index_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTransportSignalMsg_WebRTCMessage_Candidate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string sdp_mid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_sdp_mid();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sdp_mline_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_sdp_mline_index(&has_bits);
          sdp_mline_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string candidate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_candidate();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CTransportSignalMsg.WebRTCMessage.Candidate.candidate");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTransportSignalMsg_WebRTCMessage_Candidate::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTransportSignalMsg.WebRTCMessage.Candidate)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string sdp_mid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sdp_mid().data(), static_cast<int>(this->_internal_sdp_mid().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_sdp_mid(), target);
  }

  // optional int32 sdp_mline_index = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_sdp_mline_index(), target);
  }

  // optional string candidate = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_candidate().data(), static_cast<int>(this->_internal_candidate().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CTransportSignalMsg.WebRTCMessage.Candidate.candidate");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_candidate(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTransportSignalMsg.WebRTCMessage.Candidate)
  return target;
}

size_t CTransportSignalMsg_WebRTCMessage_Candidate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTransportSignalMsg.WebRTCMessage.Candidate)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string sdp_mid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sdp_mid());
    }

    // optional string candidate = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_candidate());
    }

    // optional int32 sdp_mline_index = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_sdp_mline_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTransportSignalMsg_WebRTCMessage_Candidate::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTransportSignalMsg_WebRTCMessage_Candidate::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTransportSignalMsg_WebRTCMessage_Candidate::GetClassData() const { return &_class_data_; }

void CTransportSignalMsg_WebRTCMessage_Candidate::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTransportSignalMsg_WebRTCMessage_Candidate *>(to)->MergeFrom(
      static_cast<const CTransportSignalMsg_WebRTCMessage_Candidate &>(from));
}


void CTransportSignalMsg_WebRTCMessage_Candidate::MergeFrom(const CTransportSignalMsg_WebRTCMessage_Candidate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTransportSignalMsg.WebRTCMessage.Candidate)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_sdp_mid(from._internal_sdp_mid());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_candidate(from._internal_candidate());
    }
    if (cached_has_bits & 0x00000004u) {
      sdp_mline_index_ = from.sdp_mline_index_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTransportSignalMsg_WebRTCMessage_Candidate::CopyFrom(const CTransportSignalMsg_WebRTCMessage_Candidate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTransportSignalMsg.WebRTCMessage.Candidate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTransportSignalMsg_WebRTCMessage_Candidate::IsInitialized() const {
  return true;
}

void CTransportSignalMsg_WebRTCMessage_Candidate::InternalSwap(CTransportSignalMsg_WebRTCMessage_Candidate* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &sdp_mid_, lhs_arena,
      &other->sdp_mid_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &candidate_, lhs_arena,
      &other->candidate_, rhs_arena
  );
  swap(sdp_mline_index_, other->sdp_mline_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CTransportSignalMsg_WebRTCMessage_Candidate::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[104]);
}

// ===================================================================

class CTransportSignalMsg_WebRTCMessage::_Internal {
 public:
  static const ::CTransportSignalMsg_WebRTCMessage_Candidate& candidate(const CTransportSignalMsg_WebRTCMessage* msg);
};

const ::CTransportSignalMsg_WebRTCMessage_Candidate&
CTransportSignalMsg_WebRTCMessage::_Internal::candidate(const CTransportSignalMsg_WebRTCMessage* msg) {
  return *msg->msg_.candidate_;
}
void CTransportSignalMsg_WebRTCMessage::set_allocated_candidate(::CTransportSignalMsg_WebRTCMessage_Candidate* candidate) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_msg();
  if (candidate) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CTransportSignalMsg_WebRTCMessage_Candidate>::GetOwningArena(candidate);
    if (message_arena != submessage_arena) {
      candidate = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, candidate, submessage_arena);
    }
    set_has_candidate();
    msg_.candidate_ = candidate;
  }
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.WebRTCMessage.candidate)
}
CTransportSignalMsg_WebRTCMessage::CTransportSignalMsg_WebRTCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTransportSignalMsg.WebRTCMessage)
}
CTransportSignalMsg_WebRTCMessage::CTransportSignalMsg_WebRTCMessage(const CTransportSignalMsg_WebRTCMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  clear_has_msg();
  switch (from.msg_case()) {
    case kGreeting: {
      _internal_set_greeting(from._internal_greeting());
      break;
    }
    case kOffer: {
      _internal_set_offer(from._internal_offer());
      break;
    }
    case kAnswer: {
      _internal_set_answer(from._internal_answer());
      break;
    }
    case kCandidate: {
      _internal_mutable_candidate()->::CTransportSignalMsg_WebRTCMessage_Candidate::MergeFrom(from._internal_candidate());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:CTransportSignalMsg.WebRTCMessage)
}

inline void CTransportSignalMsg_WebRTCMessage::SharedCtor() {
clear_has_msg();
}

CTransportSignalMsg_WebRTCMessage::~CTransportSignalMsg_WebRTCMessage() {
  // @@protoc_insertion_point(destructor:CTransportSignalMsg.WebRTCMessage)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTransportSignalMsg_WebRTCMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_msg()) {
    clear_msg();
  }
}

void CTransportSignalMsg_WebRTCMessage::ArenaDtor(void* object) {
  CTransportSignalMsg_WebRTCMessage* _this = reinterpret_cast< CTransportSignalMsg_WebRTCMessage* >(object);
  (void)_this;
}
void CTransportSignalMsg_WebRTCMessage::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTransportSignalMsg_WebRTCMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTransportSignalMsg_WebRTCMessage::clear_msg() {
// @@protoc_insertion_point(one_of_clear_start:CTransportSignalMsg.WebRTCMessage)
  switch (msg_case()) {
    case kGreeting: {
      // No need to clear
      break;
    }
    case kOffer: {
      msg_.offer_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kAnswer: {
      msg_.answer_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
      break;
    }
    case kCandidate: {
      if (GetArenaForAllocation() == nullptr) {
        delete msg_.candidate_;
      }
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MSG_NOT_SET;
}


void CTransportSignalMsg_WebRTCMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CTransportSignalMsg.WebRTCMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_msg();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTransportSignalMsg_WebRTCMessage::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // bool greeting = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _internal_set_greeting(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string offer = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_offer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CTransportSignalMsg.WebRTCMessage.offer");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string answer = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_answer();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CTransportSignalMsg.WebRTCMessage.answer");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_candidate(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTransportSignalMsg_WebRTCMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTransportSignalMsg.WebRTCMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (msg_case()) {
    case kGreeting: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_greeting(), target);
      break;
    }
    case kOffer: {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_offer().data(), static_cast<int>(this->_internal_offer().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "CTransportSignalMsg.WebRTCMessage.offer");
      target = stream->WriteStringMaybeAliased(
          2, this->_internal_offer(), target);
      break;
    }
    case kAnswer: {
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->_internal_answer().data(), static_cast<int>(this->_internal_answer().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "CTransportSignalMsg.WebRTCMessage.answer");
      target = stream->WriteStringMaybeAliased(
          3, this->_internal_answer(), target);
      break;
    }
    case kCandidate: {
      target = stream->EnsureSpace(target);
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(
          4, _Internal::candidate(this), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTransportSignalMsg.WebRTCMessage)
  return target;
}

size_t CTransportSignalMsg_WebRTCMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTransportSignalMsg.WebRTCMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (msg_case()) {
    // bool greeting = 1;
    case kGreeting: {
      total_size += 1 + 1;
      break;
    }
    // string offer = 2;
    case kOffer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_offer());
      break;
    }
    // string answer = 3;
    case kAnswer: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_answer());
      break;
    }
    // .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;
    case kCandidate: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *msg_.candidate_);
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTransportSignalMsg_WebRTCMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTransportSignalMsg_WebRTCMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTransportSignalMsg_WebRTCMessage::GetClassData() const { return &_class_data_; }

void CTransportSignalMsg_WebRTCMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTransportSignalMsg_WebRTCMessage *>(to)->MergeFrom(
      static_cast<const CTransportSignalMsg_WebRTCMessage &>(from));
}


void CTransportSignalMsg_WebRTCMessage::MergeFrom(const CTransportSignalMsg_WebRTCMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTransportSignalMsg.WebRTCMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.msg_case()) {
    case kGreeting: {
      _internal_set_greeting(from._internal_greeting());
      break;
    }
    case kOffer: {
      _internal_set_offer(from._internal_offer());
      break;
    }
    case kAnswer: {
      _internal_set_answer(from._internal_answer());
      break;
    }
    case kCandidate: {
      _internal_mutable_candidate()->::CTransportSignalMsg_WebRTCMessage_Candidate::MergeFrom(from._internal_candidate());
      break;
    }
    case MSG_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTransportSignalMsg_WebRTCMessage::CopyFrom(const CTransportSignalMsg_WebRTCMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTransportSignalMsg.WebRTCMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTransportSignalMsg_WebRTCMessage::IsInitialized() const {
  return true;
}

void CTransportSignalMsg_WebRTCMessage::InternalSwap(CTransportSignalMsg_WebRTCMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(msg_, other->msg_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata CTransportSignalMsg_WebRTCMessage::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[105]);
}

// ===================================================================

class CTransportSignalMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CTransportSignalMsg>()._has_bits_);
  static const ::CTransportSignalMsg_WebRTCMessage& webrtc(const CTransportSignalMsg* msg);
  static void set_has_webrtc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CTransportSignalMsg_WebRTCMessage&
CTransportSignalMsg::_Internal::webrtc(const CTransportSignalMsg* msg) {
  return *msg->webrtc_;
}
CTransportSignalMsg::CTransportSignalMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  sdr_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CTransportSignalMsg)
}
CTransportSignalMsg::CTransportSignalMsg(const CTransportSignalMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      sdr_(from.sdr_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_webrtc()) {
    webrtc_ = new ::CTransportSignalMsg_WebRTCMessage(*from.webrtc_);
  } else {
    webrtc_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:CTransportSignalMsg)
}

inline void CTransportSignalMsg::SharedCtor() {
webrtc_ = nullptr;
}

CTransportSignalMsg::~CTransportSignalMsg() {
  // @@protoc_insertion_point(destructor:CTransportSignalMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CTransportSignalMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete webrtc_;
}

void CTransportSignalMsg::ArenaDtor(void* object) {
  CTransportSignalMsg* _this = reinterpret_cast< CTransportSignalMsg* >(object);
  (void)_this;
}
void CTransportSignalMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CTransportSignalMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CTransportSignalMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CTransportSignalMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  sdr_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(webrtc_ != nullptr);
    webrtc_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CTransportSignalMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_webrtc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes sdr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_sdr();
            ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CTransportSignalMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CTransportSignalMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::webrtc(this), target, stream);
  }

  // repeated bytes sdr = 2;
  for (int i = 0, n = this->_internal_sdr_size(); i < n; i++) {
    const auto& s = this->_internal_sdr(i);
    target = stream->WriteBytes(2, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CTransportSignalMsg)
  return target;
}

size_t CTransportSignalMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CTransportSignalMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated bytes sdr = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(sdr_.size());
  for (int i = 0, n = sdr_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      sdr_.Get(i));
  }

  // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *webrtc_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CTransportSignalMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CTransportSignalMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CTransportSignalMsg::GetClassData() const { return &_class_data_; }

void CTransportSignalMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CTransportSignalMsg *>(to)->MergeFrom(
      static_cast<const CTransportSignalMsg &>(from));
}


void CTransportSignalMsg::MergeFrom(const CTransportSignalMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CTransportSignalMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  sdr_.MergeFrom(from.sdr_);
  if (from._internal_has_webrtc()) {
    _internal_mutable_webrtc()->::CTransportSignalMsg_WebRTCMessage::MergeFrom(from._internal_webrtc());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CTransportSignalMsg::CopyFrom(const CTransportSignalMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CTransportSignalMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CTransportSignalMsg::IsInitialized() const {
  return true;
}

void CTransportSignalMsg::InternalSwap(CTransportSignalMsg* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  sdr_.InternalSwap(&other->sdr_);
  swap(webrtc_, other->webrtc_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CTransportSignalMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[106]);
}

// ===================================================================

class CControllerConfigMsg_ControllerConfigResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerConfigMsg_ControllerConfigResponse>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_configurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controllertype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_controllerdata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selectionorder(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_actionblock(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CControllerConfigMsg_ControllerConfigResponse::CControllerConfigMsg_ControllerConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerConfigMsg.ControllerConfigResponse)
}
CControllerConfigMsg_ControllerConfigResponse::CControllerConfigMsg_ControllerConfigResponse(const CControllerConfigMsg_ControllerConfigResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_configurl()) {
    configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_configurl(), 
      GetArenaForAllocation());
  }
  controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controllerdata()) {
    controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controllerdata(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&actionblock_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionblock_));
  // @@protoc_insertion_point(copy_constructor:CControllerConfigMsg.ControllerConfigResponse)
}

inline void CControllerConfigMsg_ControllerConfigResponse::SharedCtor() {
configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&actionblock_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(actionblock_));
}

CControllerConfigMsg_ControllerConfigResponse::~CControllerConfigMsg_ControllerConfigResponse() {
  // @@protoc_insertion_point(destructor:CControllerConfigMsg.ControllerConfigResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerConfigMsg_ControllerConfigResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  configurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  controllerdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CControllerConfigMsg_ControllerConfigResponse::ArenaDtor(void* object) {
  CControllerConfigMsg_ControllerConfigResponse* _this = reinterpret_cast< CControllerConfigMsg_ControllerConfigResponse* >(object);
  (void)_this;
}
void CControllerConfigMsg_ControllerConfigResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerConfigMsg_ControllerConfigResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerConfigMsg_ControllerConfigResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerConfigMsg.ControllerConfigResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      configurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      controllerdata_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&actionblock_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(actionblock_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerConfigMsg_ControllerConfigResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string configURL = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_configurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerConfigResponse.configURL");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 controllerType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_controllertype(&has_bits);
          controllertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controllerData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_controllerdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerConfigResponse.controllerData");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selectionOrder = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_selectionorder(&has_bits);
          selectionorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool actionBlock = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_actionblock(&has_bits);
          actionblock_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerConfigMsg_ControllerConfigResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerConfigMsg.ControllerConfigResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string configURL = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_configurl().data(), static_cast<int>(this->_internal_configurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerConfigResponse.configURL");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_configurl(), target);
  }

  // optional uint32 controllerType = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_controllertype(), target);
  }

  // optional string controllerData = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controllerdata().data(), static_cast<int>(this->_internal_controllerdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerConfigResponse.controllerData");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_controllerdata(), target);
  }

  // optional uint32 selectionOrder = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_selectionorder(), target);
  }

  // optional bool actionBlock = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_actionblock(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerConfigMsg.ControllerConfigResponse)
  return target;
}

size_t CControllerConfigMsg_ControllerConfigResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerConfigMsg.ControllerConfigResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string configURL = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_configurl());
    }

    // optional string controllerData = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controllerdata());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 controllerType = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_controllertype());
    }

    // optional uint32 selectionOrder = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_selectionorder());
    }

    // optional bool actionBlock = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerConfigMsg_ControllerConfigResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerConfigMsg_ControllerConfigResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerConfigMsg_ControllerConfigResponse::GetClassData() const { return &_class_data_; }

void CControllerConfigMsg_ControllerConfigResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerConfigMsg_ControllerConfigResponse *>(to)->MergeFrom(
      static_cast<const CControllerConfigMsg_ControllerConfigResponse &>(from));
}


void CControllerConfigMsg_ControllerConfigResponse::MergeFrom(const CControllerConfigMsg_ControllerConfigResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerConfigMsg.ControllerConfigResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_configurl(from._internal_configurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_controllerdata(from._internal_controllerdata());
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      controllertype_ = from.controllertype_;
    }
    if (cached_has_bits & 0x00000010u) {
      selectionorder_ = from.selectionorder_;
    }
    if (cached_has_bits & 0x00000020u) {
      actionblock_ = from.actionblock_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerConfigMsg_ControllerConfigResponse::CopyFrom(const CControllerConfigMsg_ControllerConfigResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerConfigMsg.ControllerConfigResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerConfigMsg_ControllerConfigResponse::IsInitialized() const {
  return true;
}

void CControllerConfigMsg_ControllerConfigResponse::InternalSwap(CControllerConfigMsg_ControllerConfigResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &configurl_, lhs_arena,
      &other->configurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controllerdata_, lhs_arena,
      &other->controllerdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerConfigResponse, actionblock_)
      + sizeof(CControllerConfigMsg_ControllerConfigResponse::actionblock_)
      - PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerConfigResponse, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerConfigMsg_ControllerConfigResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[107]);
}

// ===================================================================

class CControllerConfigMsg_ControllerPersonalizationResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerConfigMsg_ControllerPersonalizationResponse>()._has_bits_);
  static void set_has_personalizationdata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CControllerConfigMsg_ControllerPersonalizationResponse::CControllerConfigMsg_ControllerPersonalizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerConfigMsg.ControllerPersonalizationResponse)
}
CControllerConfigMsg_ControllerPersonalizationResponse::CControllerConfigMsg_ControllerPersonalizationResponse(const CControllerConfigMsg_ControllerPersonalizationResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  personalizationdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    personalizationdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_personalizationdata()) {
    personalizationdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_personalizationdata(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CControllerConfigMsg.ControllerPersonalizationResponse)
}

inline void CControllerConfigMsg_ControllerPersonalizationResponse::SharedCtor() {
personalizationdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  personalizationdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CControllerConfigMsg_ControllerPersonalizationResponse::~CControllerConfigMsg_ControllerPersonalizationResponse() {
  // @@protoc_insertion_point(destructor:CControllerConfigMsg.ControllerPersonalizationResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerConfigMsg_ControllerPersonalizationResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  personalizationdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CControllerConfigMsg_ControllerPersonalizationResponse::ArenaDtor(void* object) {
  CControllerConfigMsg_ControllerPersonalizationResponse* _this = reinterpret_cast< CControllerConfigMsg_ControllerPersonalizationResponse* >(object);
  (void)_this;
}
void CControllerConfigMsg_ControllerPersonalizationResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerConfigMsg_ControllerPersonalizationResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerConfigMsg_ControllerPersonalizationResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerConfigMsg.ControllerPersonalizationResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    personalizationdata_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerConfigMsg_ControllerPersonalizationResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string personalizationData = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_personalizationdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerConfigMsg_ControllerPersonalizationResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerConfigMsg.ControllerPersonalizationResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string personalizationData = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_personalizationdata().data(), static_cast<int>(this->_internal_personalizationdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_personalizationdata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerConfigMsg.ControllerPersonalizationResponse)
  return target;
}

size_t CControllerConfigMsg_ControllerPersonalizationResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerConfigMsg.ControllerPersonalizationResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string personalizationData = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_personalizationdata());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerConfigMsg_ControllerPersonalizationResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerConfigMsg_ControllerPersonalizationResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerConfigMsg_ControllerPersonalizationResponse::GetClassData() const { return &_class_data_; }

void CControllerConfigMsg_ControllerPersonalizationResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerConfigMsg_ControllerPersonalizationResponse *>(to)->MergeFrom(
      static_cast<const CControllerConfigMsg_ControllerPersonalizationResponse &>(from));
}


void CControllerConfigMsg_ControllerPersonalizationResponse::MergeFrom(const CControllerConfigMsg_ControllerPersonalizationResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerConfigMsg.ControllerPersonalizationResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_personalizationdata()) {
    _internal_set_personalizationdata(from._internal_personalizationdata());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerConfigMsg_ControllerPersonalizationResponse::CopyFrom(const CControllerConfigMsg_ControllerPersonalizationResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerConfigMsg.ControllerPersonalizationResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerConfigMsg_ControllerPersonalizationResponse::IsInitialized() const {
  return true;
}

void CControllerConfigMsg_ControllerPersonalizationResponse::InternalSwap(CControllerConfigMsg_ControllerPersonalizationResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &personalizationdata_, lhs_arena,
      &other->personalizationdata_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerConfigMsg_ControllerPersonalizationResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[108]);
}

// ===================================================================

class CControllerConfigMsg_ControllerActiveConfigChangeResponse::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerConfigMsg_ControllerActiveConfigChangeResponse>()._has_bits_);
  static void set_has_configurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controllertype(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_controllerdata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_selectionorder(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CControllerConfigMsg_ControllerActiveConfigChangeResponse::CControllerConfigMsg_ControllerActiveConfigChangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
}
CControllerConfigMsg_ControllerActiveConfigChangeResponse::CControllerConfigMsg_ControllerActiveConfigChangeResponse(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_configurl()) {
    configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_configurl(), 
      GetArenaForAllocation());
  }
  controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controllerdata()) {
    controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controllerdata(), 
      GetArenaForAllocation());
  }
  ::memcpy(&controllertype_, &from.controllertype_,
    static_cast<size_t>(reinterpret_cast<char*>(&selectionorder_) -
    reinterpret_cast<char*>(&controllertype_)) + sizeof(selectionorder_));
  // @@protoc_insertion_point(copy_constructor:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
}

inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::SharedCtor() {
configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&controllertype_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&selectionorder_) -
    reinterpret_cast<char*>(&controllertype_)) + sizeof(selectionorder_));
}

CControllerConfigMsg_ControllerActiveConfigChangeResponse::~CControllerConfigMsg_ControllerActiveConfigChangeResponse() {
  // @@protoc_insertion_point(destructor:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  configurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  controllerdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CControllerConfigMsg_ControllerActiveConfigChangeResponse::ArenaDtor(void* object) {
  CControllerConfigMsg_ControllerActiveConfigChangeResponse* _this = reinterpret_cast< CControllerConfigMsg_ControllerActiveConfigChangeResponse* >(object);
  (void)_this;
}
void CControllerConfigMsg_ControllerActiveConfigChangeResponse::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerConfigMsg_ControllerActiveConfigChangeResponse::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerConfigMsg_ControllerActiveConfigChangeResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      configurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      controllerdata_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&controllertype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&selectionorder_) -
        reinterpret_cast<char*>(&controllertype_)) + sizeof(selectionorder_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerConfigMsg_ControllerActiveConfigChangeResponse::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string configURL = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_configurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 controllerType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_controllertype(&has_bits);
          controllertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controllerData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_controllerdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 selectionOrder = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_selectionorder(&has_bits);
          selectionorder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerConfigMsg_ControllerActiveConfigChangeResponse::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string configURL = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_configurl().data(), static_cast<int>(this->_internal_configurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_configurl(), target);
  }

  // optional uint32 controllerType = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_controllertype(), target);
  }

  // optional string controllerData = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controllerdata().data(), static_cast<int>(this->_internal_controllerdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_controllerdata(), target);
  }

  // optional uint32 selectionOrder = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_selectionorder(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  return target;
}

size_t CControllerConfigMsg_ControllerActiveConfigChangeResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string configURL = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_configurl());
    }

    // optional string controllerData = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controllerdata());
    }

    // optional uint32 controllerType = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_controllertype());
    }

    // optional uint32 selectionOrder = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_selectionorder());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerConfigMsg_ControllerActiveConfigChangeResponse::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerConfigMsg_ControllerActiveConfigChangeResponse::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerConfigMsg_ControllerActiveConfigChangeResponse::GetClassData() const { return &_class_data_; }

void CControllerConfigMsg_ControllerActiveConfigChangeResponse::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerConfigMsg_ControllerActiveConfigChangeResponse *>(to)->MergeFrom(
      static_cast<const CControllerConfigMsg_ControllerActiveConfigChangeResponse &>(from));
}


void CControllerConfigMsg_ControllerActiveConfigChangeResponse::MergeFrom(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_configurl(from._internal_configurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_controllerdata(from._internal_controllerdata());
    }
    if (cached_has_bits & 0x00000004u) {
      controllertype_ = from.controllertype_;
    }
    if (cached_has_bits & 0x00000008u) {
      selectionorder_ = from.selectionorder_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerConfigMsg_ControllerActiveConfigChangeResponse::CopyFrom(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::IsInitialized() const {
  return true;
}

void CControllerConfigMsg_ControllerActiveConfigChangeResponse::InternalSwap(CControllerConfigMsg_ControllerActiveConfigChangeResponse* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &configurl_, lhs_arena,
      &other->configurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controllerdata_, lhs_arena,
      &other->controllerdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerActiveConfigChangeResponse, selectionorder_)
      + sizeof(CControllerConfigMsg_ControllerActiveConfigChangeResponse::selectionorder_)
      - PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerActiveConfigChangeResponse, controllertype_)>(
          reinterpret_cast<char*>(&controllertype_),
          reinterpret_cast<char*>(&other->controllertype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerConfigMsg_ControllerActiveConfigChangeResponse::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[109]);
}

// ===================================================================

class CControllerConfigMsg_ControllerActiveConfigMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerConfigMsg_ControllerActiveConfigMsg>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_configurl(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_controllertype(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_controllerdata(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CControllerConfigMsg_ControllerActiveConfigMsg::CControllerConfigMsg_ControllerActiveConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerConfigMsg.ControllerActiveConfigMsg)
}
CControllerConfigMsg_ControllerActiveConfigMsg::CControllerConfigMsg_ControllerActiveConfigMsg(const CControllerConfigMsg_ControllerActiveConfigMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_configurl()) {
    configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_configurl(), 
      GetArenaForAllocation());
  }
  controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controllerdata()) {
    controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controllerdata(), 
      GetArenaForAllocation());
  }
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&controllertype_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(controllertype_));
  // @@protoc_insertion_point(copy_constructor:CControllerConfigMsg.ControllerActiveConfigMsg)
}

inline void CControllerConfigMsg_ControllerActiveConfigMsg::SharedCtor() {
configurl_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
controllerdata_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&controllertype_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(controllertype_));
}

CControllerConfigMsg_ControllerActiveConfigMsg::~CControllerConfigMsg_ControllerActiveConfigMsg() {
  // @@protoc_insertion_point(destructor:CControllerConfigMsg.ControllerActiveConfigMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerConfigMsg_ControllerActiveConfigMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  configurl_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  controllerdata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CControllerConfigMsg_ControllerActiveConfigMsg::ArenaDtor(void* object) {
  CControllerConfigMsg_ControllerActiveConfigMsg* _this = reinterpret_cast< CControllerConfigMsg_ControllerActiveConfigMsg* >(object);
  (void)_this;
}
void CControllerConfigMsg_ControllerActiveConfigMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerConfigMsg_ControllerActiveConfigMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerConfigMsg_ControllerActiveConfigMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerConfigMsg.ControllerActiveConfigMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      configurl_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      controllerdata_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&controllertype_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(controllertype_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerConfigMsg_ControllerActiveConfigMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string configURL = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_configurl();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerActiveConfigMsg.configURL");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 controllerType = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_controllertype(&has_bits);
          controllertype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string controllerData = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_controllerdata();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.ControllerActiveConfigMsg.controllerData");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerConfigMsg_ControllerActiveConfigMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerConfigMsg.ControllerActiveConfigMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional string configURL = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_configurl().data(), static_cast<int>(this->_internal_configurl().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerActiveConfigMsg.configURL");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_configurl(), target);
  }

  // optional uint32 controllerType = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_controllertype(), target);
  }

  // optional string controllerData = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controllerdata().data(), static_cast<int>(this->_internal_controllerdata().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.ControllerActiveConfigMsg.controllerData");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_controllerdata(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerConfigMsg.ControllerActiveConfigMsg)
  return target;
}

size_t CControllerConfigMsg_ControllerActiveConfigMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerConfigMsg.ControllerActiveConfigMsg)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string configURL = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_configurl());
    }

    // optional string controllerData = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controllerdata());
    }

    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 controllerType = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_controllertype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerConfigMsg_ControllerActiveConfigMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerConfigMsg_ControllerActiveConfigMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerConfigMsg_ControllerActiveConfigMsg::GetClassData() const { return &_class_data_; }

void CControllerConfigMsg_ControllerActiveConfigMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerConfigMsg_ControllerActiveConfigMsg *>(to)->MergeFrom(
      static_cast<const CControllerConfigMsg_ControllerActiveConfigMsg &>(from));
}


void CControllerConfigMsg_ControllerActiveConfigMsg::MergeFrom(const CControllerConfigMsg_ControllerActiveConfigMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerConfigMsg.ControllerActiveConfigMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_configurl(from._internal_configurl());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_controllerdata(from._internal_controllerdata());
    }
    if (cached_has_bits & 0x00000004u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000008u) {
      controllertype_ = from.controllertype_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerConfigMsg_ControllerActiveConfigMsg::CopyFrom(const CControllerConfigMsg_ControllerActiveConfigMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerConfigMsg.ControllerActiveConfigMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerConfigMsg_ControllerActiveConfigMsg::IsInitialized() const {
  return true;
}

void CControllerConfigMsg_ControllerActiveConfigMsg::InternalSwap(CControllerConfigMsg_ControllerActiveConfigMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &configurl_, lhs_arena,
      &other->configurl_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controllerdata_, lhs_arena,
      &other->controllerdata_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerActiveConfigMsg, controllertype_)
      + sizeof(CControllerConfigMsg_ControllerActiveConfigMsg::controllertype_)
      - PROTOBUF_FIELD_OFFSET(CControllerConfigMsg_ControllerActiveConfigMsg, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerConfigMsg_ControllerActiveConfigMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[110]);
}

// ===================================================================

class CControllerConfigMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<CControllerConfigMsg>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_controllerpath(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CControllerConfigMsg_ControllerPersonalizationResponse& personalizationresponse(const CControllerConfigMsg* msg);
  static void set_has_personalizationresponse(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CControllerConfigMsg_ControllerActiveConfigMsg& activeconfigchangemsg(const CControllerConfigMsg* msg);
  static void set_has_activeconfigchangemsg(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000008) ^ 0x00000008) != 0;
  }
};

const ::CControllerConfigMsg_ControllerPersonalizationResponse&
CControllerConfigMsg::_Internal::personalizationresponse(const CControllerConfigMsg* msg) {
  return *msg->personalizationresponse_;
}
const ::CControllerConfigMsg_ControllerActiveConfigMsg&
CControllerConfigMsg::_Internal::activeconfigchangemsg(const CControllerConfigMsg* msg) {
  return *msg->activeconfigchangemsg_;
}
CControllerConfigMsg::CControllerConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  configresponse_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CControllerConfigMsg)
}
CControllerConfigMsg::CControllerConfigMsg(const CControllerConfigMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      configresponse_(from.configresponse_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  controllerpath_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    controllerpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_controllerpath()) {
    controllerpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_controllerpath(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_personalizationresponse()) {
    personalizationresponse_ = new ::CControllerConfigMsg_ControllerPersonalizationResponse(*from.personalizationresponse_);
  } else {
    personalizationresponse_ = nullptr;
  }
  if (from._internal_has_activeconfigchangemsg()) {
    activeconfigchangemsg_ = new ::CControllerConfigMsg_ControllerActiveConfigMsg(*from.activeconfigchangemsg_);
  } else {
    activeconfigchangemsg_ = nullptr;
  }
  ::memcpy(&type_, &from.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&type_)) + sizeof(appid_));
  // @@protoc_insertion_point(copy_constructor:CControllerConfigMsg)
}

inline void CControllerConfigMsg::SharedCtor() {
controllerpath_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  controllerpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&personalizationresponse_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&appid_) -
    reinterpret_cast<char*>(&personalizationresponse_)) + sizeof(appid_));
}

CControllerConfigMsg::~CControllerConfigMsg() {
  // @@protoc_insertion_point(destructor:CControllerConfigMsg)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CControllerConfigMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  controllerpath_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete personalizationresponse_;
  if (this != internal_default_instance()) delete activeconfigchangemsg_;
}

void CControllerConfigMsg::ArenaDtor(void* object) {
  CControllerConfigMsg* _this = reinterpret_cast< CControllerConfigMsg* >(object);
  (void)_this;
}
void CControllerConfigMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CControllerConfigMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CControllerConfigMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:CControllerConfigMsg)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  configresponse_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      controllerpath_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(personalizationresponse_ != nullptr);
      personalizationresponse_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(activeconfigchangemsg_ != nullptr);
      activeconfigchangemsg_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&appid_) -
        reinterpret_cast<char*>(&type_)) + sizeof(appid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CControllerConfigMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .EStreamControllerConfigMsg type = 1 [default = k_EStreamControllerConfigMsg_RequestConfigsForApp];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EStreamControllerConfigMsg_IsValid(val))) {
            _internal_set_type(static_cast<::EStreamControllerConfigMsg>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string controllerPath = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_controllerpath();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CControllerConfigMsg.controllerPath");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_personalizationresponse(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_configresponse(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_activeconfigchangemsg(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CControllerConfigMsg::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CControllerConfigMsg)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .EStreamControllerConfigMsg type = 1 [default = k_EStreamControllerConfigMsg_RequestConfigsForApp];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional string controllerPath = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_controllerpath().data(), static_cast<int>(this->_internal_controllerpath().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CControllerConfigMsg.controllerPath");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_controllerpath(), target);
  }

  // optional uint32 appid = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_appid(), target);
  }

  // optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::personalizationresponse(this), target, stream);
  }

  // repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_configresponse_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, this->_internal_configresponse(i), target, stream);
  }

  // optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        7, _Internal::activeconfigchangemsg(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CControllerConfigMsg)
  return target;
}

size_t CControllerConfigMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CControllerConfigMsg)
  size_t total_size = 0;

  // required .EStreamControllerConfigMsg type = 1 [default = k_EStreamControllerConfigMsg_RequestConfigsForApp];
  if (_internal_has_type()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_type());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;
  total_size += 1UL * this->_internal_configresponse_size();
  for (const auto& msg : this->configresponse_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string controllerPath = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_controllerpath());
    }

    // optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *personalizationresponse_);
    }

    // optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *activeconfigchangemsg_);
    }

  }
  // optional uint32 appid = 3;
  if (cached_has_bits & 0x00000010u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CControllerConfigMsg::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CControllerConfigMsg::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CControllerConfigMsg::GetClassData() const { return &_class_data_; }

void CControllerConfigMsg::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CControllerConfigMsg *>(to)->MergeFrom(
      static_cast<const CControllerConfigMsg &>(from));
}


void CControllerConfigMsg::MergeFrom(const CControllerConfigMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CControllerConfigMsg)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  configresponse_.MergeFrom(from.configresponse_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_controllerpath(from._internal_controllerpath());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_personalizationresponse()->::CControllerConfigMsg_ControllerPersonalizationResponse::MergeFrom(from._internal_personalizationresponse());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_activeconfigchangemsg()->::CControllerConfigMsg_ControllerActiveConfigMsg::MergeFrom(from._internal_activeconfigchangemsg());
    }
    if (cached_has_bits & 0x00000008u) {
      type_ = from.type_;
    }
    if (cached_has_bits & 0x00000010u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CControllerConfigMsg::CopyFrom(const CControllerConfigMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CControllerConfigMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CControllerConfigMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void CControllerConfigMsg::InternalSwap(CControllerConfigMsg* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  configresponse_.InternalSwap(&other->configresponse_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &controllerpath_, lhs_arena,
      &other->controllerpath_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CControllerConfigMsg, appid_)
      + sizeof(CControllerConfigMsg::appid_)
      - PROTOBUF_FIELD_OFFSET(CControllerConfigMsg, personalizationresponse_)>(
          reinterpret_cast<char*>(&personalizationresponse_),
          reinterpret_cast<char*>(&other->personalizationresponse_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CControllerConfigMsg::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fremoteplay_2eproto_getter, &descriptor_table_steammessages_5fremoteplay_2eproto_once,
      file_level_metadata_steammessages_5fremoteplay_2eproto[111]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CDiscoveryPingRequest* Arena::CreateMaybeMessage< ::CDiscoveryPingRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDiscoveryPingRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CDiscoveryPingResponse* Arena::CreateMaybeMessage< ::CDiscoveryPingResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDiscoveryPingResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingClientHandshakeInfo* Arena::CreateMaybeMessage< ::CStreamingClientHandshakeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingClientHandshakeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CClientHandshakeMsg* Arena::CreateMaybeMessage< ::CClientHandshakeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CClientHandshakeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingServerHandshakeInfo* Arena::CreateMaybeMessage< ::CStreamingServerHandshakeInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingServerHandshakeInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CServerHandshakeMsg* Arena::CreateMaybeMessage< ::CServerHandshakeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CServerHandshakeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationRequestMsg* Arena::CreateMaybeMessage< ::CAuthenticationRequestMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationRequestMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationResponseMsg* Arena::CreateMaybeMessage< ::CAuthenticationResponseMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationResponseMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CKeepAliveMsg* Arena::CreateMaybeMessage< ::CKeepAliveMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CKeepAliveMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStartNetworkTestMsg* Arena::CreateMaybeMessage< ::CStartNetworkTestMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStartNetworkTestMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamVideoMode* Arena::CreateMaybeMessage< ::CStreamVideoMode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamVideoMode >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingClientCaps* Arena::CreateMaybeMessage< ::CStreamingClientCaps >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingClientCaps >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingClientConfig* Arena::CreateMaybeMessage< ::CStreamingClientConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingClientConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingServerConfig* Arena::CreateMaybeMessage< ::CStreamingServerConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingServerConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::CNegotiatedConfig* Arena::CreateMaybeMessage< ::CNegotiatedConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CNegotiatedConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::CNegotiationInitMsg* Arena::CreateMaybeMessage< ::CNegotiationInitMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CNegotiationInitMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CNegotiationSetConfigMsg* Arena::CreateMaybeMessage< ::CNegotiationSetConfigMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CNegotiationSetConfigMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CNegotiationCompleteMsg* Arena::CreateMaybeMessage< ::CNegotiationCompleteMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CNegotiationCompleteMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStartAudioDataMsg* Arena::CreateMaybeMessage< ::CStartAudioDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStartAudioDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStopAudioDataMsg* Arena::CreateMaybeMessage< ::CStopAudioDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStopAudioDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStartVideoDataMsg* Arena::CreateMaybeMessage< ::CStartVideoDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStartVideoDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStopVideoDataMsg* Arena::CreateMaybeMessage< ::CStopVideoDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStopVideoDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStartNeptuneDataMsg* Arena::CreateMaybeMessage< ::CStartNeptuneDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStartNeptuneDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStopNeptuneDataMsg* Arena::CreateMaybeMessage< ::CStopNeptuneDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStopNeptuneDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CRecordedInput* Arena::CreateMaybeMessage< ::CRecordedInput >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CRecordedInput >(arena);
}
template<> PROTOBUF_NOINLINE ::CRecordedInputStream* Arena::CreateMaybeMessage< ::CRecordedInputStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CRecordedInputStream >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputLatencyTestMsg* Arena::CreateMaybeMessage< ::CInputLatencyTestMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputLatencyTestMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputTouchFingerDownMsg* Arena::CreateMaybeMessage< ::CInputTouchFingerDownMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputTouchFingerDownMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputTouchFingerMotionMsg* Arena::CreateMaybeMessage< ::CInputTouchFingerMotionMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputTouchFingerMotionMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputTouchFingerUpMsg* Arena::CreateMaybeMessage< ::CInputTouchFingerUpMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputTouchFingerUpMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputMouseMotionMsg* Arena::CreateMaybeMessage< ::CInputMouseMotionMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputMouseMotionMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputMouseWheelMsg* Arena::CreateMaybeMessage< ::CInputMouseWheelMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputMouseWheelMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputMouseDownMsg* Arena::CreateMaybeMessage< ::CInputMouseDownMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputMouseDownMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputMouseUpMsg* Arena::CreateMaybeMessage< ::CInputMouseUpMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputMouseUpMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputKeyDownMsg* Arena::CreateMaybeMessage< ::CInputKeyDownMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputKeyDownMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputKeyUpMsg* Arena::CreateMaybeMessage< ::CInputKeyUpMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputKeyUpMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CInputTextMsg* Arena::CreateMaybeMessage< ::CInputTextMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CInputTextMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetTitleMsg* Arena::CreateMaybeMessage< ::CSetTitleMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetTitleMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetCaptureSizeMsg* Arena::CreateMaybeMessage< ::CSetCaptureSizeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetCaptureSizeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetIconMsg* Arena::CreateMaybeMessage< ::CSetIconMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetIconMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetFlashStateMsg* Arena::CreateMaybeMessage< ::CSetFlashStateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetFlashStateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CShowCursorMsg* Arena::CreateMaybeMessage< ::CShowCursorMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CShowCursorMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CHideCursorMsg* Arena::CreateMaybeMessage< ::CHideCursorMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CHideCursorMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetCursorMsg* Arena::CreateMaybeMessage< ::CSetCursorMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetCursorMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CGetCursorImageMsg* Arena::CreateMaybeMessage< ::CGetCursorImageMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGetCursorImageMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetCursorImageMsg* Arena::CreateMaybeMessage< ::CSetCursorImageMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetCursorImageMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CVideoDecoderInfoMsg* Arena::CreateMaybeMessage< ::CVideoDecoderInfoMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVideoDecoderInfoMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CVideoEncoderInfoMsg* Arena::CreateMaybeMessage< ::CVideoEncoderInfoMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVideoEncoderInfoMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CPauseMsg* Arena::CreateMaybeMessage< ::CPauseMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CPauseMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CResumeMsg* Arena::CreateMaybeMessage< ::CResumeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CResumeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CEnableHighResCaptureMsg* Arena::CreateMaybeMessage< ::CEnableHighResCaptureMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CEnableHighResCaptureMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CDisableHighResCaptureMsg* Arena::CreateMaybeMessage< ::CDisableHighResCaptureMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDisableHighResCaptureMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CEnableNeptuneDataMsg* Arena::CreateMaybeMessage< ::CEnableNeptuneDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CEnableNeptuneDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CDisableNeptuneDataMsg* Arena::CreateMaybeMessage< ::CDisableNeptuneDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDisableNeptuneDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CPauseControllerInputMsg* Arena::CreateMaybeMessage< ::CPauseControllerInputMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CPauseControllerInputMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CResumeControllerInputMsg* Arena::CreateMaybeMessage< ::CResumeControllerInputMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CResumeControllerInputMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CToggleMagnificationMsg* Arena::CreateMaybeMessage< ::CToggleMagnificationMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CToggleMagnificationMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetCapslockMsg* Arena::CreateMaybeMessage< ::CSetCapslockMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetCapslockMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingKeymapEntry* Arena::CreateMaybeMessage< ::CStreamingKeymapEntry >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingKeymapEntry >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingKeymap* Arena::CreateMaybeMessage< ::CStreamingKeymap >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingKeymap >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetKeymapMsg* Arena::CreateMaybeMessage< ::CSetKeymapMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetKeymapMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStopRequest* Arena::CreateMaybeMessage< ::CStopRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStopRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CQuitRequest* Arena::CreateMaybeMessage< ::CQuitRequest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CQuitRequest >(arena);
}
template<> PROTOBUF_NOINLINE ::CDeleteCursorMsg* Arena::CreateMaybeMessage< ::CDeleteCursorMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDeleteCursorMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetStreamingClientConfig* Arena::CreateMaybeMessage< ::CSetStreamingClientConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetStreamingClientConfig >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetQoSMsg* Arena::CreateMaybeMessage< ::CSetQoSMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetQoSMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetTargetFramerateMsg* Arena::CreateMaybeMessage< ::CSetTargetFramerateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetTargetFramerateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetTargetBitrateMsg* Arena::CreateMaybeMessage< ::CSetTargetBitrateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetTargetBitrateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::COverlayEnabledMsg* Arena::CreateMaybeMessage< ::COverlayEnabledMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::COverlayEnabledMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetGammaRampMsg* Arena::CreateMaybeMessage< ::CSetGammaRampMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetGammaRampMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetActivityMsg* Arena::CreateMaybeMessage< ::CSetActivityMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetActivityMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSystemSuspendMsg* Arena::CreateMaybeMessage< ::CSystemSuspendMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSystemSuspendMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CVirtualHereRequestMsg* Arena::CreateMaybeMessage< ::CVirtualHereRequestMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVirtualHereRequestMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CVirtualHereReadyMsg* Arena::CreateMaybeMessage< ::CVirtualHereReadyMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVirtualHereReadyMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CVirtualHereShareDeviceMsg* Arena::CreateMaybeMessage< ::CVirtualHereShareDeviceMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVirtualHereShareDeviceMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetSpectatorModeMsg* Arena::CreateMaybeMessage< ::CSetSpectatorModeMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetSpectatorModeMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CRemoteHIDMsg* Arena::CreateMaybeMessage< ::CRemoteHIDMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CRemoteHIDMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CTouchConfigActiveMsg* Arena::CreateMaybeMessage< ::CTouchConfigActiveMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTouchConfigActiveMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CGetTouchConfigDataMsg* Arena::CreateMaybeMessage< ::CGetTouchConfigDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGetTouchConfigDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetTouchConfigDataMsg* Arena::CreateMaybeMessage< ::CSetTouchConfigDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetTouchConfigDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSaveTouchConfigLayoutMsg* Arena::CreateMaybeMessage< ::CSaveTouchConfigLayoutMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSaveTouchConfigLayoutMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CTouchActionSetActiveMsg* Arena::CreateMaybeMessage< ::CTouchActionSetActiveMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTouchActionSetActiveMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CTouchActionSetLayerAddedMsg* Arena::CreateMaybeMessage< ::CTouchActionSetLayerAddedMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTouchActionSetLayerAddedMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CTouchActionSetLayerRemovedMsg* Arena::CreateMaybeMessage< ::CTouchActionSetLayerRemovedMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTouchActionSetLayerRemovedMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CGetTouchIconDataMsg* Arena::CreateMaybeMessage< ::CGetTouchIconDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CGetTouchIconDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetTouchIconDataMsg* Arena::CreateMaybeMessage< ::CSetTouchIconDataMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetTouchIconDataMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CRemotePlayTogetherGroupUpdateMsg_Player* Arena::CreateMaybeMessage< ::CRemotePlayTogetherGroupUpdateMsg_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CRemotePlayTogetherGroupUpdateMsg_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CRemotePlayTogetherGroupUpdateMsg* Arena::CreateMaybeMessage< ::CRemotePlayTogetherGroupUpdateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CRemotePlayTogetherGroupUpdateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetInputTemporarilyDisabledMsg* Arena::CreateMaybeMessage< ::CSetInputTemporarilyDisabledMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetInputTemporarilyDisabledMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetQualityOverrideMsg* Arena::CreateMaybeMessage< ::CSetQualityOverrideMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetQualityOverrideMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CSetBitrateOverrideMsg* Arena::CreateMaybeMessage< ::CSetBitrateOverrideMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSetBitrateOverrideMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CShowOnScreenKeyboardMsg* Arena::CreateMaybeMessage< ::CShowOnScreenKeyboardMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CShowOnScreenKeyboardMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerPersonalizationUpdateMsg* Arena::CreateMaybeMessage< ::CControllerPersonalizationUpdateMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerPersonalizationUpdateMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamDataLostMsg* Arena::CreateMaybeMessage< ::CStreamDataLostMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamDataLostMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CAudioFormat* Arena::CreateMaybeMessage< ::CAudioFormat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAudioFormat >(arena);
}
template<> PROTOBUF_NOINLINE ::CVideoFormat* Arena::CreateMaybeMessage< ::CVideoFormat >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CVideoFormat >(arena);
}
template<> PROTOBUF_NOINLINE ::CFrameEvent* Arena::CreateMaybeMessage< ::CFrameEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CFrameEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CFrameStats* Arena::CreateMaybeMessage< ::CFrameStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CFrameStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CFrameStatAccumulatedValue* Arena::CreateMaybeMessage< ::CFrameStatAccumulatedValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CFrameStatAccumulatedValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CFrameStatsListMsg* Arena::CreateMaybeMessage< ::CFrameStatsListMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CFrameStatsListMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CStreamingSessionStats* Arena::CreateMaybeMessage< ::CStreamingSessionStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CStreamingSessionStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CDebugDumpMsg* Arena::CreateMaybeMessage< ::CDebugDumpMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CDebugDumpMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CLogMsg* Arena::CreateMaybeMessage< ::CLogMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CLogMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CLogUploadMsg* Arena::CreateMaybeMessage< ::CLogUploadMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CLogUploadMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CTransportSignalMsg_WebRTCMessage_Candidate* Arena::CreateMaybeMessage< ::CTransportSignalMsg_WebRTCMessage_Candidate >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTransportSignalMsg_WebRTCMessage_Candidate >(arena);
}
template<> PROTOBUF_NOINLINE ::CTransportSignalMsg_WebRTCMessage* Arena::CreateMaybeMessage< ::CTransportSignalMsg_WebRTCMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTransportSignalMsg_WebRTCMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CTransportSignalMsg* Arena::CreateMaybeMessage< ::CTransportSignalMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CTransportSignalMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerConfigMsg_ControllerConfigResponse* Arena::CreateMaybeMessage< ::CControllerConfigMsg_ControllerConfigResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerConfigMsg_ControllerConfigResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerConfigMsg_ControllerPersonalizationResponse* Arena::CreateMaybeMessage< ::CControllerConfigMsg_ControllerPersonalizationResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerConfigMsg_ControllerPersonalizationResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerConfigMsg_ControllerActiveConfigChangeResponse* Arena::CreateMaybeMessage< ::CControllerConfigMsg_ControllerActiveConfigChangeResponse >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerConfigMsg_ControllerActiveConfigChangeResponse >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerConfigMsg_ControllerActiveConfigMsg* Arena::CreateMaybeMessage< ::CControllerConfigMsg_ControllerActiveConfigMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerConfigMsg_ControllerActiveConfigMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::CControllerConfigMsg* Arena::CreateMaybeMessage< ::CControllerConfigMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CControllerConfigMsg >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
