// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_remoteclient_discovery.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteclient_5fdiscovery_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteclient_5fdiscovery_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fremoteclient_5fdiscovery_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fremoteclient_5fdiscovery_2eproto;
class CMsgRemoteClientBroadcastClientIDDeconflict;
struct CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal;
extern CMsgRemoteClientBroadcastClientIDDeconflictDefaultTypeInternal _CMsgRemoteClientBroadcastClientIDDeconflict_default_instance_;
class CMsgRemoteClientBroadcastDiscovery;
struct CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal;
extern CMsgRemoteClientBroadcastDiscoveryDefaultTypeInternal _CMsgRemoteClientBroadcastDiscovery_default_instance_;
class CMsgRemoteClientBroadcastHeader;
struct CMsgRemoteClientBroadcastHeaderDefaultTypeInternal;
extern CMsgRemoteClientBroadcastHeaderDefaultTypeInternal _CMsgRemoteClientBroadcastHeader_default_instance_;
class CMsgRemoteClientBroadcastStatus;
struct CMsgRemoteClientBroadcastStatusDefaultTypeInternal;
extern CMsgRemoteClientBroadcastStatusDefaultTypeInternal _CMsgRemoteClientBroadcastStatus_default_instance_;
class CMsgRemoteClientBroadcastStatus_User;
struct CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal;
extern CMsgRemoteClientBroadcastStatus_UserDefaultTypeInternal _CMsgRemoteClientBroadcastStatus_User_default_instance_;
class CMsgRemoteDeviceAuthorizationCancelRequest;
struct CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal;
extern CMsgRemoteDeviceAuthorizationCancelRequestDefaultTypeInternal _CMsgRemoteDeviceAuthorizationCancelRequest_default_instance_;
class CMsgRemoteDeviceAuthorizationConfirmed;
struct CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal;
extern CMsgRemoteDeviceAuthorizationConfirmedDefaultTypeInternal _CMsgRemoteDeviceAuthorizationConfirmed_default_instance_;
class CMsgRemoteDeviceAuthorizationRequest;
struct CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal;
extern CMsgRemoteDeviceAuthorizationRequestDefaultTypeInternal _CMsgRemoteDeviceAuthorizationRequest_default_instance_;
class CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket;
struct CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal;
extern CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_TicketDefaultTypeInternal _CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket_default_instance_;
class CMsgRemoteDeviceAuthorizationResponse;
struct CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal;
extern CMsgRemoteDeviceAuthorizationResponseDefaultTypeInternal _CMsgRemoteDeviceAuthorizationResponse_default_instance_;
class CMsgRemoteDeviceProofRequest;
struct CMsgRemoteDeviceProofRequestDefaultTypeInternal;
extern CMsgRemoteDeviceProofRequestDefaultTypeInternal _CMsgRemoteDeviceProofRequest_default_instance_;
class CMsgRemoteDeviceProofResponse;
struct CMsgRemoteDeviceProofResponseDefaultTypeInternal;
extern CMsgRemoteDeviceProofResponseDefaultTypeInternal _CMsgRemoteDeviceProofResponse_default_instance_;
class CMsgRemoteDeviceStreamTransportSignal;
struct CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal;
extern CMsgRemoteDeviceStreamTransportSignalDefaultTypeInternal _CMsgRemoteDeviceStreamTransportSignal_default_instance_;
class CMsgRemoteDeviceStreamingCancelRequest;
struct CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal;
extern CMsgRemoteDeviceStreamingCancelRequestDefaultTypeInternal _CMsgRemoteDeviceStreamingCancelRequest_default_instance_;
class CMsgRemoteDeviceStreamingProgress;
struct CMsgRemoteDeviceStreamingProgressDefaultTypeInternal;
extern CMsgRemoteDeviceStreamingProgressDefaultTypeInternal _CMsgRemoteDeviceStreamingProgress_default_instance_;
class CMsgRemoteDeviceStreamingRequest;
struct CMsgRemoteDeviceStreamingRequestDefaultTypeInternal;
extern CMsgRemoteDeviceStreamingRequestDefaultTypeInternal _CMsgRemoteDeviceStreamingRequest_default_instance_;
class CMsgRemoteDeviceStreamingRequest_ReservedGamepad;
struct CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal;
extern CMsgRemoteDeviceStreamingRequest_ReservedGamepadDefaultTypeInternal _CMsgRemoteDeviceStreamingRequest_ReservedGamepad_default_instance_;
class CMsgRemoteDeviceStreamingResponse;
struct CMsgRemoteDeviceStreamingResponseDefaultTypeInternal;
extern CMsgRemoteDeviceStreamingResponseDefaultTypeInternal _CMsgRemoteDeviceStreamingResponse_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CMsgRemoteClientBroadcastClientIDDeconflict* Arena::CreateMaybeMessage<::CMsgRemoteClientBroadcastClientIDDeconflict>(Arena*);
template<> ::CMsgRemoteClientBroadcastDiscovery* Arena::CreateMaybeMessage<::CMsgRemoteClientBroadcastDiscovery>(Arena*);
template<> ::CMsgRemoteClientBroadcastHeader* Arena::CreateMaybeMessage<::CMsgRemoteClientBroadcastHeader>(Arena*);
template<> ::CMsgRemoteClientBroadcastStatus* Arena::CreateMaybeMessage<::CMsgRemoteClientBroadcastStatus>(Arena*);
template<> ::CMsgRemoteClientBroadcastStatus_User* Arena::CreateMaybeMessage<::CMsgRemoteClientBroadcastStatus_User>(Arena*);
template<> ::CMsgRemoteDeviceAuthorizationCancelRequest* Arena::CreateMaybeMessage<::CMsgRemoteDeviceAuthorizationCancelRequest>(Arena*);
template<> ::CMsgRemoteDeviceAuthorizationConfirmed* Arena::CreateMaybeMessage<::CMsgRemoteDeviceAuthorizationConfirmed>(Arena*);
template<> ::CMsgRemoteDeviceAuthorizationRequest* Arena::CreateMaybeMessage<::CMsgRemoteDeviceAuthorizationRequest>(Arena*);
template<> ::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* Arena::CreateMaybeMessage<::CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket>(Arena*);
template<> ::CMsgRemoteDeviceAuthorizationResponse* Arena::CreateMaybeMessage<::CMsgRemoteDeviceAuthorizationResponse>(Arena*);
template<> ::CMsgRemoteDeviceProofRequest* Arena::CreateMaybeMessage<::CMsgRemoteDeviceProofRequest>(Arena*);
template<> ::CMsgRemoteDeviceProofResponse* Arena::CreateMaybeMessage<::CMsgRemoteDeviceProofResponse>(Arena*);
template<> ::CMsgRemoteDeviceStreamTransportSignal* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamTransportSignal>(Arena*);
template<> ::CMsgRemoteDeviceStreamingCancelRequest* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamingCancelRequest>(Arena*);
template<> ::CMsgRemoteDeviceStreamingProgress* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamingProgress>(Arena*);
template<> ::CMsgRemoteDeviceStreamingRequest* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamingRequest>(Arena*);
template<> ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamingRequest_ReservedGamepad>(Arena*);
template<> ::CMsgRemoteDeviceStreamingResponse* Arena::CreateMaybeMessage<::CMsgRemoteDeviceStreamingResponse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage : int {
  CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_k_EKeyEscrowUsageStreamingDevice = 0
};
bool CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_IsValid(int value);
constexpr CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_MIN = CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_k_EKeyEscrowUsageStreamingDevice;
constexpr CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_MAX = CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_k_EKeyEscrowUsageStreamingDevice;
constexpr int CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_ARRAYSIZE = CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor();
template<typename T>
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor(), enum_t_value);
}
inline bool CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>(
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor(), name, value);
}
enum ERemoteClientBroadcastMsg : int {
  k_ERemoteClientBroadcastMsgDiscovery = 0,
  k_ERemoteClientBroadcastMsgStatus = 1,
  k_ERemoteClientBroadcastMsgOffline = 2,
  k_ERemoteDeviceAuthorizationRequest = 3,
  k_ERemoteDeviceAuthorizationResponse = 4,
  k_ERemoteDeviceStreamingRequest = 5,
  k_ERemoteDeviceStreamingResponse = 6,
  k_ERemoteDeviceProofRequest = 7,
  k_ERemoteDeviceProofResponse = 8,
  k_ERemoteDeviceAuthorizationCancelRequest = 9,
  k_ERemoteDeviceStreamingCancelRequest = 10,
  k_ERemoteClientBroadcastMsgClientIDDeconflict = 11,
  k_ERemoteDeviceStreamTransportSignal = 12,
  k_ERemoteDeviceStreamingProgress = 13,
  k_ERemoteDeviceAuthorizationConfirmed = 14
};
bool ERemoteClientBroadcastMsg_IsValid(int value);
constexpr ERemoteClientBroadcastMsg ERemoteClientBroadcastMsg_MIN = k_ERemoteClientBroadcastMsgDiscovery;
constexpr ERemoteClientBroadcastMsg ERemoteClientBroadcastMsg_MAX = k_ERemoteDeviceAuthorizationConfirmed;
constexpr int ERemoteClientBroadcastMsg_ARRAYSIZE = ERemoteClientBroadcastMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteClientBroadcastMsg_descriptor();
template<typename T>
inline const std::string& ERemoteClientBroadcastMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERemoteClientBroadcastMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERemoteClientBroadcastMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERemoteClientBroadcastMsg_descriptor(), enum_t_value);
}
inline bool ERemoteClientBroadcastMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERemoteClientBroadcastMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERemoteClientBroadcastMsg>(
    ERemoteClientBroadcastMsg_descriptor(), name, value);
}
enum ERemoteClientService : int {
  k_ERemoteClientServiceNone = 0,
  k_ERemoteClientServiceRemoteControl = 1,
  k_ERemoteClientServiceGameStreaming = 2,
  k_ERemoteClientServiceSiteLicense = 4,
  k_ERemoteClientServiceContentCache = 8,
  k_ERemoteClientServiceContentServer = 16
};
bool ERemoteClientService_IsValid(int value);
constexpr ERemoteClientService ERemoteClientService_MIN = k_ERemoteClientServiceNone;
constexpr ERemoteClientService ERemoteClientService_MAX = k_ERemoteClientServiceContentServer;
constexpr int ERemoteClientService_ARRAYSIZE = ERemoteClientService_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteClientService_descriptor();
template<typename T>
inline const std::string& ERemoteClientService_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERemoteClientService>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERemoteClientService_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERemoteClientService_descriptor(), enum_t_value);
}
inline bool ERemoteClientService_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERemoteClientService* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERemoteClientService>(
    ERemoteClientService_descriptor(), name, value);
}
enum ERemoteDeviceAuthorizationResult : int {
  k_ERemoteDeviceAuthorizationSuccess = 0,
  k_ERemoteDeviceAuthorizationDenied = 1,
  k_ERemoteDeviceAuthorizationNotLoggedIn = 2,
  k_ERemoteDeviceAuthorizationOffline = 3,
  k_ERemoteDeviceAuthorizationBusy = 4,
  k_ERemoteDeviceAuthorizationInProgress = 5,
  k_ERemoteDeviceAuthorizationTimedOut = 6,
  k_ERemoteDeviceAuthorizationFailed = 7,
  k_ERemoteDeviceAuthorizationCanceled = 8
};
bool ERemoteDeviceAuthorizationResult_IsValid(int value);
constexpr ERemoteDeviceAuthorizationResult ERemoteDeviceAuthorizationResult_MIN = k_ERemoteDeviceAuthorizationSuccess;
constexpr ERemoteDeviceAuthorizationResult ERemoteDeviceAuthorizationResult_MAX = k_ERemoteDeviceAuthorizationCanceled;
constexpr int ERemoteDeviceAuthorizationResult_ARRAYSIZE = ERemoteDeviceAuthorizationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteDeviceAuthorizationResult_descriptor();
template<typename T>
inline const std::string& ERemoteDeviceAuthorizationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERemoteDeviceAuthorizationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERemoteDeviceAuthorizationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERemoteDeviceAuthorizationResult_descriptor(), enum_t_value);
}
inline bool ERemoteDeviceAuthorizationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERemoteDeviceAuthorizationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERemoteDeviceAuthorizationResult>(
    ERemoteDeviceAuthorizationResult_descriptor(), name, value);
}
enum EStreamDeviceFormFactor : int {
  k_EStreamDeviceFormFactorUnknown = 0,
  k_EStreamDeviceFormFactorPhone = 1,
  k_EStreamDeviceFormFactorTablet = 2,
  k_EStreamDeviceFormFactorComputer = 3,
  k_EStreamDeviceFormFactorTV = 4
};
bool EStreamDeviceFormFactor_IsValid(int value);
constexpr EStreamDeviceFormFactor EStreamDeviceFormFactor_MIN = k_EStreamDeviceFormFactorUnknown;
constexpr EStreamDeviceFormFactor EStreamDeviceFormFactor_MAX = k_EStreamDeviceFormFactorTV;
constexpr int EStreamDeviceFormFactor_ARRAYSIZE = EStreamDeviceFormFactor_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDeviceFormFactor_descriptor();
template<typename T>
inline const std::string& EStreamDeviceFormFactor_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamDeviceFormFactor>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamDeviceFormFactor_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamDeviceFormFactor_descriptor(), enum_t_value);
}
inline bool EStreamDeviceFormFactor_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamDeviceFormFactor* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamDeviceFormFactor>(
    EStreamDeviceFormFactor_descriptor(), name, value);
}
enum EStreamTransport : int {
  k_EStreamTransportNone = 0,
  k_EStreamTransportUDP = 1,
  k_EStreamTransportUDPRelay = 2,
  k_EStreamTransportWebRTC = 3,
  k_EStreamTransportSDR = 4,
  k_EStreamTransportUDP_SNS = 5,
  k_EStreamTransportUDPRelay_SNS = 6
};
bool EStreamTransport_IsValid(int value);
constexpr EStreamTransport EStreamTransport_MIN = k_EStreamTransportNone;
constexpr EStreamTransport EStreamTransport_MAX = k_EStreamTransportUDPRelay_SNS;
constexpr int EStreamTransport_ARRAYSIZE = EStreamTransport_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamTransport_descriptor();
template<typename T>
inline const std::string& EStreamTransport_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamTransport>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamTransport_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamTransport_descriptor(), enum_t_value);
}
inline bool EStreamTransport_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamTransport* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamTransport>(
    EStreamTransport_descriptor(), name, value);
}
enum EStreamInterface : int {
  k_EStreamInterfaceDefault = 0,
  k_EStreamInterfaceRecentGames = 1,
  k_EStreamInterfaceBigPicture = 2,
  k_EStreamInterfaceDesktop = 3
};
bool EStreamInterface_IsValid(int value);
constexpr EStreamInterface EStreamInterface_MIN = k_EStreamInterfaceDefault;
constexpr EStreamInterface EStreamInterface_MAX = k_EStreamInterfaceDesktop;
constexpr int EStreamInterface_ARRAYSIZE = EStreamInterface_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamInterface_descriptor();
template<typename T>
inline const std::string& EStreamInterface_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamInterface>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamInterface_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamInterface_descriptor(), enum_t_value);
}
inline bool EStreamInterface_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamInterface* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamInterface>(
    EStreamInterface_descriptor(), name, value);
}
enum ERemoteDeviceStreamingResult : int {
  k_ERemoteDeviceStreamingSuccess = 0,
  k_ERemoteDeviceStreamingUnauthorized = 1,
  k_ERemoteDeviceStreamingScreenLocked = 2,
  k_ERemoteDeviceStreamingFailed = 3,
  k_ERemoteDeviceStreamingBusy = 4,
  k_ERemoteDeviceStreamingInProgress = 5,
  k_ERemoteDeviceStreamingCanceled = 6,
  k_ERemoteDeviceStreamingDriversNotInstalled = 7,
  k_ERemoteDeviceStreamingDisabled = 8,
  k_ERemoteDeviceStreamingBroadcastingActive = 9,
  k_ERemoteDeviceStreamingVRActive = 10,
  k_ERemoteDeviceStreamingPINRequired = 11,
  k_ERemoteDeviceStreamingTransportUnavailable = 12,
  k_ERemoteDeviceStreamingInvisible = 13,
  k_ERemoteDeviceStreamingGameLaunchFailed = 14
};
bool ERemoteDeviceStreamingResult_IsValid(int value);
constexpr ERemoteDeviceStreamingResult ERemoteDeviceStreamingResult_MIN = k_ERemoteDeviceStreamingSuccess;
constexpr ERemoteDeviceStreamingResult ERemoteDeviceStreamingResult_MAX = k_ERemoteDeviceStreamingGameLaunchFailed;
constexpr int ERemoteDeviceStreamingResult_ARRAYSIZE = ERemoteDeviceStreamingResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ERemoteDeviceStreamingResult_descriptor();
template<typename T>
inline const std::string& ERemoteDeviceStreamingResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ERemoteDeviceStreamingResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ERemoteDeviceStreamingResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ERemoteDeviceStreamingResult_descriptor(), enum_t_value);
}
inline bool ERemoteDeviceStreamingResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ERemoteDeviceStreamingResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ERemoteDeviceStreamingResult>(
    ERemoteDeviceStreamingResult_descriptor(), name, value);
}
// ===================================================================

class CMsgRemoteClientBroadcastHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteClientBroadcastHeader) */ {
 public:
  inline CMsgRemoteClientBroadcastHeader() : CMsgRemoteClientBroadcastHeader(nullptr) {}
  ~CMsgRemoteClientBroadcastHeader() override;
  explicit constexpr CMsgRemoteClientBroadcastHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteClientBroadcastHeader(const CMsgRemoteClientBroadcastHeader& from);
  CMsgRemoteClientBroadcastHeader(CMsgRemoteClientBroadcastHeader&& from) noexcept
    : CMsgRemoteClientBroadcastHeader() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteClientBroadcastHeader& operator=(const CMsgRemoteClientBroadcastHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteClientBroadcastHeader& operator=(CMsgRemoteClientBroadcastHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteClientBroadcastHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteClientBroadcastHeader* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteClientBroadcastHeader*>(
               &_CMsgRemoteClientBroadcastHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CMsgRemoteClientBroadcastHeader& a, CMsgRemoteClientBroadcastHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteClientBroadcastHeader* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteClientBroadcastHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteClientBroadcastHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteClientBroadcastHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteClientBroadcastHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteClientBroadcastHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteClientBroadcastHeader* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteClientBroadcastHeader";
  }
  protected:
  explicit CMsgRemoteClientBroadcastHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceTokenFieldNumber = 5,
    kClientIdFieldNumber = 1,
    kInstanceIdFieldNumber = 3,
    kDeviceIdFieldNumber = 4,
    kMsgTypeFieldNumber = 2,
  };
  // optional bytes device_token = 5;
  bool has_device_token() const;
  private:
  bool _internal_has_device_token() const;
  public:
  void clear_device_token();
  const std::string& device_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_token();
  PROTOBUF_NODISCARD std::string* release_device_token();
  void set_allocated_device_token(std::string* device_token);
  private:
  const std::string& _internal_device_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
  std::string* _internal_mutable_device_token();
  public:

  // optional uint64 client_id = 1;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional uint64 instance_id = 3;
  bool has_instance_id() const;
  private:
  bool _internal_has_instance_id() const;
  public:
  void clear_instance_id();
  uint64_t instance_id() const;
  void set_instance_id(uint64_t value);
  private:
  uint64_t _internal_instance_id() const;
  void _internal_set_instance_id(uint64_t value);
  public:

  // optional uint64 device_id = 4;
  bool has_device_id() const;
  private:
  bool _internal_has_device_id() const;
  public:
  void clear_device_id();
  uint64_t device_id() const;
  void set_device_id(uint64_t value);
  private:
  uint64_t _internal_device_id() const;
  void _internal_set_device_id(uint64_t value);
  public:

  // optional .ERemoteClientBroadcastMsg msg_type = 2 [default = k_ERemoteClientBroadcastMsgDiscovery];
  bool has_msg_type() const;
  private:
  bool _internal_has_msg_type() const;
  public:
  void clear_msg_type();
  ::ERemoteClientBroadcastMsg msg_type() const;
  void set_msg_type(::ERemoteClientBroadcastMsg value);
  private:
  ::ERemoteClientBroadcastMsg _internal_msg_type() const;
  void _internal_set_msg_type(::ERemoteClientBroadcastMsg value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteClientBroadcastHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
  uint64_t client_id_;
  uint64_t instance_id_;
  uint64_t device_id_;
  int msg_type_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteClientBroadcastStatus_User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteClientBroadcastStatus.User) */ {
 public:
  inline CMsgRemoteClientBroadcastStatus_User() : CMsgRemoteClientBroadcastStatus_User(nullptr) {}
  ~CMsgRemoteClientBroadcastStatus_User() override;
  explicit constexpr CMsgRemoteClientBroadcastStatus_User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteClientBroadcastStatus_User(const CMsgRemoteClientBroadcastStatus_User& from);
  CMsgRemoteClientBroadcastStatus_User(CMsgRemoteClientBroadcastStatus_User&& from) noexcept
    : CMsgRemoteClientBroadcastStatus_User() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteClientBroadcastStatus_User& operator=(const CMsgRemoteClientBroadcastStatus_User& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteClientBroadcastStatus_User& operator=(CMsgRemoteClientBroadcastStatus_User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteClientBroadcastStatus_User& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteClientBroadcastStatus_User* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteClientBroadcastStatus_User*>(
               &_CMsgRemoteClientBroadcastStatus_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CMsgRemoteClientBroadcastStatus_User& a, CMsgRemoteClientBroadcastStatus_User& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteClientBroadcastStatus_User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteClientBroadcastStatus_User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteClientBroadcastStatus_User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteClientBroadcastStatus_User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteClientBroadcastStatus_User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteClientBroadcastStatus_User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteClientBroadcastStatus_User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteClientBroadcastStatus.User";
  }
  protected:
  explicit CMsgRemoteClientBroadcastStatus_User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSteamidFieldNumber = 1,
    kAuthKeyIdFieldNumber = 2,
  };
  // optional fixed64 steamid = 1;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional uint32 auth_key_id = 2;
  bool has_auth_key_id() const;
  private:
  bool _internal_has_auth_key_id() const;
  public:
  void clear_auth_key_id();
  uint32_t auth_key_id() const;
  void set_auth_key_id(uint32_t value);
  private:
  uint32_t _internal_auth_key_id() const;
  void _internal_set_auth_key_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteClientBroadcastStatus.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t steamid_;
  uint32_t auth_key_id_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteClientBroadcastStatus final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteClientBroadcastStatus) */ {
 public:
  inline CMsgRemoteClientBroadcastStatus() : CMsgRemoteClientBroadcastStatus(nullptr) {}
  ~CMsgRemoteClientBroadcastStatus() override;
  explicit constexpr CMsgRemoteClientBroadcastStatus(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteClientBroadcastStatus(const CMsgRemoteClientBroadcastStatus& from);
  CMsgRemoteClientBroadcastStatus(CMsgRemoteClientBroadcastStatus&& from) noexcept
    : CMsgRemoteClientBroadcastStatus() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteClientBroadcastStatus& operator=(const CMsgRemoteClientBroadcastStatus& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteClientBroadcastStatus& operator=(CMsgRemoteClientBroadcastStatus&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteClientBroadcastStatus& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteClientBroadcastStatus* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteClientBroadcastStatus*>(
               &_CMsgRemoteClientBroadcastStatus_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CMsgRemoteClientBroadcastStatus& a, CMsgRemoteClientBroadcastStatus& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteClientBroadcastStatus* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteClientBroadcastStatus* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteClientBroadcastStatus* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteClientBroadcastStatus>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteClientBroadcastStatus& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteClientBroadcastStatus& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteClientBroadcastStatus* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteClientBroadcastStatus";
  }
  protected:
  explicit CMsgRemoteClientBroadcastStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgRemoteClientBroadcastStatus_User User;

  // accessors -------------------------------------------------------

  enum : int {
    kUsersFieldNumber = 9,
    kMacAddressesFieldNumber = 15,
    kIpAddressesFieldNumber = 20,
    kHostnameFieldNumber = 4,
    kPublicIpAddressFieldNumber = 21,
    kVersionFieldNumber = 1,
    kMinVersionFieldNumber = 2,
    kConnectPortFieldNumber = 3,
    kEnabledServicesFieldNumber = 6,
    kOstypeFieldNumber = 7,
    kEuniverseFieldNumber = 11,
    kTimestampFieldNumber = 12,
    kIs64BitFieldNumber = 8,
    kScreenLockedFieldNumber = 13,
    kGamesRunningFieldNumber = 14,
    kBroadcastingActiveFieldNumber = 17,
    kDownloadLanPeerGroupFieldNumber = 16,
    kContentCachePortFieldNumber = 19,
    kVrActiveFieldNumber = 18,
    kRemoteplayActiveFieldNumber = 22,
    kSteamDeckFieldNumber = 24,
    kSupportedServicesFieldNumber = 23,
    kSteamVersionFieldNumber = 25,
  };
  // repeated .CMsgRemoteClientBroadcastStatus.User users = 9;
  int users_size() const;
  private:
  int _internal_users_size() const;
  public:
  void clear_users();
  ::CMsgRemoteClientBroadcastStatus_User* mutable_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteClientBroadcastStatus_User >*
      mutable_users();
  private:
  const ::CMsgRemoteClientBroadcastStatus_User& _internal_users(int index) const;
  ::CMsgRemoteClientBroadcastStatus_User* _internal_add_users();
  public:
  const ::CMsgRemoteClientBroadcastStatus_User& users(int index) const;
  ::CMsgRemoteClientBroadcastStatus_User* add_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteClientBroadcastStatus_User >&
      users() const;

  // repeated string mac_addresses = 15;
  int mac_addresses_size() const;
  private:
  int _internal_mac_addresses_size() const;
  public:
  void clear_mac_addresses();
  const std::string& mac_addresses(int index) const;
  std::string* mutable_mac_addresses(int index);
  void set_mac_addresses(int index, const std::string& value);
  void set_mac_addresses(int index, std::string&& value);
  void set_mac_addresses(int index, const char* value);
  void set_mac_addresses(int index, const char* value, size_t size);
  std::string* add_mac_addresses();
  void add_mac_addresses(const std::string& value);
  void add_mac_addresses(std::string&& value);
  void add_mac_addresses(const char* value);
  void add_mac_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& mac_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_mac_addresses();
  private:
  const std::string& _internal_mac_addresses(int index) const;
  std::string* _internal_add_mac_addresses();
  public:

  // repeated string ip_addresses = 20;
  int ip_addresses_size() const;
  private:
  int _internal_ip_addresses_size() const;
  public:
  void clear_ip_addresses();
  const std::string& ip_addresses(int index) const;
  std::string* mutable_ip_addresses(int index);
  void set_ip_addresses(int index, const std::string& value);
  void set_ip_addresses(int index, std::string&& value);
  void set_ip_addresses(int index, const char* value);
  void set_ip_addresses(int index, const char* value, size_t size);
  std::string* add_ip_addresses();
  void add_ip_addresses(const std::string& value);
  void add_ip_addresses(std::string&& value);
  void add_ip_addresses(const char* value);
  void add_ip_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& ip_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_ip_addresses();
  private:
  const std::string& _internal_ip_addresses(int index) const;
  std::string* _internal_add_ip_addresses();
  public:

  // optional string hostname = 4;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // optional string public_ip_address = 21;
  bool has_public_ip_address() const;
  private:
  bool _internal_has_public_ip_address() const;
  public:
  void clear_public_ip_address();
  const std::string& public_ip_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_ip_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_ip_address();
  PROTOBUF_NODISCARD std::string* release_public_ip_address();
  void set_allocated_public_ip_address(std::string* public_ip_address);
  private:
  const std::string& _internal_public_ip_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_ip_address(const std::string& value);
  std::string* _internal_mutable_public_ip_address();
  public:

  // optional int32 version = 1;
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  int32_t version() const;
  void set_version(int32_t value);
  private:
  int32_t _internal_version() const;
  void _internal_set_version(int32_t value);
  public:

  // optional int32 min_version = 2;
  bool has_min_version() const;
  private:
  bool _internal_has_min_version() const;
  public:
  void clear_min_version();
  int32_t min_version() const;
  void set_min_version(int32_t value);
  private:
  int32_t _internal_min_version() const;
  void _internal_set_min_version(int32_t value);
  public:

  // optional uint32 connect_port = 3;
  bool has_connect_port() const;
  private:
  bool _internal_has_connect_port() const;
  public:
  void clear_connect_port();
  uint32_t connect_port() const;
  void set_connect_port(uint32_t value);
  private:
  uint32_t _internal_connect_port() const;
  void _internal_set_connect_port(uint32_t value);
  public:

  // optional uint32 enabled_services = 6;
  bool has_enabled_services() const;
  private:
  bool _internal_has_enabled_services() const;
  public:
  void clear_enabled_services();
  uint32_t enabled_services() const;
  void set_enabled_services(uint32_t value);
  private:
  uint32_t _internal_enabled_services() const;
  void _internal_set_enabled_services(uint32_t value);
  public:

  // optional int32 ostype = 7 [default = 0];
  bool has_ostype() const;
  private:
  bool _internal_has_ostype() const;
  public:
  void clear_ostype();
  int32_t ostype() const;
  void set_ostype(int32_t value);
  private:
  int32_t _internal_ostype() const;
  void _internal_set_ostype(int32_t value);
  public:

  // optional int32 euniverse = 11;
  bool has_euniverse() const;
  private:
  bool _internal_has_euniverse() const;
  public:
  void clear_euniverse();
  int32_t euniverse() const;
  void set_euniverse(int32_t value);
  private:
  int32_t _internal_euniverse() const;
  void _internal_set_euniverse(int32_t value);
  public:

  // optional uint32 timestamp = 12;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional bool is64bit = 8;
  bool has_is64bit() const;
  private:
  bool _internal_has_is64bit() const;
  public:
  void clear_is64bit();
  bool is64bit() const;
  void set_is64bit(bool value);
  private:
  bool _internal_is64bit() const;
  void _internal_set_is64bit(bool value);
  public:

  // optional bool screen_locked = 13;
  bool has_screen_locked() const;
  private:
  bool _internal_has_screen_locked() const;
  public:
  void clear_screen_locked();
  bool screen_locked() const;
  void set_screen_locked(bool value);
  private:
  bool _internal_screen_locked() const;
  void _internal_set_screen_locked(bool value);
  public:

  // optional bool games_running = 14;
  bool has_games_running() const;
  private:
  bool _internal_has_games_running() const;
  public:
  void clear_games_running();
  bool games_running() const;
  void set_games_running(bool value);
  private:
  bool _internal_games_running() const;
  void _internal_set_games_running(bool value);
  public:

  // optional bool broadcasting_active = 17;
  bool has_broadcasting_active() const;
  private:
  bool _internal_has_broadcasting_active() const;
  public:
  void clear_broadcasting_active();
  bool broadcasting_active() const;
  void set_broadcasting_active(bool value);
  private:
  bool _internal_broadcasting_active() const;
  void _internal_set_broadcasting_active(bool value);
  public:

  // optional uint32 download_lan_peer_group = 16;
  bool has_download_lan_peer_group() const;
  private:
  bool _internal_has_download_lan_peer_group() const;
  public:
  void clear_download_lan_peer_group();
  uint32_t download_lan_peer_group() const;
  void set_download_lan_peer_group(uint32_t value);
  private:
  uint32_t _internal_download_lan_peer_group() const;
  void _internal_set_download_lan_peer_group(uint32_t value);
  public:

  // optional uint32 content_cache_port = 19;
  bool has_content_cache_port() const;
  private:
  bool _internal_has_content_cache_port() const;
  public:
  void clear_content_cache_port();
  uint32_t content_cache_port() const;
  void set_content_cache_port(uint32_t value);
  private:
  uint32_t _internal_content_cache_port() const;
  void _internal_set_content_cache_port(uint32_t value);
  public:

  // optional bool vr_active = 18;
  bool has_vr_active() const;
  private:
  bool _internal_has_vr_active() const;
  public:
  void clear_vr_active();
  bool vr_active() const;
  void set_vr_active(bool value);
  private:
  bool _internal_vr_active() const;
  void _internal_set_vr_active(bool value);
  public:

  // optional bool remoteplay_active = 22;
  bool has_remoteplay_active() const;
  private:
  bool _internal_has_remoteplay_active() const;
  public:
  void clear_remoteplay_active();
  bool remoteplay_active() const;
  void set_remoteplay_active(bool value);
  private:
  bool _internal_remoteplay_active() const;
  void _internal_set_remoteplay_active(bool value);
  public:

  // optional bool steam_deck = 24;
  bool has_steam_deck() const;
  private:
  bool _internal_has_steam_deck() const;
  public:
  void clear_steam_deck();
  bool steam_deck() const;
  void set_steam_deck(bool value);
  private:
  bool _internal_steam_deck() const;
  void _internal_set_steam_deck(bool value);
  public:

  // optional uint32 supported_services = 23;
  bool has_supported_services() const;
  private:
  bool _internal_has_supported_services() const;
  public:
  void clear_supported_services();
  uint32_t supported_services() const;
  void set_supported_services(uint32_t value);
  private:
  uint32_t _internal_supported_services() const;
  void _internal_set_supported_services(uint32_t value);
  public:

  // optional uint64 steam_version = 25;
  bool has_steam_version() const;
  private:
  bool _internal_has_steam_version() const;
  public:
  void clear_steam_version();
  uint64_t steam_version() const;
  void set_steam_version(uint64_t value);
  private:
  uint64_t _internal_steam_version() const;
  void _internal_set_steam_version(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteClientBroadcastStatus)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteClientBroadcastStatus_User > users_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> mac_addresses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> ip_addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_ip_address_;
  int32_t version_;
  int32_t min_version_;
  uint32_t connect_port_;
  uint32_t enabled_services_;
  int32_t ostype_;
  int32_t euniverse_;
  uint32_t timestamp_;
  bool is64bit_;
  bool screen_locked_;
  bool games_running_;
  bool broadcasting_active_;
  uint32_t download_lan_peer_group_;
  uint32_t content_cache_port_;
  bool vr_active_;
  bool remoteplay_active_;
  bool steam_deck_;
  uint32_t supported_services_;
  uint64_t steam_version_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteClientBroadcastDiscovery final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteClientBroadcastDiscovery) */ {
 public:
  inline CMsgRemoteClientBroadcastDiscovery() : CMsgRemoteClientBroadcastDiscovery(nullptr) {}
  ~CMsgRemoteClientBroadcastDiscovery() override;
  explicit constexpr CMsgRemoteClientBroadcastDiscovery(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteClientBroadcastDiscovery(const CMsgRemoteClientBroadcastDiscovery& from);
  CMsgRemoteClientBroadcastDiscovery(CMsgRemoteClientBroadcastDiscovery&& from) noexcept
    : CMsgRemoteClientBroadcastDiscovery() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteClientBroadcastDiscovery& operator=(const CMsgRemoteClientBroadcastDiscovery& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteClientBroadcastDiscovery& operator=(CMsgRemoteClientBroadcastDiscovery&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteClientBroadcastDiscovery& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteClientBroadcastDiscovery* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteClientBroadcastDiscovery*>(
               &_CMsgRemoteClientBroadcastDiscovery_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CMsgRemoteClientBroadcastDiscovery& a, CMsgRemoteClientBroadcastDiscovery& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteClientBroadcastDiscovery* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteClientBroadcastDiscovery* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteClientBroadcastDiscovery* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteClientBroadcastDiscovery>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteClientBroadcastDiscovery& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteClientBroadcastDiscovery& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteClientBroadcastDiscovery* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteClientBroadcastDiscovery";
  }
  protected:
  explicit CMsgRemoteClientBroadcastDiscovery(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 2,
    kSeqNumFieldNumber = 1,
  };
  // repeated uint64 client_ids = 2;
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;
  public:
  void clear_client_ids();
  private:
  uint64_t _internal_client_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_client_ids() const;
  void _internal_add_client_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_client_ids();
  public:
  uint64_t client_ids(int index) const;
  void set_client_ids(int index, uint64_t value);
  void add_client_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      client_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_client_ids();

  // optional uint32 seq_num = 1;
  bool has_seq_num() const;
  private:
  bool _internal_has_seq_num() const;
  public:
  void clear_seq_num();
  uint32_t seq_num() const;
  void set_seq_num(uint32_t value);
  private:
  uint32_t _internal_seq_num() const;
  void _internal_set_seq_num(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteClientBroadcastDiscovery)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > client_ids_;
  uint32_t seq_num_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteClientBroadcastClientIDDeconflict final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteClientBroadcastClientIDDeconflict) */ {
 public:
  inline CMsgRemoteClientBroadcastClientIDDeconflict() : CMsgRemoteClientBroadcastClientIDDeconflict(nullptr) {}
  ~CMsgRemoteClientBroadcastClientIDDeconflict() override;
  explicit constexpr CMsgRemoteClientBroadcastClientIDDeconflict(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteClientBroadcastClientIDDeconflict(const CMsgRemoteClientBroadcastClientIDDeconflict& from);
  CMsgRemoteClientBroadcastClientIDDeconflict(CMsgRemoteClientBroadcastClientIDDeconflict&& from) noexcept
    : CMsgRemoteClientBroadcastClientIDDeconflict() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteClientBroadcastClientIDDeconflict& operator=(const CMsgRemoteClientBroadcastClientIDDeconflict& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteClientBroadcastClientIDDeconflict& operator=(CMsgRemoteClientBroadcastClientIDDeconflict&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteClientBroadcastClientIDDeconflict& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteClientBroadcastClientIDDeconflict* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteClientBroadcastClientIDDeconflict*>(
               &_CMsgRemoteClientBroadcastClientIDDeconflict_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CMsgRemoteClientBroadcastClientIDDeconflict& a, CMsgRemoteClientBroadcastClientIDDeconflict& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteClientBroadcastClientIDDeconflict* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteClientBroadcastClientIDDeconflict* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteClientBroadcastClientIDDeconflict* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteClientBroadcastClientIDDeconflict>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteClientBroadcastClientIDDeconflict& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteClientBroadcastClientIDDeconflict& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteClientBroadcastClientIDDeconflict* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteClientBroadcastClientIDDeconflict";
  }
  protected:
  explicit CMsgRemoteClientBroadcastClientIDDeconflict(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientIdsFieldNumber = 2,
  };
  // repeated uint64 client_ids = 2;
  int client_ids_size() const;
  private:
  int _internal_client_ids_size() const;
  public:
  void clear_client_ids();
  private:
  uint64_t _internal_client_ids(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      _internal_client_ids() const;
  void _internal_add_client_ids(uint64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      _internal_mutable_client_ids();
  public:
  uint64_t client_ids(int index) const;
  void set_client_ids(int index, uint64_t value);
  void add_client_ids(uint64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
      client_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
      mutable_client_ids();

  // @@protoc_insertion_point(class_scope:CMsgRemoteClientBroadcastClientIDDeconflict)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t > client_ids_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket) */ {
 public:
  inline CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket() : CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(nullptr) {}
  ~CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket() override;
  explicit constexpr CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from);
  CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket&& from) noexcept
    : CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& operator=(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& operator=(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket*>(
               &_CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& a, CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket";
  }
  protected:
  explicit CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPasswordFieldNumber = 1,
    kPayloadFieldNumber = 3,
    kDeviceNameFieldNumber = 6,
    kDeviceModelFieldNumber = 7,
    kDeviceSerialFieldNumber = 8,
    kIdentifierFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kUsageFieldNumber = 5,
    kDeviceProvisioningIdFieldNumber = 9,
  };
  // optional bytes password = 1;
  bool has_password() const;
  private:
  bool _internal_has_password() const;
  public:
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // optional bytes payload = 3;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // optional string device_name = 6;
  bool has_device_name() const;
  private:
  bool _internal_has_device_name() const;
  public:
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // optional string device_model = 7;
  bool has_device_model() const;
  private:
  bool _internal_has_device_model() const;
  public:
  void clear_device_model();
  const std::string& device_model() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_model(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_model();
  PROTOBUF_NODISCARD std::string* release_device_model();
  void set_allocated_device_model(std::string* device_model);
  private:
  const std::string& _internal_device_model() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_model(const std::string& value);
  std::string* _internal_mutable_device_model();
  public:

  // optional string device_serial = 8;
  bool has_device_serial() const;
  private:
  bool _internal_has_device_serial() const;
  public:
  void clear_device_serial();
  const std::string& device_serial() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_serial(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_serial();
  PROTOBUF_NODISCARD std::string* release_device_serial();
  void set_allocated_device_serial(std::string* device_serial);
  private:
  const std::string& _internal_device_serial() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_serial(const std::string& value);
  std::string* _internal_mutable_device_serial();
  public:

  // optional uint64 identifier = 2;
  bool has_identifier() const;
  private:
  bool _internal_has_identifier() const;
  public:
  void clear_identifier();
  uint64_t identifier() const;
  void set_identifier(uint64_t value);
  private:
  uint64_t _internal_identifier() const;
  void _internal_set_identifier(uint64_t value);
  public:

  // optional uint32 timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5 [default = k_EKeyEscrowUsageStreamingDevice];
  bool has_usage() const;
  private:
  bool _internal_has_usage() const;
  public:
  void clear_usage();
  ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage usage() const;
  void set_usage(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage value);
  private:
  ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage _internal_usage() const;
  void _internal_set_usage(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage value);
  public:

  // optional uint32 device_provisioning_id = 9;
  bool has_device_provisioning_id() const;
  private:
  bool _internal_has_device_provisioning_id() const;
  public:
  void clear_device_provisioning_id();
  uint32_t device_provisioning_id() const;
  void set_device_provisioning_id(uint32_t value);
  private:
  uint32_t _internal_device_provisioning_id() const;
  void _internal_set_device_provisioning_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_model_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_serial_;
  uint64_t identifier_;
  uint32_t timestamp_;
  int usage_;
  uint32_t device_provisioning_id_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceAuthorizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceAuthorizationRequest) */ {
 public:
  inline CMsgRemoteDeviceAuthorizationRequest() : CMsgRemoteDeviceAuthorizationRequest(nullptr) {}
  ~CMsgRemoteDeviceAuthorizationRequest() override;
  explicit constexpr CMsgRemoteDeviceAuthorizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceAuthorizationRequest(const CMsgRemoteDeviceAuthorizationRequest& from);
  CMsgRemoteDeviceAuthorizationRequest(CMsgRemoteDeviceAuthorizationRequest&& from) noexcept
    : CMsgRemoteDeviceAuthorizationRequest() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceAuthorizationRequest& operator=(const CMsgRemoteDeviceAuthorizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceAuthorizationRequest& operator=(CMsgRemoteDeviceAuthorizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceAuthorizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceAuthorizationRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceAuthorizationRequest*>(
               &_CMsgRemoteDeviceAuthorizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CMsgRemoteDeviceAuthorizationRequest& a, CMsgRemoteDeviceAuthorizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceAuthorizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceAuthorizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceAuthorizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceAuthorizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceAuthorizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceAuthorizationRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceAuthorizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceAuthorizationRequest";
  }
  protected:
  explicit CMsgRemoteDeviceAuthorizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket CKeyEscrow_Ticket;

  typedef CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage EKeyEscrowUsage;
  static constexpr EKeyEscrowUsage k_EKeyEscrowUsageStreamingDevice =
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_k_EKeyEscrowUsageStreamingDevice;
  static inline bool EKeyEscrowUsage_IsValid(int value) {
    return CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_IsValid(value);
  }
  static constexpr EKeyEscrowUsage EKeyEscrowUsage_MIN =
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_MIN;
  static constexpr EKeyEscrowUsage EKeyEscrowUsage_MAX =
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_MAX;
  static constexpr int EKeyEscrowUsage_ARRAYSIZE =
    CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_EKeyEscrowUsage_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  EKeyEscrowUsage_descriptor() {
    return CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor();
  }
  template<typename T>
  static inline const std::string& EKeyEscrowUsage_Name(T enum_t_value) {
    static_assert(::std::is_same<T, EKeyEscrowUsage>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function EKeyEscrowUsage_Name.");
    return CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_Name(enum_t_value);
  }
  static inline bool EKeyEscrowUsage_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      EKeyEscrowUsage* value) {
    return CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceTokenFieldNumber = 1,
    kDeviceNameFieldNumber = 2,
    kEncryptedRequestFieldNumber = 3,
    kAuthKeyFieldNumber = 4,
  };
  // required bytes device_token = 1;
  bool has_device_token() const;
  private:
  bool _internal_has_device_token() const;
  public:
  void clear_device_token();
  const std::string& device_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_token();
  PROTOBUF_NODISCARD std::string* release_device_token();
  void set_allocated_device_token(std::string* device_token);
  private:
  const std::string& _internal_device_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
  std::string* _internal_mutable_device_token();
  public:

  // optional string device_name = 2;
  bool has_device_name() const;
  private:
  bool _internal_has_device_name() const;
  public:
  void clear_device_name();
  const std::string& device_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_name();
  PROTOBUF_NODISCARD std::string* release_device_name();
  void set_allocated_device_name(std::string* device_name);
  private:
  const std::string& _internal_device_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_name(const std::string& value);
  std::string* _internal_mutable_device_name();
  public:

  // required bytes encrypted_request = 3;
  bool has_encrypted_request() const;
  private:
  bool _internal_has_encrypted_request() const;
  public:
  void clear_encrypted_request();
  const std::string& encrypted_request() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_request(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_request();
  PROTOBUF_NODISCARD std::string* release_encrypted_request();
  void set_allocated_encrypted_request(std::string* encrypted_request);
  private:
  const std::string& _internal_encrypted_request() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_request(const std::string& value);
  std::string* _internal_mutable_encrypted_request();
  public:

  // optional bytes auth_key = 4;
  bool has_auth_key() const;
  private:
  bool _internal_has_auth_key() const;
  public:
  void clear_auth_key();
  const std::string& auth_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_key();
  PROTOBUF_NODISCARD std::string* release_auth_key();
  void set_allocated_auth_key(std::string* auth_key);
  private:
  const std::string& _internal_auth_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_key(const std::string& value);
  std::string* _internal_mutable_auth_key();
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceAuthorizationRequest)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_request_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_key_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceAuthorizationCancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceAuthorizationCancelRequest) */ {
 public:
  inline CMsgRemoteDeviceAuthorizationCancelRequest() : CMsgRemoteDeviceAuthorizationCancelRequest(nullptr) {}
  explicit constexpr CMsgRemoteDeviceAuthorizationCancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceAuthorizationCancelRequest(const CMsgRemoteDeviceAuthorizationCancelRequest& from);
  CMsgRemoteDeviceAuthorizationCancelRequest(CMsgRemoteDeviceAuthorizationCancelRequest&& from) noexcept
    : CMsgRemoteDeviceAuthorizationCancelRequest() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceAuthorizationCancelRequest& operator=(const CMsgRemoteDeviceAuthorizationCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceAuthorizationCancelRequest& operator=(CMsgRemoteDeviceAuthorizationCancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceAuthorizationCancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceAuthorizationCancelRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceAuthorizationCancelRequest*>(
               &_CMsgRemoteDeviceAuthorizationCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CMsgRemoteDeviceAuthorizationCancelRequest& a, CMsgRemoteDeviceAuthorizationCancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceAuthorizationCancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceAuthorizationCancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceAuthorizationCancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceAuthorizationCancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CMsgRemoteDeviceAuthorizationCancelRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceAuthorizationCancelRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceAuthorizationCancelRequest";
  }
  protected:
  explicit CMsgRemoteDeviceAuthorizationCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceAuthorizationCancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceAuthorizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceAuthorizationResponse) */ {
 public:
  inline CMsgRemoteDeviceAuthorizationResponse() : CMsgRemoteDeviceAuthorizationResponse(nullptr) {}
  ~CMsgRemoteDeviceAuthorizationResponse() override;
  explicit constexpr CMsgRemoteDeviceAuthorizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceAuthorizationResponse(const CMsgRemoteDeviceAuthorizationResponse& from);
  CMsgRemoteDeviceAuthorizationResponse(CMsgRemoteDeviceAuthorizationResponse&& from) noexcept
    : CMsgRemoteDeviceAuthorizationResponse() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceAuthorizationResponse& operator=(const CMsgRemoteDeviceAuthorizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceAuthorizationResponse& operator=(CMsgRemoteDeviceAuthorizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceAuthorizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceAuthorizationResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceAuthorizationResponse*>(
               &_CMsgRemoteDeviceAuthorizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CMsgRemoteDeviceAuthorizationResponse& a, CMsgRemoteDeviceAuthorizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceAuthorizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceAuthorizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceAuthorizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceAuthorizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceAuthorizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceAuthorizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceAuthorizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceAuthorizationResponse";
  }
  protected:
  explicit CMsgRemoteDeviceAuthorizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAuthKeyFieldNumber = 3,
    kDeviceTokenFieldNumber = 4,
    kSteamidFieldNumber = 2,
    kResultFieldNumber = 1,
  };
  // optional bytes auth_key = 3;
  bool has_auth_key() const;
  private:
  bool _internal_has_auth_key() const;
  public:
  void clear_auth_key();
  const std::string& auth_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_auth_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_auth_key();
  PROTOBUF_NODISCARD std::string* release_auth_key();
  void set_allocated_auth_key(std::string* auth_key);
  private:
  const std::string& _internal_auth_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_auth_key(const std::string& value);
  std::string* _internal_mutable_auth_key();
  public:

  // optional bytes device_token = 4;
  bool has_device_token() const;
  private:
  bool _internal_has_device_token() const;
  public:
  void clear_device_token();
  const std::string& device_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_token();
  PROTOBUF_NODISCARD std::string* release_device_token();
  void set_allocated_device_token(std::string* device_token);
  private:
  const std::string& _internal_device_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
  std::string* _internal_mutable_device_token();
  public:

  // optional fixed64 steamid = 2;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ERemoteDeviceAuthorizationResult result() const;
  void set_result(::ERemoteDeviceAuthorizationResult value);
  private:
  ::ERemoteDeviceAuthorizationResult _internal_result() const;
  void _internal_set_result(::ERemoteDeviceAuthorizationResult value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceAuthorizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr auth_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
  uint64_t steamid_;
  int result_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceAuthorizationConfirmed final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceAuthorizationConfirmed) */ {
 public:
  inline CMsgRemoteDeviceAuthorizationConfirmed() : CMsgRemoteDeviceAuthorizationConfirmed(nullptr) {}
  ~CMsgRemoteDeviceAuthorizationConfirmed() override;
  explicit constexpr CMsgRemoteDeviceAuthorizationConfirmed(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceAuthorizationConfirmed(const CMsgRemoteDeviceAuthorizationConfirmed& from);
  CMsgRemoteDeviceAuthorizationConfirmed(CMsgRemoteDeviceAuthorizationConfirmed&& from) noexcept
    : CMsgRemoteDeviceAuthorizationConfirmed() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceAuthorizationConfirmed& operator=(const CMsgRemoteDeviceAuthorizationConfirmed& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceAuthorizationConfirmed& operator=(CMsgRemoteDeviceAuthorizationConfirmed&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceAuthorizationConfirmed& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceAuthorizationConfirmed* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceAuthorizationConfirmed*>(
               &_CMsgRemoteDeviceAuthorizationConfirmed_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CMsgRemoteDeviceAuthorizationConfirmed& a, CMsgRemoteDeviceAuthorizationConfirmed& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceAuthorizationConfirmed* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceAuthorizationConfirmed* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceAuthorizationConfirmed* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceAuthorizationConfirmed>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceAuthorizationConfirmed& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceAuthorizationConfirmed& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceAuthorizationConfirmed* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceAuthorizationConfirmed";
  }
  protected:
  explicit CMsgRemoteDeviceAuthorizationConfirmed(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
  };
  // required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ERemoteDeviceAuthorizationResult result() const;
  void set_result(::ERemoteDeviceAuthorizationResult value);
  private:
  ::ERemoteDeviceAuthorizationResult _internal_result() const;
  void _internal_set_result(::ERemoteDeviceAuthorizationResult value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceAuthorizationConfirmed)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int result_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamingRequest_ReservedGamepad final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamingRequest.ReservedGamepad) */ {
 public:
  inline CMsgRemoteDeviceStreamingRequest_ReservedGamepad() : CMsgRemoteDeviceStreamingRequest_ReservedGamepad(nullptr) {}
  ~CMsgRemoteDeviceStreamingRequest_ReservedGamepad() override;
  explicit constexpr CMsgRemoteDeviceStreamingRequest_ReservedGamepad(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamingRequest_ReservedGamepad(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from);
  CMsgRemoteDeviceStreamingRequest_ReservedGamepad(CMsgRemoteDeviceStreamingRequest_ReservedGamepad&& from) noexcept
    : CMsgRemoteDeviceStreamingRequest_ReservedGamepad() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamingRequest_ReservedGamepad& operator=(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamingRequest_ReservedGamepad& operator=(CMsgRemoteDeviceStreamingRequest_ReservedGamepad&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamingRequest_ReservedGamepad* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamingRequest_ReservedGamepad*>(
               &_CMsgRemoteDeviceStreamingRequest_ReservedGamepad_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CMsgRemoteDeviceStreamingRequest_ReservedGamepad& a, CMsgRemoteDeviceStreamingRequest_ReservedGamepad& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamingRequest_ReservedGamepad* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamingRequest_ReservedGamepad* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamingRequest_ReservedGamepad* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamingRequest_ReservedGamepad>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamingRequest_ReservedGamepad& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamingRequest_ReservedGamepad* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamingRequest.ReservedGamepad";
  }
  protected:
  explicit CMsgRemoteDeviceStreamingRequest_ReservedGamepad(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerTypeFieldNumber = 1,
    kControllerSubtypeFieldNumber = 2,
  };
  // optional uint32 controller_type = 1;
  bool has_controller_type() const;
  private:
  bool _internal_has_controller_type() const;
  public:
  void clear_controller_type();
  uint32_t controller_type() const;
  void set_controller_type(uint32_t value);
  private:
  uint32_t _internal_controller_type() const;
  void _internal_set_controller_type(uint32_t value);
  public:

  // optional uint32 controller_subtype = 2;
  bool has_controller_subtype() const;
  private:
  bool _internal_has_controller_subtype() const;
  public:
  void clear_controller_subtype();
  uint32_t controller_subtype() const;
  void set_controller_subtype(uint32_t value);
  private:
  uint32_t _internal_controller_subtype() const;
  void _internal_set_controller_subtype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamingRequest.ReservedGamepad)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t controller_type_;
  uint32_t controller_subtype_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamingRequest) */ {
 public:
  inline CMsgRemoteDeviceStreamingRequest() : CMsgRemoteDeviceStreamingRequest(nullptr) {}
  ~CMsgRemoteDeviceStreamingRequest() override;
  explicit constexpr CMsgRemoteDeviceStreamingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamingRequest(const CMsgRemoteDeviceStreamingRequest& from);
  CMsgRemoteDeviceStreamingRequest(CMsgRemoteDeviceStreamingRequest&& from) noexcept
    : CMsgRemoteDeviceStreamingRequest() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamingRequest& operator=(const CMsgRemoteDeviceStreamingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamingRequest& operator=(CMsgRemoteDeviceStreamingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamingRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamingRequest*>(
               &_CMsgRemoteDeviceStreamingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CMsgRemoteDeviceStreamingRequest& a, CMsgRemoteDeviceStreamingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamingRequest";
  }
  protected:
  explicit CMsgRemoteDeviceStreamingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CMsgRemoteDeviceStreamingRequest_ReservedGamepad ReservedGamepad;

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedTransportFieldNumber = 14,
    kGamepadsFieldNumber = 18,
    kDeviceVersionFieldNumber = 5,
    kDeviceTokenFieldNumber = 7,
    kPinFieldNumber = 8,
    kRequestIdFieldNumber = 1,
    kMaximumResolutionXFieldNumber = 2,
    kMaximumResolutionYFieldNumber = 3,
    kStreamDesktopFieldNumber = 6,
    kNetworkTestFieldNumber = 12,
    kRestrictedFieldNumber = 15,
    kClientIdFieldNumber = 13,
    kFormFactorFieldNumber = 16,
    kGamepadCountFieldNumber = 17,
    kGameidFieldNumber = 19,
    kStreamInterfaceFieldNumber = 20,
    kAudioChannelCountFieldNumber = 4,
    kEnableVideoStreamingFieldNumber = 9,
    kEnableAudioStreamingFieldNumber = 10,
    kEnableInputStreamingFieldNumber = 11,
  };
  // repeated .EStreamTransport supported_transport = 14;
  int supported_transport_size() const;
  private:
  int _internal_supported_transport_size() const;
  public:
  void clear_supported_transport();
  private:
  ::EStreamTransport _internal_supported_transport(int index) const;
  void _internal_add_supported_transport(::EStreamTransport value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_transport();
  public:
  ::EStreamTransport supported_transport(int index) const;
  void set_supported_transport(int index, ::EStreamTransport value);
  void add_supported_transport(::EStreamTransport value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_transport() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_transport();

  // repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;
  int gamepads_size() const;
  private:
  int _internal_gamepads_size() const;
  public:
  void clear_gamepads();
  ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* mutable_gamepads(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >*
      mutable_gamepads();
  private:
  const ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad& _internal_gamepads(int index) const;
  ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* _internal_add_gamepads();
  public:
  const ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad& gamepads(int index) const;
  ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* add_gamepads();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >&
      gamepads() const;

  // optional string device_version = 5;
  bool has_device_version() const;
  private:
  bool _internal_has_device_version() const;
  public:
  void clear_device_version();
  const std::string& device_version() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_version(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_version();
  PROTOBUF_NODISCARD std::string* release_device_version();
  void set_allocated_device_version(std::string* device_version);
  private:
  const std::string& _internal_device_version() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_version(const std::string& value);
  std::string* _internal_mutable_device_version();
  public:

  // optional bytes device_token = 7;
  bool has_device_token() const;
  private:
  bool _internal_has_device_token() const;
  public:
  void clear_device_token();
  const std::string& device_token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_token();
  PROTOBUF_NODISCARD std::string* release_device_token();
  void set_allocated_device_token(std::string* device_token);
  private:
  const std::string& _internal_device_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_token(const std::string& value);
  std::string* _internal_mutable_device_token();
  public:

  // optional bytes pin = 8;
  bool has_pin() const;
  private:
  bool _internal_has_pin() const;
  public:
  void clear_pin();
  const std::string& pin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pin();
  PROTOBUF_NODISCARD std::string* release_pin();
  void set_allocated_pin(std::string* pin);
  private:
  const std::string& _internal_pin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pin(const std::string& value);
  std::string* _internal_mutable_pin();
  public:

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // optional int32 maximum_resolution_x = 2;
  bool has_maximum_resolution_x() const;
  private:
  bool _internal_has_maximum_resolution_x() const;
  public:
  void clear_maximum_resolution_x();
  int32_t maximum_resolution_x() const;
  void set_maximum_resolution_x(int32_t value);
  private:
  int32_t _internal_maximum_resolution_x() const;
  void _internal_set_maximum_resolution_x(int32_t value);
  public:

  // optional int32 maximum_resolution_y = 3;
  bool has_maximum_resolution_y() const;
  private:
  bool _internal_has_maximum_resolution_y() const;
  public:
  void clear_maximum_resolution_y();
  int32_t maximum_resolution_y() const;
  void set_maximum_resolution_y(int32_t value);
  private:
  int32_t _internal_maximum_resolution_y() const;
  void _internal_set_maximum_resolution_y(int32_t value);
  public:

  // optional bool stream_desktop = 6;
  bool has_stream_desktop() const;
  private:
  bool _internal_has_stream_desktop() const;
  public:
  void clear_stream_desktop();
  bool stream_desktop() const;
  void set_stream_desktop(bool value);
  private:
  bool _internal_stream_desktop() const;
  void _internal_set_stream_desktop(bool value);
  public:

  // optional bool network_test = 12;
  bool has_network_test() const;
  private:
  bool _internal_has_network_test() const;
  public:
  void clear_network_test();
  bool network_test() const;
  void set_network_test(bool value);
  private:
  bool _internal_network_test() const;
  void _internal_set_network_test(bool value);
  public:

  // optional bool restricted = 15;
  bool has_restricted() const;
  private:
  bool _internal_has_restricted() const;
  public:
  void clear_restricted();
  bool restricted() const;
  void set_restricted(bool value);
  private:
  bool _internal_restricted() const;
  void _internal_set_restricted(bool value);
  public:

  // optional uint64 client_id = 13;
  bool has_client_id() const;
  private:
  bool _internal_has_client_id() const;
  public:
  void clear_client_id();
  uint64_t client_id() const;
  void set_client_id(uint64_t value);
  private:
  uint64_t _internal_client_id() const;
  void _internal_set_client_id(uint64_t value);
  public:

  // optional .EStreamDeviceFormFactor form_factor = 16 [default = k_EStreamDeviceFormFactorUnknown];
  bool has_form_factor() const;
  private:
  bool _internal_has_form_factor() const;
  public:
  void clear_form_factor();
  ::EStreamDeviceFormFactor form_factor() const;
  void set_form_factor(::EStreamDeviceFormFactor value);
  private:
  ::EStreamDeviceFormFactor _internal_form_factor() const;
  void _internal_set_form_factor(::EStreamDeviceFormFactor value);
  public:

  // optional int32 gamepad_count = 17;
  bool has_gamepad_count() const;
  private:
  bool _internal_has_gamepad_count() const;
  public:
  void clear_gamepad_count();
  int32_t gamepad_count() const;
  void set_gamepad_count(int32_t value);
  private:
  int32_t _internal_gamepad_count() const;
  void _internal_set_gamepad_count(int32_t value);
  public:

  // optional uint64 gameid = 19;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint64_t gameid() const;
  void set_gameid(uint64_t value);
  private:
  uint64_t _internal_gameid() const;
  void _internal_set_gameid(uint64_t value);
  public:

  // optional .EStreamInterface stream_interface = 20 [default = k_EStreamInterfaceDefault];
  bool has_stream_interface() const;
  private:
  bool _internal_has_stream_interface() const;
  public:
  void clear_stream_interface();
  ::EStreamInterface stream_interface() const;
  void set_stream_interface(::EStreamInterface value);
  private:
  ::EStreamInterface _internal_stream_interface() const;
  void _internal_set_stream_interface(::EStreamInterface value);
  public:

  // optional int32 audio_channel_count = 4 [default = 2];
  bool has_audio_channel_count() const;
  private:
  bool _internal_has_audio_channel_count() const;
  public:
  void clear_audio_channel_count();
  int32_t audio_channel_count() const;
  void set_audio_channel_count(int32_t value);
  private:
  int32_t _internal_audio_channel_count() const;
  void _internal_set_audio_channel_count(int32_t value);
  public:

  // optional bool enable_video_streaming = 9 [default = true];
  bool has_enable_video_streaming() const;
  private:
  bool _internal_has_enable_video_streaming() const;
  public:
  void clear_enable_video_streaming();
  bool enable_video_streaming() const;
  void set_enable_video_streaming(bool value);
  private:
  bool _internal_enable_video_streaming() const;
  void _internal_set_enable_video_streaming(bool value);
  public:

  // optional bool enable_audio_streaming = 10 [default = true];
  bool has_enable_audio_streaming() const;
  private:
  bool _internal_has_enable_audio_streaming() const;
  public:
  void clear_enable_audio_streaming();
  bool enable_audio_streaming() const;
  void set_enable_audio_streaming(bool value);
  private:
  bool _internal_enable_audio_streaming() const;
  void _internal_set_enable_audio_streaming(bool value);
  public:

  // optional bool enable_input_streaming = 11 [default = true];
  bool has_enable_input_streaming() const;
  private:
  bool _internal_has_enable_input_streaming() const;
  public:
  void clear_enable_input_streaming();
  bool enable_input_streaming() const;
  void set_enable_input_streaming(bool value);
  private:
  bool _internal_enable_input_streaming() const;
  void _internal_set_enable_input_streaming(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_transport_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad > gamepads_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_version_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pin_;
  uint32_t request_id_;
  int32_t maximum_resolution_x_;
  int32_t maximum_resolution_y_;
  bool stream_desktop_;
  bool network_test_;
  bool restricted_;
  uint64_t client_id_;
  int form_factor_;
  int32_t gamepad_count_;
  uint64_t gameid_;
  int stream_interface_;
  int32_t audio_channel_count_;
  bool enable_video_streaming_;
  bool enable_audio_streaming_;
  bool enable_input_streaming_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamingCancelRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamingCancelRequest) */ {
 public:
  inline CMsgRemoteDeviceStreamingCancelRequest() : CMsgRemoteDeviceStreamingCancelRequest(nullptr) {}
  ~CMsgRemoteDeviceStreamingCancelRequest() override;
  explicit constexpr CMsgRemoteDeviceStreamingCancelRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamingCancelRequest(const CMsgRemoteDeviceStreamingCancelRequest& from);
  CMsgRemoteDeviceStreamingCancelRequest(CMsgRemoteDeviceStreamingCancelRequest&& from) noexcept
    : CMsgRemoteDeviceStreamingCancelRequest() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamingCancelRequest& operator=(const CMsgRemoteDeviceStreamingCancelRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamingCancelRequest& operator=(CMsgRemoteDeviceStreamingCancelRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamingCancelRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamingCancelRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamingCancelRequest*>(
               &_CMsgRemoteDeviceStreamingCancelRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CMsgRemoteDeviceStreamingCancelRequest& a, CMsgRemoteDeviceStreamingCancelRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamingCancelRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamingCancelRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamingCancelRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamingCancelRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamingCancelRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamingCancelRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamingCancelRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamingCancelRequest";
  }
  protected:
  explicit CMsgRemoteDeviceStreamingCancelRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
  };
  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamingCancelRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t request_id_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamingProgress final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamingProgress) */ {
 public:
  inline CMsgRemoteDeviceStreamingProgress() : CMsgRemoteDeviceStreamingProgress(nullptr) {}
  ~CMsgRemoteDeviceStreamingProgress() override;
  explicit constexpr CMsgRemoteDeviceStreamingProgress(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamingProgress(const CMsgRemoteDeviceStreamingProgress& from);
  CMsgRemoteDeviceStreamingProgress(CMsgRemoteDeviceStreamingProgress&& from) noexcept
    : CMsgRemoteDeviceStreamingProgress() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamingProgress& operator=(const CMsgRemoteDeviceStreamingProgress& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamingProgress& operator=(CMsgRemoteDeviceStreamingProgress&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamingProgress& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamingProgress* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamingProgress*>(
               &_CMsgRemoteDeviceStreamingProgress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CMsgRemoteDeviceStreamingProgress& a, CMsgRemoteDeviceStreamingProgress& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamingProgress* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamingProgress* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamingProgress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamingProgress>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamingProgress& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamingProgress& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamingProgress* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamingProgress";
  }
  protected:
  explicit CMsgRemoteDeviceStreamingProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRequestIdFieldNumber = 1,
    kProgressFieldNumber = 2,
  };
  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // optional float progress = 2;
  bool has_progress() const;
  private:
  bool _internal_has_progress() const;
  public:
  void clear_progress();
  float progress() const;
  void set_progress(float value);
  private:
  float _internal_progress() const;
  void _internal_set_progress(float value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamingProgress)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t request_id_;
  float progress_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamingResponse) */ {
 public:
  inline CMsgRemoteDeviceStreamingResponse() : CMsgRemoteDeviceStreamingResponse(nullptr) {}
  ~CMsgRemoteDeviceStreamingResponse() override;
  explicit constexpr CMsgRemoteDeviceStreamingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamingResponse(const CMsgRemoteDeviceStreamingResponse& from);
  CMsgRemoteDeviceStreamingResponse(CMsgRemoteDeviceStreamingResponse&& from) noexcept
    : CMsgRemoteDeviceStreamingResponse() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamingResponse& operator=(const CMsgRemoteDeviceStreamingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamingResponse& operator=(CMsgRemoteDeviceStreamingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamingResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamingResponse*>(
               &_CMsgRemoteDeviceStreamingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CMsgRemoteDeviceStreamingResponse& a, CMsgRemoteDeviceStreamingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamingResponse";
  }
  protected:
  explicit CMsgRemoteDeviceStreamingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEncryptedSessionKeyFieldNumber = 4,
    kRelayServerFieldNumber = 7,
    kCertFieldNumber = 8,
    kRequestIdFieldNumber = 1,
    kResultFieldNumber = 2,
    kPortFieldNumber = 3,
    kTransportFieldNumber = 6,
  };
  // optional bytes encrypted_session_key = 4;
  bool has_encrypted_session_key() const;
  private:
  bool _internal_has_encrypted_session_key() const;
  public:
  void clear_encrypted_session_key();
  const std::string& encrypted_session_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_encrypted_session_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_encrypted_session_key();
  PROTOBUF_NODISCARD std::string* release_encrypted_session_key();
  void set_allocated_encrypted_session_key(std::string* encrypted_session_key);
  private:
  const std::string& _internal_encrypted_session_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_encrypted_session_key(const std::string& value);
  std::string* _internal_mutable_encrypted_session_key();
  public:

  // optional string relay_server = 7;
  bool has_relay_server() const;
  private:
  bool _internal_has_relay_server() const;
  public:
  void clear_relay_server();
  const std::string& relay_server() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relay_server(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relay_server();
  PROTOBUF_NODISCARD std::string* release_relay_server();
  void set_allocated_relay_server(std::string* relay_server);
  private:
  const std::string& _internal_relay_server() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relay_server(const std::string& value);
  std::string* _internal_mutable_relay_server();
  public:

  // optional string cert = 8;
  bool has_cert() const;
  private:
  bool _internal_has_cert() const;
  public:
  void clear_cert();
  const std::string& cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cert();
  PROTOBUF_NODISCARD std::string* release_cert();
  void set_allocated_cert(std::string* cert);
  private:
  const std::string& _internal_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cert(const std::string& value);
  std::string* _internal_mutable_cert();
  public:

  // required uint32 request_id = 1;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::ERemoteDeviceStreamingResult result() const;
  void set_result(::ERemoteDeviceStreamingResult value);
  private:
  ::ERemoteDeviceStreamingResult _internal_result() const;
  void _internal_set_result(::ERemoteDeviceStreamingResult value);
  public:

  // optional uint32 port = 3;
  bool has_port() const;
  private:
  bool _internal_has_port() const;
  public:
  void clear_port();
  uint32_t port() const;
  void set_port(uint32_t value);
  private:
  uint32_t _internal_port() const;
  void _internal_set_port(uint32_t value);
  public:

  // optional .EStreamTransport transport = 6 [default = k_EStreamTransportUDP];
  bool has_transport() const;
  private:
  bool _internal_has_transport() const;
  public:
  void clear_transport();
  ::EStreamTransport transport() const;
  void set_transport(::EStreamTransport value);
  private:
  ::EStreamTransport _internal_transport() const;
  void _internal_set_transport(::EStreamTransport value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamingResponse)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr encrypted_session_key_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relay_server_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cert_;
  uint32_t request_id_;
  int result_;
  uint32_t port_;
  int transport_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceProofRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceProofRequest) */ {
 public:
  inline CMsgRemoteDeviceProofRequest() : CMsgRemoteDeviceProofRequest(nullptr) {}
  ~CMsgRemoteDeviceProofRequest() override;
  explicit constexpr CMsgRemoteDeviceProofRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceProofRequest(const CMsgRemoteDeviceProofRequest& from);
  CMsgRemoteDeviceProofRequest(CMsgRemoteDeviceProofRequest&& from) noexcept
    : CMsgRemoteDeviceProofRequest() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceProofRequest& operator=(const CMsgRemoteDeviceProofRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceProofRequest& operator=(CMsgRemoteDeviceProofRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceProofRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceProofRequest* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceProofRequest*>(
               &_CMsgRemoteDeviceProofRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CMsgRemoteDeviceProofRequest& a, CMsgRemoteDeviceProofRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceProofRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceProofRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceProofRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceProofRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceProofRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceProofRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceProofRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceProofRequest";
  }
  protected:
  explicit CMsgRemoteDeviceProofRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChallengeFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kUpdateSecretFieldNumber = 3,
  };
  // required bytes challenge = 1;
  bool has_challenge() const;
  private:
  bool _internal_has_challenge() const;
  public:
  void clear_challenge();
  const std::string& challenge() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_challenge(ArgT0&& arg0, ArgT... args);
  std::string* mutable_challenge();
  PROTOBUF_NODISCARD std::string* release_challenge();
  void set_allocated_challenge(std::string* challenge);
  private:
  const std::string& _internal_challenge() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_challenge(const std::string& value);
  std::string* _internal_mutable_challenge();
  public:

  // optional uint32 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // optional bool update_secret = 3;
  bool has_update_secret() const;
  private:
  bool _internal_has_update_secret() const;
  public:
  void clear_update_secret();
  bool update_secret() const;
  void set_update_secret(bool value);
  private:
  bool _internal_update_secret() const;
  void _internal_set_update_secret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceProofRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr challenge_;
  uint32_t request_id_;
  bool update_secret_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceProofResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceProofResponse) */ {
 public:
  inline CMsgRemoteDeviceProofResponse() : CMsgRemoteDeviceProofResponse(nullptr) {}
  ~CMsgRemoteDeviceProofResponse() override;
  explicit constexpr CMsgRemoteDeviceProofResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceProofResponse(const CMsgRemoteDeviceProofResponse& from);
  CMsgRemoteDeviceProofResponse(CMsgRemoteDeviceProofResponse&& from) noexcept
    : CMsgRemoteDeviceProofResponse() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceProofResponse& operator=(const CMsgRemoteDeviceProofResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceProofResponse& operator=(CMsgRemoteDeviceProofResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceProofResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceProofResponse* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceProofResponse*>(
               &_CMsgRemoteDeviceProofResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CMsgRemoteDeviceProofResponse& a, CMsgRemoteDeviceProofResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceProofResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceProofResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceProofResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceProofResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceProofResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceProofResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceProofResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceProofResponse";
  }
  protected:
  explicit CMsgRemoteDeviceProofResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 1,
    kRequestIdFieldNumber = 2,
    kUpdatedSecretFieldNumber = 3,
  };
  // required bytes response = 1;
  bool has_response() const;
  private:
  bool _internal_has_response() const;
  public:
  void clear_response();
  const std::string& response() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_response(ArgT0&& arg0, ArgT... args);
  std::string* mutable_response();
  PROTOBUF_NODISCARD std::string* release_response();
  void set_allocated_response(std::string* response);
  private:
  const std::string& _internal_response() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_response(const std::string& value);
  std::string* _internal_mutable_response();
  public:

  // optional uint32 request_id = 2;
  bool has_request_id() const;
  private:
  bool _internal_has_request_id() const;
  public:
  void clear_request_id();
  uint32_t request_id() const;
  void set_request_id(uint32_t value);
  private:
  uint32_t _internal_request_id() const;
  void _internal_set_request_id(uint32_t value);
  public:

  // optional bool updated_secret = 3;
  bool has_updated_secret() const;
  private:
  bool _internal_has_updated_secret() const;
  public:
  void clear_updated_secret();
  bool updated_secret() const;
  void set_updated_secret(bool value);
  private:
  bool _internal_updated_secret() const;
  void _internal_set_updated_secret(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceProofResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr response_;
  uint32_t request_id_;
  bool updated_secret_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// -------------------------------------------------------------------

class CMsgRemoteDeviceStreamTransportSignal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CMsgRemoteDeviceStreamTransportSignal) */ {
 public:
  inline CMsgRemoteDeviceStreamTransportSignal() : CMsgRemoteDeviceStreamTransportSignal(nullptr) {}
  ~CMsgRemoteDeviceStreamTransportSignal() override;
  explicit constexpr CMsgRemoteDeviceStreamTransportSignal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CMsgRemoteDeviceStreamTransportSignal(const CMsgRemoteDeviceStreamTransportSignal& from);
  CMsgRemoteDeviceStreamTransportSignal(CMsgRemoteDeviceStreamTransportSignal&& from) noexcept
    : CMsgRemoteDeviceStreamTransportSignal() {
    *this = ::std::move(from);
  }

  inline CMsgRemoteDeviceStreamTransportSignal& operator=(const CMsgRemoteDeviceStreamTransportSignal& from) {
    CopyFrom(from);
    return *this;
  }
  inline CMsgRemoteDeviceStreamTransportSignal& operator=(CMsgRemoteDeviceStreamTransportSignal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CMsgRemoteDeviceStreamTransportSignal& default_instance() {
    return *internal_default_instance();
  }
  static inline const CMsgRemoteDeviceStreamTransportSignal* internal_default_instance() {
    return reinterpret_cast<const CMsgRemoteDeviceStreamTransportSignal*>(
               &_CMsgRemoteDeviceStreamTransportSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CMsgRemoteDeviceStreamTransportSignal& a, CMsgRemoteDeviceStreamTransportSignal& b) {
    a.Swap(&b);
  }
  inline void Swap(CMsgRemoteDeviceStreamTransportSignal* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CMsgRemoteDeviceStreamTransportSignal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CMsgRemoteDeviceStreamTransportSignal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CMsgRemoteDeviceStreamTransportSignal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CMsgRemoteDeviceStreamTransportSignal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CMsgRemoteDeviceStreamTransportSignal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CMsgRemoteDeviceStreamTransportSignal* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CMsgRemoteDeviceStreamTransportSignal";
  }
  protected:
  explicit CMsgRemoteDeviceStreamTransportSignal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // optional bytes token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional bytes payload = 2;
  bool has_payload() const;
  private:
  bool _internal_has_payload() const;
  public:
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_NODISCARD std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:CMsgRemoteDeviceStreamTransportSignal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  friend struct ::TableStruct_steammessages_5fremoteclient_5fdiscovery_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CMsgRemoteClientBroadcastHeader

// optional uint64 client_id = 1;
inline bool CMsgRemoteClientBroadcastHeader::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastHeader::has_client_id() const {
  return _internal_has_client_id();
}
inline void CMsgRemoteClientBroadcastHeader::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::client_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastHeader.client_id)
  return _internal_client_id();
}
inline void CMsgRemoteClientBroadcastHeader::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  client_id_ = value;
}
inline void CMsgRemoteClientBroadcastHeader::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastHeader.client_id)
}

// optional .ERemoteClientBroadcastMsg msg_type = 2 [default = k_ERemoteClientBroadcastMsgDiscovery];
inline bool CMsgRemoteClientBroadcastHeader::_internal_has_msg_type() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastHeader::has_msg_type() const {
  return _internal_has_msg_type();
}
inline void CMsgRemoteClientBroadcastHeader::clear_msg_type() {
  msg_type_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ERemoteClientBroadcastMsg CMsgRemoteClientBroadcastHeader::_internal_msg_type() const {
  return static_cast< ::ERemoteClientBroadcastMsg >(msg_type_);
}
inline ::ERemoteClientBroadcastMsg CMsgRemoteClientBroadcastHeader::msg_type() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastHeader.msg_type)
  return _internal_msg_type();
}
inline void CMsgRemoteClientBroadcastHeader::_internal_set_msg_type(::ERemoteClientBroadcastMsg value) {
  assert(::ERemoteClientBroadcastMsg_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  msg_type_ = value;
}
inline void CMsgRemoteClientBroadcastHeader::set_msg_type(::ERemoteClientBroadcastMsg value) {
  _internal_set_msg_type(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastHeader.msg_type)
}

// optional uint64 instance_id = 3;
inline bool CMsgRemoteClientBroadcastHeader::_internal_has_instance_id() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastHeader::has_instance_id() const {
  return _internal_has_instance_id();
}
inline void CMsgRemoteClientBroadcastHeader::clear_instance_id() {
  instance_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::_internal_instance_id() const {
  return instance_id_;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::instance_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastHeader.instance_id)
  return _internal_instance_id();
}
inline void CMsgRemoteClientBroadcastHeader::_internal_set_instance_id(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  instance_id_ = value;
}
inline void CMsgRemoteClientBroadcastHeader::set_instance_id(uint64_t value) {
  _internal_set_instance_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastHeader.instance_id)
}

// optional uint64 device_id = 4;
inline bool CMsgRemoteClientBroadcastHeader::_internal_has_device_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastHeader::has_device_id() const {
  return _internal_has_device_id();
}
inline void CMsgRemoteClientBroadcastHeader::clear_device_id() {
  device_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000008u;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::_internal_device_id() const {
  return device_id_;
}
inline uint64_t CMsgRemoteClientBroadcastHeader::device_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastHeader.device_id)
  return _internal_device_id();
}
inline void CMsgRemoteClientBroadcastHeader::_internal_set_device_id(uint64_t value) {
  _has_bits_[0] |= 0x00000008u;
  device_id_ = value;
}
inline void CMsgRemoteClientBroadcastHeader::set_device_id(uint64_t value) {
  _internal_set_device_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastHeader.device_id)
}

// optional bytes device_token = 5;
inline bool CMsgRemoteClientBroadcastHeader::_internal_has_device_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastHeader::has_device_token() const {
  return _internal_has_device_token();
}
inline void CMsgRemoteClientBroadcastHeader::clear_device_token() {
  device_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteClientBroadcastHeader::device_token() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastHeader.device_token)
  return _internal_device_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteClientBroadcastHeader::set_device_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastHeader.device_token)
}
inline std::string* CMsgRemoteClientBroadcastHeader::mutable_device_token() {
  std::string* _s = _internal_mutable_device_token();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastHeader.device_token)
  return _s;
}
inline const std::string& CMsgRemoteClientBroadcastHeader::_internal_device_token() const {
  return device_token_.Get();
}
inline void CMsgRemoteClientBroadcastHeader::_internal_set_device_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastHeader::_internal_mutable_device_token() {
  _has_bits_[0] |= 0x00000001u;
  return device_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastHeader::release_device_token() {
  // @@protoc_insertion_point(field_release:CMsgRemoteClientBroadcastHeader.device_token)
  if (!_internal_has_device_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteClientBroadcastHeader::set_allocated_device_token(std::string* device_token) {
  if (device_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteClientBroadcastHeader.device_token)
}

// -------------------------------------------------------------------

// CMsgRemoteClientBroadcastStatus_User

// optional fixed64 steamid = 1;
inline bool CMsgRemoteClientBroadcastStatus_User::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus_User::has_steamid() const {
  return _internal_has_steamid();
}
inline void CMsgRemoteClientBroadcastStatus_User::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CMsgRemoteClientBroadcastStatus_User::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CMsgRemoteClientBroadcastStatus_User::steamid() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.User.steamid)
  return _internal_steamid();
}
inline void CMsgRemoteClientBroadcastStatus_User::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  steamid_ = value;
}
inline void CMsgRemoteClientBroadcastStatus_User::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.User.steamid)
}

// optional uint32 auth_key_id = 2;
inline bool CMsgRemoteClientBroadcastStatus_User::_internal_has_auth_key_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus_User::has_auth_key_id() const {
  return _internal_has_auth_key_id();
}
inline void CMsgRemoteClientBroadcastStatus_User::clear_auth_key_id() {
  auth_key_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus_User::_internal_auth_key_id() const {
  return auth_key_id_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus_User::auth_key_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.User.auth_key_id)
  return _internal_auth_key_id();
}
inline void CMsgRemoteClientBroadcastStatus_User::_internal_set_auth_key_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  auth_key_id_ = value;
}
inline void CMsgRemoteClientBroadcastStatus_User::set_auth_key_id(uint32_t value) {
  _internal_set_auth_key_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.User.auth_key_id)
}

// -------------------------------------------------------------------

// CMsgRemoteClientBroadcastStatus

// optional int32 version = 1;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_version() const {
  return _internal_has_version();
}
inline void CMsgRemoteClientBroadcastStatus::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CMsgRemoteClientBroadcastStatus::_internal_version() const {
  return version_;
}
inline int32_t CMsgRemoteClientBroadcastStatus::version() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.version)
  return _internal_version();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_version(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_version(int32_t value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.version)
}

// optional int32 min_version = 2;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_min_version() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_min_version() const {
  return _internal_has_min_version();
}
inline void CMsgRemoteClientBroadcastStatus::clear_min_version() {
  min_version_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CMsgRemoteClientBroadcastStatus::_internal_min_version() const {
  return min_version_;
}
inline int32_t CMsgRemoteClientBroadcastStatus::min_version() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.min_version)
  return _internal_min_version();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_min_version(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  min_version_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_min_version(int32_t value) {
  _internal_set_min_version(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.min_version)
}

// optional uint32 connect_port = 3;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_connect_port() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_connect_port() const {
  return _internal_has_connect_port();
}
inline void CMsgRemoteClientBroadcastStatus::clear_connect_port() {
  connect_port_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_connect_port() const {
  return connect_port_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::connect_port() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.connect_port)
  return _internal_connect_port();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_connect_port(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  connect_port_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_connect_port(uint32_t value) {
  _internal_set_connect_port(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.connect_port)
}

// optional string hostname = 4;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_hostname() const {
  return _internal_has_hostname();
}
inline void CMsgRemoteClientBroadcastStatus::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::hostname() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteClientBroadcastStatus::set_hostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.hostname)
}
inline std::string* CMsgRemoteClientBroadcastStatus::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastStatus.hostname)
  return _s;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::_internal_hostname() const {
  return hostname_.Get();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastStatus::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastStatus::release_hostname() {
  // @@protoc_insertion_point(field_release:CMsgRemoteClientBroadcastStatus.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteClientBroadcastStatus::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteClientBroadcastStatus.hostname)
}

// optional uint32 enabled_services = 6;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_enabled_services() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_enabled_services() const {
  return _internal_has_enabled_services();
}
inline void CMsgRemoteClientBroadcastStatus::clear_enabled_services() {
  enabled_services_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_enabled_services() const {
  return enabled_services_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::enabled_services() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.enabled_services)
  return _internal_enabled_services();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_enabled_services(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  enabled_services_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_enabled_services(uint32_t value) {
  _internal_set_enabled_services(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.enabled_services)
}

// optional int32 ostype = 7 [default = 0];
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_ostype() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_ostype() const {
  return _internal_has_ostype();
}
inline void CMsgRemoteClientBroadcastStatus::clear_ostype() {
  ostype_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t CMsgRemoteClientBroadcastStatus::_internal_ostype() const {
  return ostype_;
}
inline int32_t CMsgRemoteClientBroadcastStatus::ostype() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.ostype)
  return _internal_ostype();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_ostype(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  ostype_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_ostype(int32_t value) {
  _internal_set_ostype(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.ostype)
}

// optional bool is64bit = 8;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_is64bit() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_is64bit() const {
  return _internal_has_is64bit();
}
inline void CMsgRemoteClientBroadcastStatus::clear_is64bit() {
  is64bit_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_is64bit() const {
  return is64bit_;
}
inline bool CMsgRemoteClientBroadcastStatus::is64bit() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.is64bit)
  return _internal_is64bit();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_is64bit(bool value) {
  _has_bits_[0] |= 0x00000200u;
  is64bit_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_is64bit(bool value) {
  _internal_set_is64bit(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.is64bit)
}

// repeated .CMsgRemoteClientBroadcastStatus.User users = 9;
inline int CMsgRemoteClientBroadcastStatus::_internal_users_size() const {
  return users_.size();
}
inline int CMsgRemoteClientBroadcastStatus::users_size() const {
  return _internal_users_size();
}
inline void CMsgRemoteClientBroadcastStatus::clear_users() {
  users_.Clear();
}
inline ::CMsgRemoteClientBroadcastStatus_User* CMsgRemoteClientBroadcastStatus::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastStatus.users)
  return users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteClientBroadcastStatus_User >*
CMsgRemoteClientBroadcastStatus::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteClientBroadcastStatus.users)
  return &users_;
}
inline const ::CMsgRemoteClientBroadcastStatus_User& CMsgRemoteClientBroadcastStatus::_internal_users(int index) const {
  return users_.Get(index);
}
inline const ::CMsgRemoteClientBroadcastStatus_User& CMsgRemoteClientBroadcastStatus::users(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.users)
  return _internal_users(index);
}
inline ::CMsgRemoteClientBroadcastStatus_User* CMsgRemoteClientBroadcastStatus::_internal_add_users() {
  return users_.Add();
}
inline ::CMsgRemoteClientBroadcastStatus_User* CMsgRemoteClientBroadcastStatus::add_users() {
  ::CMsgRemoteClientBroadcastStatus_User* _add = _internal_add_users();
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastStatus.users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteClientBroadcastStatus_User >&
CMsgRemoteClientBroadcastStatus::users() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteClientBroadcastStatus.users)
  return users_;
}

// optional int32 euniverse = 11;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_euniverse() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_euniverse() const {
  return _internal_has_euniverse();
}
inline void CMsgRemoteClientBroadcastStatus::clear_euniverse() {
  euniverse_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t CMsgRemoteClientBroadcastStatus::_internal_euniverse() const {
  return euniverse_;
}
inline int32_t CMsgRemoteClientBroadcastStatus::euniverse() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.euniverse)
  return _internal_euniverse();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_euniverse(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  euniverse_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_euniverse(int32_t value) {
  _internal_set_euniverse(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.euniverse)
}

// optional uint32 timestamp = 12;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgRemoteClientBroadcastStatus::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.timestamp)
  return _internal_timestamp();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_timestamp(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  timestamp_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.timestamp)
}

// optional bool screen_locked = 13;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_screen_locked() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_screen_locked() const {
  return _internal_has_screen_locked();
}
inline void CMsgRemoteClientBroadcastStatus::clear_screen_locked() {
  screen_locked_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_screen_locked() const {
  return screen_locked_;
}
inline bool CMsgRemoteClientBroadcastStatus::screen_locked() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.screen_locked)
  return _internal_screen_locked();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_screen_locked(bool value) {
  _has_bits_[0] |= 0x00000400u;
  screen_locked_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_screen_locked(bool value) {
  _internal_set_screen_locked(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.screen_locked)
}

// optional bool games_running = 14;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_games_running() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_games_running() const {
  return _internal_has_games_running();
}
inline void CMsgRemoteClientBroadcastStatus::clear_games_running() {
  games_running_ = false;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_games_running() const {
  return games_running_;
}
inline bool CMsgRemoteClientBroadcastStatus::games_running() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.games_running)
  return _internal_games_running();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_games_running(bool value) {
  _has_bits_[0] |= 0x00000800u;
  games_running_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_games_running(bool value) {
  _internal_set_games_running(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.games_running)
}

// repeated string mac_addresses = 15;
inline int CMsgRemoteClientBroadcastStatus::_internal_mac_addresses_size() const {
  return mac_addresses_.size();
}
inline int CMsgRemoteClientBroadcastStatus::mac_addresses_size() const {
  return _internal_mac_addresses_size();
}
inline void CMsgRemoteClientBroadcastStatus::clear_mac_addresses() {
  mac_addresses_.Clear();
}
inline std::string* CMsgRemoteClientBroadcastStatus::add_mac_addresses() {
  std::string* _s = _internal_add_mac_addresses();
  // @@protoc_insertion_point(field_add_mutable:CMsgRemoteClientBroadcastStatus.mac_addresses)
  return _s;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::_internal_mac_addresses(int index) const {
  return mac_addresses_.Get(index);
}
inline const std::string& CMsgRemoteClientBroadcastStatus::mac_addresses(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.mac_addresses)
  return _internal_mac_addresses(index);
}
inline std::string* CMsgRemoteClientBroadcastStatus::mutable_mac_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastStatus.mac_addresses)
  return mac_addresses_.Mutable(index);
}
inline void CMsgRemoteClientBroadcastStatus::set_mac_addresses(int index, const std::string& value) {
  mac_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_mac_addresses(int index, std::string&& value) {
  mac_addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_mac_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mac_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_mac_addresses(int index, const char* value, size_t size) {
  mac_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline std::string* CMsgRemoteClientBroadcastStatus::_internal_add_mac_addresses() {
  return mac_addresses_.Add();
}
inline void CMsgRemoteClientBroadcastStatus::add_mac_addresses(const std::string& value) {
  mac_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_mac_addresses(std::string&& value) {
  mac_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_mac_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  mac_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_mac_addresses(const char* value, size_t size) {
  mac_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CMsgRemoteClientBroadcastStatus.mac_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CMsgRemoteClientBroadcastStatus::mac_addresses() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteClientBroadcastStatus.mac_addresses)
  return mac_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CMsgRemoteClientBroadcastStatus::mutable_mac_addresses() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteClientBroadcastStatus.mac_addresses)
  return &mac_addresses_;
}

// optional uint32 download_lan_peer_group = 16;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_download_lan_peer_group() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_download_lan_peer_group() const {
  return _internal_has_download_lan_peer_group();
}
inline void CMsgRemoteClientBroadcastStatus::clear_download_lan_peer_group() {
  download_lan_peer_group_ = 0u;
  _has_bits_[0] &= ~0x00002000u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_download_lan_peer_group() const {
  return download_lan_peer_group_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::download_lan_peer_group() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.download_lan_peer_group)
  return _internal_download_lan_peer_group();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_download_lan_peer_group(uint32_t value) {
  _has_bits_[0] |= 0x00002000u;
  download_lan_peer_group_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_download_lan_peer_group(uint32_t value) {
  _internal_set_download_lan_peer_group(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.download_lan_peer_group)
}

// optional bool broadcasting_active = 17;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_broadcasting_active() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_broadcasting_active() const {
  return _internal_has_broadcasting_active();
}
inline void CMsgRemoteClientBroadcastStatus::clear_broadcasting_active() {
  broadcasting_active_ = false;
  _has_bits_[0] &= ~0x00001000u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_broadcasting_active() const {
  return broadcasting_active_;
}
inline bool CMsgRemoteClientBroadcastStatus::broadcasting_active() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.broadcasting_active)
  return _internal_broadcasting_active();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_broadcasting_active(bool value) {
  _has_bits_[0] |= 0x00001000u;
  broadcasting_active_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_broadcasting_active(bool value) {
  _internal_set_broadcasting_active(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.broadcasting_active)
}

// optional bool vr_active = 18;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_vr_active() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_vr_active() const {
  return _internal_has_vr_active();
}
inline void CMsgRemoteClientBroadcastStatus::clear_vr_active() {
  vr_active_ = false;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_vr_active() const {
  return vr_active_;
}
inline bool CMsgRemoteClientBroadcastStatus::vr_active() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.vr_active)
  return _internal_vr_active();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_vr_active(bool value) {
  _has_bits_[0] |= 0x00008000u;
  vr_active_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_vr_active(bool value) {
  _internal_set_vr_active(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.vr_active)
}

// optional uint32 content_cache_port = 19;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_content_cache_port() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_content_cache_port() const {
  return _internal_has_content_cache_port();
}
inline void CMsgRemoteClientBroadcastStatus::clear_content_cache_port() {
  content_cache_port_ = 0u;
  _has_bits_[0] &= ~0x00004000u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_content_cache_port() const {
  return content_cache_port_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::content_cache_port() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.content_cache_port)
  return _internal_content_cache_port();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_content_cache_port(uint32_t value) {
  _has_bits_[0] |= 0x00004000u;
  content_cache_port_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_content_cache_port(uint32_t value) {
  _internal_set_content_cache_port(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.content_cache_port)
}

// repeated string ip_addresses = 20;
inline int CMsgRemoteClientBroadcastStatus::_internal_ip_addresses_size() const {
  return ip_addresses_.size();
}
inline int CMsgRemoteClientBroadcastStatus::ip_addresses_size() const {
  return _internal_ip_addresses_size();
}
inline void CMsgRemoteClientBroadcastStatus::clear_ip_addresses() {
  ip_addresses_.Clear();
}
inline std::string* CMsgRemoteClientBroadcastStatus::add_ip_addresses() {
  std::string* _s = _internal_add_ip_addresses();
  // @@protoc_insertion_point(field_add_mutable:CMsgRemoteClientBroadcastStatus.ip_addresses)
  return _s;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::_internal_ip_addresses(int index) const {
  return ip_addresses_.Get(index);
}
inline const std::string& CMsgRemoteClientBroadcastStatus::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.ip_addresses)
  return _internal_ip_addresses(index);
}
inline std::string* CMsgRemoteClientBroadcastStatus::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastStatus.ip_addresses)
  return ip_addresses_.Mutable(index);
}
inline void CMsgRemoteClientBroadcastStatus::set_ip_addresses(int index, const std::string& value) {
  ip_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_ip_addresses(int index, std::string&& value) {
  ip_addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_ip_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::set_ip_addresses(int index, const char* value, size_t size) {
  ip_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline std::string* CMsgRemoteClientBroadcastStatus::_internal_add_ip_addresses() {
  return ip_addresses_.Add();
}
inline void CMsgRemoteClientBroadcastStatus::add_ip_addresses(const std::string& value) {
  ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_ip_addresses(std::string&& value) {
  ip_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_ip_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  ip_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline void CMsgRemoteClientBroadcastStatus::add_ip_addresses(const char* value, size_t size) {
  ip_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CMsgRemoteClientBroadcastStatus.ip_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CMsgRemoteClientBroadcastStatus::ip_addresses() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteClientBroadcastStatus.ip_addresses)
  return ip_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CMsgRemoteClientBroadcastStatus::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteClientBroadcastStatus.ip_addresses)
  return &ip_addresses_;
}

// optional string public_ip_address = 21;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_public_ip_address() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_public_ip_address() const {
  return _internal_has_public_ip_address();
}
inline void CMsgRemoteClientBroadcastStatus::clear_public_ip_address() {
  public_ip_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::public_ip_address() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.public_ip_address)
  return _internal_public_ip_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteClientBroadcastStatus::set_public_ip_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 public_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.public_ip_address)
}
inline std::string* CMsgRemoteClientBroadcastStatus::mutable_public_ip_address() {
  std::string* _s = _internal_mutable_public_ip_address();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteClientBroadcastStatus.public_ip_address)
  return _s;
}
inline const std::string& CMsgRemoteClientBroadcastStatus::_internal_public_ip_address() const {
  return public_ip_address_.Get();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_public_ip_address(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  public_ip_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastStatus::_internal_mutable_public_ip_address() {
  _has_bits_[0] |= 0x00000002u;
  return public_ip_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteClientBroadcastStatus::release_public_ip_address() {
  // @@protoc_insertion_point(field_release:CMsgRemoteClientBroadcastStatus.public_ip_address)
  if (!_internal_has_public_ip_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = public_ip_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteClientBroadcastStatus::set_allocated_public_ip_address(std::string* public_ip_address) {
  if (public_ip_address != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  public_ip_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_ip_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (public_ip_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    public_ip_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteClientBroadcastStatus.public_ip_address)
}

// optional bool remoteplay_active = 22;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_remoteplay_active() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_remoteplay_active() const {
  return _internal_has_remoteplay_active();
}
inline void CMsgRemoteClientBroadcastStatus::clear_remoteplay_active() {
  remoteplay_active_ = false;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_remoteplay_active() const {
  return remoteplay_active_;
}
inline bool CMsgRemoteClientBroadcastStatus::remoteplay_active() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.remoteplay_active)
  return _internal_remoteplay_active();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_remoteplay_active(bool value) {
  _has_bits_[0] |= 0x00010000u;
  remoteplay_active_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_remoteplay_active(bool value) {
  _internal_set_remoteplay_active(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.remoteplay_active)
}

// optional uint32 supported_services = 23;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_supported_services() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_supported_services() const {
  return _internal_has_supported_services();
}
inline void CMsgRemoteClientBroadcastStatus::clear_supported_services() {
  supported_services_ = 0u;
  _has_bits_[0] &= ~0x00040000u;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::_internal_supported_services() const {
  return supported_services_;
}
inline uint32_t CMsgRemoteClientBroadcastStatus::supported_services() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.supported_services)
  return _internal_supported_services();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_supported_services(uint32_t value) {
  _has_bits_[0] |= 0x00040000u;
  supported_services_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_supported_services(uint32_t value) {
  _internal_set_supported_services(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.supported_services)
}

// optional bool steam_deck = 24;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_steam_deck() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_steam_deck() const {
  return _internal_has_steam_deck();
}
inline void CMsgRemoteClientBroadcastStatus::clear_steam_deck() {
  steam_deck_ = false;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool CMsgRemoteClientBroadcastStatus::_internal_steam_deck() const {
  return steam_deck_;
}
inline bool CMsgRemoteClientBroadcastStatus::steam_deck() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.steam_deck)
  return _internal_steam_deck();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_steam_deck(bool value) {
  _has_bits_[0] |= 0x00020000u;
  steam_deck_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_steam_deck(bool value) {
  _internal_set_steam_deck(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.steam_deck)
}

// optional uint64 steam_version = 25;
inline bool CMsgRemoteClientBroadcastStatus::_internal_has_steam_version() const {
  bool value = (_has_bits_[0] & 0x00080000u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastStatus::has_steam_version() const {
  return _internal_has_steam_version();
}
inline void CMsgRemoteClientBroadcastStatus::clear_steam_version() {
  steam_version_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00080000u;
}
inline uint64_t CMsgRemoteClientBroadcastStatus::_internal_steam_version() const {
  return steam_version_;
}
inline uint64_t CMsgRemoteClientBroadcastStatus::steam_version() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastStatus.steam_version)
  return _internal_steam_version();
}
inline void CMsgRemoteClientBroadcastStatus::_internal_set_steam_version(uint64_t value) {
  _has_bits_[0] |= 0x00080000u;
  steam_version_ = value;
}
inline void CMsgRemoteClientBroadcastStatus::set_steam_version(uint64_t value) {
  _internal_set_steam_version(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastStatus.steam_version)
}

// -------------------------------------------------------------------

// CMsgRemoteClientBroadcastDiscovery

// optional uint32 seq_num = 1;
inline bool CMsgRemoteClientBroadcastDiscovery::_internal_has_seq_num() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteClientBroadcastDiscovery::has_seq_num() const {
  return _internal_has_seq_num();
}
inline void CMsgRemoteClientBroadcastDiscovery::clear_seq_num() {
  seq_num_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgRemoteClientBroadcastDiscovery::_internal_seq_num() const {
  return seq_num_;
}
inline uint32_t CMsgRemoteClientBroadcastDiscovery::seq_num() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastDiscovery.seq_num)
  return _internal_seq_num();
}
inline void CMsgRemoteClientBroadcastDiscovery::_internal_set_seq_num(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  seq_num_ = value;
}
inline void CMsgRemoteClientBroadcastDiscovery::set_seq_num(uint32_t value) {
  _internal_set_seq_num(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastDiscovery.seq_num)
}

// repeated uint64 client_ids = 2;
inline int CMsgRemoteClientBroadcastDiscovery::_internal_client_ids_size() const {
  return client_ids_.size();
}
inline int CMsgRemoteClientBroadcastDiscovery::client_ids_size() const {
  return _internal_client_ids_size();
}
inline void CMsgRemoteClientBroadcastDiscovery::clear_client_ids() {
  client_ids_.Clear();
}
inline uint64_t CMsgRemoteClientBroadcastDiscovery::_internal_client_ids(int index) const {
  return client_ids_.Get(index);
}
inline uint64_t CMsgRemoteClientBroadcastDiscovery::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastDiscovery.client_ids)
  return _internal_client_ids(index);
}
inline void CMsgRemoteClientBroadcastDiscovery::set_client_ids(int index, uint64_t value) {
  client_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastDiscovery.client_ids)
}
inline void CMsgRemoteClientBroadcastDiscovery::_internal_add_client_ids(uint64_t value) {
  client_ids_.Add(value);
}
inline void CMsgRemoteClientBroadcastDiscovery::add_client_ids(uint64_t value) {
  _internal_add_client_ids(value);
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastDiscovery.client_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgRemoteClientBroadcastDiscovery::_internal_client_ids() const {
  return client_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgRemoteClientBroadcastDiscovery::client_ids() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteClientBroadcastDiscovery.client_ids)
  return _internal_client_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgRemoteClientBroadcastDiscovery::_internal_mutable_client_ids() {
  return &client_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgRemoteClientBroadcastDiscovery::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteClientBroadcastDiscovery.client_ids)
  return _internal_mutable_client_ids();
}

// -------------------------------------------------------------------

// CMsgRemoteClientBroadcastClientIDDeconflict

// repeated uint64 client_ids = 2;
inline int CMsgRemoteClientBroadcastClientIDDeconflict::_internal_client_ids_size() const {
  return client_ids_.size();
}
inline int CMsgRemoteClientBroadcastClientIDDeconflict::client_ids_size() const {
  return _internal_client_ids_size();
}
inline void CMsgRemoteClientBroadcastClientIDDeconflict::clear_client_ids() {
  client_ids_.Clear();
}
inline uint64_t CMsgRemoteClientBroadcastClientIDDeconflict::_internal_client_ids(int index) const {
  return client_ids_.Get(index);
}
inline uint64_t CMsgRemoteClientBroadcastClientIDDeconflict::client_ids(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
  return _internal_client_ids(index);
}
inline void CMsgRemoteClientBroadcastClientIDDeconflict::set_client_ids(int index, uint64_t value) {
  client_ids_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
}
inline void CMsgRemoteClientBroadcastClientIDDeconflict::_internal_add_client_ids(uint64_t value) {
  client_ids_.Add(value);
}
inline void CMsgRemoteClientBroadcastClientIDDeconflict::add_client_ids(uint64_t value) {
  _internal_add_client_ids(value);
  // @@protoc_insertion_point(field_add:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgRemoteClientBroadcastClientIDDeconflict::_internal_client_ids() const {
  return client_ids_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >&
CMsgRemoteClientBroadcastClientIDDeconflict::client_ids() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
  return _internal_client_ids();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgRemoteClientBroadcastClientIDDeconflict::_internal_mutable_client_ids() {
  return &client_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint64_t >*
CMsgRemoteClientBroadcastClientIDDeconflict::mutable_client_ids() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteClientBroadcastClientIDDeconflict.client_ids)
  return _internal_mutable_client_ids();
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket

// optional bytes password = 1;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_password() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_password() const {
  return _internal_has_password();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_password() {
  password_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::password() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_password(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 password_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_password() const {
  return password_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_password(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_mutable_password() {
  _has_bits_[0] |= 0x00000001u;
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::release_password() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
  if (!_internal_has_password()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = password_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.password)
}

// optional uint64 identifier = 2;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_identifier() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_identifier() const {
  return _internal_has_identifier();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_identifier() {
  identifier_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000020u;
}
inline uint64_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_identifier() const {
  return identifier_;
}
inline uint64_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::identifier() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.identifier)
  return _internal_identifier();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_identifier(uint64_t value) {
  _has_bits_[0] |= 0x00000020u;
  identifier_ = value;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_identifier(uint64_t value) {
  _internal_set_identifier(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.identifier)
}

// optional bytes payload = 3;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_payload() const {
  return _internal_has_payload();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_payload() {
  payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::payload() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_payload() const {
  return payload_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000002u;
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::release_payload() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = payload_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.payload)
}

// optional uint32 timestamp = 4;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline uint32_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::timestamp() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.timestamp)
  return _internal_timestamp();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_timestamp(uint32_t value) {
  _has_bits_[0] |= 0x00000040u;
  timestamp_ = value;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.timestamp)
}

// optional .CMsgRemoteDeviceAuthorizationRequest.EKeyEscrowUsage usage = 5 [default = k_EKeyEscrowUsageStreamingDevice];
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_usage() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_usage() const {
  return _internal_has_usage();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_usage() {
  usage_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_usage() const {
  return static_cast< ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage >(usage_);
}
inline ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::usage() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.usage)
  return _internal_usage();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_usage(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage value) {
  assert(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_IsValid(value));
  _has_bits_[0] |= 0x00000080u;
  usage_ = value;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_usage(::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage value) {
  _internal_set_usage(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.usage)
}

// optional string device_name = 6;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_device_name() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_device_name() const {
  return _internal_has_device_name();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_device_name() {
  device_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::device_name() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_device_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_device_name() const {
  return device_name_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_device_name(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_mutable_device_name() {
  _has_bits_[0] |= 0x00000004u;
  return device_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::release_device_name() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
  if (!_internal_has_device_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = device_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  device_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_name)
}

// optional string device_model = 7;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_device_model() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_device_model() const {
  return _internal_has_device_model();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_device_model() {
  device_model_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::device_model() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
  return _internal_device_model();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_device_model(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 device_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::mutable_device_model() {
  std::string* _s = _internal_mutable_device_model();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_device_model() const {
  return device_model_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_device_model(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  device_model_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_mutable_device_model() {
  _has_bits_[0] |= 0x00000008u;
  return device_model_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::release_device_model() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
  if (!_internal_has_device_model()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = device_model_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_allocated_device_model(std::string* device_model) {
  if (device_model != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  device_model_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_model,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_model_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_model_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_model)
}

// optional string device_serial = 8;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_device_serial() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_device_serial() const {
  return _internal_has_device_serial();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_device_serial() {
  device_serial_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000010u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::device_serial() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
  return _internal_device_serial();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_device_serial(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000010u;
 device_serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::mutable_device_serial() {
  std::string* _s = _internal_mutable_device_serial();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_device_serial() const {
  return device_serial_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_device_serial(const std::string& value) {
  _has_bits_[0] |= 0x00000010u;
  device_serial_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_mutable_device_serial() {
  _has_bits_[0] |= 0x00000010u;
  return device_serial_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::release_device_serial() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
  if (!_internal_has_device_serial()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000010u;
  auto* p = device_serial_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_allocated_device_serial(std::string* device_serial) {
  if (device_serial != nullptr) {
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  device_serial_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_serial,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_serial_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_serial_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_serial)
}

// optional uint32 device_provisioning_id = 9;
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_has_device_provisioning_id() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::has_device_provisioning_id() const {
  return _internal_has_device_provisioning_id();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::clear_device_provisioning_id() {
  device_provisioning_id_ = 0u;
  _has_bits_[0] &= ~0x00000100u;
}
inline uint32_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_device_provisioning_id() const {
  return device_provisioning_id_;
}
inline uint32_t CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::device_provisioning_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_provisioning_id)
  return _internal_device_provisioning_id();
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::_internal_set_device_provisioning_id(uint32_t value) {
  _has_bits_[0] |= 0x00000100u;
  device_provisioning_id_ = value;
}
inline void CMsgRemoteDeviceAuthorizationRequest_CKeyEscrow_Ticket::set_device_provisioning_id(uint32_t value) {
  _internal_set_device_provisioning_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.CKeyEscrow_Ticket.device_provisioning_id)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceAuthorizationRequest

// required bytes device_token = 1;
inline bool CMsgRemoteDeviceAuthorizationRequest::_internal_has_device_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest::has_device_token() const {
  return _internal_has_device_token();
}
inline void CMsgRemoteDeviceAuthorizationRequest::clear_device_token() {
  device_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::device_token() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.device_token)
  return _internal_device_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest::set_device_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.device_token)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::mutable_device_token() {
  std::string* _s = _internal_mutable_device_token();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.device_token)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::_internal_device_token() const {
  return device_token_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest::_internal_set_device_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::_internal_mutable_device_token() {
  _has_bits_[0] |= 0x00000001u;
  return device_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::release_device_token() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.device_token)
  if (!_internal_has_device_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest::set_allocated_device_token(std::string* device_token) {
  if (device_token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.device_token)
}

// optional string device_name = 2;
inline bool CMsgRemoteDeviceAuthorizationRequest::_internal_has_device_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest::has_device_name() const {
  return _internal_has_device_name();
}
inline void CMsgRemoteDeviceAuthorizationRequest::clear_device_name() {
  device_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::device_name() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.device_name)
  return _internal_device_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest::set_device_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.device_name)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::mutable_device_name() {
  std::string* _s = _internal_mutable_device_name();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.device_name)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::_internal_device_name() const {
  return device_name_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest::_internal_set_device_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::_internal_mutable_device_name() {
  _has_bits_[0] |= 0x00000002u;
  return device_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::release_device_name() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.device_name)
  if (!_internal_has_device_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = device_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest::set_allocated_device_name(std::string* device_name) {
  if (device_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.device_name)
}

// required bytes encrypted_request = 3;
inline bool CMsgRemoteDeviceAuthorizationRequest::_internal_has_encrypted_request() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest::has_encrypted_request() const {
  return _internal_has_encrypted_request();
}
inline void CMsgRemoteDeviceAuthorizationRequest::clear_encrypted_request() {
  encrypted_request_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::encrypted_request() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
  return _internal_encrypted_request();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest::set_encrypted_request(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 encrypted_request_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::mutable_encrypted_request() {
  std::string* _s = _internal_mutable_encrypted_request();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::_internal_encrypted_request() const {
  return encrypted_request_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest::_internal_set_encrypted_request(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  encrypted_request_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::_internal_mutable_encrypted_request() {
  _has_bits_[0] |= 0x00000004u;
  return encrypted_request_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::release_encrypted_request() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
  if (!_internal_has_encrypted_request()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = encrypted_request_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_request_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_request_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest::set_allocated_encrypted_request(std::string* encrypted_request) {
  if (encrypted_request != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  encrypted_request_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_request,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_request_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_request_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.encrypted_request)
}

// optional bytes auth_key = 4;
inline bool CMsgRemoteDeviceAuthorizationRequest::_internal_has_auth_key() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationRequest::has_auth_key() const {
  return _internal_has_auth_key();
}
inline void CMsgRemoteDeviceAuthorizationRequest::clear_auth_key() {
  auth_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000008u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::auth_key() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationRequest.auth_key)
  return _internal_auth_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationRequest::set_auth_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000008u;
 auth_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationRequest.auth_key)
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::mutable_auth_key() {
  std::string* _s = _internal_mutable_auth_key();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationRequest.auth_key)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationRequest::_internal_auth_key() const {
  return auth_key_.Get();
}
inline void CMsgRemoteDeviceAuthorizationRequest::_internal_set_auth_key(const std::string& value) {
  _has_bits_[0] |= 0x00000008u;
  auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::_internal_mutable_auth_key() {
  _has_bits_[0] |= 0x00000008u;
  return auth_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationRequest::release_auth_key() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationRequest.auth_key)
  if (!_internal_has_auth_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000008u;
  auto* p = auth_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationRequest::set_allocated_auth_key(std::string* auth_key) {
  if (auth_key != nullptr) {
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  auth_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationRequest.auth_key)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceAuthorizationCancelRequest

// -------------------------------------------------------------------

// CMsgRemoteDeviceAuthorizationResponse

// required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
inline bool CMsgRemoteDeviceAuthorizationResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgRemoteDeviceAuthorizationResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::ERemoteDeviceAuthorizationResult CMsgRemoteDeviceAuthorizationResponse::_internal_result() const {
  return static_cast< ::ERemoteDeviceAuthorizationResult >(result_);
}
inline ::ERemoteDeviceAuthorizationResult CMsgRemoteDeviceAuthorizationResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationResponse.result)
  return _internal_result();
}
inline void CMsgRemoteDeviceAuthorizationResponse::_internal_set_result(::ERemoteDeviceAuthorizationResult value) {
  assert(::ERemoteDeviceAuthorizationResult_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  result_ = value;
}
inline void CMsgRemoteDeviceAuthorizationResponse::set_result(::ERemoteDeviceAuthorizationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationResponse.result)
}

// optional fixed64 steamid = 2;
inline bool CMsgRemoteDeviceAuthorizationResponse::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationResponse::has_steamid() const {
  return _internal_has_steamid();
}
inline void CMsgRemoteDeviceAuthorizationResponse::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CMsgRemoteDeviceAuthorizationResponse::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CMsgRemoteDeviceAuthorizationResponse::steamid() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationResponse.steamid)
  return _internal_steamid();
}
inline void CMsgRemoteDeviceAuthorizationResponse::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  steamid_ = value;
}
inline void CMsgRemoteDeviceAuthorizationResponse::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationResponse.steamid)
}

// optional bytes auth_key = 3;
inline bool CMsgRemoteDeviceAuthorizationResponse::_internal_has_auth_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationResponse::has_auth_key() const {
  return _internal_has_auth_key();
}
inline void CMsgRemoteDeviceAuthorizationResponse::clear_auth_key() {
  auth_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationResponse::auth_key() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationResponse.auth_key)
  return _internal_auth_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationResponse::set_auth_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 auth_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationResponse.auth_key)
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::mutable_auth_key() {
  std::string* _s = _internal_mutable_auth_key();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationResponse.auth_key)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationResponse::_internal_auth_key() const {
  return auth_key_.Get();
}
inline void CMsgRemoteDeviceAuthorizationResponse::_internal_set_auth_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  auth_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::_internal_mutable_auth_key() {
  _has_bits_[0] |= 0x00000001u;
  return auth_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::release_auth_key() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationResponse.auth_key)
  if (!_internal_has_auth_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = auth_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationResponse::set_allocated_auth_key(std::string* auth_key) {
  if (auth_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  auth_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), auth_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (auth_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    auth_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationResponse.auth_key)
}

// optional bytes device_token = 4;
inline bool CMsgRemoteDeviceAuthorizationResponse::_internal_has_device_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationResponse::has_device_token() const {
  return _internal_has_device_token();
}
inline void CMsgRemoteDeviceAuthorizationResponse::clear_device_token() {
  device_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceAuthorizationResponse::device_token() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationResponse.device_token)
  return _internal_device_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceAuthorizationResponse::set_device_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 device_token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationResponse.device_token)
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::mutable_device_token() {
  std::string* _s = _internal_mutable_device_token();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceAuthorizationResponse.device_token)
  return _s;
}
inline const std::string& CMsgRemoteDeviceAuthorizationResponse::_internal_device_token() const {
  return device_token_.Get();
}
inline void CMsgRemoteDeviceAuthorizationResponse::_internal_set_device_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::_internal_mutable_device_token() {
  _has_bits_[0] |= 0x00000002u;
  return device_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceAuthorizationResponse::release_device_token() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceAuthorizationResponse.device_token)
  if (!_internal_has_device_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = device_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceAuthorizationResponse::set_allocated_device_token(std::string* device_token) {
  if (device_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceAuthorizationResponse.device_token)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceAuthorizationConfirmed

// required .ERemoteDeviceAuthorizationResult result = 1 [default = k_ERemoteDeviceAuthorizationSuccess];
inline bool CMsgRemoteDeviceAuthorizationConfirmed::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceAuthorizationConfirmed::has_result() const {
  return _internal_has_result();
}
inline void CMsgRemoteDeviceAuthorizationConfirmed::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::ERemoteDeviceAuthorizationResult CMsgRemoteDeviceAuthorizationConfirmed::_internal_result() const {
  return static_cast< ::ERemoteDeviceAuthorizationResult >(result_);
}
inline ::ERemoteDeviceAuthorizationResult CMsgRemoteDeviceAuthorizationConfirmed::result() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceAuthorizationConfirmed.result)
  return _internal_result();
}
inline void CMsgRemoteDeviceAuthorizationConfirmed::_internal_set_result(::ERemoteDeviceAuthorizationResult value) {
  assert(::ERemoteDeviceAuthorizationResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
}
inline void CMsgRemoteDeviceAuthorizationConfirmed::set_result(::ERemoteDeviceAuthorizationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceAuthorizationConfirmed.result)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamingRequest_ReservedGamepad

// optional uint32 controller_type = 1;
inline bool CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_has_controller_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest_ReservedGamepad::has_controller_type() const {
  return _internal_has_controller_type();
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::clear_controller_type() {
  controller_type_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_controller_type() const {
  return controller_type_;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest_ReservedGamepad::controller_type() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_type)
  return _internal_controller_type();
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_set_controller_type(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  controller_type_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::set_controller_type(uint32_t value) {
  _internal_set_controller_type(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_type)
}

// optional uint32 controller_subtype = 2;
inline bool CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_has_controller_subtype() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest_ReservedGamepad::has_controller_subtype() const {
  return _internal_has_controller_subtype();
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::clear_controller_subtype() {
  controller_subtype_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_controller_subtype() const {
  return controller_subtype_;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest_ReservedGamepad::controller_subtype() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_subtype)
  return _internal_controller_subtype();
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::_internal_set_controller_subtype(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  controller_subtype_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest_ReservedGamepad::set_controller_subtype(uint32_t value) {
  _internal_set_controller_subtype(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.ReservedGamepad.controller_subtype)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamingRequest

// required uint32 request_id = 1;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceStreamingRequest::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.request_id)
}

// optional int32 maximum_resolution_x = 2;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_maximum_resolution_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_maximum_resolution_x() const {
  return _internal_has_maximum_resolution_x();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_maximum_resolution_x() {
  maximum_resolution_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::_internal_maximum_resolution_x() const {
  return maximum_resolution_x_;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::maximum_resolution_x() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.maximum_resolution_x)
  return _internal_maximum_resolution_x();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_maximum_resolution_x(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  maximum_resolution_x_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_maximum_resolution_x(int32_t value) {
  _internal_set_maximum_resolution_x(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.maximum_resolution_x)
}

// optional int32 maximum_resolution_y = 3;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_maximum_resolution_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_maximum_resolution_y() const {
  return _internal_has_maximum_resolution_y();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_maximum_resolution_y() {
  maximum_resolution_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::_internal_maximum_resolution_y() const {
  return maximum_resolution_y_;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::maximum_resolution_y() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.maximum_resolution_y)
  return _internal_maximum_resolution_y();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_maximum_resolution_y(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  maximum_resolution_y_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_maximum_resolution_y(int32_t value) {
  _internal_set_maximum_resolution_y(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.maximum_resolution_y)
}

// optional int32 audio_channel_count = 4 [default = 2];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_audio_channel_count() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_audio_channel_count() const {
  return _internal_has_audio_channel_count();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_audio_channel_count() {
  audio_channel_count_ = 2;
  _has_bits_[0] &= ~0x00004000u;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::_internal_audio_channel_count() const {
  return audio_channel_count_;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::audio_channel_count() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.audio_channel_count)
  return _internal_audio_channel_count();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_audio_channel_count(int32_t value) {
  _has_bits_[0] |= 0x00004000u;
  audio_channel_count_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_audio_channel_count(int32_t value) {
  _internal_set_audio_channel_count(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.audio_channel_count)
}

// optional string device_version = 5;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_device_version() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_device_version() const {
  return _internal_has_device_version();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_device_version() {
  device_version_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::device_version() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.device_version)
  return _internal_device_version();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingRequest::set_device_version(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.device_version)
}
inline std::string* CMsgRemoteDeviceStreamingRequest::mutable_device_version() {
  std::string* _s = _internal_mutable_device_version();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingRequest.device_version)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::_internal_device_version() const {
  return device_version_.Get();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_device_version(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_version_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::_internal_mutable_device_version() {
  _has_bits_[0] |= 0x00000001u;
  return device_version_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::release_device_version() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingRequest.device_version)
  if (!_internal_has_device_version()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_version_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingRequest::set_allocated_device_version(std::string* device_version) {
  if (device_version != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_version_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_version,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_version_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_version_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingRequest.device_version)
}

// optional bool stream_desktop = 6;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_stream_desktop() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_stream_desktop() const {
  return _internal_has_stream_desktop();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_stream_desktop() {
  stream_desktop_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_stream_desktop() const {
  return stream_desktop_;
}
inline bool CMsgRemoteDeviceStreamingRequest::stream_desktop() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.stream_desktop)
  return _internal_stream_desktop();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_stream_desktop(bool value) {
  _has_bits_[0] |= 0x00000040u;
  stream_desktop_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_stream_desktop(bool value) {
  _internal_set_stream_desktop(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.stream_desktop)
}

// optional bytes device_token = 7;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_device_token() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_device_token() const {
  return _internal_has_device_token();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_device_token() {
  device_token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::device_token() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.device_token)
  return _internal_device_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingRequest::set_device_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 device_token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.device_token)
}
inline std::string* CMsgRemoteDeviceStreamingRequest::mutable_device_token() {
  std::string* _s = _internal_mutable_device_token();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingRequest.device_token)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::_internal_device_token() const {
  return device_token_.Get();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_device_token(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  device_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::_internal_mutable_device_token() {
  _has_bits_[0] |= 0x00000002u;
  return device_token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::release_device_token() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingRequest.device_token)
  if (!_internal_has_device_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = device_token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingRequest::set_allocated_device_token(std::string* device_token) {
  if (device_token != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  device_token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingRequest.device_token)
}

// optional bytes pin = 8;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_pin() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_pin() const {
  return _internal_has_pin();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_pin() {
  pin_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::pin() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.pin)
  return _internal_pin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingRequest::set_pin(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 pin_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.pin)
}
inline std::string* CMsgRemoteDeviceStreamingRequest::mutable_pin() {
  std::string* _s = _internal_mutable_pin();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingRequest.pin)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingRequest::_internal_pin() const {
  return pin_.Get();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_pin(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  pin_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::_internal_mutable_pin() {
  _has_bits_[0] |= 0x00000004u;
  return pin_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingRequest::release_pin() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingRequest.pin)
  if (!_internal_has_pin()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = pin_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pin_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingRequest::set_allocated_pin(std::string* pin) {
  if (pin != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  pin_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), pin,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (pin_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    pin_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingRequest.pin)
}

// optional bool enable_video_streaming = 9 [default = true];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_enable_video_streaming() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_enable_video_streaming() const {
  return _internal_has_enable_video_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_enable_video_streaming() {
  enable_video_streaming_ = true;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_enable_video_streaming() const {
  return enable_video_streaming_;
}
inline bool CMsgRemoteDeviceStreamingRequest::enable_video_streaming() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.enable_video_streaming)
  return _internal_enable_video_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_enable_video_streaming(bool value) {
  _has_bits_[0] |= 0x00008000u;
  enable_video_streaming_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_enable_video_streaming(bool value) {
  _internal_set_enable_video_streaming(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.enable_video_streaming)
}

// optional bool enable_audio_streaming = 10 [default = true];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_enable_audio_streaming() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_enable_audio_streaming() const {
  return _internal_has_enable_audio_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_enable_audio_streaming() {
  enable_audio_streaming_ = true;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_enable_audio_streaming() const {
  return enable_audio_streaming_;
}
inline bool CMsgRemoteDeviceStreamingRequest::enable_audio_streaming() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.enable_audio_streaming)
  return _internal_enable_audio_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_enable_audio_streaming(bool value) {
  _has_bits_[0] |= 0x00010000u;
  enable_audio_streaming_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_enable_audio_streaming(bool value) {
  _internal_set_enable_audio_streaming(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.enable_audio_streaming)
}

// optional bool enable_input_streaming = 11 [default = true];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_enable_input_streaming() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_enable_input_streaming() const {
  return _internal_has_enable_input_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_enable_input_streaming() {
  enable_input_streaming_ = true;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_enable_input_streaming() const {
  return enable_input_streaming_;
}
inline bool CMsgRemoteDeviceStreamingRequest::enable_input_streaming() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.enable_input_streaming)
  return _internal_enable_input_streaming();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_enable_input_streaming(bool value) {
  _has_bits_[0] |= 0x00020000u;
  enable_input_streaming_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_enable_input_streaming(bool value) {
  _internal_set_enable_input_streaming(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.enable_input_streaming)
}

// optional bool network_test = 12;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_network_test() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_network_test() const {
  return _internal_has_network_test();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_network_test() {
  network_test_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_network_test() const {
  return network_test_;
}
inline bool CMsgRemoteDeviceStreamingRequest::network_test() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.network_test)
  return _internal_network_test();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_network_test(bool value) {
  _has_bits_[0] |= 0x00000080u;
  network_test_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_network_test(bool value) {
  _internal_set_network_test(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.network_test)
}

// optional uint64 client_id = 13;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_client_id() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_client_id() const {
  return _internal_has_client_id();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_client_id() {
  client_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000200u;
}
inline uint64_t CMsgRemoteDeviceStreamingRequest::_internal_client_id() const {
  return client_id_;
}
inline uint64_t CMsgRemoteDeviceStreamingRequest::client_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.client_id)
  return _internal_client_id();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_client_id(uint64_t value) {
  _has_bits_[0] |= 0x00000200u;
  client_id_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_client_id(uint64_t value) {
  _internal_set_client_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.client_id)
}

// repeated .EStreamTransport supported_transport = 14;
inline int CMsgRemoteDeviceStreamingRequest::_internal_supported_transport_size() const {
  return supported_transport_.size();
}
inline int CMsgRemoteDeviceStreamingRequest::supported_transport_size() const {
  return _internal_supported_transport_size();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_supported_transport() {
  supported_transport_.Clear();
}
inline ::EStreamTransport CMsgRemoteDeviceStreamingRequest::_internal_supported_transport(int index) const {
  return static_cast< ::EStreamTransport >(supported_transport_.Get(index));
}
inline ::EStreamTransport CMsgRemoteDeviceStreamingRequest::supported_transport(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.supported_transport)
  return _internal_supported_transport(index);
}
inline void CMsgRemoteDeviceStreamingRequest::set_supported_transport(int index, ::EStreamTransport value) {
  assert(::EStreamTransport_IsValid(value));
  supported_transport_.Set(index, value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.supported_transport)
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_add_supported_transport(::EStreamTransport value) {
  assert(::EStreamTransport_IsValid(value));
  supported_transport_.Add(value);
}
inline void CMsgRemoteDeviceStreamingRequest::add_supported_transport(::EStreamTransport value) {
  _internal_add_supported_transport(value);
  // @@protoc_insertion_point(field_add:CMsgRemoteDeviceStreamingRequest.supported_transport)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CMsgRemoteDeviceStreamingRequest::supported_transport() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteDeviceStreamingRequest.supported_transport)
  return supported_transport_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CMsgRemoteDeviceStreamingRequest::_internal_mutable_supported_transport() {
  return &supported_transport_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CMsgRemoteDeviceStreamingRequest::mutable_supported_transport() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteDeviceStreamingRequest.supported_transport)
  return _internal_mutable_supported_transport();
}

// optional bool restricted = 15;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_restricted() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_restricted() const {
  return _internal_has_restricted();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_restricted() {
  restricted_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CMsgRemoteDeviceStreamingRequest::_internal_restricted() const {
  return restricted_;
}
inline bool CMsgRemoteDeviceStreamingRequest::restricted() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.restricted)
  return _internal_restricted();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_restricted(bool value) {
  _has_bits_[0] |= 0x00000100u;
  restricted_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_restricted(bool value) {
  _internal_set_restricted(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.restricted)
}

// optional .EStreamDeviceFormFactor form_factor = 16 [default = k_EStreamDeviceFormFactorUnknown];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_form_factor() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_form_factor() const {
  return _internal_has_form_factor();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_form_factor() {
  form_factor_ = 0;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::EStreamDeviceFormFactor CMsgRemoteDeviceStreamingRequest::_internal_form_factor() const {
  return static_cast< ::EStreamDeviceFormFactor >(form_factor_);
}
inline ::EStreamDeviceFormFactor CMsgRemoteDeviceStreamingRequest::form_factor() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.form_factor)
  return _internal_form_factor();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_form_factor(::EStreamDeviceFormFactor value) {
  assert(::EStreamDeviceFormFactor_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  form_factor_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_form_factor(::EStreamDeviceFormFactor value) {
  _internal_set_form_factor(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.form_factor)
}

// optional int32 gamepad_count = 17;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_gamepad_count() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_gamepad_count() const {
  return _internal_has_gamepad_count();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_gamepad_count() {
  gamepad_count_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::_internal_gamepad_count() const {
  return gamepad_count_;
}
inline int32_t CMsgRemoteDeviceStreamingRequest::gamepad_count() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.gamepad_count)
  return _internal_gamepad_count();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_gamepad_count(int32_t value) {
  _has_bits_[0] |= 0x00000800u;
  gamepad_count_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_gamepad_count(int32_t value) {
  _internal_set_gamepad_count(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.gamepad_count)
}

// repeated .CMsgRemoteDeviceStreamingRequest.ReservedGamepad gamepads = 18;
inline int CMsgRemoteDeviceStreamingRequest::_internal_gamepads_size() const {
  return gamepads_.size();
}
inline int CMsgRemoteDeviceStreamingRequest::gamepads_size() const {
  return _internal_gamepads_size();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_gamepads() {
  gamepads_.Clear();
}
inline ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* CMsgRemoteDeviceStreamingRequest::mutable_gamepads(int index) {
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingRequest.gamepads)
  return gamepads_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >*
CMsgRemoteDeviceStreamingRequest::mutable_gamepads() {
  // @@protoc_insertion_point(field_mutable_list:CMsgRemoteDeviceStreamingRequest.gamepads)
  return &gamepads_;
}
inline const ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad& CMsgRemoteDeviceStreamingRequest::_internal_gamepads(int index) const {
  return gamepads_.Get(index);
}
inline const ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad& CMsgRemoteDeviceStreamingRequest::gamepads(int index) const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.gamepads)
  return _internal_gamepads(index);
}
inline ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* CMsgRemoteDeviceStreamingRequest::_internal_add_gamepads() {
  return gamepads_.Add();
}
inline ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* CMsgRemoteDeviceStreamingRequest::add_gamepads() {
  ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad* _add = _internal_add_gamepads();
  // @@protoc_insertion_point(field_add:CMsgRemoteDeviceStreamingRequest.gamepads)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CMsgRemoteDeviceStreamingRequest_ReservedGamepad >&
CMsgRemoteDeviceStreamingRequest::gamepads() const {
  // @@protoc_insertion_point(field_list:CMsgRemoteDeviceStreamingRequest.gamepads)
  return gamepads_;
}

// optional uint64 gameid = 19;
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_gameid() const {
  return _internal_has_gameid();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_gameid() {
  gameid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00001000u;
}
inline uint64_t CMsgRemoteDeviceStreamingRequest::_internal_gameid() const {
  return gameid_;
}
inline uint64_t CMsgRemoteDeviceStreamingRequest::gameid() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.gameid)
  return _internal_gameid();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_gameid(uint64_t value) {
  _has_bits_[0] |= 0x00001000u;
  gameid_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_gameid(uint64_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.gameid)
}

// optional .EStreamInterface stream_interface = 20 [default = k_EStreamInterfaceDefault];
inline bool CMsgRemoteDeviceStreamingRequest::_internal_has_stream_interface() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingRequest::has_stream_interface() const {
  return _internal_has_stream_interface();
}
inline void CMsgRemoteDeviceStreamingRequest::clear_stream_interface() {
  stream_interface_ = 0;
  _has_bits_[0] &= ~0x00002000u;
}
inline ::EStreamInterface CMsgRemoteDeviceStreamingRequest::_internal_stream_interface() const {
  return static_cast< ::EStreamInterface >(stream_interface_);
}
inline ::EStreamInterface CMsgRemoteDeviceStreamingRequest::stream_interface() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingRequest.stream_interface)
  return _internal_stream_interface();
}
inline void CMsgRemoteDeviceStreamingRequest::_internal_set_stream_interface(::EStreamInterface value) {
  assert(::EStreamInterface_IsValid(value));
  _has_bits_[0] |= 0x00002000u;
  stream_interface_ = value;
}
inline void CMsgRemoteDeviceStreamingRequest::set_stream_interface(::EStreamInterface value) {
  _internal_set_stream_interface(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingRequest.stream_interface)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamingCancelRequest

// required uint32 request_id = 1;
inline bool CMsgRemoteDeviceStreamingCancelRequest::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingCancelRequest::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceStreamingCancelRequest::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgRemoteDeviceStreamingCancelRequest::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceStreamingCancelRequest::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingCancelRequest.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceStreamingCancelRequest::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceStreamingCancelRequest::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingCancelRequest.request_id)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamingProgress

// required uint32 request_id = 1;
inline bool CMsgRemoteDeviceStreamingProgress::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingProgress::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceStreamingProgress::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CMsgRemoteDeviceStreamingProgress::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceStreamingProgress::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingProgress.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceStreamingProgress::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceStreamingProgress::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingProgress.request_id)
}

// optional float progress = 2;
inline bool CMsgRemoteDeviceStreamingProgress::_internal_has_progress() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingProgress::has_progress() const {
  return _internal_has_progress();
}
inline void CMsgRemoteDeviceStreamingProgress::clear_progress() {
  progress_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CMsgRemoteDeviceStreamingProgress::_internal_progress() const {
  return progress_;
}
inline float CMsgRemoteDeviceStreamingProgress::progress() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingProgress.progress)
  return _internal_progress();
}
inline void CMsgRemoteDeviceStreamingProgress::_internal_set_progress(float value) {
  _has_bits_[0] |= 0x00000002u;
  progress_ = value;
}
inline void CMsgRemoteDeviceStreamingProgress::set_progress(float value) {
  _internal_set_progress(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingProgress.progress)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamingResponse

// required uint32 request_id = 1;
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CMsgRemoteDeviceStreamingResponse::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceStreamingResponse::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceStreamingResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.request_id)
}

// required .ERemoteDeviceStreamingResult result = 2 [default = k_ERemoteDeviceStreamingSuccess];
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_result() const {
  return _internal_has_result();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ERemoteDeviceStreamingResult CMsgRemoteDeviceStreamingResponse::_internal_result() const {
  return static_cast< ::ERemoteDeviceStreamingResult >(result_);
}
inline ::ERemoteDeviceStreamingResult CMsgRemoteDeviceStreamingResponse::result() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.result)
  return _internal_result();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_result(::ERemoteDeviceStreamingResult value) {
  assert(::ERemoteDeviceStreamingResult_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  result_ = value;
}
inline void CMsgRemoteDeviceStreamingResponse::set_result(::ERemoteDeviceStreamingResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.result)
}

// optional uint32 port = 3;
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_port() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_port() const {
  return _internal_has_port();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_port() {
  port_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline uint32_t CMsgRemoteDeviceStreamingResponse::_internal_port() const {
  return port_;
}
inline uint32_t CMsgRemoteDeviceStreamingResponse::port() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.port)
  return _internal_port();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_port(uint32_t value) {
  _has_bits_[0] |= 0x00000020u;
  port_ = value;
}
inline void CMsgRemoteDeviceStreamingResponse::set_port(uint32_t value) {
  _internal_set_port(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.port)
}

// optional bytes encrypted_session_key = 4;
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_encrypted_session_key() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_encrypted_session_key() const {
  return _internal_has_encrypted_session_key();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_encrypted_session_key() {
  encrypted_session_key_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::encrypted_session_key() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
  return _internal_encrypted_session_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingResponse::set_encrypted_session_key(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 encrypted_session_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
}
inline std::string* CMsgRemoteDeviceStreamingResponse::mutable_encrypted_session_key() {
  std::string* _s = _internal_mutable_encrypted_session_key();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::_internal_encrypted_session_key() const {
  return encrypted_session_key_.Get();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_encrypted_session_key(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  encrypted_session_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::_internal_mutable_encrypted_session_key() {
  _has_bits_[0] |= 0x00000001u;
  return encrypted_session_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::release_encrypted_session_key() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
  if (!_internal_has_encrypted_session_key()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = encrypted_session_key_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_session_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_session_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingResponse::set_allocated_encrypted_session_key(std::string* encrypted_session_key) {
  if (encrypted_session_key != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  encrypted_session_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), encrypted_session_key,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (encrypted_session_key_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    encrypted_session_key_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingResponse.encrypted_session_key)
}

// optional .EStreamTransport transport = 6 [default = k_EStreamTransportUDP];
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_transport() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_transport() const {
  return _internal_has_transport();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_transport() {
  transport_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::EStreamTransport CMsgRemoteDeviceStreamingResponse::_internal_transport() const {
  return static_cast< ::EStreamTransport >(transport_);
}
inline ::EStreamTransport CMsgRemoteDeviceStreamingResponse::transport() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.transport)
  return _internal_transport();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_transport(::EStreamTransport value) {
  assert(::EStreamTransport_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  transport_ = value;
}
inline void CMsgRemoteDeviceStreamingResponse::set_transport(::EStreamTransport value) {
  _internal_set_transport(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.transport)
}

// optional string relay_server = 7;
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_relay_server() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_relay_server() const {
  return _internal_has_relay_server();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_relay_server() {
  relay_server_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::relay_server() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.relay_server)
  return _internal_relay_server();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingResponse::set_relay_server(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 relay_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.relay_server)
}
inline std::string* CMsgRemoteDeviceStreamingResponse::mutable_relay_server() {
  std::string* _s = _internal_mutable_relay_server();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingResponse.relay_server)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::_internal_relay_server() const {
  return relay_server_.Get();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_relay_server(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  relay_server_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::_internal_mutable_relay_server() {
  _has_bits_[0] |= 0x00000002u;
  return relay_server_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::release_relay_server() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingResponse.relay_server)
  if (!_internal_has_relay_server()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = relay_server_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (relay_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    relay_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingResponse::set_allocated_relay_server(std::string* relay_server) {
  if (relay_server != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  relay_server_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), relay_server,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (relay_server_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    relay_server_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingResponse.relay_server)
}

// optional string cert = 8;
inline bool CMsgRemoteDeviceStreamingResponse::_internal_has_cert() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamingResponse::has_cert() const {
  return _internal_has_cert();
}
inline void CMsgRemoteDeviceStreamingResponse::clear_cert() {
  cert_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::cert() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamingResponse.cert)
  return _internal_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamingResponse::set_cert(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamingResponse.cert)
}
inline std::string* CMsgRemoteDeviceStreamingResponse::mutable_cert() {
  std::string* _s = _internal_mutable_cert();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamingResponse.cert)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamingResponse::_internal_cert() const {
  return cert_.Get();
}
inline void CMsgRemoteDeviceStreamingResponse::_internal_set_cert(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::_internal_mutable_cert() {
  _has_bits_[0] |= 0x00000004u;
  return cert_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamingResponse::release_cert() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamingResponse.cert)
  if (!_internal_has_cert()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = cert_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cert_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamingResponse::set_allocated_cert(std::string* cert) {
  if (cert != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cert_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cert,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cert_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cert_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamingResponse.cert)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceProofRequest

// required bytes challenge = 1;
inline bool CMsgRemoteDeviceProofRequest::_internal_has_challenge() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofRequest::has_challenge() const {
  return _internal_has_challenge();
}
inline void CMsgRemoteDeviceProofRequest::clear_challenge() {
  challenge_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceProofRequest::challenge() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofRequest.challenge)
  return _internal_challenge();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceProofRequest::set_challenge(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 challenge_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofRequest.challenge)
}
inline std::string* CMsgRemoteDeviceProofRequest::mutable_challenge() {
  std::string* _s = _internal_mutable_challenge();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceProofRequest.challenge)
  return _s;
}
inline const std::string& CMsgRemoteDeviceProofRequest::_internal_challenge() const {
  return challenge_.Get();
}
inline void CMsgRemoteDeviceProofRequest::_internal_set_challenge(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  challenge_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceProofRequest::_internal_mutable_challenge() {
  _has_bits_[0] |= 0x00000001u;
  return challenge_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceProofRequest::release_challenge() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceProofRequest.challenge)
  if (!_internal_has_challenge()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = challenge_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (challenge_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    challenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceProofRequest::set_allocated_challenge(std::string* challenge) {
  if (challenge != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  challenge_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), challenge,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (challenge_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    challenge_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceProofRequest.challenge)
}

// optional uint32 request_id = 2;
inline bool CMsgRemoteDeviceProofRequest::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofRequest::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceProofRequest::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgRemoteDeviceProofRequest::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceProofRequest::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofRequest.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceProofRequest::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceProofRequest::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofRequest.request_id)
}

// optional bool update_secret = 3;
inline bool CMsgRemoteDeviceProofRequest::_internal_has_update_secret() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofRequest::has_update_secret() const {
  return _internal_has_update_secret();
}
inline void CMsgRemoteDeviceProofRequest::clear_update_secret() {
  update_secret_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgRemoteDeviceProofRequest::_internal_update_secret() const {
  return update_secret_;
}
inline bool CMsgRemoteDeviceProofRequest::update_secret() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofRequest.update_secret)
  return _internal_update_secret();
}
inline void CMsgRemoteDeviceProofRequest::_internal_set_update_secret(bool value) {
  _has_bits_[0] |= 0x00000004u;
  update_secret_ = value;
}
inline void CMsgRemoteDeviceProofRequest::set_update_secret(bool value) {
  _internal_set_update_secret(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofRequest.update_secret)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceProofResponse

// required bytes response = 1;
inline bool CMsgRemoteDeviceProofResponse::_internal_has_response() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofResponse::has_response() const {
  return _internal_has_response();
}
inline void CMsgRemoteDeviceProofResponse::clear_response() {
  response_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceProofResponse::response() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofResponse.response)
  return _internal_response();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceProofResponse::set_response(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 response_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofResponse.response)
}
inline std::string* CMsgRemoteDeviceProofResponse::mutable_response() {
  std::string* _s = _internal_mutable_response();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceProofResponse.response)
  return _s;
}
inline const std::string& CMsgRemoteDeviceProofResponse::_internal_response() const {
  return response_.Get();
}
inline void CMsgRemoteDeviceProofResponse::_internal_set_response(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  response_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceProofResponse::_internal_mutable_response() {
  _has_bits_[0] |= 0x00000001u;
  return response_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceProofResponse::release_response() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceProofResponse.response)
  if (!_internal_has_response()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = response_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    response_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceProofResponse::set_allocated_response(std::string* response) {
  if (response != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  response_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), response,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (response_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    response_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceProofResponse.response)
}

// optional uint32 request_id = 2;
inline bool CMsgRemoteDeviceProofResponse::_internal_has_request_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofResponse::has_request_id() const {
  return _internal_has_request_id();
}
inline void CMsgRemoteDeviceProofResponse::clear_request_id() {
  request_id_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CMsgRemoteDeviceProofResponse::_internal_request_id() const {
  return request_id_;
}
inline uint32_t CMsgRemoteDeviceProofResponse::request_id() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofResponse.request_id)
  return _internal_request_id();
}
inline void CMsgRemoteDeviceProofResponse::_internal_set_request_id(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  request_id_ = value;
}
inline void CMsgRemoteDeviceProofResponse::set_request_id(uint32_t value) {
  _internal_set_request_id(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofResponse.request_id)
}

// optional bool updated_secret = 3;
inline bool CMsgRemoteDeviceProofResponse::_internal_has_updated_secret() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceProofResponse::has_updated_secret() const {
  return _internal_has_updated_secret();
}
inline void CMsgRemoteDeviceProofResponse::clear_updated_secret() {
  updated_secret_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CMsgRemoteDeviceProofResponse::_internal_updated_secret() const {
  return updated_secret_;
}
inline bool CMsgRemoteDeviceProofResponse::updated_secret() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceProofResponse.updated_secret)
  return _internal_updated_secret();
}
inline void CMsgRemoteDeviceProofResponse::_internal_set_updated_secret(bool value) {
  _has_bits_[0] |= 0x00000004u;
  updated_secret_ = value;
}
inline void CMsgRemoteDeviceProofResponse::set_updated_secret(bool value) {
  _internal_set_updated_secret(value);
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceProofResponse.updated_secret)
}

// -------------------------------------------------------------------

// CMsgRemoteDeviceStreamTransportSignal

// optional bytes token = 1;
inline bool CMsgRemoteDeviceStreamTransportSignal::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamTransportSignal::has_token() const {
  return _internal_has_token();
}
inline void CMsgRemoteDeviceStreamTransportSignal::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CMsgRemoteDeviceStreamTransportSignal::token() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamTransportSignal.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamTransportSignal::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamTransportSignal.token)
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamTransportSignal.token)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamTransportSignal::_internal_token() const {
  return token_.Get();
}
inline void CMsgRemoteDeviceStreamTransportSignal::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::release_token() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamTransportSignal.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamTransportSignal::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamTransportSignal.token)
}

// optional bytes payload = 2;
inline bool CMsgRemoteDeviceStreamTransportSignal::_internal_has_payload() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CMsgRemoteDeviceStreamTransportSignal::has_payload() const {
  return _internal_has_payload();
}
inline void CMsgRemoteDeviceStreamTransportSignal::clear_payload() {
  payload_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CMsgRemoteDeviceStreamTransportSignal::payload() const {
  // @@protoc_insertion_point(field_get:CMsgRemoteDeviceStreamTransportSignal.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CMsgRemoteDeviceStreamTransportSignal::set_payload(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CMsgRemoteDeviceStreamTransportSignal.payload)
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:CMsgRemoteDeviceStreamTransportSignal.payload)
  return _s;
}
inline const std::string& CMsgRemoteDeviceStreamTransportSignal::_internal_payload() const {
  return payload_.Get();
}
inline void CMsgRemoteDeviceStreamTransportSignal::_internal_set_payload(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::_internal_mutable_payload() {
  _has_bits_[0] |= 0x00000002u;
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CMsgRemoteDeviceStreamTransportSignal::release_payload() {
  // @@protoc_insertion_point(field_release:CMsgRemoteDeviceStreamTransportSignal.payload)
  if (!_internal_has_payload()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = payload_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CMsgRemoteDeviceStreamTransportSignal::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (payload_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    payload_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CMsgRemoteDeviceStreamTransportSignal.payload)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage>() {
  return ::CMsgRemoteDeviceAuthorizationRequest_EKeyEscrowUsage_descriptor();
}
template <> struct is_proto_enum< ::ERemoteClientBroadcastMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ERemoteClientBroadcastMsg>() {
  return ::ERemoteClientBroadcastMsg_descriptor();
}
template <> struct is_proto_enum< ::ERemoteClientService> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ERemoteClientService>() {
  return ::ERemoteClientService_descriptor();
}
template <> struct is_proto_enum< ::ERemoteDeviceAuthorizationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ERemoteDeviceAuthorizationResult>() {
  return ::ERemoteDeviceAuthorizationResult_descriptor();
}
template <> struct is_proto_enum< ::EStreamDeviceFormFactor> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamDeviceFormFactor>() {
  return ::EStreamDeviceFormFactor_descriptor();
}
template <> struct is_proto_enum< ::EStreamTransport> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamTransport>() {
  return ::EStreamTransport_descriptor();
}
template <> struct is_proto_enum< ::EStreamInterface> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamInterface>() {
  return ::EStreamInterface_descriptor();
}
template <> struct is_proto_enum< ::ERemoteDeviceStreamingResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ERemoteDeviceStreamingResult>() {
  return ::ERemoteDeviceStreamingResult_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteclient_5fdiscovery_2eproto
