// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_contentsystem.steamclient.proto

#include "steammessages_contentsystem.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CContentServerDirectory_GetServersForSteamPipe_Request::CContentServerDirectory_GetServersForSteamPipe_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_override_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ipv6_public_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , cell_id_(0u)
  , launcher_type_(0)
  , max_servers_(20u){}
struct CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetServersForSteamPipe_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetServersForSteamPipe_RequestDefaultTypeInternal _CContentServerDirectory_GetServersForSteamPipe_Request_default_instance_;
constexpr CContentServerDirectory_ServerInfo::CContentServerDirectory_ServerInfo(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : allowed_app_ids_()
  , type_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , host_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , vhost_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , proxy_request_path_template_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , https_support_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , source_id_(0)
  , cell_id_(0)
  , load_(0)
  , weighted_load_(0)
  , num_entries_in_client_list_(0)
  , steam_china_only_(false)
  , use_as_proxy_(false)
  , preferred_server_(false){}
struct CContentServerDirectory_ServerInfoDefaultTypeInternal {
  constexpr CContentServerDirectory_ServerInfoDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_ServerInfoDefaultTypeInternal() {}
  union {
    CContentServerDirectory_ServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_ServerInfoDefaultTypeInternal _CContentServerDirectory_ServerInfo_default_instance_;
constexpr CContentServerDirectory_GetServersForSteamPipe_Response::CContentServerDirectory_GetServersForSteamPipe_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : servers_(){}
struct CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetServersForSteamPipe_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetServersForSteamPipe_ResponseDefaultTypeInternal _CContentServerDirectory_GetServersForSteamPipe_Response_default_instance_;
constexpr CContentServerDirectory_GetDepotPatchInfo_Request::CContentServerDirectory_GetDepotPatchInfo_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , depotid_(0u)
  , source_manifestid_(uint64_t{0u})
  , target_manifestid_(uint64_t{0u}){}
struct CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetDepotPatchInfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetDepotPatchInfo_RequestDefaultTypeInternal _CContentServerDirectory_GetDepotPatchInfo_Request_default_instance_;
constexpr CContentServerDirectory_GetDepotPatchInfo_Response::CContentServerDirectory_GetDepotPatchInfo_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : patch_size_(uint64_t{0u})
  , patched_chunks_size_(uint64_t{0u})
  , is_available_(false){}
struct CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetDepotPatchInfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetDepotPatchInfo_ResponseDefaultTypeInternal _CContentServerDirectory_GetDepotPatchInfo_Response_default_instance_;
constexpr CContentServerDirectory_GetClientUpdateHosts_Request::CContentServerDirectory_GetClientUpdateHosts_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : cached_signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetClientUpdateHosts_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetClientUpdateHosts_RequestDefaultTypeInternal _CContentServerDirectory_GetClientUpdateHosts_Request_default_instance_;
constexpr CContentServerDirectory_GetClientUpdateHosts_Response::CContentServerDirectory_GetClientUpdateHosts_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : hosts_kv_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_country_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , valid_until_time_(uint64_t{0u}){}
struct CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetClientUpdateHosts_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetClientUpdateHosts_ResponseDefaultTypeInternal _CContentServerDirectory_GetClientUpdateHosts_Response_default_instance_;
constexpr CContentServerDirectory_GetManifestRequestCode_Request::CContentServerDirectory_GetManifestRequestCode_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : app_branch_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , branch_password_hash_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , app_id_(0u)
  , depot_id_(0u)
  , manifest_id_(uint64_t{0u}){}
struct CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetManifestRequestCode_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetManifestRequestCode_RequestDefaultTypeInternal _CContentServerDirectory_GetManifestRequestCode_Request_default_instance_;
constexpr CContentServerDirectory_GetManifestRequestCode_Response::CContentServerDirectory_GetManifestRequestCode_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : manifest_request_code_(uint64_t{0u}){}
struct CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetManifestRequestCode_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetManifestRequestCode_ResponseDefaultTypeInternal _CContentServerDirectory_GetManifestRequestCode_Response_default_instance_;
constexpr CContentServerDirectory_GetCDNAuthToken_Request::CContentServerDirectory_GetCDNAuthToken_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : host_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , depot_id_(0u)
  , app_id_(0u){}
struct CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetCDNAuthToken_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetCDNAuthToken_RequestDefaultTypeInternal _CContentServerDirectory_GetCDNAuthToken_Request_default_instance_;
constexpr CContentServerDirectory_GetCDNAuthToken_Response::CContentServerDirectory_GetCDNAuthToken_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , expiration_time_(0u){}
struct CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetCDNAuthToken_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetCDNAuthToken_ResponseDefaultTypeInternal _CContentServerDirectory_GetCDNAuthToken_Response_default_instance_;
constexpr CContentServerDirectory_RequestPeerContentServer_Request::CContentServerDirectory_RequestPeerContentServer_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : remote_client_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , server_remote_client_id_(uint64_t{0u})
  , app_id_(0u)
  , current_build_id_(0u){}
struct CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_RequestPeerContentServer_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_RequestPeerContentServer_RequestDefaultTypeInternal _CContentServerDirectory_RequestPeerContentServer_Request_default_instance_;
constexpr CContentServerDirectory_RequestPeerContentServer_Response::CContentServerDirectory_RequestPeerContentServer_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : installed_depots_()
  , server_port_(0u){}
struct CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_RequestPeerContentServer_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_RequestPeerContentServer_ResponseDefaultTypeInternal _CContentServerDirectory_RequestPeerContentServer_Response_default_instance_;
constexpr CContentServerDirectory_GetPeerContentInfo_Request::CContentServerDirectory_GetPeerContentInfo_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : remote_client_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , server_remote_client_id_(uint64_t{0u}){}
struct CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal {
  constexpr CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetPeerContentInfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetPeerContentInfo_RequestDefaultTypeInternal _CContentServerDirectory_GetPeerContentInfo_Request_default_instance_;
constexpr CContentServerDirectory_GetPeerContentInfo_Response::CContentServerDirectory_GetPeerContentInfo_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appids_()
  , ip_public_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal {
  constexpr CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal() {}
  union {
    CContentServerDirectory_GetPeerContentInfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CContentServerDirectory_GetPeerContentInfo_ResponseDefaultTypeInternal _CContentServerDirectory_GetPeerContentInfo_Response_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[15];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto = nullptr;
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto[1];

const uint32_t TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, cell_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, max_servers_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, ip_override_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, launcher_type_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Request, ipv6_public_),
  2,
  4,
  0,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, type_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, source_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, cell_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, load_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, weighted_load_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, num_entries_in_client_list_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, steam_china_only_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, host_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, vhost_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, use_as_proxy_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, proxy_request_path_template_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, https_support_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, allowed_app_ids_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_ServerInfo, preferred_server_),
  0,
  5,
  6,
  7,
  8,
  9,
  10,
  1,
  2,
  11,
  3,
  4,
  ~0u,
  12,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetServersForSteamPipe_Response, servers_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, appid_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, depotid_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, source_manifestid_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Request, target_manifestid_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Response, is_available_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Response, patch_size_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetDepotPatchInfo_Response, patched_chunks_size_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Request, cached_signature_),
  0,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Response, hosts_kv_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Response, valid_until_time_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetClientUpdateHosts_Response, ip_country_),
  0,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, app_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, depot_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, manifest_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, app_branch_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Request, branch_password_hash_),
  2,
  3,
  4,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetManifestRequestCode_Response, manifest_request_code_),
  0,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Request, depot_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Request, host_name_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Request, app_id_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Response, token_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetCDNAuthToken_Response, expiration_time_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, remote_client_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, server_remote_client_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, app_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Request, current_build_id_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Response, server_port_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_RequestPeerContentServer_Response, installed_depots_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Request, remote_client_id_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Request, server_remote_client_id_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Response, appids_),
  PROTOBUF_FIELD_OFFSET(::CContentServerDirectory_GetPeerContentInfo_Response, ip_public_),
  ~0u,
  0,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::CContentServerDirectory_GetServersForSteamPipe_Request)},
  { 16, 36, -1, sizeof(::CContentServerDirectory_ServerInfo)},
  { 50, -1, -1, sizeof(::CContentServerDirectory_GetServersForSteamPipe_Response)},
  { 57, 67, -1, sizeof(::CContentServerDirectory_GetDepotPatchInfo_Request)},
  { 71, 80, -1, sizeof(::CContentServerDirectory_GetDepotPatchInfo_Response)},
  { 83, 90, -1, sizeof(::CContentServerDirectory_GetClientUpdateHosts_Request)},
  { 91, 100, -1, sizeof(::CContentServerDirectory_GetClientUpdateHosts_Response)},
  { 103, 114, -1, sizeof(::CContentServerDirectory_GetManifestRequestCode_Request)},
  { 119, 126, -1, sizeof(::CContentServerDirectory_GetManifestRequestCode_Response)},
  { 127, 136, -1, sizeof(::CContentServerDirectory_GetCDNAuthToken_Request)},
  { 139, 147, -1, sizeof(::CContentServerDirectory_GetCDNAuthToken_Response)},
  { 149, 160, -1, sizeof(::CContentServerDirectory_RequestPeerContentServer_Request)},
  { 165, 173, -1, sizeof(::CContentServerDirectory_RequestPeerContentServer_Response)},
  { 175, 184, -1, sizeof(::CContentServerDirectory_GetPeerContentInfo_Request)},
  { 187, 195, -1, sizeof(::CContentServerDirectory_GetPeerContentInfo_Response)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetServersForSteamPipe_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_ServerInfo_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetServersForSteamPipe_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetDepotPatchInfo_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetDepotPatchInfo_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetClientUpdateHosts_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetClientUpdateHosts_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetManifestRequestCode_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetManifestRequestCode_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetCDNAuthToken_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetCDNAuthToken_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_RequestPeerContentServer_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_RequestPeerContentServer_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetPeerContentInfo_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CContentServerDirectory_GetPeerContentInfo_Response_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fcontentsystem_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n-steammessages_contentsystem.steamclien"
  "t.proto\032\030steammessages_base.proto\032,steam"
  "messages_unified_base.steamclient.proto\""
  "\265\002\n6CContentServerDirectory_GetServersFo"
  "rSteamPipe_Request\022#\n\007cell_id\030\001 \001(\rB\022\202\265\030"
  "\016client Cell ID\0229\n\013max_servers\030\002 \001(\r:\00220"
  "B \202\265\030\034max servers in response list\022*\n\013ip"
  "_override\030\003 \001(\tB\025\202\265\030\021client IP address\022+"
  "\n\rlauncher_type\030\004 \001(\005:\0010B\021\202\265\030\rlauncher t"
  "ype\022B\n\013ipv6_public\030\005 \001(\tB-\202\265\030)client pub"
  "lic ipv6 address if it knows it\"\333\002\n\"CCon"
  "tentServerDirectory_ServerInfo\022\014\n\004type\030\001"
  " \001(\t\022\021\n\tsource_id\030\002 \001(\005\022\017\n\007cell_id\030\003 \001(\005"
  "\022\014\n\004load\030\004 \001(\005\022\025\n\rweighted_load\030\005 \001(\002\022\"\n"
  "\032num_entries_in_client_list\030\006 \001(\005\022\030\n\020ste"
  "am_china_only\030\007 \001(\010\022\014\n\004host\030\010 \001(\t\022\r\n\005vho"
  "st\030\t \001(\t\022\024\n\014use_as_proxy\030\n \001(\010\022#\n\033proxy_"
  "request_path_template\030\013 \001(\t\022\025\n\rhttps_sup"
  "port\030\014 \001(\t\022\027\n\017allowed_app_ids\030\r \003(\r\022\030\n\020p"
  "referred_server\030\016 \001(\010\"o\n7CContentServerD"
  "irectory_GetServersForSteamPipe_Response"
  "\0224\n\007servers\030\001 \003(\0132#.CContentServerDirect"
  "ory_ServerInfo\"\211\001\n1CContentServerDirecto"
  "ry_GetDepotPatchInfo_Request\022\r\n\005appid\030\001 "
  "\001(\r\022\017\n\007depotid\030\002 \001(\r\022\031\n\021source_manifesti"
  "d\030\003 \001(\004\022\031\n\021target_manifestid\030\004 \001(\004\"{\n2CC"
  "ontentServerDirectory_GetDepotPatchInfo_"
  "Response\022\024\n\014is_available\030\001 \001(\010\022\022\n\npatch_"
  "size\030\002 \001(\004\022\033\n\023patched_chunks_size\030\003 \001(\004\""
  "P\n4CContentServerDirectory_GetClientUpda"
  "teHosts_Request\022\030\n\020cached_signature\030\001 \001("
  "\t\"w\n5CContentServerDirectory_GetClientUp"
  "dateHosts_Response\022\020\n\010hosts_kv\030\001 \001(\t\022\030\n\020"
  "valid_until_time\030\002 \001(\004\022\022\n\nip_country\030\003 \001"
  "(\t\"\241\001\n6CContentServerDirectory_GetManife"
  "stRequestCode_Request\022\016\n\006app_id\030\001 \001(\r\022\020\n"
  "\010depot_id\030\002 \001(\r\022\023\n\013manifest_id\030\003 \001(\004\022\022\n\n"
  "app_branch\030\004 \001(\t\022\034\n\024branch_password_hash"
  "\030\005 \001(\t\"X\n7CContentServerDirectory_GetMan"
  "ifestRequestCode_Response\022\035\n\025manifest_re"
  "quest_code\030\001 \001(\004\"f\n/CContentServerDirect"
  "ory_GetCDNAuthToken_Request\022\020\n\010depot_id\030"
  "\001 \001(\r\022\021\n\thost_name\030\002 \001(\t\022\016\n\006app_id\030\003 \001(\r"
  "\"Z\n0CContentServerDirectory_GetCDNAuthTo"
  "ken_Response\022\r\n\005token\030\001 \001(\t\022\027\n\017expiratio"
  "n_time\030\002 \001(\r\"\260\001\n8CContentServerDirectory"
  "_RequestPeerContentServer_Request\022\030\n\020rem"
  "ote_client_id\030\001 \001(\004\022\017\n\007steamid\030\002 \001(\004\022\037\n\027"
  "server_remote_client_id\030\003 \001(\004\022\016\n\006app_id\030"
  "\004 \001(\r\022\030\n\020current_build_id\030\005 \001(\r\"j\n9CCont"
  "entServerDirectory_RequestPeerContentSer"
  "ver_Response\022\023\n\013server_port\030\001 \001(\r\022\030\n\020ins"
  "talled_depots\030\002 \003(\r\"\200\001\n2CContentServerDi"
  "rectory_GetPeerContentInfo_Request\022\030\n\020re"
  "mote_client_id\030\001 \001(\004\022\017\n\007steamid\030\002 \001(\004\022\037\n"
  "\027server_remote_client_id\030\003 \001(\004\"X\n3CConte"
  "ntServerDirectory_GetPeerContentInfo_Res"
  "ponse\022\016\n\006appids\030\001 \003(\r\022\021\n\tip_public\030\002 \001(\t"
  "2\355\007\n\026ContentServerDirectory\022\213\001\n\026GetServe"
  "rsForSteamPipe\0227.CContentServerDirectory"
  "_GetServersForSteamPipe_Request\0328.CConte"
  "ntServerDirectory_GetServersForSteamPipe"
  "_Response\022|\n\021GetDepotPatchInfo\0222.CConten"
  "tServerDirectory_GetDepotPatchInfo_Reque"
  "st\0323.CContentServerDirectory_GetDepotPat"
  "chInfo_Response\022\205\001\n\024GetClientUpdateHosts"
  "\0225.CContentServerDirectory_GetClientUpda"
  "teHosts_Request\0326.CContentServerDirector"
  "y_GetClientUpdateHosts_Response\022\213\001\n\026GetM"
  "anifestRequestCode\0227.CContentServerDirec"
  "tory_GetManifestRequestCode_Request\0328.CC"
  "ontentServerDirectory_GetManifestRequest"
  "Code_Response\022v\n\017GetCDNAuthToken\0220.CCont"
  "entServerDirectory_GetCDNAuthToken_Reque"
  "st\0321.CContentServerDirectory_GetCDNAuthT"
  "oken_Response\022\221\001\n\030RequestPeerContentServ"
  "er\0229.CContentServerDirectory_RequestPeer"
  "ContentServer_Request\032:.CContentServerDi"
  "rectory_RequestPeerContentServer_Respons"
  "e\022\177\n\022GetPeerContentInfo\0223.CContentServer"
  "Directory_GetPeerContentInfo_Request\0324.C"
  "ContentServerDirectory_GetPeerContentInf"
  "o_Response\032$\202\265\030 Content Server and CDN d"
  "irectoryB\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_deps[2] = {
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto = {
  false, false, 3333, descriptor_table_protodef_steammessages_5fcontentsystem_2esteamclient_2eproto, "steammessages_contentsystem.steamclient.proto", 
  &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once, descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_deps, 2, 15,
  schemas, file_default_instances, TableStruct_steammessages_5fcontentsystem_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter() {
  return &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fcontentsystem_2esteamclient_2eproto(&descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto);

// ===================================================================

class CContentServerDirectory_GetServersForSteamPipe_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetServersForSteamPipe_Request>()._has_bits_);
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_max_servers(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_ip_override(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_launcher_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ipv6_public(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CContentServerDirectory_GetServersForSteamPipe_Request::CContentServerDirectory_GetServersForSteamPipe_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetServersForSteamPipe_Request)
}
CContentServerDirectory_GetServersForSteamPipe_Request::CContentServerDirectory_GetServersForSteamPipe_Request(const CContentServerDirectory_GetServersForSteamPipe_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_override_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_override()) {
    ip_override_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_override(), 
      GetArenaForAllocation());
  }
  ipv6_public_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ipv6_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ipv6_public()) {
    ipv6_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ipv6_public(), 
      GetArenaForAllocation());
  }
  ::memcpy(&cell_id_, &from.cell_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&max_servers_) -
    reinterpret_cast<char*>(&cell_id_)) + sizeof(max_servers_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetServersForSteamPipe_Request)
}

inline void CContentServerDirectory_GetServersForSteamPipe_Request::SharedCtor() {
ip_override_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_override_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ipv6_public_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ipv6_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&cell_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&launcher_type_) -
    reinterpret_cast<char*>(&cell_id_)) + sizeof(launcher_type_));
max_servers_ = 20u;
}

CContentServerDirectory_GetServersForSteamPipe_Request::~CContentServerDirectory_GetServersForSteamPipe_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetServersForSteamPipe_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetServersForSteamPipe_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_override_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ipv6_public_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetServersForSteamPipe_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetServersForSteamPipe_Request* _this = reinterpret_cast< CContentServerDirectory_GetServersForSteamPipe_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetServersForSteamPipe_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetServersForSteamPipe_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetServersForSteamPipe_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetServersForSteamPipe_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ip_override_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ipv6_public_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&cell_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&launcher_type_) -
        reinterpret_cast<char*>(&cell_id_)) + sizeof(launcher_type_));
    max_servers_ = 20u;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetServersForSteamPipe_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 cell_id = 1 [(.description) = "client Cell ID"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cell_id(&has_bits);
          cell_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_servers = 2 [default = 20, (.description) = "max servers in response list"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_max_servers(&has_bits);
          max_servers_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ip_override = 3 [(.description) = "client IP address"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_override();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetServersForSteamPipe_Request.ip_override");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 launcher_type = 4 [default = 0, (.description) = "launcher type"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_launcher_type(&has_bits);
          launcher_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ipv6_public = 5 [(.description) = "client public ipv6 address if it knows it"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_ipv6_public();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetServersForSteamPipe_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetServersForSteamPipe_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 cell_id = 1 [(.description) = "client Cell ID"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_cell_id(), target);
  }

  // optional uint32 max_servers = 2 [default = 20, (.description) = "max servers in response list"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_max_servers(), target);
  }

  // optional string ip_override = 3 [(.description) = "client IP address"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_override().data(), static_cast<int>(this->_internal_ip_override().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetServersForSteamPipe_Request.ip_override");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ip_override(), target);
  }

  // optional int32 launcher_type = 4 [default = 0, (.description) = "launcher type"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_launcher_type(), target);
  }

  // optional string ipv6_public = 5 [(.description) = "client public ipv6 address if it knows it"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ipv6_public().data(), static_cast<int>(this->_internal_ipv6_public().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetServersForSteamPipe_Request.ipv6_public");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_ipv6_public(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetServersForSteamPipe_Request)
  return target;
}

size_t CContentServerDirectory_GetServersForSteamPipe_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetServersForSteamPipe_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string ip_override = 3 [(.description) = "client IP address"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip_override());
    }

    // optional string ipv6_public = 5 [(.description) = "client public ipv6 address if it knows it"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ipv6_public());
    }

    // optional uint32 cell_id = 1 [(.description) = "client Cell ID"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_cell_id());
    }

    // optional int32 launcher_type = 4 [default = 0, (.description) = "launcher type"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_launcher_type());
    }

    // optional uint32 max_servers = 2 [default = 20, (.description) = "max servers in response list"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_max_servers());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetServersForSteamPipe_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetServersForSteamPipe_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetServersForSteamPipe_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetServersForSteamPipe_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetServersForSteamPipe_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetServersForSteamPipe_Request &>(from));
}


void CContentServerDirectory_GetServersForSteamPipe_Request::MergeFrom(const CContentServerDirectory_GetServersForSteamPipe_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetServersForSteamPipe_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip_override(from._internal_ip_override());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ipv6_public(from._internal_ipv6_public());
    }
    if (cached_has_bits & 0x00000004u) {
      cell_id_ = from.cell_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      launcher_type_ = from.launcher_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      max_servers_ = from.max_servers_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetServersForSteamPipe_Request::CopyFrom(const CContentServerDirectory_GetServersForSteamPipe_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetServersForSteamPipe_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetServersForSteamPipe_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetServersForSteamPipe_Request::InternalSwap(CContentServerDirectory_GetServersForSteamPipe_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_override_, lhs_arena,
      &other->ip_override_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ipv6_public_, lhs_arena,
      &other->ipv6_public_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetServersForSteamPipe_Request, launcher_type_)
      + sizeof(CContentServerDirectory_GetServersForSteamPipe_Request::launcher_type_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetServersForSteamPipe_Request, cell_id_)>(
          reinterpret_cast<char*>(&cell_id_),
          reinterpret_cast<char*>(&other->cell_id_));
  swap(max_servers_, other->max_servers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetServersForSteamPipe_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[0]);
}

// ===================================================================

class CContentServerDirectory_ServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_ServerInfo>()._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_source_id(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cell_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_load(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_weighted_load(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_num_entries_in_client_list(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_steam_china_only(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_host(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_vhost(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_use_as_proxy(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_proxy_request_path_template(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_https_support(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_preferred_server(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

CContentServerDirectory_ServerInfo::CContentServerDirectory_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  allowed_app_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_ServerInfo)
}
CContentServerDirectory_ServerInfo::CContentServerDirectory_ServerInfo(const CContentServerDirectory_ServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      allowed_app_ids_(from.allowed_app_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_type()) {
    type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_type(), 
      GetArenaForAllocation());
  }
  host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host()) {
    host_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_host(), 
      GetArenaForAllocation());
  }
  vhost_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    vhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_vhost()) {
    vhost_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_vhost(), 
      GetArenaForAllocation());
  }
  proxy_request_path_template_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    proxy_request_path_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_proxy_request_path_template()) {
    proxy_request_path_template_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_proxy_request_path_template(), 
      GetArenaForAllocation());
  }
  https_support_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    https_support_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_https_support()) {
    https_support_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_https_support(), 
      GetArenaForAllocation());
  }
  ::memcpy(&source_id_, &from.source_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&preferred_server_) -
    reinterpret_cast<char*>(&source_id_)) + sizeof(preferred_server_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_ServerInfo)
}

inline void CContentServerDirectory_ServerInfo::SharedCtor() {
type_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  type_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
host_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  host_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
vhost_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  vhost_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
proxy_request_path_template_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  proxy_request_path_template_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
https_support_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  https_support_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&source_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&preferred_server_) -
    reinterpret_cast<char*>(&source_id_)) + sizeof(preferred_server_));
}

CContentServerDirectory_ServerInfo::~CContentServerDirectory_ServerInfo() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_ServerInfo)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_ServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  type_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  host_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  vhost_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  proxy_request_path_template_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  https_support_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_ServerInfo::ArenaDtor(void* object) {
  CContentServerDirectory_ServerInfo* _this = reinterpret_cast< CContentServerDirectory_ServerInfo* >(object);
  (void)_this;
}
void CContentServerDirectory_ServerInfo::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_ServerInfo::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_ServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_ServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowed_app_ids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      type_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      host_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      vhost_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      proxy_request_path_template_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      https_support_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&source_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&load_) -
        reinterpret_cast<char*>(&source_id_)) + sizeof(load_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&weighted_load_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&preferred_server_) -
        reinterpret_cast<char*>(&weighted_load_)) + sizeof(preferred_server_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_ServerInfo::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_type();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_ServerInfo.type");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 source_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_source_id(&has_bits);
          source_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cell_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_cell_id(&has_bits);
          cell_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 load = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_load(&has_bits);
          load_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float weighted_load = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_weighted_load(&has_bits);
          weighted_load_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries_in_client_list = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_entries_in_client_list(&has_bits);
          num_entries_in_client_list_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool steam_china_only = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_steam_china_only(&has_bits);
          steam_china_only_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string host = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_host();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_ServerInfo.host");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string vhost = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          auto str = _internal_mutable_vhost();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_ServerInfo.vhost");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool use_as_proxy = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_use_as_proxy(&has_bits);
          use_as_proxy_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string proxy_request_path_template = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          auto str = _internal_mutable_proxy_request_path_template();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_ServerInfo.proxy_request_path_template");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string https_support = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          auto str = _internal_mutable_https_support();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_ServerInfo.https_support");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 allowed_app_ids = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_allowed_app_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<104>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_allowed_app_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool preferred_server = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_preferred_server(&has_bits);
          preferred_server_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_ServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_ServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string type = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_type().data(), static_cast<int>(this->_internal_type().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_ServerInfo.type");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_type(), target);
  }

  // optional int32 source_id = 2;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_source_id(), target);
  }

  // optional int32 cell_id = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_cell_id(), target);
  }

  // optional int32 load = 4;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_load(), target);
  }

  // optional float weighted_load = 5;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(5, this->_internal_weighted_load(), target);
  }

  // optional int32 num_entries_in_client_list = 6;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_num_entries_in_client_list(), target);
  }

  // optional bool steam_china_only = 7;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(7, this->_internal_steam_china_only(), target);
  }

  // optional string host = 8;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_host().data(), static_cast<int>(this->_internal_host().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_ServerInfo.host");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_host(), target);
  }

  // optional string vhost = 9;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_vhost().data(), static_cast<int>(this->_internal_vhost().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_ServerInfo.vhost");
    target = stream->WriteStringMaybeAliased(
        9, this->_internal_vhost(), target);
  }

  // optional bool use_as_proxy = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_use_as_proxy(), target);
  }

  // optional string proxy_request_path_template = 11;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_proxy_request_path_template().data(), static_cast<int>(this->_internal_proxy_request_path_template().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_ServerInfo.proxy_request_path_template");
    target = stream->WriteStringMaybeAliased(
        11, this->_internal_proxy_request_path_template(), target);
  }

  // optional string https_support = 12;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_https_support().data(), static_cast<int>(this->_internal_https_support().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_ServerInfo.https_support");
    target = stream->WriteStringMaybeAliased(
        12, this->_internal_https_support(), target);
  }

  // repeated uint32 allowed_app_ids = 13;
  for (int i = 0, n = this->_internal_allowed_app_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(13, this->_internal_allowed_app_ids(i), target);
  }

  // optional bool preferred_server = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(14, this->_internal_preferred_server(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_ServerInfo)
  return target;
}

size_t CContentServerDirectory_ServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_ServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 allowed_app_ids = 13;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->allowed_app_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_allowed_app_ids_size());
    total_size += data_size;
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string type = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_type());
    }

    // optional string host = 8;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host());
    }

    // optional string vhost = 9;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_vhost());
    }

    // optional string proxy_request_path_template = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_proxy_request_path_template());
    }

    // optional string https_support = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_https_support());
    }

    // optional int32 source_id = 2;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_source_id());
    }

    // optional int32 cell_id = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_cell_id());
    }

    // optional int32 load = 4;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_load());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional float weighted_load = 5;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional int32 num_entries_in_client_list = 6;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries_in_client_list());
    }

    // optional bool steam_china_only = 7;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional bool use_as_proxy = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 1;
    }

    // optional bool preferred_server = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_ServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_ServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_ServerInfo::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_ServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_ServerInfo *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_ServerInfo &>(from));
}


void CContentServerDirectory_ServerInfo::MergeFrom(const CContentServerDirectory_ServerInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_ServerInfo)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowed_app_ids_.MergeFrom(from.allowed_app_ids_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_type(from._internal_type());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_host(from._internal_host());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_vhost(from._internal_vhost());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_proxy_request_path_template(from._internal_proxy_request_path_template());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_https_support(from._internal_https_support());
    }
    if (cached_has_bits & 0x00000020u) {
      source_id_ = from.source_id_;
    }
    if (cached_has_bits & 0x00000040u) {
      cell_id_ = from.cell_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      load_ = from.load_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      weighted_load_ = from.weighted_load_;
    }
    if (cached_has_bits & 0x00000200u) {
      num_entries_in_client_list_ = from.num_entries_in_client_list_;
    }
    if (cached_has_bits & 0x00000400u) {
      steam_china_only_ = from.steam_china_only_;
    }
    if (cached_has_bits & 0x00000800u) {
      use_as_proxy_ = from.use_as_proxy_;
    }
    if (cached_has_bits & 0x00001000u) {
      preferred_server_ = from.preferred_server_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_ServerInfo::CopyFrom(const CContentServerDirectory_ServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_ServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_ServerInfo::IsInitialized() const {
  return true;
}

void CContentServerDirectory_ServerInfo::InternalSwap(CContentServerDirectory_ServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowed_app_ids_.InternalSwap(&other->allowed_app_ids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &type_, lhs_arena,
      &other->type_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &host_, lhs_arena,
      &other->host_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &vhost_, lhs_arena,
      &other->vhost_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &proxy_request_path_template_, lhs_arena,
      &other->proxy_request_path_template_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &https_support_, lhs_arena,
      &other->https_support_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_ServerInfo, preferred_server_)
      + sizeof(CContentServerDirectory_ServerInfo::preferred_server_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_ServerInfo, source_id_)>(
          reinterpret_cast<char*>(&source_id_),
          reinterpret_cast<char*>(&other->source_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_ServerInfo::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[1]);
}

// ===================================================================

class CContentServerDirectory_GetServersForSteamPipe_Response::_Internal {
 public:
};

CContentServerDirectory_GetServersForSteamPipe_Response::CContentServerDirectory_GetServersForSteamPipe_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  servers_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetServersForSteamPipe_Response)
}
CContentServerDirectory_GetServersForSteamPipe_Response::CContentServerDirectory_GetServersForSteamPipe_Response(const CContentServerDirectory_GetServersForSteamPipe_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      servers_(from.servers_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetServersForSteamPipe_Response)
}

inline void CContentServerDirectory_GetServersForSteamPipe_Response::SharedCtor() {
}

CContentServerDirectory_GetServersForSteamPipe_Response::~CContentServerDirectory_GetServersForSteamPipe_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetServersForSteamPipe_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetServersForSteamPipe_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_GetServersForSteamPipe_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetServersForSteamPipe_Response* _this = reinterpret_cast< CContentServerDirectory_GetServersForSteamPipe_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetServersForSteamPipe_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetServersForSteamPipe_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetServersForSteamPipe_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetServersForSteamPipe_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  servers_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetServersForSteamPipe_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CContentServerDirectory_ServerInfo servers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_servers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetServersForSteamPipe_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetServersForSteamPipe_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CContentServerDirectory_ServerInfo servers = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_servers_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_servers(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetServersForSteamPipe_Response)
  return target;
}

size_t CContentServerDirectory_GetServersForSteamPipe_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetServersForSteamPipe_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CContentServerDirectory_ServerInfo servers = 1;
  total_size += 1UL * this->_internal_servers_size();
  for (const auto& msg : this->servers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetServersForSteamPipe_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetServersForSteamPipe_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetServersForSteamPipe_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetServersForSteamPipe_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetServersForSteamPipe_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetServersForSteamPipe_Response &>(from));
}


void CContentServerDirectory_GetServersForSteamPipe_Response::MergeFrom(const CContentServerDirectory_GetServersForSteamPipe_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetServersForSteamPipe_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  servers_.MergeFrom(from.servers_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetServersForSteamPipe_Response::CopyFrom(const CContentServerDirectory_GetServersForSteamPipe_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetServersForSteamPipe_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetServersForSteamPipe_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetServersForSteamPipe_Response::InternalSwap(CContentServerDirectory_GetServersForSteamPipe_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  servers_.InternalSwap(&other->servers_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetServersForSteamPipe_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[2]);
}

// ===================================================================

class CContentServerDirectory_GetDepotPatchInfo_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetDepotPatchInfo_Request>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_depotid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_source_manifestid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_target_manifestid(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CContentServerDirectory_GetDepotPatchInfo_Request::CContentServerDirectory_GetDepotPatchInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetDepotPatchInfo_Request)
}
CContentServerDirectory_GetDepotPatchInfo_Request::CContentServerDirectory_GetDepotPatchInfo_Request(const CContentServerDirectory_GetDepotPatchInfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&target_manifestid_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(target_manifestid_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetDepotPatchInfo_Request)
}

inline void CContentServerDirectory_GetDepotPatchInfo_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&target_manifestid_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(target_manifestid_));
}

CContentServerDirectory_GetDepotPatchInfo_Request::~CContentServerDirectory_GetDepotPatchInfo_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetDepotPatchInfo_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetDepotPatchInfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_GetDepotPatchInfo_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetDepotPatchInfo_Request* _this = reinterpret_cast< CContentServerDirectory_GetDepotPatchInfo_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetDepotPatchInfo_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetDepotPatchInfo_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetDepotPatchInfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetDepotPatchInfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&target_manifestid_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(target_manifestid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetDepotPatchInfo_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 depotid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_depotid(&has_bits);
          depotid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 source_manifestid = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_source_manifestid(&has_bits);
          source_manifestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 target_manifestid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_target_manifestid(&has_bits);
          target_manifestid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetDepotPatchInfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetDepotPatchInfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 depotid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_depotid(), target);
  }

  // optional uint64 source_manifestid = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_source_manifestid(), target);
  }

  // optional uint64 target_manifestid = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_target_manifestid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetDepotPatchInfo_Request)
  return target;
}

size_t CContentServerDirectory_GetDepotPatchInfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetDepotPatchInfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 depotid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_depotid());
    }

    // optional uint64 source_manifestid = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_source_manifestid());
    }

    // optional uint64 target_manifestid = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_target_manifestid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetDepotPatchInfo_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetDepotPatchInfo_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetDepotPatchInfo_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetDepotPatchInfo_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetDepotPatchInfo_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetDepotPatchInfo_Request &>(from));
}


void CContentServerDirectory_GetDepotPatchInfo_Request::MergeFrom(const CContentServerDirectory_GetDepotPatchInfo_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetDepotPatchInfo_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      depotid_ = from.depotid_;
    }
    if (cached_has_bits & 0x00000004u) {
      source_manifestid_ = from.source_manifestid_;
    }
    if (cached_has_bits & 0x00000008u) {
      target_manifestid_ = from.target_manifestid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetDepotPatchInfo_Request::CopyFrom(const CContentServerDirectory_GetDepotPatchInfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetDepotPatchInfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetDepotPatchInfo_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetDepotPatchInfo_Request::InternalSwap(CContentServerDirectory_GetDepotPatchInfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetDepotPatchInfo_Request, target_manifestid_)
      + sizeof(CContentServerDirectory_GetDepotPatchInfo_Request::target_manifestid_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetDepotPatchInfo_Request, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetDepotPatchInfo_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[3]);
}

// ===================================================================

class CContentServerDirectory_GetDepotPatchInfo_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetDepotPatchInfo_Response>()._has_bits_);
  static void set_has_is_available(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_patch_size(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_patched_chunks_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CContentServerDirectory_GetDepotPatchInfo_Response::CContentServerDirectory_GetDepotPatchInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetDepotPatchInfo_Response)
}
CContentServerDirectory_GetDepotPatchInfo_Response::CContentServerDirectory_GetDepotPatchInfo_Response(const CContentServerDirectory_GetDepotPatchInfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&patch_size_, &from.patch_size_,
    static_cast<size_t>(reinterpret_cast<char*>(&is_available_) -
    reinterpret_cast<char*>(&patch_size_)) + sizeof(is_available_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetDepotPatchInfo_Response)
}

inline void CContentServerDirectory_GetDepotPatchInfo_Response::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&patch_size_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&is_available_) -
    reinterpret_cast<char*>(&patch_size_)) + sizeof(is_available_));
}

CContentServerDirectory_GetDepotPatchInfo_Response::~CContentServerDirectory_GetDepotPatchInfo_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetDepotPatchInfo_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetDepotPatchInfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_GetDepotPatchInfo_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetDepotPatchInfo_Response* _this = reinterpret_cast< CContentServerDirectory_GetDepotPatchInfo_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetDepotPatchInfo_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetDepotPatchInfo_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetDepotPatchInfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetDepotPatchInfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&patch_size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&is_available_) -
        reinterpret_cast<char*>(&patch_size_)) + sizeof(is_available_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetDepotPatchInfo_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_available = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_available(&has_bits);
          is_available_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 patch_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_patch_size(&has_bits);
          patch_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 patched_chunks_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_patched_chunks_size(&has_bits);
          patched_chunks_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetDepotPatchInfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetDepotPatchInfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional bool is_available = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_is_available(), target);
  }

  // optional uint64 patch_size = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_patch_size(), target);
  }

  // optional uint64 patched_chunks_size = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_patched_chunks_size(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetDepotPatchInfo_Response)
  return target;
}

size_t CContentServerDirectory_GetDepotPatchInfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetDepotPatchInfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 patch_size = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_patch_size());
    }

    // optional uint64 patched_chunks_size = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_patched_chunks_size());
    }

    // optional bool is_available = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetDepotPatchInfo_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetDepotPatchInfo_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetDepotPatchInfo_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetDepotPatchInfo_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetDepotPatchInfo_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetDepotPatchInfo_Response &>(from));
}


void CContentServerDirectory_GetDepotPatchInfo_Response::MergeFrom(const CContentServerDirectory_GetDepotPatchInfo_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetDepotPatchInfo_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      patch_size_ = from.patch_size_;
    }
    if (cached_has_bits & 0x00000002u) {
      patched_chunks_size_ = from.patched_chunks_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      is_available_ = from.is_available_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetDepotPatchInfo_Response::CopyFrom(const CContentServerDirectory_GetDepotPatchInfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetDepotPatchInfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetDepotPatchInfo_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetDepotPatchInfo_Response::InternalSwap(CContentServerDirectory_GetDepotPatchInfo_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetDepotPatchInfo_Response, is_available_)
      + sizeof(CContentServerDirectory_GetDepotPatchInfo_Response::is_available_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetDepotPatchInfo_Response, patch_size_)>(
          reinterpret_cast<char*>(&patch_size_),
          reinterpret_cast<char*>(&other->patch_size_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetDepotPatchInfo_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[4]);
}

// ===================================================================

class CContentServerDirectory_GetClientUpdateHosts_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetClientUpdateHosts_Request>()._has_bits_);
  static void set_has_cached_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CContentServerDirectory_GetClientUpdateHosts_Request::CContentServerDirectory_GetClientUpdateHosts_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetClientUpdateHosts_Request)
}
CContentServerDirectory_GetClientUpdateHosts_Request::CContentServerDirectory_GetClientUpdateHosts_Request(const CContentServerDirectory_GetClientUpdateHosts_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  cached_signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    cached_signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cached_signature()) {
    cached_signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_cached_signature(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetClientUpdateHosts_Request)
}

inline void CContentServerDirectory_GetClientUpdateHosts_Request::SharedCtor() {
cached_signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  cached_signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CContentServerDirectory_GetClientUpdateHosts_Request::~CContentServerDirectory_GetClientUpdateHosts_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetClientUpdateHosts_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetClientUpdateHosts_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  cached_signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetClientUpdateHosts_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetClientUpdateHosts_Request* _this = reinterpret_cast< CContentServerDirectory_GetClientUpdateHosts_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetClientUpdateHosts_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetClientUpdateHosts_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetClientUpdateHosts_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetClientUpdateHosts_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    cached_signature_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetClientUpdateHosts_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cached_signature = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cached_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetClientUpdateHosts_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetClientUpdateHosts_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string cached_signature = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cached_signature().data(), static_cast<int>(this->_internal_cached_signature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetClientUpdateHosts_Request.cached_signature");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cached_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetClientUpdateHosts_Request)
  return target;
}

size_t CContentServerDirectory_GetClientUpdateHosts_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetClientUpdateHosts_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string cached_signature = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cached_signature());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetClientUpdateHosts_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetClientUpdateHosts_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetClientUpdateHosts_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetClientUpdateHosts_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetClientUpdateHosts_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetClientUpdateHosts_Request &>(from));
}


void CContentServerDirectory_GetClientUpdateHosts_Request::MergeFrom(const CContentServerDirectory_GetClientUpdateHosts_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetClientUpdateHosts_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cached_signature()) {
    _internal_set_cached_signature(from._internal_cached_signature());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetClientUpdateHosts_Request::CopyFrom(const CContentServerDirectory_GetClientUpdateHosts_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetClientUpdateHosts_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetClientUpdateHosts_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetClientUpdateHosts_Request::InternalSwap(CContentServerDirectory_GetClientUpdateHosts_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &cached_signature_, lhs_arena,
      &other->cached_signature_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetClientUpdateHosts_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[5]);
}

// ===================================================================

class CContentServerDirectory_GetClientUpdateHosts_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetClientUpdateHosts_Response>()._has_bits_);
  static void set_has_hosts_kv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_valid_until_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_ip_country(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CContentServerDirectory_GetClientUpdateHosts_Response::CContentServerDirectory_GetClientUpdateHosts_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetClientUpdateHosts_Response)
}
CContentServerDirectory_GetClientUpdateHosts_Response::CContentServerDirectory_GetClientUpdateHosts_Response(const CContentServerDirectory_GetClientUpdateHosts_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  hosts_kv_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    hosts_kv_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_hosts_kv()) {
    hosts_kv_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_hosts_kv(), 
      GetArenaForAllocation());
  }
  ip_country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_country()) {
    ip_country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_country(), 
      GetArenaForAllocation());
  }
  valid_until_time_ = from.valid_until_time_;
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetClientUpdateHosts_Response)
}

inline void CContentServerDirectory_GetClientUpdateHosts_Response::SharedCtor() {
hosts_kv_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  hosts_kv_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
ip_country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
valid_until_time_ = uint64_t{0u};
}

CContentServerDirectory_GetClientUpdateHosts_Response::~CContentServerDirectory_GetClientUpdateHosts_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetClientUpdateHosts_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetClientUpdateHosts_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  hosts_kv_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ip_country_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetClientUpdateHosts_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetClientUpdateHosts_Response* _this = reinterpret_cast< CContentServerDirectory_GetClientUpdateHosts_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetClientUpdateHosts_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetClientUpdateHosts_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetClientUpdateHosts_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetClientUpdateHosts_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      hosts_kv_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      ip_country_.ClearNonDefaultToEmpty();
    }
  }
  valid_until_time_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetClientUpdateHosts_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string hosts_kv = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_hosts_kv();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 valid_until_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_valid_until_time(&has_bits);
          valid_until_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ip_country = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_ip_country();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetClientUpdateHosts_Response.ip_country");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetClientUpdateHosts_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetClientUpdateHosts_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string hosts_kv = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_hosts_kv().data(), static_cast<int>(this->_internal_hosts_kv().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetClientUpdateHosts_Response.hosts_kv");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_hosts_kv(), target);
  }

  // optional uint64 valid_until_time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_valid_until_time(), target);
  }

  // optional string ip_country = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_country().data(), static_cast<int>(this->_internal_ip_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetClientUpdateHosts_Response.ip_country");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_ip_country(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetClientUpdateHosts_Response)
  return target;
}

size_t CContentServerDirectory_GetClientUpdateHosts_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetClientUpdateHosts_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string hosts_kv = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_hosts_kv());
    }

    // optional string ip_country = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip_country());
    }

    // optional uint64 valid_until_time = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_valid_until_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetClientUpdateHosts_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetClientUpdateHosts_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetClientUpdateHosts_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetClientUpdateHosts_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetClientUpdateHosts_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetClientUpdateHosts_Response &>(from));
}


void CContentServerDirectory_GetClientUpdateHosts_Response::MergeFrom(const CContentServerDirectory_GetClientUpdateHosts_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetClientUpdateHosts_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_hosts_kv(from._internal_hosts_kv());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_ip_country(from._internal_ip_country());
    }
    if (cached_has_bits & 0x00000004u) {
      valid_until_time_ = from.valid_until_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetClientUpdateHosts_Response::CopyFrom(const CContentServerDirectory_GetClientUpdateHosts_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetClientUpdateHosts_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetClientUpdateHosts_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetClientUpdateHosts_Response::InternalSwap(CContentServerDirectory_GetClientUpdateHosts_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &hosts_kv_, lhs_arena,
      &other->hosts_kv_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_country_, lhs_arena,
      &other->ip_country_, rhs_arena
  );
  swap(valid_until_time_, other->valid_until_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetClientUpdateHosts_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[6]);
}

// ===================================================================

class CContentServerDirectory_GetManifestRequestCode_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetManifestRequestCode_Request>()._has_bits_);
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_depot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_manifest_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_app_branch(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_branch_password_hash(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CContentServerDirectory_GetManifestRequestCode_Request::CContentServerDirectory_GetManifestRequestCode_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetManifestRequestCode_Request)
}
CContentServerDirectory_GetManifestRequestCode_Request::CContentServerDirectory_GetManifestRequestCode_Request(const CContentServerDirectory_GetManifestRequestCode_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  app_branch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    app_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_app_branch()) {
    app_branch_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_app_branch(), 
      GetArenaForAllocation());
  }
  branch_password_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    branch_password_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_branch_password_hash()) {
    branch_password_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_branch_password_hash(), 
      GetArenaForAllocation());
  }
  ::memcpy(&app_id_, &from.app_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&manifest_id_) -
    reinterpret_cast<char*>(&app_id_)) + sizeof(manifest_id_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetManifestRequestCode_Request)
}

inline void CContentServerDirectory_GetManifestRequestCode_Request::SharedCtor() {
app_branch_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  app_branch_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
branch_password_hash_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  branch_password_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&app_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&manifest_id_) -
    reinterpret_cast<char*>(&app_id_)) + sizeof(manifest_id_));
}

CContentServerDirectory_GetManifestRequestCode_Request::~CContentServerDirectory_GetManifestRequestCode_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetManifestRequestCode_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetManifestRequestCode_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  app_branch_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  branch_password_hash_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetManifestRequestCode_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetManifestRequestCode_Request* _this = reinterpret_cast< CContentServerDirectory_GetManifestRequestCode_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetManifestRequestCode_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetManifestRequestCode_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetManifestRequestCode_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetManifestRequestCode_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      app_branch_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      branch_password_hash_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&app_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&manifest_id_) -
        reinterpret_cast<char*>(&app_id_)) + sizeof(manifest_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetManifestRequestCode_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 app_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_app_id(&has_bits);
          app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 depot_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_depot_id(&has_bits);
          depot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 manifest_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_manifest_id(&has_bits);
          manifest_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string app_branch = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_app_branch();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetManifestRequestCode_Request.app_branch");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string branch_password_hash = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_branch_password_hash();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetManifestRequestCode_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetManifestRequestCode_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 app_id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_app_id(), target);
  }

  // optional uint32 depot_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_depot_id(), target);
  }

  // optional uint64 manifest_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_manifest_id(), target);
  }

  // optional string app_branch = 4;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_app_branch().data(), static_cast<int>(this->_internal_app_branch().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetManifestRequestCode_Request.app_branch");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_app_branch(), target);
  }

  // optional string branch_password_hash = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_branch_password_hash().data(), static_cast<int>(this->_internal_branch_password_hash().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetManifestRequestCode_Request.branch_password_hash");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_branch_password_hash(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetManifestRequestCode_Request)
  return target;
}

size_t CContentServerDirectory_GetManifestRequestCode_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetManifestRequestCode_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string app_branch = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_app_branch());
    }

    // optional string branch_password_hash = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_branch_password_hash());
    }

    // optional uint32 app_id = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional uint32 depot_id = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_depot_id());
    }

    // optional uint64 manifest_id = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_manifest_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetManifestRequestCode_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetManifestRequestCode_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetManifestRequestCode_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetManifestRequestCode_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetManifestRequestCode_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetManifestRequestCode_Request &>(from));
}


void CContentServerDirectory_GetManifestRequestCode_Request::MergeFrom(const CContentServerDirectory_GetManifestRequestCode_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetManifestRequestCode_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_app_branch(from._internal_app_branch());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_branch_password_hash(from._internal_branch_password_hash());
    }
    if (cached_has_bits & 0x00000004u) {
      app_id_ = from.app_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      depot_id_ = from.depot_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      manifest_id_ = from.manifest_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetManifestRequestCode_Request::CopyFrom(const CContentServerDirectory_GetManifestRequestCode_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetManifestRequestCode_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetManifestRequestCode_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetManifestRequestCode_Request::InternalSwap(CContentServerDirectory_GetManifestRequestCode_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &app_branch_, lhs_arena,
      &other->app_branch_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &branch_password_hash_, lhs_arena,
      &other->branch_password_hash_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetManifestRequestCode_Request, manifest_id_)
      + sizeof(CContentServerDirectory_GetManifestRequestCode_Request::manifest_id_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetManifestRequestCode_Request, app_id_)>(
          reinterpret_cast<char*>(&app_id_),
          reinterpret_cast<char*>(&other->app_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetManifestRequestCode_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[7]);
}

// ===================================================================

class CContentServerDirectory_GetManifestRequestCode_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetManifestRequestCode_Response>()._has_bits_);
  static void set_has_manifest_request_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CContentServerDirectory_GetManifestRequestCode_Response::CContentServerDirectory_GetManifestRequestCode_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetManifestRequestCode_Response)
}
CContentServerDirectory_GetManifestRequestCode_Response::CContentServerDirectory_GetManifestRequestCode_Response(const CContentServerDirectory_GetManifestRequestCode_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  manifest_request_code_ = from.manifest_request_code_;
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetManifestRequestCode_Response)
}

inline void CContentServerDirectory_GetManifestRequestCode_Response::SharedCtor() {
manifest_request_code_ = uint64_t{0u};
}

CContentServerDirectory_GetManifestRequestCode_Response::~CContentServerDirectory_GetManifestRequestCode_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetManifestRequestCode_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetManifestRequestCode_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_GetManifestRequestCode_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetManifestRequestCode_Response* _this = reinterpret_cast< CContentServerDirectory_GetManifestRequestCode_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetManifestRequestCode_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetManifestRequestCode_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetManifestRequestCode_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetManifestRequestCode_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  manifest_request_code_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetManifestRequestCode_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 manifest_request_code = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_manifest_request_code(&has_bits);
          manifest_request_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetManifestRequestCode_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetManifestRequestCode_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 manifest_request_code = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_manifest_request_code(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetManifestRequestCode_Response)
  return target;
}

size_t CContentServerDirectory_GetManifestRequestCode_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetManifestRequestCode_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 manifest_request_code = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_manifest_request_code());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetManifestRequestCode_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetManifestRequestCode_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetManifestRequestCode_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetManifestRequestCode_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetManifestRequestCode_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetManifestRequestCode_Response &>(from));
}


void CContentServerDirectory_GetManifestRequestCode_Response::MergeFrom(const CContentServerDirectory_GetManifestRequestCode_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetManifestRequestCode_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_manifest_request_code()) {
    _internal_set_manifest_request_code(from._internal_manifest_request_code());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetManifestRequestCode_Response::CopyFrom(const CContentServerDirectory_GetManifestRequestCode_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetManifestRequestCode_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetManifestRequestCode_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetManifestRequestCode_Response::InternalSwap(CContentServerDirectory_GetManifestRequestCode_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(manifest_request_code_, other->manifest_request_code_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetManifestRequestCode_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[8]);
}

// ===================================================================

class CContentServerDirectory_GetCDNAuthToken_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetCDNAuthToken_Request>()._has_bits_);
  static void set_has_depot_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_host_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CContentServerDirectory_GetCDNAuthToken_Request::CContentServerDirectory_GetCDNAuthToken_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetCDNAuthToken_Request)
}
CContentServerDirectory_GetCDNAuthToken_Request::CContentServerDirectory_GetCDNAuthToken_Request(const CContentServerDirectory_GetCDNAuthToken_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host_name()) {
    host_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_host_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&depot_id_, &from.depot_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&app_id_) -
    reinterpret_cast<char*>(&depot_id_)) + sizeof(app_id_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetCDNAuthToken_Request)
}

inline void CContentServerDirectory_GetCDNAuthToken_Request::SharedCtor() {
host_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  host_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&depot_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&app_id_) -
    reinterpret_cast<char*>(&depot_id_)) + sizeof(app_id_));
}

CContentServerDirectory_GetCDNAuthToken_Request::~CContentServerDirectory_GetCDNAuthToken_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetCDNAuthToken_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetCDNAuthToken_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  host_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetCDNAuthToken_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetCDNAuthToken_Request* _this = reinterpret_cast< CContentServerDirectory_GetCDNAuthToken_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetCDNAuthToken_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetCDNAuthToken_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetCDNAuthToken_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetCDNAuthToken_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    host_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&depot_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&app_id_) -
        reinterpret_cast<char*>(&depot_id_)) + sizeof(app_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetCDNAuthToken_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 depot_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_depot_id(&has_bits);
          depot_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string host_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_host_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetCDNAuthToken_Request.host_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_app_id(&has_bits);
          app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetCDNAuthToken_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetCDNAuthToken_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 depot_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_depot_id(), target);
  }

  // optional string host_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_host_name().data(), static_cast<int>(this->_internal_host_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetCDNAuthToken_Request.host_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_host_name(), target);
  }

  // optional uint32 app_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_app_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetCDNAuthToken_Request)
  return target;
}

size_t CContentServerDirectory_GetCDNAuthToken_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetCDNAuthToken_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string host_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host_name());
    }

    // optional uint32 depot_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_depot_id());
    }

    // optional uint32 app_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetCDNAuthToken_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetCDNAuthToken_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetCDNAuthToken_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetCDNAuthToken_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetCDNAuthToken_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetCDNAuthToken_Request &>(from));
}


void CContentServerDirectory_GetCDNAuthToken_Request::MergeFrom(const CContentServerDirectory_GetCDNAuthToken_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetCDNAuthToken_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_host_name(from._internal_host_name());
    }
    if (cached_has_bits & 0x00000002u) {
      depot_id_ = from.depot_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      app_id_ = from.app_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetCDNAuthToken_Request::CopyFrom(const CContentServerDirectory_GetCDNAuthToken_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetCDNAuthToken_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetCDNAuthToken_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetCDNAuthToken_Request::InternalSwap(CContentServerDirectory_GetCDNAuthToken_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &host_name_, lhs_arena,
      &other->host_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetCDNAuthToken_Request, app_id_)
      + sizeof(CContentServerDirectory_GetCDNAuthToken_Request::app_id_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetCDNAuthToken_Request, depot_id_)>(
          reinterpret_cast<char*>(&depot_id_),
          reinterpret_cast<char*>(&other->depot_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetCDNAuthToken_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[9]);
}

// ===================================================================

class CContentServerDirectory_GetCDNAuthToken_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetCDNAuthToken_Response>()._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiration_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CContentServerDirectory_GetCDNAuthToken_Response::CContentServerDirectory_GetCDNAuthToken_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetCDNAuthToken_Response)
}
CContentServerDirectory_GetCDNAuthToken_Response::CContentServerDirectory_GetCDNAuthToken_Response(const CContentServerDirectory_GetCDNAuthToken_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  expiration_time_ = from.expiration_time_;
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetCDNAuthToken_Response)
}

inline void CContentServerDirectory_GetCDNAuthToken_Response::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
expiration_time_ = 0u;
}

CContentServerDirectory_GetCDNAuthToken_Response::~CContentServerDirectory_GetCDNAuthToken_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetCDNAuthToken_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetCDNAuthToken_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetCDNAuthToken_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetCDNAuthToken_Response* _this = reinterpret_cast< CContentServerDirectory_GetCDNAuthToken_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetCDNAuthToken_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetCDNAuthToken_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetCDNAuthToken_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetCDNAuthToken_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    token_.ClearNonDefaultToEmpty();
  }
  expiration_time_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetCDNAuthToken_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetCDNAuthToken_Response.token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expiration_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_expiration_time(&has_bits);
          expiration_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetCDNAuthToken_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetCDNAuthToken_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetCDNAuthToken_Response.token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional uint32 expiration_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_expiration_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetCDNAuthToken_Response)
  return target;
}

size_t CContentServerDirectory_GetCDNAuthToken_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetCDNAuthToken_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional uint32 expiration_time = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_expiration_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetCDNAuthToken_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetCDNAuthToken_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetCDNAuthToken_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetCDNAuthToken_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetCDNAuthToken_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetCDNAuthToken_Response &>(from));
}


void CContentServerDirectory_GetCDNAuthToken_Response::MergeFrom(const CContentServerDirectory_GetCDNAuthToken_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetCDNAuthToken_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      expiration_time_ = from.expiration_time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetCDNAuthToken_Response::CopyFrom(const CContentServerDirectory_GetCDNAuthToken_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetCDNAuthToken_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetCDNAuthToken_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetCDNAuthToken_Response::InternalSwap(CContentServerDirectory_GetCDNAuthToken_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  swap(expiration_time_, other->expiration_time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetCDNAuthToken_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[10]);
}

// ===================================================================

class CContentServerDirectory_RequestPeerContentServer_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_RequestPeerContentServer_Request>()._has_bits_);
  static void set_has_remote_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_remote_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_app_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_current_build_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CContentServerDirectory_RequestPeerContentServer_Request::CContentServerDirectory_RequestPeerContentServer_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_RequestPeerContentServer_Request)
}
CContentServerDirectory_RequestPeerContentServer_Request::CContentServerDirectory_RequestPeerContentServer_Request(const CContentServerDirectory_RequestPeerContentServer_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&remote_client_id_, &from.remote_client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&current_build_id_) -
    reinterpret_cast<char*>(&remote_client_id_)) + sizeof(current_build_id_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_RequestPeerContentServer_Request)
}

inline void CContentServerDirectory_RequestPeerContentServer_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&remote_client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&current_build_id_) -
    reinterpret_cast<char*>(&remote_client_id_)) + sizeof(current_build_id_));
}

CContentServerDirectory_RequestPeerContentServer_Request::~CContentServerDirectory_RequestPeerContentServer_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_RequestPeerContentServer_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_RequestPeerContentServer_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_RequestPeerContentServer_Request::ArenaDtor(void* object) {
  CContentServerDirectory_RequestPeerContentServer_Request* _this = reinterpret_cast< CContentServerDirectory_RequestPeerContentServer_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_RequestPeerContentServer_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_RequestPeerContentServer_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_RequestPeerContentServer_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_RequestPeerContentServer_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&remote_client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&current_build_id_) -
        reinterpret_cast<char*>(&remote_client_id_)) + sizeof(current_build_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_RequestPeerContentServer_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 remote_client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_remote_client_id(&has_bits);
          remote_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 server_remote_client_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_server_remote_client_id(&has_bits);
          server_remote_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 app_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_app_id(&has_bits);
          app_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 current_build_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_current_build_id(&has_bits);
          current_build_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_RequestPeerContentServer_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_RequestPeerContentServer_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 remote_client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_remote_client_id(), target);
  }

  // optional uint64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_steamid(), target);
  }

  // optional uint64 server_remote_client_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_server_remote_client_id(), target);
  }

  // optional uint32 app_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_app_id(), target);
  }

  // optional uint32 current_build_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_current_build_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_RequestPeerContentServer_Request)
  return target;
}

size_t CContentServerDirectory_RequestPeerContentServer_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_RequestPeerContentServer_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint64 remote_client_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_remote_client_id());
    }

    // optional uint64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional uint64 server_remote_client_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_server_remote_client_id());
    }

    // optional uint32 app_id = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_app_id());
    }

    // optional uint32 current_build_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_current_build_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_RequestPeerContentServer_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_RequestPeerContentServer_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_RequestPeerContentServer_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_RequestPeerContentServer_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_RequestPeerContentServer_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_RequestPeerContentServer_Request &>(from));
}


void CContentServerDirectory_RequestPeerContentServer_Request::MergeFrom(const CContentServerDirectory_RequestPeerContentServer_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_RequestPeerContentServer_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      remote_client_id_ = from.remote_client_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      server_remote_client_id_ = from.server_remote_client_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      app_id_ = from.app_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      current_build_id_ = from.current_build_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_RequestPeerContentServer_Request::CopyFrom(const CContentServerDirectory_RequestPeerContentServer_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_RequestPeerContentServer_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_RequestPeerContentServer_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_RequestPeerContentServer_Request::InternalSwap(CContentServerDirectory_RequestPeerContentServer_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_RequestPeerContentServer_Request, current_build_id_)
      + sizeof(CContentServerDirectory_RequestPeerContentServer_Request::current_build_id_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_RequestPeerContentServer_Request, remote_client_id_)>(
          reinterpret_cast<char*>(&remote_client_id_),
          reinterpret_cast<char*>(&other->remote_client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_RequestPeerContentServer_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[11]);
}

// ===================================================================

class CContentServerDirectory_RequestPeerContentServer_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_RequestPeerContentServer_Response>()._has_bits_);
  static void set_has_server_port(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CContentServerDirectory_RequestPeerContentServer_Response::CContentServerDirectory_RequestPeerContentServer_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  installed_depots_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_RequestPeerContentServer_Response)
}
CContentServerDirectory_RequestPeerContentServer_Response::CContentServerDirectory_RequestPeerContentServer_Response(const CContentServerDirectory_RequestPeerContentServer_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      installed_depots_(from.installed_depots_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  server_port_ = from.server_port_;
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_RequestPeerContentServer_Response)
}

inline void CContentServerDirectory_RequestPeerContentServer_Response::SharedCtor() {
server_port_ = 0u;
}

CContentServerDirectory_RequestPeerContentServer_Response::~CContentServerDirectory_RequestPeerContentServer_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_RequestPeerContentServer_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_RequestPeerContentServer_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_RequestPeerContentServer_Response::ArenaDtor(void* object) {
  CContentServerDirectory_RequestPeerContentServer_Response* _this = reinterpret_cast< CContentServerDirectory_RequestPeerContentServer_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_RequestPeerContentServer_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_RequestPeerContentServer_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_RequestPeerContentServer_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_RequestPeerContentServer_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  installed_depots_.Clear();
  server_port_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_RequestPeerContentServer_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 server_port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_server_port(&has_bits);
          server_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 installed_depots = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_installed_depots(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_installed_depots(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_RequestPeerContentServer_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_RequestPeerContentServer_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 server_port = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_server_port(), target);
  }

  // repeated uint32 installed_depots = 2;
  for (int i = 0, n = this->_internal_installed_depots_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_installed_depots(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_RequestPeerContentServer_Response)
  return target;
}

size_t CContentServerDirectory_RequestPeerContentServer_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_RequestPeerContentServer_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 installed_depots = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->installed_depots_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_installed_depots_size());
    total_size += data_size;
  }

  // optional uint32 server_port = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_server_port());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_RequestPeerContentServer_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_RequestPeerContentServer_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_RequestPeerContentServer_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_RequestPeerContentServer_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_RequestPeerContentServer_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_RequestPeerContentServer_Response &>(from));
}


void CContentServerDirectory_RequestPeerContentServer_Response::MergeFrom(const CContentServerDirectory_RequestPeerContentServer_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_RequestPeerContentServer_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  installed_depots_.MergeFrom(from.installed_depots_);
  if (from._internal_has_server_port()) {
    _internal_set_server_port(from._internal_server_port());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_RequestPeerContentServer_Response::CopyFrom(const CContentServerDirectory_RequestPeerContentServer_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_RequestPeerContentServer_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_RequestPeerContentServer_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_RequestPeerContentServer_Response::InternalSwap(CContentServerDirectory_RequestPeerContentServer_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  installed_depots_.InternalSwap(&other->installed_depots_);
  swap(server_port_, other->server_port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_RequestPeerContentServer_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[12]);
}

// ===================================================================

class CContentServerDirectory_GetPeerContentInfo_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetPeerContentInfo_Request>()._has_bits_);
  static void set_has_remote_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_remote_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CContentServerDirectory_GetPeerContentInfo_Request::CContentServerDirectory_GetPeerContentInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetPeerContentInfo_Request)
}
CContentServerDirectory_GetPeerContentInfo_Request::CContentServerDirectory_GetPeerContentInfo_Request(const CContentServerDirectory_GetPeerContentInfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&remote_client_id_, &from.remote_client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&server_remote_client_id_) -
    reinterpret_cast<char*>(&remote_client_id_)) + sizeof(server_remote_client_id_));
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetPeerContentInfo_Request)
}

inline void CContentServerDirectory_GetPeerContentInfo_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&remote_client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&server_remote_client_id_) -
    reinterpret_cast<char*>(&remote_client_id_)) + sizeof(server_remote_client_id_));
}

CContentServerDirectory_GetPeerContentInfo_Request::~CContentServerDirectory_GetPeerContentInfo_Request() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetPeerContentInfo_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetPeerContentInfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CContentServerDirectory_GetPeerContentInfo_Request::ArenaDtor(void* object) {
  CContentServerDirectory_GetPeerContentInfo_Request* _this = reinterpret_cast< CContentServerDirectory_GetPeerContentInfo_Request* >(object);
  (void)_this;
}
void CContentServerDirectory_GetPeerContentInfo_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetPeerContentInfo_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetPeerContentInfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetPeerContentInfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&remote_client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&server_remote_client_id_) -
        reinterpret_cast<char*>(&remote_client_id_)) + sizeof(server_remote_client_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetPeerContentInfo_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 remote_client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_remote_client_id(&has_bits);
          remote_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 server_remote_client_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_server_remote_client_id(&has_bits);
          server_remote_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetPeerContentInfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetPeerContentInfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 remote_client_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_remote_client_id(), target);
  }

  // optional uint64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_steamid(), target);
  }

  // optional uint64 server_remote_client_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_server_remote_client_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetPeerContentInfo_Request)
  return target;
}

size_t CContentServerDirectory_GetPeerContentInfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetPeerContentInfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint64 remote_client_id = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_remote_client_id());
    }

    // optional uint64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional uint64 server_remote_client_id = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_server_remote_client_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetPeerContentInfo_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetPeerContentInfo_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetPeerContentInfo_Request::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetPeerContentInfo_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetPeerContentInfo_Request *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetPeerContentInfo_Request &>(from));
}


void CContentServerDirectory_GetPeerContentInfo_Request::MergeFrom(const CContentServerDirectory_GetPeerContentInfo_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetPeerContentInfo_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      remote_client_id_ = from.remote_client_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      server_remote_client_id_ = from.server_remote_client_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetPeerContentInfo_Request::CopyFrom(const CContentServerDirectory_GetPeerContentInfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetPeerContentInfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetPeerContentInfo_Request::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetPeerContentInfo_Request::InternalSwap(CContentServerDirectory_GetPeerContentInfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetPeerContentInfo_Request, server_remote_client_id_)
      + sizeof(CContentServerDirectory_GetPeerContentInfo_Request::server_remote_client_id_)
      - PROTOBUF_FIELD_OFFSET(CContentServerDirectory_GetPeerContentInfo_Request, remote_client_id_)>(
          reinterpret_cast<char*>(&remote_client_id_),
          reinterpret_cast<char*>(&other->remote_client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetPeerContentInfo_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[13]);
}

// ===================================================================

class CContentServerDirectory_GetPeerContentInfo_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CContentServerDirectory_GetPeerContentInfo_Response>()._has_bits_);
  static void set_has_ip_public(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CContentServerDirectory_GetPeerContentInfo_Response::CContentServerDirectory_GetPeerContentInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  appids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CContentServerDirectory_GetPeerContentInfo_Response)
}
CContentServerDirectory_GetPeerContentInfo_Response::CContentServerDirectory_GetPeerContentInfo_Response(const CContentServerDirectory_GetPeerContentInfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      appids_(from.appids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_public_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip_public()) {
    ip_public_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip_public(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CContentServerDirectory_GetPeerContentInfo_Response)
}

inline void CContentServerDirectory_GetPeerContentInfo_Response::SharedCtor() {
ip_public_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_public_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CContentServerDirectory_GetPeerContentInfo_Response::~CContentServerDirectory_GetPeerContentInfo_Response() {
  // @@protoc_insertion_point(destructor:CContentServerDirectory_GetPeerContentInfo_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CContentServerDirectory_GetPeerContentInfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_public_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CContentServerDirectory_GetPeerContentInfo_Response::ArenaDtor(void* object) {
  CContentServerDirectory_GetPeerContentInfo_Response* _this = reinterpret_cast< CContentServerDirectory_GetPeerContentInfo_Response* >(object);
  (void)_this;
}
void CContentServerDirectory_GetPeerContentInfo_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CContentServerDirectory_GetPeerContentInfo_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CContentServerDirectory_GetPeerContentInfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CContentServerDirectory_GetPeerContentInfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appids_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    ip_public_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CContentServerDirectory_GetPeerContentInfo_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint32 appids = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_appids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_appids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string ip_public = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_ip_public();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CContentServerDirectory_GetPeerContentInfo_Response.ip_public");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CContentServerDirectory_GetPeerContentInfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CContentServerDirectory_GetPeerContentInfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint32 appids = 1;
  for (int i = 0, n = this->_internal_appids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appids(i), target);
  }

  cached_has_bits = _has_bits_[0];
  // optional string ip_public = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip_public().data(), static_cast<int>(this->_internal_ip_public().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CContentServerDirectory_GetPeerContentInfo_Response.ip_public");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_ip_public(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CContentServerDirectory_GetPeerContentInfo_Response)
  return target;
}

size_t CContentServerDirectory_GetPeerContentInfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CContentServerDirectory_GetPeerContentInfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 appids = 1;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->appids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_appids_size());
    total_size += data_size;
  }

  // optional string ip_public = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_ip_public());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CContentServerDirectory_GetPeerContentInfo_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CContentServerDirectory_GetPeerContentInfo_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CContentServerDirectory_GetPeerContentInfo_Response::GetClassData() const { return &_class_data_; }

void CContentServerDirectory_GetPeerContentInfo_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CContentServerDirectory_GetPeerContentInfo_Response *>(to)->MergeFrom(
      static_cast<const CContentServerDirectory_GetPeerContentInfo_Response &>(from));
}


void CContentServerDirectory_GetPeerContentInfo_Response::MergeFrom(const CContentServerDirectory_GetPeerContentInfo_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CContentServerDirectory_GetPeerContentInfo_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  appids_.MergeFrom(from.appids_);
  if (from._internal_has_ip_public()) {
    _internal_set_ip_public(from._internal_ip_public());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CContentServerDirectory_GetPeerContentInfo_Response::CopyFrom(const CContentServerDirectory_GetPeerContentInfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CContentServerDirectory_GetPeerContentInfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CContentServerDirectory_GetPeerContentInfo_Response::IsInitialized() const {
  return true;
}

void CContentServerDirectory_GetPeerContentInfo_Response::InternalSwap(CContentServerDirectory_GetPeerContentInfo_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  appids_.InternalSwap(&other->appids_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_public_, lhs_arena,
      &other->ip_public_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CContentServerDirectory_GetPeerContentInfo_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fcontentsystem_2esteamclient_2eproto[14]);
}

// ===================================================================

ContentServerDirectory::~ContentServerDirectory() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* ContentServerDirectory::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fcontentsystem_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* ContentServerDirectory::GetDescriptor() {
  return descriptor();
}

void ContentServerDirectory::GetServersForSteamPipe(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetServersForSteamPipe_Request*,
                         ::CContentServerDirectory_GetServersForSteamPipe_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetServersForSteamPipe() not implemented.");
  done->Run();
}

void ContentServerDirectory::GetDepotPatchInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetDepotPatchInfo_Request*,
                         ::CContentServerDirectory_GetDepotPatchInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetDepotPatchInfo() not implemented.");
  done->Run();
}

void ContentServerDirectory::GetClientUpdateHosts(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetClientUpdateHosts_Request*,
                         ::CContentServerDirectory_GetClientUpdateHosts_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetClientUpdateHosts() not implemented.");
  done->Run();
}

void ContentServerDirectory::GetManifestRequestCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetManifestRequestCode_Request*,
                         ::CContentServerDirectory_GetManifestRequestCode_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetManifestRequestCode() not implemented.");
  done->Run();
}

void ContentServerDirectory::GetCDNAuthToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetCDNAuthToken_Request*,
                         ::CContentServerDirectory_GetCDNAuthToken_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetCDNAuthToken() not implemented.");
  done->Run();
}

void ContentServerDirectory::RequestPeerContentServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_RequestPeerContentServer_Request*,
                         ::CContentServerDirectory_RequestPeerContentServer_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method RequestPeerContentServer() not implemented.");
  done->Run();
}

void ContentServerDirectory::GetPeerContentInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CContentServerDirectory_GetPeerContentInfo_Request*,
                         ::CContentServerDirectory_GetPeerContentInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetPeerContentInfo() not implemented.");
  done->Run();
}

void ContentServerDirectory::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fcontentsystem_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      GetServersForSteamPipe(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetServersForSteamPipe_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetServersForSteamPipe_Response*>(
                 response),
             done);
      break;
    case 1:
      GetDepotPatchInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetDepotPatchInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetDepotPatchInfo_Response*>(
                 response),
             done);
      break;
    case 2:
      GetClientUpdateHosts(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetClientUpdateHosts_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetClientUpdateHosts_Response*>(
                 response),
             done);
      break;
    case 3:
      GetManifestRequestCode(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetManifestRequestCode_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetManifestRequestCode_Response*>(
                 response),
             done);
      break;
    case 4:
      GetCDNAuthToken(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetCDNAuthToken_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetCDNAuthToken_Response*>(
                 response),
             done);
      break;
    case 5:
      RequestPeerContentServer(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_RequestPeerContentServer_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_RequestPeerContentServer_Response*>(
                 response),
             done);
      break;
    case 6:
      GetPeerContentInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CContentServerDirectory_GetPeerContentInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CContentServerDirectory_GetPeerContentInfo_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& ContentServerDirectory::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CContentServerDirectory_GetServersForSteamPipe_Request::default_instance();
    case 1:
      return ::CContentServerDirectory_GetDepotPatchInfo_Request::default_instance();
    case 2:
      return ::CContentServerDirectory_GetClientUpdateHosts_Request::default_instance();
    case 3:
      return ::CContentServerDirectory_GetManifestRequestCode_Request::default_instance();
    case 4:
      return ::CContentServerDirectory_GetCDNAuthToken_Request::default_instance();
    case 5:
      return ::CContentServerDirectory_RequestPeerContentServer_Request::default_instance();
    case 6:
      return ::CContentServerDirectory_GetPeerContentInfo_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& ContentServerDirectory::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CContentServerDirectory_GetServersForSteamPipe_Response::default_instance();
    case 1:
      return ::CContentServerDirectory_GetDepotPatchInfo_Response::default_instance();
    case 2:
      return ::CContentServerDirectory_GetClientUpdateHosts_Response::default_instance();
    case 3:
      return ::CContentServerDirectory_GetManifestRequestCode_Response::default_instance();
    case 4:
      return ::CContentServerDirectory_GetCDNAuthToken_Response::default_instance();
    case 5:
      return ::CContentServerDirectory_RequestPeerContentServer_Response::default_instance();
    case 6:
      return ::CContentServerDirectory_GetPeerContentInfo_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

ContentServerDirectory_Stub::ContentServerDirectory_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
ContentServerDirectory_Stub::ContentServerDirectory_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
ContentServerDirectory_Stub::~ContentServerDirectory_Stub() {
  if (owns_channel_) delete channel_;
}

void ContentServerDirectory_Stub::GetServersForSteamPipe(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetServersForSteamPipe_Request* request,
                              ::CContentServerDirectory_GetServersForSteamPipe_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::GetDepotPatchInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetDepotPatchInfo_Request* request,
                              ::CContentServerDirectory_GetDepotPatchInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::GetClientUpdateHosts(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetClientUpdateHosts_Request* request,
                              ::CContentServerDirectory_GetClientUpdateHosts_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::GetManifestRequestCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetManifestRequestCode_Request* request,
                              ::CContentServerDirectory_GetManifestRequestCode_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::GetCDNAuthToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetCDNAuthToken_Request* request,
                              ::CContentServerDirectory_GetCDNAuthToken_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::RequestPeerContentServer(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_RequestPeerContentServer_Request* request,
                              ::CContentServerDirectory_RequestPeerContentServer_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void ContentServerDirectory_Stub::GetPeerContentInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CContentServerDirectory_GetPeerContentInfo_Request* request,
                              ::CContentServerDirectory_GetPeerContentInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetServersForSteamPipe_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetServersForSteamPipe_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetServersForSteamPipe_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_ServerInfo* Arena::CreateMaybeMessage< ::CContentServerDirectory_ServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_ServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetServersForSteamPipe_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetServersForSteamPipe_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetServersForSteamPipe_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetDepotPatchInfo_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetDepotPatchInfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetDepotPatchInfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetDepotPatchInfo_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetDepotPatchInfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetDepotPatchInfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetClientUpdateHosts_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetClientUpdateHosts_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetClientUpdateHosts_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetClientUpdateHosts_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetClientUpdateHosts_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetClientUpdateHosts_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetManifestRequestCode_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetManifestRequestCode_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetManifestRequestCode_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetManifestRequestCode_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetManifestRequestCode_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetManifestRequestCode_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetCDNAuthToken_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetCDNAuthToken_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetCDNAuthToken_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetCDNAuthToken_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetCDNAuthToken_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetCDNAuthToken_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_RequestPeerContentServer_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_RequestPeerContentServer_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_RequestPeerContentServer_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_RequestPeerContentServer_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_RequestPeerContentServer_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_RequestPeerContentServer_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetPeerContentInfo_Request* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetPeerContentInfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetPeerContentInfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CContentServerDirectory_GetPeerContentInfo_Response* Arena::CreateMaybeMessage< ::CContentServerDirectory_GetPeerContentInfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CContentServerDirectory_GetPeerContentInfo_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
