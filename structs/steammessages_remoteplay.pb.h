// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_remoteplay.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteplay_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteplay_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019005 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_steammessages_5fremoteplay_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_steammessages_5fremoteplay_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[112]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fremoteplay_2eproto;
class CAudioFormat;
struct CAudioFormatDefaultTypeInternal;
extern CAudioFormatDefaultTypeInternal _CAudioFormat_default_instance_;
class CAuthenticationRequestMsg;
struct CAuthenticationRequestMsgDefaultTypeInternal;
extern CAuthenticationRequestMsgDefaultTypeInternal _CAuthenticationRequestMsg_default_instance_;
class CAuthenticationResponseMsg;
struct CAuthenticationResponseMsgDefaultTypeInternal;
extern CAuthenticationResponseMsgDefaultTypeInternal _CAuthenticationResponseMsg_default_instance_;
class CClientHandshakeMsg;
struct CClientHandshakeMsgDefaultTypeInternal;
extern CClientHandshakeMsgDefaultTypeInternal _CClientHandshakeMsg_default_instance_;
class CControllerConfigMsg;
struct CControllerConfigMsgDefaultTypeInternal;
extern CControllerConfigMsgDefaultTypeInternal _CControllerConfigMsg_default_instance_;
class CControllerConfigMsg_ControllerActiveConfigChangeResponse;
struct CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal;
extern CControllerConfigMsg_ControllerActiveConfigChangeResponseDefaultTypeInternal _CControllerConfigMsg_ControllerActiveConfigChangeResponse_default_instance_;
class CControllerConfigMsg_ControllerActiveConfigMsg;
struct CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal;
extern CControllerConfigMsg_ControllerActiveConfigMsgDefaultTypeInternal _CControllerConfigMsg_ControllerActiveConfigMsg_default_instance_;
class CControllerConfigMsg_ControllerConfigResponse;
struct CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal;
extern CControllerConfigMsg_ControllerConfigResponseDefaultTypeInternal _CControllerConfigMsg_ControllerConfigResponse_default_instance_;
class CControllerConfigMsg_ControllerPersonalizationResponse;
struct CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal;
extern CControllerConfigMsg_ControllerPersonalizationResponseDefaultTypeInternal _CControllerConfigMsg_ControllerPersonalizationResponse_default_instance_;
class CControllerPersonalizationUpdateMsg;
struct CControllerPersonalizationUpdateMsgDefaultTypeInternal;
extern CControllerPersonalizationUpdateMsgDefaultTypeInternal _CControllerPersonalizationUpdateMsg_default_instance_;
class CDebugDumpMsg;
struct CDebugDumpMsgDefaultTypeInternal;
extern CDebugDumpMsgDefaultTypeInternal _CDebugDumpMsg_default_instance_;
class CDeleteCursorMsg;
struct CDeleteCursorMsgDefaultTypeInternal;
extern CDeleteCursorMsgDefaultTypeInternal _CDeleteCursorMsg_default_instance_;
class CDisableHighResCaptureMsg;
struct CDisableHighResCaptureMsgDefaultTypeInternal;
extern CDisableHighResCaptureMsgDefaultTypeInternal _CDisableHighResCaptureMsg_default_instance_;
class CDisableNeptuneDataMsg;
struct CDisableNeptuneDataMsgDefaultTypeInternal;
extern CDisableNeptuneDataMsgDefaultTypeInternal _CDisableNeptuneDataMsg_default_instance_;
class CDiscoveryPingRequest;
struct CDiscoveryPingRequestDefaultTypeInternal;
extern CDiscoveryPingRequestDefaultTypeInternal _CDiscoveryPingRequest_default_instance_;
class CDiscoveryPingResponse;
struct CDiscoveryPingResponseDefaultTypeInternal;
extern CDiscoveryPingResponseDefaultTypeInternal _CDiscoveryPingResponse_default_instance_;
class CEnableHighResCaptureMsg;
struct CEnableHighResCaptureMsgDefaultTypeInternal;
extern CEnableHighResCaptureMsgDefaultTypeInternal _CEnableHighResCaptureMsg_default_instance_;
class CEnableNeptuneDataMsg;
struct CEnableNeptuneDataMsgDefaultTypeInternal;
extern CEnableNeptuneDataMsgDefaultTypeInternal _CEnableNeptuneDataMsg_default_instance_;
class CFrameEvent;
struct CFrameEventDefaultTypeInternal;
extern CFrameEventDefaultTypeInternal _CFrameEvent_default_instance_;
class CFrameStatAccumulatedValue;
struct CFrameStatAccumulatedValueDefaultTypeInternal;
extern CFrameStatAccumulatedValueDefaultTypeInternal _CFrameStatAccumulatedValue_default_instance_;
class CFrameStats;
struct CFrameStatsDefaultTypeInternal;
extern CFrameStatsDefaultTypeInternal _CFrameStats_default_instance_;
class CFrameStatsListMsg;
struct CFrameStatsListMsgDefaultTypeInternal;
extern CFrameStatsListMsgDefaultTypeInternal _CFrameStatsListMsg_default_instance_;
class CGetCursorImageMsg;
struct CGetCursorImageMsgDefaultTypeInternal;
extern CGetCursorImageMsgDefaultTypeInternal _CGetCursorImageMsg_default_instance_;
class CGetTouchConfigDataMsg;
struct CGetTouchConfigDataMsgDefaultTypeInternal;
extern CGetTouchConfigDataMsgDefaultTypeInternal _CGetTouchConfigDataMsg_default_instance_;
class CGetTouchIconDataMsg;
struct CGetTouchIconDataMsgDefaultTypeInternal;
extern CGetTouchIconDataMsgDefaultTypeInternal _CGetTouchIconDataMsg_default_instance_;
class CHideCursorMsg;
struct CHideCursorMsgDefaultTypeInternal;
extern CHideCursorMsgDefaultTypeInternal _CHideCursorMsg_default_instance_;
class CInputKeyDownMsg;
struct CInputKeyDownMsgDefaultTypeInternal;
extern CInputKeyDownMsgDefaultTypeInternal _CInputKeyDownMsg_default_instance_;
class CInputKeyUpMsg;
struct CInputKeyUpMsgDefaultTypeInternal;
extern CInputKeyUpMsgDefaultTypeInternal _CInputKeyUpMsg_default_instance_;
class CInputLatencyTestMsg;
struct CInputLatencyTestMsgDefaultTypeInternal;
extern CInputLatencyTestMsgDefaultTypeInternal _CInputLatencyTestMsg_default_instance_;
class CInputMouseDownMsg;
struct CInputMouseDownMsgDefaultTypeInternal;
extern CInputMouseDownMsgDefaultTypeInternal _CInputMouseDownMsg_default_instance_;
class CInputMouseMotionMsg;
struct CInputMouseMotionMsgDefaultTypeInternal;
extern CInputMouseMotionMsgDefaultTypeInternal _CInputMouseMotionMsg_default_instance_;
class CInputMouseUpMsg;
struct CInputMouseUpMsgDefaultTypeInternal;
extern CInputMouseUpMsgDefaultTypeInternal _CInputMouseUpMsg_default_instance_;
class CInputMouseWheelMsg;
struct CInputMouseWheelMsgDefaultTypeInternal;
extern CInputMouseWheelMsgDefaultTypeInternal _CInputMouseWheelMsg_default_instance_;
class CInputTextMsg;
struct CInputTextMsgDefaultTypeInternal;
extern CInputTextMsgDefaultTypeInternal _CInputTextMsg_default_instance_;
class CInputTouchFingerDownMsg;
struct CInputTouchFingerDownMsgDefaultTypeInternal;
extern CInputTouchFingerDownMsgDefaultTypeInternal _CInputTouchFingerDownMsg_default_instance_;
class CInputTouchFingerMotionMsg;
struct CInputTouchFingerMotionMsgDefaultTypeInternal;
extern CInputTouchFingerMotionMsgDefaultTypeInternal _CInputTouchFingerMotionMsg_default_instance_;
class CInputTouchFingerUpMsg;
struct CInputTouchFingerUpMsgDefaultTypeInternal;
extern CInputTouchFingerUpMsgDefaultTypeInternal _CInputTouchFingerUpMsg_default_instance_;
class CKeepAliveMsg;
struct CKeepAliveMsgDefaultTypeInternal;
extern CKeepAliveMsgDefaultTypeInternal _CKeepAliveMsg_default_instance_;
class CLogMsg;
struct CLogMsgDefaultTypeInternal;
extern CLogMsgDefaultTypeInternal _CLogMsg_default_instance_;
class CLogUploadMsg;
struct CLogUploadMsgDefaultTypeInternal;
extern CLogUploadMsgDefaultTypeInternal _CLogUploadMsg_default_instance_;
class CNegotiatedConfig;
struct CNegotiatedConfigDefaultTypeInternal;
extern CNegotiatedConfigDefaultTypeInternal _CNegotiatedConfig_default_instance_;
class CNegotiationCompleteMsg;
struct CNegotiationCompleteMsgDefaultTypeInternal;
extern CNegotiationCompleteMsgDefaultTypeInternal _CNegotiationCompleteMsg_default_instance_;
class CNegotiationInitMsg;
struct CNegotiationInitMsgDefaultTypeInternal;
extern CNegotiationInitMsgDefaultTypeInternal _CNegotiationInitMsg_default_instance_;
class CNegotiationSetConfigMsg;
struct CNegotiationSetConfigMsgDefaultTypeInternal;
extern CNegotiationSetConfigMsgDefaultTypeInternal _CNegotiationSetConfigMsg_default_instance_;
class COverlayEnabledMsg;
struct COverlayEnabledMsgDefaultTypeInternal;
extern COverlayEnabledMsgDefaultTypeInternal _COverlayEnabledMsg_default_instance_;
class CPauseControllerInputMsg;
struct CPauseControllerInputMsgDefaultTypeInternal;
extern CPauseControllerInputMsgDefaultTypeInternal _CPauseControllerInputMsg_default_instance_;
class CPauseMsg;
struct CPauseMsgDefaultTypeInternal;
extern CPauseMsgDefaultTypeInternal _CPauseMsg_default_instance_;
class CQuitRequest;
struct CQuitRequestDefaultTypeInternal;
extern CQuitRequestDefaultTypeInternal _CQuitRequest_default_instance_;
class CRecordedInput;
struct CRecordedInputDefaultTypeInternal;
extern CRecordedInputDefaultTypeInternal _CRecordedInput_default_instance_;
class CRecordedInputStream;
struct CRecordedInputStreamDefaultTypeInternal;
extern CRecordedInputStreamDefaultTypeInternal _CRecordedInputStream_default_instance_;
class CRemoteHIDMsg;
struct CRemoteHIDMsgDefaultTypeInternal;
extern CRemoteHIDMsgDefaultTypeInternal _CRemoteHIDMsg_default_instance_;
class CRemotePlayTogetherGroupUpdateMsg;
struct CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal;
extern CRemotePlayTogetherGroupUpdateMsgDefaultTypeInternal _CRemotePlayTogetherGroupUpdateMsg_default_instance_;
class CRemotePlayTogetherGroupUpdateMsg_Player;
struct CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal;
extern CRemotePlayTogetherGroupUpdateMsg_PlayerDefaultTypeInternal _CRemotePlayTogetherGroupUpdateMsg_Player_default_instance_;
class CResumeControllerInputMsg;
struct CResumeControllerInputMsgDefaultTypeInternal;
extern CResumeControllerInputMsgDefaultTypeInternal _CResumeControllerInputMsg_default_instance_;
class CResumeMsg;
struct CResumeMsgDefaultTypeInternal;
extern CResumeMsgDefaultTypeInternal _CResumeMsg_default_instance_;
class CSaveTouchConfigLayoutMsg;
struct CSaveTouchConfigLayoutMsgDefaultTypeInternal;
extern CSaveTouchConfigLayoutMsgDefaultTypeInternal _CSaveTouchConfigLayoutMsg_default_instance_;
class CServerHandshakeMsg;
struct CServerHandshakeMsgDefaultTypeInternal;
extern CServerHandshakeMsgDefaultTypeInternal _CServerHandshakeMsg_default_instance_;
class CSetActivityMsg;
struct CSetActivityMsgDefaultTypeInternal;
extern CSetActivityMsgDefaultTypeInternal _CSetActivityMsg_default_instance_;
class CSetBitrateOverrideMsg;
struct CSetBitrateOverrideMsgDefaultTypeInternal;
extern CSetBitrateOverrideMsgDefaultTypeInternal _CSetBitrateOverrideMsg_default_instance_;
class CSetCapslockMsg;
struct CSetCapslockMsgDefaultTypeInternal;
extern CSetCapslockMsgDefaultTypeInternal _CSetCapslockMsg_default_instance_;
class CSetCaptureSizeMsg;
struct CSetCaptureSizeMsgDefaultTypeInternal;
extern CSetCaptureSizeMsgDefaultTypeInternal _CSetCaptureSizeMsg_default_instance_;
class CSetCursorImageMsg;
struct CSetCursorImageMsgDefaultTypeInternal;
extern CSetCursorImageMsgDefaultTypeInternal _CSetCursorImageMsg_default_instance_;
class CSetCursorMsg;
struct CSetCursorMsgDefaultTypeInternal;
extern CSetCursorMsgDefaultTypeInternal _CSetCursorMsg_default_instance_;
class CSetFlashStateMsg;
struct CSetFlashStateMsgDefaultTypeInternal;
extern CSetFlashStateMsgDefaultTypeInternal _CSetFlashStateMsg_default_instance_;
class CSetGammaRampMsg;
struct CSetGammaRampMsgDefaultTypeInternal;
extern CSetGammaRampMsgDefaultTypeInternal _CSetGammaRampMsg_default_instance_;
class CSetIconMsg;
struct CSetIconMsgDefaultTypeInternal;
extern CSetIconMsgDefaultTypeInternal _CSetIconMsg_default_instance_;
class CSetInputTemporarilyDisabledMsg;
struct CSetInputTemporarilyDisabledMsgDefaultTypeInternal;
extern CSetInputTemporarilyDisabledMsgDefaultTypeInternal _CSetInputTemporarilyDisabledMsg_default_instance_;
class CSetKeymapMsg;
struct CSetKeymapMsgDefaultTypeInternal;
extern CSetKeymapMsgDefaultTypeInternal _CSetKeymapMsg_default_instance_;
class CSetQoSMsg;
struct CSetQoSMsgDefaultTypeInternal;
extern CSetQoSMsgDefaultTypeInternal _CSetQoSMsg_default_instance_;
class CSetQualityOverrideMsg;
struct CSetQualityOverrideMsgDefaultTypeInternal;
extern CSetQualityOverrideMsgDefaultTypeInternal _CSetQualityOverrideMsg_default_instance_;
class CSetSpectatorModeMsg;
struct CSetSpectatorModeMsgDefaultTypeInternal;
extern CSetSpectatorModeMsgDefaultTypeInternal _CSetSpectatorModeMsg_default_instance_;
class CSetStreamingClientConfig;
struct CSetStreamingClientConfigDefaultTypeInternal;
extern CSetStreamingClientConfigDefaultTypeInternal _CSetStreamingClientConfig_default_instance_;
class CSetTargetBitrateMsg;
struct CSetTargetBitrateMsgDefaultTypeInternal;
extern CSetTargetBitrateMsgDefaultTypeInternal _CSetTargetBitrateMsg_default_instance_;
class CSetTargetFramerateMsg;
struct CSetTargetFramerateMsgDefaultTypeInternal;
extern CSetTargetFramerateMsgDefaultTypeInternal _CSetTargetFramerateMsg_default_instance_;
class CSetTitleMsg;
struct CSetTitleMsgDefaultTypeInternal;
extern CSetTitleMsgDefaultTypeInternal _CSetTitleMsg_default_instance_;
class CSetTouchConfigDataMsg;
struct CSetTouchConfigDataMsgDefaultTypeInternal;
extern CSetTouchConfigDataMsgDefaultTypeInternal _CSetTouchConfigDataMsg_default_instance_;
class CSetTouchIconDataMsg;
struct CSetTouchIconDataMsgDefaultTypeInternal;
extern CSetTouchIconDataMsgDefaultTypeInternal _CSetTouchIconDataMsg_default_instance_;
class CShowCursorMsg;
struct CShowCursorMsgDefaultTypeInternal;
extern CShowCursorMsgDefaultTypeInternal _CShowCursorMsg_default_instance_;
class CShowOnScreenKeyboardMsg;
struct CShowOnScreenKeyboardMsgDefaultTypeInternal;
extern CShowOnScreenKeyboardMsgDefaultTypeInternal _CShowOnScreenKeyboardMsg_default_instance_;
class CStartAudioDataMsg;
struct CStartAudioDataMsgDefaultTypeInternal;
extern CStartAudioDataMsgDefaultTypeInternal _CStartAudioDataMsg_default_instance_;
class CStartNeptuneDataMsg;
struct CStartNeptuneDataMsgDefaultTypeInternal;
extern CStartNeptuneDataMsgDefaultTypeInternal _CStartNeptuneDataMsg_default_instance_;
class CStartNetworkTestMsg;
struct CStartNetworkTestMsgDefaultTypeInternal;
extern CStartNetworkTestMsgDefaultTypeInternal _CStartNetworkTestMsg_default_instance_;
class CStartVideoDataMsg;
struct CStartVideoDataMsgDefaultTypeInternal;
extern CStartVideoDataMsgDefaultTypeInternal _CStartVideoDataMsg_default_instance_;
class CStopAudioDataMsg;
struct CStopAudioDataMsgDefaultTypeInternal;
extern CStopAudioDataMsgDefaultTypeInternal _CStopAudioDataMsg_default_instance_;
class CStopNeptuneDataMsg;
struct CStopNeptuneDataMsgDefaultTypeInternal;
extern CStopNeptuneDataMsgDefaultTypeInternal _CStopNeptuneDataMsg_default_instance_;
class CStopRequest;
struct CStopRequestDefaultTypeInternal;
extern CStopRequestDefaultTypeInternal _CStopRequest_default_instance_;
class CStopVideoDataMsg;
struct CStopVideoDataMsgDefaultTypeInternal;
extern CStopVideoDataMsgDefaultTypeInternal _CStopVideoDataMsg_default_instance_;
class CStreamDataLostMsg;
struct CStreamDataLostMsgDefaultTypeInternal;
extern CStreamDataLostMsgDefaultTypeInternal _CStreamDataLostMsg_default_instance_;
class CStreamVideoMode;
struct CStreamVideoModeDefaultTypeInternal;
extern CStreamVideoModeDefaultTypeInternal _CStreamVideoMode_default_instance_;
class CStreamingClientCaps;
struct CStreamingClientCapsDefaultTypeInternal;
extern CStreamingClientCapsDefaultTypeInternal _CStreamingClientCaps_default_instance_;
class CStreamingClientConfig;
struct CStreamingClientConfigDefaultTypeInternal;
extern CStreamingClientConfigDefaultTypeInternal _CStreamingClientConfig_default_instance_;
class CStreamingClientHandshakeInfo;
struct CStreamingClientHandshakeInfoDefaultTypeInternal;
extern CStreamingClientHandshakeInfoDefaultTypeInternal _CStreamingClientHandshakeInfo_default_instance_;
class CStreamingKeymap;
struct CStreamingKeymapDefaultTypeInternal;
extern CStreamingKeymapDefaultTypeInternal _CStreamingKeymap_default_instance_;
class CStreamingKeymapEntry;
struct CStreamingKeymapEntryDefaultTypeInternal;
extern CStreamingKeymapEntryDefaultTypeInternal _CStreamingKeymapEntry_default_instance_;
class CStreamingServerConfig;
struct CStreamingServerConfigDefaultTypeInternal;
extern CStreamingServerConfigDefaultTypeInternal _CStreamingServerConfig_default_instance_;
class CStreamingServerHandshakeInfo;
struct CStreamingServerHandshakeInfoDefaultTypeInternal;
extern CStreamingServerHandshakeInfoDefaultTypeInternal _CStreamingServerHandshakeInfo_default_instance_;
class CStreamingSessionStats;
struct CStreamingSessionStatsDefaultTypeInternal;
extern CStreamingSessionStatsDefaultTypeInternal _CStreamingSessionStats_default_instance_;
class CSystemSuspendMsg;
struct CSystemSuspendMsgDefaultTypeInternal;
extern CSystemSuspendMsgDefaultTypeInternal _CSystemSuspendMsg_default_instance_;
class CToggleMagnificationMsg;
struct CToggleMagnificationMsgDefaultTypeInternal;
extern CToggleMagnificationMsgDefaultTypeInternal _CToggleMagnificationMsg_default_instance_;
class CTouchActionSetActiveMsg;
struct CTouchActionSetActiveMsgDefaultTypeInternal;
extern CTouchActionSetActiveMsgDefaultTypeInternal _CTouchActionSetActiveMsg_default_instance_;
class CTouchActionSetLayerAddedMsg;
struct CTouchActionSetLayerAddedMsgDefaultTypeInternal;
extern CTouchActionSetLayerAddedMsgDefaultTypeInternal _CTouchActionSetLayerAddedMsg_default_instance_;
class CTouchActionSetLayerRemovedMsg;
struct CTouchActionSetLayerRemovedMsgDefaultTypeInternal;
extern CTouchActionSetLayerRemovedMsgDefaultTypeInternal _CTouchActionSetLayerRemovedMsg_default_instance_;
class CTouchConfigActiveMsg;
struct CTouchConfigActiveMsgDefaultTypeInternal;
extern CTouchConfigActiveMsgDefaultTypeInternal _CTouchConfigActiveMsg_default_instance_;
class CTransportSignalMsg;
struct CTransportSignalMsgDefaultTypeInternal;
extern CTransportSignalMsgDefaultTypeInternal _CTransportSignalMsg_default_instance_;
class CTransportSignalMsg_WebRTCMessage;
struct CTransportSignalMsg_WebRTCMessageDefaultTypeInternal;
extern CTransportSignalMsg_WebRTCMessageDefaultTypeInternal _CTransportSignalMsg_WebRTCMessage_default_instance_;
class CTransportSignalMsg_WebRTCMessage_Candidate;
struct CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal;
extern CTransportSignalMsg_WebRTCMessage_CandidateDefaultTypeInternal _CTransportSignalMsg_WebRTCMessage_Candidate_default_instance_;
class CVideoDecoderInfoMsg;
struct CVideoDecoderInfoMsgDefaultTypeInternal;
extern CVideoDecoderInfoMsgDefaultTypeInternal _CVideoDecoderInfoMsg_default_instance_;
class CVideoEncoderInfoMsg;
struct CVideoEncoderInfoMsgDefaultTypeInternal;
extern CVideoEncoderInfoMsgDefaultTypeInternal _CVideoEncoderInfoMsg_default_instance_;
class CVideoFormat;
struct CVideoFormatDefaultTypeInternal;
extern CVideoFormatDefaultTypeInternal _CVideoFormat_default_instance_;
class CVirtualHereReadyMsg;
struct CVirtualHereReadyMsgDefaultTypeInternal;
extern CVirtualHereReadyMsgDefaultTypeInternal _CVirtualHereReadyMsg_default_instance_;
class CVirtualHereRequestMsg;
struct CVirtualHereRequestMsgDefaultTypeInternal;
extern CVirtualHereRequestMsgDefaultTypeInternal _CVirtualHereRequestMsg_default_instance_;
class CVirtualHereShareDeviceMsg;
struct CVirtualHereShareDeviceMsgDefaultTypeInternal;
extern CVirtualHereShareDeviceMsgDefaultTypeInternal _CVirtualHereShareDeviceMsg_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::CAudioFormat* Arena::CreateMaybeMessage<::CAudioFormat>(Arena*);
template<> ::CAuthenticationRequestMsg* Arena::CreateMaybeMessage<::CAuthenticationRequestMsg>(Arena*);
template<> ::CAuthenticationResponseMsg* Arena::CreateMaybeMessage<::CAuthenticationResponseMsg>(Arena*);
template<> ::CClientHandshakeMsg* Arena::CreateMaybeMessage<::CClientHandshakeMsg>(Arena*);
template<> ::CControllerConfigMsg* Arena::CreateMaybeMessage<::CControllerConfigMsg>(Arena*);
template<> ::CControllerConfigMsg_ControllerActiveConfigChangeResponse* Arena::CreateMaybeMessage<::CControllerConfigMsg_ControllerActiveConfigChangeResponse>(Arena*);
template<> ::CControllerConfigMsg_ControllerActiveConfigMsg* Arena::CreateMaybeMessage<::CControllerConfigMsg_ControllerActiveConfigMsg>(Arena*);
template<> ::CControllerConfigMsg_ControllerConfigResponse* Arena::CreateMaybeMessage<::CControllerConfigMsg_ControllerConfigResponse>(Arena*);
template<> ::CControllerConfigMsg_ControllerPersonalizationResponse* Arena::CreateMaybeMessage<::CControllerConfigMsg_ControllerPersonalizationResponse>(Arena*);
template<> ::CControllerPersonalizationUpdateMsg* Arena::CreateMaybeMessage<::CControllerPersonalizationUpdateMsg>(Arena*);
template<> ::CDebugDumpMsg* Arena::CreateMaybeMessage<::CDebugDumpMsg>(Arena*);
template<> ::CDeleteCursorMsg* Arena::CreateMaybeMessage<::CDeleteCursorMsg>(Arena*);
template<> ::CDisableHighResCaptureMsg* Arena::CreateMaybeMessage<::CDisableHighResCaptureMsg>(Arena*);
template<> ::CDisableNeptuneDataMsg* Arena::CreateMaybeMessage<::CDisableNeptuneDataMsg>(Arena*);
template<> ::CDiscoveryPingRequest* Arena::CreateMaybeMessage<::CDiscoveryPingRequest>(Arena*);
template<> ::CDiscoveryPingResponse* Arena::CreateMaybeMessage<::CDiscoveryPingResponse>(Arena*);
template<> ::CEnableHighResCaptureMsg* Arena::CreateMaybeMessage<::CEnableHighResCaptureMsg>(Arena*);
template<> ::CEnableNeptuneDataMsg* Arena::CreateMaybeMessage<::CEnableNeptuneDataMsg>(Arena*);
template<> ::CFrameEvent* Arena::CreateMaybeMessage<::CFrameEvent>(Arena*);
template<> ::CFrameStatAccumulatedValue* Arena::CreateMaybeMessage<::CFrameStatAccumulatedValue>(Arena*);
template<> ::CFrameStats* Arena::CreateMaybeMessage<::CFrameStats>(Arena*);
template<> ::CFrameStatsListMsg* Arena::CreateMaybeMessage<::CFrameStatsListMsg>(Arena*);
template<> ::CGetCursorImageMsg* Arena::CreateMaybeMessage<::CGetCursorImageMsg>(Arena*);
template<> ::CGetTouchConfigDataMsg* Arena::CreateMaybeMessage<::CGetTouchConfigDataMsg>(Arena*);
template<> ::CGetTouchIconDataMsg* Arena::CreateMaybeMessage<::CGetTouchIconDataMsg>(Arena*);
template<> ::CHideCursorMsg* Arena::CreateMaybeMessage<::CHideCursorMsg>(Arena*);
template<> ::CInputKeyDownMsg* Arena::CreateMaybeMessage<::CInputKeyDownMsg>(Arena*);
template<> ::CInputKeyUpMsg* Arena::CreateMaybeMessage<::CInputKeyUpMsg>(Arena*);
template<> ::CInputLatencyTestMsg* Arena::CreateMaybeMessage<::CInputLatencyTestMsg>(Arena*);
template<> ::CInputMouseDownMsg* Arena::CreateMaybeMessage<::CInputMouseDownMsg>(Arena*);
template<> ::CInputMouseMotionMsg* Arena::CreateMaybeMessage<::CInputMouseMotionMsg>(Arena*);
template<> ::CInputMouseUpMsg* Arena::CreateMaybeMessage<::CInputMouseUpMsg>(Arena*);
template<> ::CInputMouseWheelMsg* Arena::CreateMaybeMessage<::CInputMouseWheelMsg>(Arena*);
template<> ::CInputTextMsg* Arena::CreateMaybeMessage<::CInputTextMsg>(Arena*);
template<> ::CInputTouchFingerDownMsg* Arena::CreateMaybeMessage<::CInputTouchFingerDownMsg>(Arena*);
template<> ::CInputTouchFingerMotionMsg* Arena::CreateMaybeMessage<::CInputTouchFingerMotionMsg>(Arena*);
template<> ::CInputTouchFingerUpMsg* Arena::CreateMaybeMessage<::CInputTouchFingerUpMsg>(Arena*);
template<> ::CKeepAliveMsg* Arena::CreateMaybeMessage<::CKeepAliveMsg>(Arena*);
template<> ::CLogMsg* Arena::CreateMaybeMessage<::CLogMsg>(Arena*);
template<> ::CLogUploadMsg* Arena::CreateMaybeMessage<::CLogUploadMsg>(Arena*);
template<> ::CNegotiatedConfig* Arena::CreateMaybeMessage<::CNegotiatedConfig>(Arena*);
template<> ::CNegotiationCompleteMsg* Arena::CreateMaybeMessage<::CNegotiationCompleteMsg>(Arena*);
template<> ::CNegotiationInitMsg* Arena::CreateMaybeMessage<::CNegotiationInitMsg>(Arena*);
template<> ::CNegotiationSetConfigMsg* Arena::CreateMaybeMessage<::CNegotiationSetConfigMsg>(Arena*);
template<> ::COverlayEnabledMsg* Arena::CreateMaybeMessage<::COverlayEnabledMsg>(Arena*);
template<> ::CPauseControllerInputMsg* Arena::CreateMaybeMessage<::CPauseControllerInputMsg>(Arena*);
template<> ::CPauseMsg* Arena::CreateMaybeMessage<::CPauseMsg>(Arena*);
template<> ::CQuitRequest* Arena::CreateMaybeMessage<::CQuitRequest>(Arena*);
template<> ::CRecordedInput* Arena::CreateMaybeMessage<::CRecordedInput>(Arena*);
template<> ::CRecordedInputStream* Arena::CreateMaybeMessage<::CRecordedInputStream>(Arena*);
template<> ::CRemoteHIDMsg* Arena::CreateMaybeMessage<::CRemoteHIDMsg>(Arena*);
template<> ::CRemotePlayTogetherGroupUpdateMsg* Arena::CreateMaybeMessage<::CRemotePlayTogetherGroupUpdateMsg>(Arena*);
template<> ::CRemotePlayTogetherGroupUpdateMsg_Player* Arena::CreateMaybeMessage<::CRemotePlayTogetherGroupUpdateMsg_Player>(Arena*);
template<> ::CResumeControllerInputMsg* Arena::CreateMaybeMessage<::CResumeControllerInputMsg>(Arena*);
template<> ::CResumeMsg* Arena::CreateMaybeMessage<::CResumeMsg>(Arena*);
template<> ::CSaveTouchConfigLayoutMsg* Arena::CreateMaybeMessage<::CSaveTouchConfigLayoutMsg>(Arena*);
template<> ::CServerHandshakeMsg* Arena::CreateMaybeMessage<::CServerHandshakeMsg>(Arena*);
template<> ::CSetActivityMsg* Arena::CreateMaybeMessage<::CSetActivityMsg>(Arena*);
template<> ::CSetBitrateOverrideMsg* Arena::CreateMaybeMessage<::CSetBitrateOverrideMsg>(Arena*);
template<> ::CSetCapslockMsg* Arena::CreateMaybeMessage<::CSetCapslockMsg>(Arena*);
template<> ::CSetCaptureSizeMsg* Arena::CreateMaybeMessage<::CSetCaptureSizeMsg>(Arena*);
template<> ::CSetCursorImageMsg* Arena::CreateMaybeMessage<::CSetCursorImageMsg>(Arena*);
template<> ::CSetCursorMsg* Arena::CreateMaybeMessage<::CSetCursorMsg>(Arena*);
template<> ::CSetFlashStateMsg* Arena::CreateMaybeMessage<::CSetFlashStateMsg>(Arena*);
template<> ::CSetGammaRampMsg* Arena::CreateMaybeMessage<::CSetGammaRampMsg>(Arena*);
template<> ::CSetIconMsg* Arena::CreateMaybeMessage<::CSetIconMsg>(Arena*);
template<> ::CSetInputTemporarilyDisabledMsg* Arena::CreateMaybeMessage<::CSetInputTemporarilyDisabledMsg>(Arena*);
template<> ::CSetKeymapMsg* Arena::CreateMaybeMessage<::CSetKeymapMsg>(Arena*);
template<> ::CSetQoSMsg* Arena::CreateMaybeMessage<::CSetQoSMsg>(Arena*);
template<> ::CSetQualityOverrideMsg* Arena::CreateMaybeMessage<::CSetQualityOverrideMsg>(Arena*);
template<> ::CSetSpectatorModeMsg* Arena::CreateMaybeMessage<::CSetSpectatorModeMsg>(Arena*);
template<> ::CSetStreamingClientConfig* Arena::CreateMaybeMessage<::CSetStreamingClientConfig>(Arena*);
template<> ::CSetTargetBitrateMsg* Arena::CreateMaybeMessage<::CSetTargetBitrateMsg>(Arena*);
template<> ::CSetTargetFramerateMsg* Arena::CreateMaybeMessage<::CSetTargetFramerateMsg>(Arena*);
template<> ::CSetTitleMsg* Arena::CreateMaybeMessage<::CSetTitleMsg>(Arena*);
template<> ::CSetTouchConfigDataMsg* Arena::CreateMaybeMessage<::CSetTouchConfigDataMsg>(Arena*);
template<> ::CSetTouchIconDataMsg* Arena::CreateMaybeMessage<::CSetTouchIconDataMsg>(Arena*);
template<> ::CShowCursorMsg* Arena::CreateMaybeMessage<::CShowCursorMsg>(Arena*);
template<> ::CShowOnScreenKeyboardMsg* Arena::CreateMaybeMessage<::CShowOnScreenKeyboardMsg>(Arena*);
template<> ::CStartAudioDataMsg* Arena::CreateMaybeMessage<::CStartAudioDataMsg>(Arena*);
template<> ::CStartNeptuneDataMsg* Arena::CreateMaybeMessage<::CStartNeptuneDataMsg>(Arena*);
template<> ::CStartNetworkTestMsg* Arena::CreateMaybeMessage<::CStartNetworkTestMsg>(Arena*);
template<> ::CStartVideoDataMsg* Arena::CreateMaybeMessage<::CStartVideoDataMsg>(Arena*);
template<> ::CStopAudioDataMsg* Arena::CreateMaybeMessage<::CStopAudioDataMsg>(Arena*);
template<> ::CStopNeptuneDataMsg* Arena::CreateMaybeMessage<::CStopNeptuneDataMsg>(Arena*);
template<> ::CStopRequest* Arena::CreateMaybeMessage<::CStopRequest>(Arena*);
template<> ::CStopVideoDataMsg* Arena::CreateMaybeMessage<::CStopVideoDataMsg>(Arena*);
template<> ::CStreamDataLostMsg* Arena::CreateMaybeMessage<::CStreamDataLostMsg>(Arena*);
template<> ::CStreamVideoMode* Arena::CreateMaybeMessage<::CStreamVideoMode>(Arena*);
template<> ::CStreamingClientCaps* Arena::CreateMaybeMessage<::CStreamingClientCaps>(Arena*);
template<> ::CStreamingClientConfig* Arena::CreateMaybeMessage<::CStreamingClientConfig>(Arena*);
template<> ::CStreamingClientHandshakeInfo* Arena::CreateMaybeMessage<::CStreamingClientHandshakeInfo>(Arena*);
template<> ::CStreamingKeymap* Arena::CreateMaybeMessage<::CStreamingKeymap>(Arena*);
template<> ::CStreamingKeymapEntry* Arena::CreateMaybeMessage<::CStreamingKeymapEntry>(Arena*);
template<> ::CStreamingServerConfig* Arena::CreateMaybeMessage<::CStreamingServerConfig>(Arena*);
template<> ::CStreamingServerHandshakeInfo* Arena::CreateMaybeMessage<::CStreamingServerHandshakeInfo>(Arena*);
template<> ::CStreamingSessionStats* Arena::CreateMaybeMessage<::CStreamingSessionStats>(Arena*);
template<> ::CSystemSuspendMsg* Arena::CreateMaybeMessage<::CSystemSuspendMsg>(Arena*);
template<> ::CToggleMagnificationMsg* Arena::CreateMaybeMessage<::CToggleMagnificationMsg>(Arena*);
template<> ::CTouchActionSetActiveMsg* Arena::CreateMaybeMessage<::CTouchActionSetActiveMsg>(Arena*);
template<> ::CTouchActionSetLayerAddedMsg* Arena::CreateMaybeMessage<::CTouchActionSetLayerAddedMsg>(Arena*);
template<> ::CTouchActionSetLayerRemovedMsg* Arena::CreateMaybeMessage<::CTouchActionSetLayerRemovedMsg>(Arena*);
template<> ::CTouchConfigActiveMsg* Arena::CreateMaybeMessage<::CTouchConfigActiveMsg>(Arena*);
template<> ::CTransportSignalMsg* Arena::CreateMaybeMessage<::CTransportSignalMsg>(Arena*);
template<> ::CTransportSignalMsg_WebRTCMessage* Arena::CreateMaybeMessage<::CTransportSignalMsg_WebRTCMessage>(Arena*);
template<> ::CTransportSignalMsg_WebRTCMessage_Candidate* Arena::CreateMaybeMessage<::CTransportSignalMsg_WebRTCMessage_Candidate>(Arena*);
template<> ::CVideoDecoderInfoMsg* Arena::CreateMaybeMessage<::CVideoDecoderInfoMsg>(Arena*);
template<> ::CVideoEncoderInfoMsg* Arena::CreateMaybeMessage<::CVideoEncoderInfoMsg>(Arena*);
template<> ::CVideoFormat* Arena::CreateMaybeMessage<::CVideoFormat>(Arena*);
template<> ::CVirtualHereReadyMsg* Arena::CreateMaybeMessage<::CVirtualHereReadyMsg>(Arena*);
template<> ::CVirtualHereRequestMsg* Arena::CreateMaybeMessage<::CVirtualHereRequestMsg>(Arena*);
template<> ::CVirtualHereShareDeviceMsg* Arena::CreateMaybeMessage<::CVirtualHereShareDeviceMsg>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum CAuthenticationResponseMsg_AuthenticationResult : int {
  CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED = 0,
  CAuthenticationResponseMsg_AuthenticationResult_FAILED = 1
};
bool CAuthenticationResponseMsg_AuthenticationResult_IsValid(int value);
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MIN = CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED;
constexpr CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX = CAuthenticationResponseMsg_AuthenticationResult_FAILED;
constexpr int CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_ARRAYSIZE = CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CAuthenticationResponseMsg_AuthenticationResult_descriptor();
template<typename T>
inline const std::string& CAuthenticationResponseMsg_AuthenticationResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CAuthenticationResponseMsg_AuthenticationResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CAuthenticationResponseMsg_AuthenticationResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    CAuthenticationResponseMsg_AuthenticationResult_descriptor(), enum_t_value);
}
inline bool CAuthenticationResponseMsg_AuthenticationResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CAuthenticationResponseMsg_AuthenticationResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<CAuthenticationResponseMsg_AuthenticationResult>(
    CAuthenticationResponseMsg_AuthenticationResult_descriptor(), name, value);
}
enum EStreamChannel : int {
  k_EStreamChannelInvalid = -1,
  k_EStreamChannelDiscovery = 0,
  k_EStreamChannelControl = 1,
  k_EStreamChannelStats = 2,
  k_EStreamChannelDataChannelStart = 3
};
bool EStreamChannel_IsValid(int value);
constexpr EStreamChannel EStreamChannel_MIN = k_EStreamChannelInvalid;
constexpr EStreamChannel EStreamChannel_MAX = k_EStreamChannelDataChannelStart;
constexpr int EStreamChannel_ARRAYSIZE = EStreamChannel_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamChannel_descriptor();
template<typename T>
inline const std::string& EStreamChannel_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamChannel>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamChannel_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamChannel_descriptor(), enum_t_value);
}
inline bool EStreamChannel_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamChannel* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamChannel>(
    EStreamChannel_descriptor(), name, value);
}
enum EStreamDiscoveryMessage : int {
  k_EStreamDiscoveryPingRequest = 1,
  k_EStreamDiscoveryPingResponse = 2
};
bool EStreamDiscoveryMessage_IsValid(int value);
constexpr EStreamDiscoveryMessage EStreamDiscoveryMessage_MIN = k_EStreamDiscoveryPingRequest;
constexpr EStreamDiscoveryMessage EStreamDiscoveryMessage_MAX = k_EStreamDiscoveryPingResponse;
constexpr int EStreamDiscoveryMessage_ARRAYSIZE = EStreamDiscoveryMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDiscoveryMessage_descriptor();
template<typename T>
inline const std::string& EStreamDiscoveryMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamDiscoveryMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamDiscoveryMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamDiscoveryMessage_descriptor(), enum_t_value);
}
inline bool EStreamDiscoveryMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamDiscoveryMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamDiscoveryMessage>(
    EStreamDiscoveryMessage_descriptor(), name, value);
}
enum EStreamControlMessage : int {
  k_EStreamControlAuthenticationRequest = 1,
  k_EStreamControlAuthenticationResponse = 2,
  k_EStreamControlNegotiationInit = 3,
  k_EStreamControlNegotiationSetConfig = 4,
  k_EStreamControlNegotiationComplete = 5,
  k_EStreamControlClientHandshake = 6,
  k_EStreamControlServerHandshake = 7,
  k_EStreamControlStartNetworkTest = 8,
  k_EStreamControlKeepAlive = 9,
  k_EStreamControl_LAST_SETUP_MESSAGE = 15,
  k_EStreamControlStartAudioData = 50,
  k_EStreamControlStopAudioData = 51,
  k_EStreamControlStartVideoData = 52,
  k_EStreamControlStopVideoData = 53,
  k_EStreamControlInputMouseMotion = 54,
  k_EStreamControlInputMouseWheel = 55,
  k_EStreamControlInputMouseDown = 56,
  k_EStreamControlInputMouseUp = 57,
  k_EStreamControlInputKeyDown = 58,
  k_EStreamControlInputKeyUp = 59,
  k_EStreamControlInputGamepadAttached_OBSOLETE = 60,
  k_EStreamControlInputGamepadEvent_OBSOLETE = 61,
  k_EStreamControlInputGamepadDetached_OBSOLETE = 62,
  k_EStreamControlShowCursor = 63,
  k_EStreamControlHideCursor = 64,
  k_EStreamControlSetCursor = 65,
  k_EStreamControlGetCursorImage = 66,
  k_EStreamControlSetCursorImage = 67,
  k_EStreamControlDeleteCursor = 68,
  k_EStreamControlSetTargetFramerate = 69,
  k_EStreamControlInputLatencyTest = 70,
  k_EStreamControlGamepadRumble_OBSOLETE = 71,
  k_EStreamControlOverlayEnabled = 74,
  k_EStreamControlInputControllerAttached_OBSOLETE = 75,
  k_EStreamControlInputControllerState_OBSOLETE = 76,
  k_EStreamControlTriggerHapticPulse_OBSOLETE = 77,
  k_EStreamControlInputControllerDetached_OBSOLETE = 78,
  k_EStreamControlVideoDecoderInfo = 80,
  k_EStreamControlSetTitle = 81,
  k_EStreamControlSetIcon = 82,
  k_EStreamControlQuitRequest = 83,
  k_EStreamControlSetQoS = 87,
  k_EStreamControlInputControllerWirelessPresence_OBSOLETE = 88,
  k_EStreamControlSetGammaRamp = 89,
  k_EStreamControlVideoEncoderInfo = 90,
  k_EStreamControlInputControllerStateHID_OBSOLETE = 93,
  k_EStreamControlSetTargetBitrate = 94,
  k_EStreamControlSetControllerPairingEnabled_OBSOLETE = 95,
  k_EStreamControlSetControllerPairingResult_OBSOLETE = 96,
  k_EStreamControlTriggerControllerDisconnect_OBSOLETE = 97,
  k_EStreamControlSetActivity = 98,
  k_EStreamControlSetStreamingClientConfig = 99,
  k_EStreamControlSystemSuspend = 100,
  k_EStreamControlSetControllerSettings_OBSOLETE = 101,
  k_EStreamControlVirtualHereRequest = 102,
  k_EStreamControlVirtualHereReady = 103,
  k_EStreamControlVirtualHereShareDevice = 104,
  k_EStreamControlSetSpectatorMode = 105,
  k_EStreamControlRemoteHID = 106,
  k_EStreamControlStartMicrophoneData = 107,
  k_EStreamControlStopMicrophoneData = 108,
  k_EStreamControlInputText = 109,
  k_EStreamControlTouchConfigActive = 110,
  k_EStreamControlGetTouchConfigData = 111,
  k_EStreamControlSetTouchConfigData = 112,
  k_EStreamControlSaveTouchConfigLayout = 113,
  k_EStreamControlTouchActionSetActive = 114,
  k_EStreamControlGetTouchIconData = 115,
  k_EStreamControlSetTouchIconData = 116,
  k_EStreamControlInputTouchFingerDown = 117,
  k_EStreamControlInputTouchFingerMotion = 118,
  k_EStreamControlInputTouchFingerUp = 119,
  k_EStreamControlSetCaptureSize = 120,
  k_EStreamControlSetFlashState = 121,
  k_EStreamControlPause = 122,
  k_EStreamControlResume = 123,
  k_EStreamControlEnableHighResCapture = 124,
  k_EStreamControlDisableHighResCapture = 125,
  k_EStreamControlToggleMagnification = 126,
  k_EStreamControlSetCapslock = 127,
  k_EStreamControlSetKeymap = 128,
  k_EStreamControlStopRequest = 129,
  k_EStreamControlTouchActionSetLayerAdded = 130,
  k_EStreamControlTouchActionSetLayerRemoved = 131,
  k_EStreamControlRemotePlayTogetherGroupUpdate = 132,
  k_EStreamControlSetInputTemporarilyDisabled = 133,
  k_EStreamControlSetQualityOverride = 134,
  k_EStreamControlSetBitrateOverride = 135,
  k_EStreamControlShowOnScreenKeyboard = 136,
  k_EStreamControlControllerConfigMsg = 137,
  k_EStreamControlControllerPersonalizationUpdate = 138,
  k_EStreamControlEnableNeptuneData = 139,
  k_EStreamControlDisableNeptuneData = 140,
  k_EStreamControlStartNeptuneData = 141,
  k_EStreamControlStopNeptuneData = 142,
  k_EStreamControlPauseControllerInput = 143,
  k_EStreamControlResumeControllerInput = 144
};
bool EStreamControlMessage_IsValid(int value);
constexpr EStreamControlMessage EStreamControlMessage_MIN = k_EStreamControlAuthenticationRequest;
constexpr EStreamControlMessage EStreamControlMessage_MAX = k_EStreamControlResumeControllerInput;
constexpr int EStreamControlMessage_ARRAYSIZE = EStreamControlMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamControlMessage_descriptor();
template<typename T>
inline const std::string& EStreamControlMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamControlMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamControlMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamControlMessage_descriptor(), enum_t_value);
}
inline bool EStreamControlMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamControlMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamControlMessage>(
    EStreamControlMessage_descriptor(), name, value);
}
enum EStreamVersion : int {
  k_EStreamVersionNone = 0,
  k_EStreamVersionCurrent = 1
};
bool EStreamVersion_IsValid(int value);
constexpr EStreamVersion EStreamVersion_MIN = k_EStreamVersionNone;
constexpr EStreamVersion EStreamVersion_MAX = k_EStreamVersionCurrent;
constexpr int EStreamVersion_ARRAYSIZE = EStreamVersion_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamVersion_descriptor();
template<typename T>
inline const std::string& EStreamVersion_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamVersion>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamVersion_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamVersion_descriptor(), enum_t_value);
}
inline bool EStreamVersion_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamVersion* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamVersion>(
    EStreamVersion_descriptor(), name, value);
}
enum EStreamAudioCodec : int {
  k_EStreamAudioCodecNone = 0,
  k_EStreamAudioCodecRaw = 1,
  k_EStreamAudioCodecVorbis = 2,
  k_EStreamAudioCodecOpus = 3,
  k_EStreamAudioCodecMP3 = 4,
  k_EStreamAudioCodecAAC = 5
};
bool EStreamAudioCodec_IsValid(int value);
constexpr EStreamAudioCodec EStreamAudioCodec_MIN = k_EStreamAudioCodecNone;
constexpr EStreamAudioCodec EStreamAudioCodec_MAX = k_EStreamAudioCodecAAC;
constexpr int EStreamAudioCodec_ARRAYSIZE = EStreamAudioCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamAudioCodec_descriptor();
template<typename T>
inline const std::string& EStreamAudioCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamAudioCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamAudioCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamAudioCodec_descriptor(), enum_t_value);
}
inline bool EStreamAudioCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamAudioCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamAudioCodec>(
    EStreamAudioCodec_descriptor(), name, value);
}
enum EStreamVideoCodec : int {
  k_EStreamVideoCodecNone = 0,
  k_EStreamVideoCodecRaw = 1,
  k_EStreamVideoCodecVP8 = 2,
  k_EStreamVideoCodecVP9 = 3,
  k_EStreamVideoCodecH264 = 4,
  k_EStreamVideoCodecHEVC = 5,
  k_EStreamVideoCodecORBX1 = 6,
  k_EStreamVideoCodecORBX2 = 7
};
bool EStreamVideoCodec_IsValid(int value);
constexpr EStreamVideoCodec EStreamVideoCodec_MIN = k_EStreamVideoCodecNone;
constexpr EStreamVideoCodec EStreamVideoCodec_MAX = k_EStreamVideoCodecORBX2;
constexpr int EStreamVideoCodec_ARRAYSIZE = EStreamVideoCodec_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamVideoCodec_descriptor();
template<typename T>
inline const std::string& EStreamVideoCodec_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamVideoCodec>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamVideoCodec_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamVideoCodec_descriptor(), enum_t_value);
}
inline bool EStreamVideoCodec_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamVideoCodec* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamVideoCodec>(
    EStreamVideoCodec_descriptor(), name, value);
}
enum EStreamQualityPreference : int {
  k_EStreamQualityAutomatic = -1,
  k_EStreamQualityFast = 1,
  k_EStreamQualityBalanced = 2,
  k_EStreamQualityBeautiful = 3
};
bool EStreamQualityPreference_IsValid(int value);
constexpr EStreamQualityPreference EStreamQualityPreference_MIN = k_EStreamQualityAutomatic;
constexpr EStreamQualityPreference EStreamQualityPreference_MAX = k_EStreamQualityBeautiful;
constexpr int EStreamQualityPreference_ARRAYSIZE = EStreamQualityPreference_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamQualityPreference_descriptor();
template<typename T>
inline const std::string& EStreamQualityPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamQualityPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamQualityPreference_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamQualityPreference_descriptor(), enum_t_value);
}
inline bool EStreamQualityPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamQualityPreference* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamQualityPreference>(
    EStreamQualityPreference_descriptor(), name, value);
}
enum EStreamBitrate : int {
  k_EStreamBitrateAutodetect = -1,
  k_EStreamBitrateUnlimited = 0
};
bool EStreamBitrate_IsValid(int value);
constexpr EStreamBitrate EStreamBitrate_MIN = k_EStreamBitrateAutodetect;
constexpr EStreamBitrate EStreamBitrate_MAX = k_EStreamBitrateUnlimited;
constexpr int EStreamBitrate_ARRAYSIZE = EStreamBitrate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamBitrate_descriptor();
template<typename T>
inline const std::string& EStreamBitrate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamBitrate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamBitrate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamBitrate_descriptor(), enum_t_value);
}
inline bool EStreamBitrate_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamBitrate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamBitrate>(
    EStreamBitrate_descriptor(), name, value);
}
enum EStreamColorspace : int {
  k_EStreamColorspace_Unknown = 0,
  k_EStreamColorspace_BT601 = 1,
  k_EStreamColorspace_BT601_Full = 2,
  k_EStreamColorspace_BT709 = 3,
  k_EStreamColorspace_BT709_Full = 4
};
bool EStreamColorspace_IsValid(int value);
constexpr EStreamColorspace EStreamColorspace_MIN = k_EStreamColorspace_Unknown;
constexpr EStreamColorspace EStreamColorspace_MAX = k_EStreamColorspace_BT709_Full;
constexpr int EStreamColorspace_ARRAYSIZE = EStreamColorspace_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamColorspace_descriptor();
template<typename T>
inline const std::string& EStreamColorspace_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamColorspace>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamColorspace_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamColorspace_descriptor(), enum_t_value);
}
inline bool EStreamColorspace_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamColorspace* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamColorspace>(
    EStreamColorspace_descriptor(), name, value);
}
enum EStreamP2PScope : int {
  k_EStreamP2PScopeAutomatic = 0,
  k_EStreamP2PScopeDisabled = 1,
  k_EStreamP2PScopeOnlyMe = 2,
  k_EStreamP2PScopeFriends = 3,
  k_EStreamP2PScopeEveryone = 4
};
bool EStreamP2PScope_IsValid(int value);
constexpr EStreamP2PScope EStreamP2PScope_MIN = k_EStreamP2PScopeAutomatic;
constexpr EStreamP2PScope EStreamP2PScope_MAX = k_EStreamP2PScopeEveryone;
constexpr int EStreamP2PScope_ARRAYSIZE = EStreamP2PScope_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamP2PScope_descriptor();
template<typename T>
inline const std::string& EStreamP2PScope_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamP2PScope>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamP2PScope_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamP2PScope_descriptor(), enum_t_value);
}
inline bool EStreamP2PScope_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamP2PScope* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamP2PScope>(
    EStreamP2PScope_descriptor(), name, value);
}
enum EStreamHostPlayAudioPreference : int {
  k_EStreamHostPlayAudioDefault = 0,
  k_EStreamHostPlayAudioAlways = 1
};
bool EStreamHostPlayAudioPreference_IsValid(int value);
constexpr EStreamHostPlayAudioPreference EStreamHostPlayAudioPreference_MIN = k_EStreamHostPlayAudioDefault;
constexpr EStreamHostPlayAudioPreference EStreamHostPlayAudioPreference_MAX = k_EStreamHostPlayAudioAlways;
constexpr int EStreamHostPlayAudioPreference_ARRAYSIZE = EStreamHostPlayAudioPreference_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamHostPlayAudioPreference_descriptor();
template<typename T>
inline const std::string& EStreamHostPlayAudioPreference_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamHostPlayAudioPreference>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamHostPlayAudioPreference_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamHostPlayAudioPreference_descriptor(), enum_t_value);
}
inline bool EStreamHostPlayAudioPreference_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamHostPlayAudioPreference* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamHostPlayAudioPreference>(
    EStreamHostPlayAudioPreference_descriptor(), name, value);
}
enum EStreamingDataType : int {
  k_EStreamingAudioData = 0,
  k_EStreamingVideoData = 1,
  k_EStreamingMicrophoneData = 2,
  k_EStreamingNeptuneData = 3
};
bool EStreamingDataType_IsValid(int value);
constexpr EStreamingDataType EStreamingDataType_MIN = k_EStreamingAudioData;
constexpr EStreamingDataType EStreamingDataType_MAX = k_EStreamingNeptuneData;
constexpr int EStreamingDataType_ARRAYSIZE = EStreamingDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamingDataType_descriptor();
template<typename T>
inline const std::string& EStreamingDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamingDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamingDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamingDataType_descriptor(), enum_t_value);
}
inline bool EStreamingDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamingDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamingDataType>(
    EStreamingDataType_descriptor(), name, value);
}
enum EStreamMouseButton : int {
  k_EStreamMouseButtonLeft = 1,
  k_EStreamMouseButtonRight = 2,
  k_EStreamMouseButtonMiddle = 16,
  k_EStreamMouseButtonX1 = 32,
  k_EStreamMouseButtonX2 = 64,
  k_EStreamMouseButtonUnknown = 4096
};
bool EStreamMouseButton_IsValid(int value);
constexpr EStreamMouseButton EStreamMouseButton_MIN = k_EStreamMouseButtonLeft;
constexpr EStreamMouseButton EStreamMouseButton_MAX = k_EStreamMouseButtonUnknown;
constexpr int EStreamMouseButton_ARRAYSIZE = EStreamMouseButton_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamMouseButton_descriptor();
template<typename T>
inline const std::string& EStreamMouseButton_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamMouseButton>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamMouseButton_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamMouseButton_descriptor(), enum_t_value);
}
inline bool EStreamMouseButton_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamMouseButton* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamMouseButton>(
    EStreamMouseButton_descriptor(), name, value);
}
enum EStreamMouseWheelDirection : int {
  k_EStreamMouseWheelUp = 120,
  k_EStreamMouseWheelDown = -120,
  k_EStreamMouseWheelLeft = 3,
  k_EStreamMouseWheelRight = 4
};
bool EStreamMouseWheelDirection_IsValid(int value);
constexpr EStreamMouseWheelDirection EStreamMouseWheelDirection_MIN = k_EStreamMouseWheelDown;
constexpr EStreamMouseWheelDirection EStreamMouseWheelDirection_MAX = k_EStreamMouseWheelUp;
constexpr int EStreamMouseWheelDirection_ARRAYSIZE = EStreamMouseWheelDirection_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamMouseWheelDirection_descriptor();
template<typename T>
inline const std::string& EStreamMouseWheelDirection_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamMouseWheelDirection>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamMouseWheelDirection_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamMouseWheelDirection_descriptor(), enum_t_value);
}
inline bool EStreamMouseWheelDirection_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamMouseWheelDirection* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamMouseWheelDirection>(
    EStreamMouseWheelDirection_descriptor(), name, value);
}
enum EStreamFramerateLimiter : int {
  k_EStreamFramerateSlowCapture = 1,
  k_EStreamFramerateSlowConvert = 2,
  k_EStreamFramerateSlowEncode = 4,
  k_EStreamFramerateSlowNetwork = 8,
  k_EStreamFramerateSlowDecode = 16,
  k_EStreamFramerateSlowGame = 32,
  k_EStreamFramerateSlowDisplay = 64
};
bool EStreamFramerateLimiter_IsValid(int value);
constexpr EStreamFramerateLimiter EStreamFramerateLimiter_MIN = k_EStreamFramerateSlowCapture;
constexpr EStreamFramerateLimiter EStreamFramerateLimiter_MAX = k_EStreamFramerateSlowDisplay;
constexpr int EStreamFramerateLimiter_ARRAYSIZE = EStreamFramerateLimiter_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFramerateLimiter_descriptor();
template<typename T>
inline const std::string& EStreamFramerateLimiter_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamFramerateLimiter>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamFramerateLimiter_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamFramerateLimiter_descriptor(), enum_t_value);
}
inline bool EStreamFramerateLimiter_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamFramerateLimiter* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamFramerateLimiter>(
    EStreamFramerateLimiter_descriptor(), name, value);
}
enum EStreamActivity : int {
  k_EStreamActivityIdle = 1,
  k_EStreamActivityGame = 2,
  k_EStreamActivityDesktop = 3,
  k_EStreamActivitySecureDesktop = 4,
  k_EStreamActivityMusic = 5
};
bool EStreamActivity_IsValid(int value);
constexpr EStreamActivity EStreamActivity_MIN = k_EStreamActivityIdle;
constexpr EStreamActivity EStreamActivity_MAX = k_EStreamActivityMusic;
constexpr int EStreamActivity_ARRAYSIZE = EStreamActivity_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamActivity_descriptor();
template<typename T>
inline const std::string& EStreamActivity_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamActivity>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamActivity_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamActivity_descriptor(), enum_t_value);
}
inline bool EStreamActivity_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamActivity* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamActivity>(
    EStreamActivity_descriptor(), name, value);
}
enum EStreamDataMessage : int {
  k_EStreamDataPacket = 1,
  k_EStreamDataLost = 2
};
bool EStreamDataMessage_IsValid(int value);
constexpr EStreamDataMessage EStreamDataMessage_MIN = k_EStreamDataPacket;
constexpr EStreamDataMessage EStreamDataMessage_MAX = k_EStreamDataLost;
constexpr int EStreamDataMessage_ARRAYSIZE = EStreamDataMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamDataMessage_descriptor();
template<typename T>
inline const std::string& EStreamDataMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamDataMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamDataMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamDataMessage_descriptor(), enum_t_value);
}
inline bool EStreamDataMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamDataMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamDataMessage>(
    EStreamDataMessage_descriptor(), name, value);
}
enum EAudioFormat : int {
  k_EAudioFormatNone = 0,
  k_EAudioFormat16BitLittleEndian = 1,
  k_EAudioFormatFloat = 2
};
bool EAudioFormat_IsValid(int value);
constexpr EAudioFormat EAudioFormat_MIN = k_EAudioFormatNone;
constexpr EAudioFormat EAudioFormat_MAX = k_EAudioFormatFloat;
constexpr int EAudioFormat_ARRAYSIZE = EAudioFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAudioFormat_descriptor();
template<typename T>
inline const std::string& EAudioFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EAudioFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EAudioFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EAudioFormat_descriptor(), enum_t_value);
}
inline bool EAudioFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EAudioFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EAudioFormat>(
    EAudioFormat_descriptor(), name, value);
}
enum EVideoFormat : int {
  k_EVideoFormatNone = 0,
  k_EVideoFormatYV12 = 1,
  k_EVideoFormatAccel = 2
};
bool EVideoFormat_IsValid(int value);
constexpr EVideoFormat EVideoFormat_MIN = k_EVideoFormatNone;
constexpr EVideoFormat EVideoFormat_MAX = k_EVideoFormatAccel;
constexpr int EVideoFormat_ARRAYSIZE = EVideoFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EVideoFormat_descriptor();
template<typename T>
inline const std::string& EVideoFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EVideoFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EVideoFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EVideoFormat_descriptor(), enum_t_value);
}
inline bool EVideoFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EVideoFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EVideoFormat>(
    EVideoFormat_descriptor(), name, value);
}
enum EStreamStatsMessage : int {
  k_EStreamStatsFrameEvents = 1,
  k_EStreamStatsDebugDump = 2,
  k_EStreamStatsLogMessage = 3,
  k_EStreamStatsLogUploadBegin = 4,
  k_EStreamStatsLogUploadData = 5,
  k_EStreamStatsLogUploadComplete = 6
};
bool EStreamStatsMessage_IsValid(int value);
constexpr EStreamStatsMessage EStreamStatsMessage_MIN = k_EStreamStatsFrameEvents;
constexpr EStreamStatsMessage EStreamStatsMessage_MAX = k_EStreamStatsLogUploadComplete;
constexpr int EStreamStatsMessage_ARRAYSIZE = EStreamStatsMessage_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamStatsMessage_descriptor();
template<typename T>
inline const std::string& EStreamStatsMessage_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamStatsMessage>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamStatsMessage_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamStatsMessage_descriptor(), enum_t_value);
}
inline bool EStreamStatsMessage_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamStatsMessage* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamStatsMessage>(
    EStreamStatsMessage_descriptor(), name, value);
}
enum EStreamFrameEvent : int {
  k_EStreamInputEventStart = 0,
  k_EStreamInputEventSend = 1,
  k_EStreamInputEventRecv = 2,
  k_EStreamInputEventQueued = 3,
  k_EStreamInputEventHandled = 4,
  k_EStreamFrameEventStart = 5,
  k_EStreamFrameEventCaptureBegin = 6,
  k_EStreamFrameEventCaptureEnd = 7,
  k_EStreamFrameEventConvertBegin = 8,
  k_EStreamFrameEventConvertEnd = 9,
  k_EStreamFrameEventEncodeBegin = 10,
  k_EStreamFrameEventEncodeEnd = 11,
  k_EStreamFrameEventSend = 12,
  k_EStreamFrameEventRecv = 13,
  k_EStreamFrameEventDecodeBegin = 14,
  k_EStreamFrameEventDecodeEnd = 15,
  k_EStreamFrameEventUploadBegin = 16,
  k_EStreamFrameEventUploadEnd = 17,
  k_EStreamFrameEventComplete = 18
};
bool EStreamFrameEvent_IsValid(int value);
constexpr EStreamFrameEvent EStreamFrameEvent_MIN = k_EStreamInputEventStart;
constexpr EStreamFrameEvent EStreamFrameEvent_MAX = k_EStreamFrameEventComplete;
constexpr int EStreamFrameEvent_ARRAYSIZE = EStreamFrameEvent_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFrameEvent_descriptor();
template<typename T>
inline const std::string& EStreamFrameEvent_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamFrameEvent>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamFrameEvent_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamFrameEvent_descriptor(), enum_t_value);
}
inline bool EStreamFrameEvent_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamFrameEvent* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamFrameEvent>(
    EStreamFrameEvent_descriptor(), name, value);
}
enum EStreamFrameResult : int {
  k_EStreamFrameResultPending = 0,
  k_EStreamFrameResultDisplayed = 1,
  k_EStreamFrameResultDroppedNetworkSlow = 2,
  k_EStreamFrameResultDroppedNetworkLost = 3,
  k_EStreamFrameResultDroppedDecodeSlow = 4,
  k_EStreamFrameResultDroppedDecodeCorrupt = 5,
  k_EStreamFrameResultDroppedLate = 6,
  k_EStreamFrameResultDroppedReset = 7
};
bool EStreamFrameResult_IsValid(int value);
constexpr EStreamFrameResult EStreamFrameResult_MIN = k_EStreamFrameResultPending;
constexpr EStreamFrameResult EStreamFrameResult_MAX = k_EStreamFrameResultDroppedReset;
constexpr int EStreamFrameResult_ARRAYSIZE = EStreamFrameResult_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamFrameResult_descriptor();
template<typename T>
inline const std::string& EStreamFrameResult_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamFrameResult>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamFrameResult_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamFrameResult_descriptor(), enum_t_value);
}
inline bool EStreamFrameResult_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamFrameResult* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamFrameResult>(
    EStreamFrameResult_descriptor(), name, value);
}
enum EFrameAccumulatedStat : int {
  k_EFrameStatFPS = 0,
  k_EFrameStatCaptureDurationMS = 1,
  k_EFrameStatConvertDurationMS = 2,
  k_EFrameStatEncodeDurationMS = 3,
  k_EFrameStatSteamDurationMS = 4,
  k_EFrameStatServerDurationMS = 5,
  k_EFrameStatNetworkDurationMS = 6,
  k_EFrameStatDecodeDurationMS = 7,
  k_EFrameStatDisplayDurationMS = 8,
  k_EFrameStatClientDurationMS = 9,
  k_EFrameStatFrameDurationMS = 10,
  k_EFrameStatInputLatencyMS = 11,
  k_EFrameStatGameLatencyMS = 12,
  k_EFrameStatRoundTripLatencyMS = 13,
  k_EFrameStatPingTimeMS = 14,
  k_EFrameStatServerBitrateKbitPerSec = 15,
  k_EFrameStatClientBitrateKbitPerSec = 16,
  k_EFrameStatLinkBandwidthKbitPerSec = 17,
  k_EFrameStatPacketLossPercentage = 18
};
bool EFrameAccumulatedStat_IsValid(int value);
constexpr EFrameAccumulatedStat EFrameAccumulatedStat_MIN = k_EFrameStatFPS;
constexpr EFrameAccumulatedStat EFrameAccumulatedStat_MAX = k_EFrameStatPacketLossPercentage;
constexpr int EFrameAccumulatedStat_ARRAYSIZE = EFrameAccumulatedStat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EFrameAccumulatedStat_descriptor();
template<typename T>
inline const std::string& EFrameAccumulatedStat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EFrameAccumulatedStat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EFrameAccumulatedStat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EFrameAccumulatedStat_descriptor(), enum_t_value);
}
inline bool EFrameAccumulatedStat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EFrameAccumulatedStat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EFrameAccumulatedStat>(
    EFrameAccumulatedStat_descriptor(), name, value);
}
enum ELogFileType : int {
  k_ELogFileSystemBoot = 0,
  k_ELogFileSystemReset = 1,
  k_ELogFileSystemDebug = 2
};
bool ELogFileType_IsValid(int value);
constexpr ELogFileType ELogFileType_MIN = k_ELogFileSystemBoot;
constexpr ELogFileType ELogFileType_MAX = k_ELogFileSystemDebug;
constexpr int ELogFileType_ARRAYSIZE = ELogFileType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ELogFileType_descriptor();
template<typename T>
inline const std::string& ELogFileType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ELogFileType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ELogFileType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ELogFileType_descriptor(), enum_t_value);
}
inline bool ELogFileType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ELogFileType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ELogFileType>(
    ELogFileType_descriptor(), name, value);
}
enum EStreamControllerConfigMsg : int {
  k_EStreamControllerConfigMsg_RequestConfigsForApp = 0,
  k_EStreamControllerConfigMsg_ConfigResponse = 1,
  k_EStreamControllerConfigMsg_PersonalizationResponse = 2,
  k_EStreamControllerConfigMsg_ActiveConfigChange = 3,
  k_EStreamControllerConfigMsg_RequestActiveConfig = 4
};
bool EStreamControllerConfigMsg_IsValid(int value);
constexpr EStreamControllerConfigMsg EStreamControllerConfigMsg_MIN = k_EStreamControllerConfigMsg_RequestConfigsForApp;
constexpr EStreamControllerConfigMsg EStreamControllerConfigMsg_MAX = k_EStreamControllerConfigMsg_RequestActiveConfig;
constexpr int EStreamControllerConfigMsg_ARRAYSIZE = EStreamControllerConfigMsg_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EStreamControllerConfigMsg_descriptor();
template<typename T>
inline const std::string& EStreamControllerConfigMsg_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EStreamControllerConfigMsg>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EStreamControllerConfigMsg_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EStreamControllerConfigMsg_descriptor(), enum_t_value);
}
inline bool EStreamControllerConfigMsg_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EStreamControllerConfigMsg* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EStreamControllerConfigMsg>(
    EStreamControllerConfigMsg_descriptor(), name, value);
}
// ===================================================================

class CDiscoveryPingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDiscoveryPingRequest) */ {
 public:
  inline CDiscoveryPingRequest() : CDiscoveryPingRequest(nullptr) {}
  ~CDiscoveryPingRequest() override;
  explicit constexpr CDiscoveryPingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDiscoveryPingRequest(const CDiscoveryPingRequest& from);
  CDiscoveryPingRequest(CDiscoveryPingRequest&& from) noexcept
    : CDiscoveryPingRequest() {
    *this = ::std::move(from);
  }

  inline CDiscoveryPingRequest& operator=(const CDiscoveryPingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDiscoveryPingRequest& operator=(CDiscoveryPingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDiscoveryPingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDiscoveryPingRequest* internal_default_instance() {
    return reinterpret_cast<const CDiscoveryPingRequest*>(
               &_CDiscoveryPingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(CDiscoveryPingRequest& a, CDiscoveryPingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CDiscoveryPingRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDiscoveryPingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDiscoveryPingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDiscoveryPingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDiscoveryPingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CDiscoveryPingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDiscoveryPingRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDiscoveryPingRequest";
  }
  protected:
  explicit CDiscoveryPingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
    kPacketSizeRequestedFieldNumber = 2,
  };
  // optional uint32 sequence = 1;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  uint32_t sequence() const;
  void set_sequence(uint32_t value);
  private:
  uint32_t _internal_sequence() const;
  void _internal_set_sequence(uint32_t value);
  public:

  // optional uint32 packet_size_requested = 2;
  bool has_packet_size_requested() const;
  private:
  bool _internal_has_packet_size_requested() const;
  public:
  void clear_packet_size_requested();
  uint32_t packet_size_requested() const;
  void set_packet_size_requested(uint32_t value);
  private:
  uint32_t _internal_packet_size_requested() const;
  void _internal_set_packet_size_requested(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDiscoveryPingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t sequence_;
  uint32_t packet_size_requested_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CDiscoveryPingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDiscoveryPingResponse) */ {
 public:
  inline CDiscoveryPingResponse() : CDiscoveryPingResponse(nullptr) {}
  ~CDiscoveryPingResponse() override;
  explicit constexpr CDiscoveryPingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDiscoveryPingResponse(const CDiscoveryPingResponse& from);
  CDiscoveryPingResponse(CDiscoveryPingResponse&& from) noexcept
    : CDiscoveryPingResponse() {
    *this = ::std::move(from);
  }

  inline CDiscoveryPingResponse& operator=(const CDiscoveryPingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDiscoveryPingResponse& operator=(CDiscoveryPingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDiscoveryPingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDiscoveryPingResponse* internal_default_instance() {
    return reinterpret_cast<const CDiscoveryPingResponse*>(
               &_CDiscoveryPingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(CDiscoveryPingResponse& a, CDiscoveryPingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CDiscoveryPingResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDiscoveryPingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDiscoveryPingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDiscoveryPingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDiscoveryPingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CDiscoveryPingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDiscoveryPingResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDiscoveryPingResponse";
  }
  protected:
  explicit CDiscoveryPingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSequenceFieldNumber = 1,
    kPacketSizeReceivedFieldNumber = 2,
  };
  // optional uint32 sequence = 1;
  bool has_sequence() const;
  private:
  bool _internal_has_sequence() const;
  public:
  void clear_sequence();
  uint32_t sequence() const;
  void set_sequence(uint32_t value);
  private:
  uint32_t _internal_sequence() const;
  void _internal_set_sequence(uint32_t value);
  public:

  // optional uint32 packet_size_received = 2;
  bool has_packet_size_received() const;
  private:
  bool _internal_has_packet_size_received() const;
  public:
  void clear_packet_size_received();
  uint32_t packet_size_received() const;
  void set_packet_size_received(uint32_t value);
  private:
  uint32_t _internal_packet_size_received() const;
  void _internal_set_packet_size_received(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDiscoveryPingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t sequence_;
  uint32_t packet_size_received_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingClientHandshakeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingClientHandshakeInfo) */ {
 public:
  inline CStreamingClientHandshakeInfo() : CStreamingClientHandshakeInfo(nullptr) {}
  ~CStreamingClientHandshakeInfo() override;
  explicit constexpr CStreamingClientHandshakeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingClientHandshakeInfo(const CStreamingClientHandshakeInfo& from);
  CStreamingClientHandshakeInfo(CStreamingClientHandshakeInfo&& from) noexcept
    : CStreamingClientHandshakeInfo() {
    *this = ::std::move(from);
  }

  inline CStreamingClientHandshakeInfo& operator=(const CStreamingClientHandshakeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingClientHandshakeInfo& operator=(CStreamingClientHandshakeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingClientHandshakeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingClientHandshakeInfo* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientHandshakeInfo*>(
               &_CStreamingClientHandshakeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CStreamingClientHandshakeInfo& a, CStreamingClientHandshakeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingClientHandshakeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingClientHandshakeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingClientHandshakeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingClientHandshakeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingClientHandshakeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingClientHandshakeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientHandshakeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingClientHandshakeInfo";
  }
  protected:
  explicit CStreamingClientHandshakeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNetworkTestFieldNumber = 2,
  };
  // optional int32 network_test = 2;
  bool has_network_test() const;
  private:
  bool _internal_has_network_test() const;
  public:
  void clear_network_test();
  int32_t network_test() const;
  void set_network_test(int32_t value);
  private:
  int32_t _internal_network_test() const;
  void _internal_set_network_test(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingClientHandshakeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t network_test_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CClientHandshakeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CClientHandshakeMsg) */ {
 public:
  inline CClientHandshakeMsg() : CClientHandshakeMsg(nullptr) {}
  ~CClientHandshakeMsg() override;
  explicit constexpr CClientHandshakeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CClientHandshakeMsg(const CClientHandshakeMsg& from);
  CClientHandshakeMsg(CClientHandshakeMsg&& from) noexcept
    : CClientHandshakeMsg() {
    *this = ::std::move(from);
  }

  inline CClientHandshakeMsg& operator=(const CClientHandshakeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CClientHandshakeMsg& operator=(CClientHandshakeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CClientHandshakeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CClientHandshakeMsg* internal_default_instance() {
    return reinterpret_cast<const CClientHandshakeMsg*>(
               &_CClientHandshakeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CClientHandshakeMsg& a, CClientHandshakeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CClientHandshakeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CClientHandshakeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CClientHandshakeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CClientHandshakeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CClientHandshakeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CClientHandshakeMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CClientHandshakeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CClientHandshakeMsg";
  }
  protected:
  explicit CClientHandshakeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // required .CStreamingClientHandshakeInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::CStreamingClientHandshakeInfo& info() const;
  PROTOBUF_NODISCARD ::CStreamingClientHandshakeInfo* release_info();
  ::CStreamingClientHandshakeInfo* mutable_info();
  void set_allocated_info(::CStreamingClientHandshakeInfo* info);
  private:
  const ::CStreamingClientHandshakeInfo& _internal_info() const;
  ::CStreamingClientHandshakeInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::CStreamingClientHandshakeInfo* info);
  ::CStreamingClientHandshakeInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:CClientHandshakeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CStreamingClientHandshakeInfo* info_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingServerHandshakeInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingServerHandshakeInfo) */ {
 public:
  inline CStreamingServerHandshakeInfo() : CStreamingServerHandshakeInfo(nullptr) {}
  ~CStreamingServerHandshakeInfo() override;
  explicit constexpr CStreamingServerHandshakeInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingServerHandshakeInfo(const CStreamingServerHandshakeInfo& from);
  CStreamingServerHandshakeInfo(CStreamingServerHandshakeInfo&& from) noexcept
    : CStreamingServerHandshakeInfo() {
    *this = ::std::move(from);
  }

  inline CStreamingServerHandshakeInfo& operator=(const CStreamingServerHandshakeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingServerHandshakeInfo& operator=(CStreamingServerHandshakeInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingServerHandshakeInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingServerHandshakeInfo* internal_default_instance() {
    return reinterpret_cast<const CStreamingServerHandshakeInfo*>(
               &_CStreamingServerHandshakeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(CStreamingServerHandshakeInfo& a, CStreamingServerHandshakeInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingServerHandshakeInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingServerHandshakeInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingServerHandshakeInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingServerHandshakeInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingServerHandshakeInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingServerHandshakeInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingServerHandshakeInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingServerHandshakeInfo";
  }
  protected:
  explicit CStreamingServerHandshakeInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMtuFieldNumber = 1,
  };
  // optional int32 mtu = 1;
  bool has_mtu() const;
  private:
  bool _internal_has_mtu() const;
  public:
  void clear_mtu();
  int32_t mtu() const;
  void set_mtu(int32_t value);
  private:
  int32_t _internal_mtu() const;
  void _internal_set_mtu(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingServerHandshakeInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t mtu_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CServerHandshakeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CServerHandshakeMsg) */ {
 public:
  inline CServerHandshakeMsg() : CServerHandshakeMsg(nullptr) {}
  ~CServerHandshakeMsg() override;
  explicit constexpr CServerHandshakeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CServerHandshakeMsg(const CServerHandshakeMsg& from);
  CServerHandshakeMsg(CServerHandshakeMsg&& from) noexcept
    : CServerHandshakeMsg() {
    *this = ::std::move(from);
  }

  inline CServerHandshakeMsg& operator=(const CServerHandshakeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CServerHandshakeMsg& operator=(CServerHandshakeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CServerHandshakeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CServerHandshakeMsg* internal_default_instance() {
    return reinterpret_cast<const CServerHandshakeMsg*>(
               &_CServerHandshakeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(CServerHandshakeMsg& a, CServerHandshakeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CServerHandshakeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CServerHandshakeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CServerHandshakeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CServerHandshakeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CServerHandshakeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CServerHandshakeMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CServerHandshakeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CServerHandshakeMsg";
  }
  protected:
  explicit CServerHandshakeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // required .CStreamingServerHandshakeInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::CStreamingServerHandshakeInfo& info() const;
  PROTOBUF_NODISCARD ::CStreamingServerHandshakeInfo* release_info();
  ::CStreamingServerHandshakeInfo* mutable_info();
  void set_allocated_info(::CStreamingServerHandshakeInfo* info);
  private:
  const ::CStreamingServerHandshakeInfo& _internal_info() const;
  ::CStreamingServerHandshakeInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::CStreamingServerHandshakeInfo* info);
  ::CStreamingServerHandshakeInfo* unsafe_arena_release_info();

  // @@protoc_insertion_point(class_scope:CServerHandshakeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CStreamingServerHandshakeInfo* info_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationRequestMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationRequestMsg) */ {
 public:
  inline CAuthenticationRequestMsg() : CAuthenticationRequestMsg(nullptr) {}
  ~CAuthenticationRequestMsg() override;
  explicit constexpr CAuthenticationRequestMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationRequestMsg(const CAuthenticationRequestMsg& from);
  CAuthenticationRequestMsg(CAuthenticationRequestMsg&& from) noexcept
    : CAuthenticationRequestMsg() {
    *this = ::std::move(from);
  }

  inline CAuthenticationRequestMsg& operator=(const CAuthenticationRequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationRequestMsg& operator=(CAuthenticationRequestMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationRequestMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationRequestMsg* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationRequestMsg*>(
               &_CAuthenticationRequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(CAuthenticationRequestMsg& a, CAuthenticationRequestMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationRequestMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationRequestMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationRequestMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationRequestMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationRequestMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationRequestMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationRequestMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationRequestMsg";
  }
  protected:
  explicit CAuthenticationRequestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTokenFieldNumber = 1,
    kSteamidFieldNumber = 3,
    kVersionFieldNumber = 2,
  };
  // optional bytes token = 1;
  bool has_token() const;
  private:
  bool _internal_has_token() const;
  public:
  void clear_token();
  const std::string& token() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_token(ArgT0&& arg0, ArgT... args);
  std::string* mutable_token();
  PROTOBUF_NODISCARD std::string* release_token();
  void set_allocated_token(std::string* token);
  private:
  const std::string& _internal_token() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_token(const std::string& value);
  std::string* _internal_mutable_token();
  public:

  // optional uint64 steamid = 3;
  bool has_steamid() const;
  private:
  bool _internal_has_steamid() const;
  public:
  void clear_steamid();
  uint64_t steamid() const;
  void set_steamid(uint64_t value);
  private:
  uint64_t _internal_steamid() const;
  void _internal_set_steamid(uint64_t value);
  public:

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::EStreamVersion version() const;
  void set_version(::EStreamVersion value);
  private:
  ::EStreamVersion _internal_version() const;
  void _internal_set_version(::EStreamVersion value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationRequestMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr token_;
  uint64_t steamid_;
  int version_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CAuthenticationResponseMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAuthenticationResponseMsg) */ {
 public:
  inline CAuthenticationResponseMsg() : CAuthenticationResponseMsg(nullptr) {}
  ~CAuthenticationResponseMsg() override;
  explicit constexpr CAuthenticationResponseMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAuthenticationResponseMsg(const CAuthenticationResponseMsg& from);
  CAuthenticationResponseMsg(CAuthenticationResponseMsg&& from) noexcept
    : CAuthenticationResponseMsg() {
    *this = ::std::move(from);
  }

  inline CAuthenticationResponseMsg& operator=(const CAuthenticationResponseMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAuthenticationResponseMsg& operator=(CAuthenticationResponseMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAuthenticationResponseMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAuthenticationResponseMsg* internal_default_instance() {
    return reinterpret_cast<const CAuthenticationResponseMsg*>(
               &_CAuthenticationResponseMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(CAuthenticationResponseMsg& a, CAuthenticationResponseMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CAuthenticationResponseMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAuthenticationResponseMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAuthenticationResponseMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAuthenticationResponseMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAuthenticationResponseMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAuthenticationResponseMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAuthenticationResponseMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAuthenticationResponseMsg";
  }
  protected:
  explicit CAuthenticationResponseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CAuthenticationResponseMsg_AuthenticationResult AuthenticationResult;
  static constexpr AuthenticationResult SUCCEEDED =
    CAuthenticationResponseMsg_AuthenticationResult_SUCCEEDED;
  static constexpr AuthenticationResult FAILED =
    CAuthenticationResponseMsg_AuthenticationResult_FAILED;
  static inline bool AuthenticationResult_IsValid(int value) {
    return CAuthenticationResponseMsg_AuthenticationResult_IsValid(value);
  }
  static constexpr AuthenticationResult AuthenticationResult_MIN =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MIN;
  static constexpr AuthenticationResult AuthenticationResult_MAX =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_MAX;
  static constexpr int AuthenticationResult_ARRAYSIZE =
    CAuthenticationResponseMsg_AuthenticationResult_AuthenticationResult_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AuthenticationResult_descriptor() {
    return CAuthenticationResponseMsg_AuthenticationResult_descriptor();
  }
  template<typename T>
  static inline const std::string& AuthenticationResult_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AuthenticationResult>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AuthenticationResult_Name.");
    return CAuthenticationResponseMsg_AuthenticationResult_Name(enum_t_value);
  }
  static inline bool AuthenticationResult_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AuthenticationResult* value) {
    return CAuthenticationResponseMsg_AuthenticationResult_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kResultFieldNumber = 1,
    kVersionFieldNumber = 2,
  };
  // optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::CAuthenticationResponseMsg_AuthenticationResult result() const;
  void set_result(::CAuthenticationResponseMsg_AuthenticationResult value);
  private:
  ::CAuthenticationResponseMsg_AuthenticationResult _internal_result() const;
  void _internal_set_result(::CAuthenticationResponseMsg_AuthenticationResult value);
  public:

  // optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
  bool has_version() const;
  private:
  bool _internal_has_version() const;
  public:
  void clear_version();
  ::EStreamVersion version() const;
  void set_version(::EStreamVersion value);
  private:
  ::EStreamVersion _internal_version() const;
  void _internal_set_version(::EStreamVersion value);
  public:

  // @@protoc_insertion_point(class_scope:CAuthenticationResponseMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int result_;
  int version_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CKeepAliveMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CKeepAliveMsg) */ {
 public:
  inline CKeepAliveMsg() : CKeepAliveMsg(nullptr) {}
  explicit constexpr CKeepAliveMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CKeepAliveMsg(const CKeepAliveMsg& from);
  CKeepAliveMsg(CKeepAliveMsg&& from) noexcept
    : CKeepAliveMsg() {
    *this = ::std::move(from);
  }

  inline CKeepAliveMsg& operator=(const CKeepAliveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CKeepAliveMsg& operator=(CKeepAliveMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CKeepAliveMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CKeepAliveMsg* internal_default_instance() {
    return reinterpret_cast<const CKeepAliveMsg*>(
               &_CKeepAliveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(CKeepAliveMsg& a, CKeepAliveMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CKeepAliveMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CKeepAliveMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CKeepAliveMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CKeepAliveMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CKeepAliveMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CKeepAliveMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CKeepAliveMsg";
  }
  protected:
  explicit CKeepAliveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CKeepAliveMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStartNetworkTestMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStartNetworkTestMsg) */ {
 public:
  inline CStartNetworkTestMsg() : CStartNetworkTestMsg(nullptr) {}
  ~CStartNetworkTestMsg() override;
  explicit constexpr CStartNetworkTestMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStartNetworkTestMsg(const CStartNetworkTestMsg& from);
  CStartNetworkTestMsg(CStartNetworkTestMsg&& from) noexcept
    : CStartNetworkTestMsg() {
    *this = ::std::move(from);
  }

  inline CStartNetworkTestMsg& operator=(const CStartNetworkTestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStartNetworkTestMsg& operator=(CStartNetworkTestMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStartNetworkTestMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStartNetworkTestMsg* internal_default_instance() {
    return reinterpret_cast<const CStartNetworkTestMsg*>(
               &_CStartNetworkTestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(CStartNetworkTestMsg& a, CStartNetworkTestMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStartNetworkTestMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStartNetworkTestMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStartNetworkTestMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStartNetworkTestMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStartNetworkTestMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStartNetworkTestMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartNetworkTestMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStartNetworkTestMsg";
  }
  protected:
  explicit CStartNetworkTestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramesFieldNumber = 1,
    kFramerateFieldNumber = 2,
    kBitrateKbpsFieldNumber = 3,
    kBurstBitrateKbpsFieldNumber = 4,
    kBandwidthTestFieldNumber = 5,
  };
  // optional uint32 frames = 1;
  bool has_frames() const;
  private:
  bool _internal_has_frames() const;
  public:
  void clear_frames();
  uint32_t frames() const;
  void set_frames(uint32_t value);
  private:
  uint32_t _internal_frames() const;
  void _internal_set_frames(uint32_t value);
  public:

  // optional uint32 framerate = 2;
  bool has_framerate() const;
  private:
  bool _internal_has_framerate() const;
  public:
  void clear_framerate();
  uint32_t framerate() const;
  void set_framerate(uint32_t value);
  private:
  uint32_t _internal_framerate() const;
  void _internal_set_framerate(uint32_t value);
  public:

  // optional uint32 bitrate_kbps = 3;
  bool has_bitrate_kbps() const;
  private:
  bool _internal_has_bitrate_kbps() const;
  public:
  void clear_bitrate_kbps();
  uint32_t bitrate_kbps() const;
  void set_bitrate_kbps(uint32_t value);
  private:
  uint32_t _internal_bitrate_kbps() const;
  void _internal_set_bitrate_kbps(uint32_t value);
  public:

  // optional uint32 burst_bitrate_kbps = 4;
  bool has_burst_bitrate_kbps() const;
  private:
  bool _internal_has_burst_bitrate_kbps() const;
  public:
  void clear_burst_bitrate_kbps();
  uint32_t burst_bitrate_kbps() const;
  void set_burst_bitrate_kbps(uint32_t value);
  private:
  uint32_t _internal_burst_bitrate_kbps() const;
  void _internal_set_burst_bitrate_kbps(uint32_t value);
  public:

  // optional bool bandwidth_test = 5;
  bool has_bandwidth_test() const;
  private:
  bool _internal_has_bandwidth_test() const;
  public:
  void clear_bandwidth_test();
  bool bandwidth_test() const;
  void set_bandwidth_test(bool value);
  private:
  bool _internal_bandwidth_test() const;
  void _internal_set_bandwidth_test(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CStartNetworkTestMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t frames_;
  uint32_t framerate_;
  uint32_t bitrate_kbps_;
  uint32_t burst_bitrate_kbps_;
  bool bandwidth_test_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamVideoMode final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamVideoMode) */ {
 public:
  inline CStreamVideoMode() : CStreamVideoMode(nullptr) {}
  ~CStreamVideoMode() override;
  explicit constexpr CStreamVideoMode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamVideoMode(const CStreamVideoMode& from);
  CStreamVideoMode(CStreamVideoMode&& from) noexcept
    : CStreamVideoMode() {
    *this = ::std::move(from);
  }

  inline CStreamVideoMode& operator=(const CStreamVideoMode& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamVideoMode& operator=(CStreamVideoMode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamVideoMode& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamVideoMode* internal_default_instance() {
    return reinterpret_cast<const CStreamVideoMode*>(
               &_CStreamVideoMode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CStreamVideoMode& a, CStreamVideoMode& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamVideoMode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamVideoMode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamVideoMode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamVideoMode>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamVideoMode& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamVideoMode& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamVideoMode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamVideoMode";
  }
  protected:
  explicit CStreamVideoMode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
    kRefreshRateFieldNumber = 3,
    kRefreshRateNumeratorFieldNumber = 4,
    kRefreshRateDenominatorFieldNumber = 5,
  };
  // required uint32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // required uint32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // optional uint32 refresh_rate = 3;
  bool has_refresh_rate() const;
  private:
  bool _internal_has_refresh_rate() const;
  public:
  void clear_refresh_rate();
  uint32_t refresh_rate() const;
  void set_refresh_rate(uint32_t value);
  private:
  uint32_t _internal_refresh_rate() const;
  void _internal_set_refresh_rate(uint32_t value);
  public:

  // optional uint32 refresh_rate_numerator = 4;
  bool has_refresh_rate_numerator() const;
  private:
  bool _internal_has_refresh_rate_numerator() const;
  public:
  void clear_refresh_rate_numerator();
  uint32_t refresh_rate_numerator() const;
  void set_refresh_rate_numerator(uint32_t value);
  private:
  uint32_t _internal_refresh_rate_numerator() const;
  void _internal_set_refresh_rate_numerator(uint32_t value);
  public:

  // optional uint32 refresh_rate_denominator = 5;
  bool has_refresh_rate_denominator() const;
  private:
  bool _internal_has_refresh_rate_denominator() const;
  public:
  void clear_refresh_rate_denominator();
  uint32_t refresh_rate_denominator() const;
  void set_refresh_rate_denominator(uint32_t value);
  private:
  uint32_t _internal_refresh_rate_denominator() const;
  void _internal_set_refresh_rate_denominator(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamVideoMode)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t width_;
  uint32_t height_;
  uint32_t refresh_rate_;
  uint32_t refresh_rate_numerator_;
  uint32_t refresh_rate_denominator_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingClientCaps final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingClientCaps) */ {
 public:
  inline CStreamingClientCaps() : CStreamingClientCaps(nullptr) {}
  ~CStreamingClientCaps() override;
  explicit constexpr CStreamingClientCaps(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingClientCaps(const CStreamingClientCaps& from);
  CStreamingClientCaps(CStreamingClientCaps&& from) noexcept
    : CStreamingClientCaps() {
    *this = ::std::move(from);
  }

  inline CStreamingClientCaps& operator=(const CStreamingClientCaps& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingClientCaps& operator=(CStreamingClientCaps&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingClientCaps& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingClientCaps* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientCaps*>(
               &_CStreamingClientCaps_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CStreamingClientCaps& a, CStreamingClientCaps& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingClientCaps* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingClientCaps* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingClientCaps* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingClientCaps>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingClientCaps& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingClientCaps& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientCaps* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingClientCaps";
  }
  protected:
  explicit CStreamingClientCaps(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedColorspacesFieldNumber = 13,
    kSystemInfoFieldNumber = 1,
    kMaximumDecodeBitrateKbpsFieldNumber = 3,
    kMaximumBurstBitrateKbpsFieldNumber = 4,
    kSystemCanSuspendFieldNumber = 2,
    kSupportsVideoHevcFieldNumber = 5,
    kDisableSteamStoreFieldNumber = 6,
    kDisableClientCursorFieldNumber = 7,
    kDisableIntelHardwareEncodingFieldNumber = 8,
    kDisableAmdHardwareEncodingFieldNumber = 9,
    kDisableNvidiaHardwareEncodingFieldNumber = 10,
    kHasOnScreenKeyboardFieldNumber = 12,
    kFormFactorFieldNumber = 11,
  };
  // repeated .EStreamColorspace supported_colorspaces = 13;
  int supported_colorspaces_size() const;
  private:
  int _internal_supported_colorspaces_size() const;
  public:
  void clear_supported_colorspaces();
  private:
  ::EStreamColorspace _internal_supported_colorspaces(int index) const;
  void _internal_add_supported_colorspaces(::EStreamColorspace value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_colorspaces();
  public:
  ::EStreamColorspace supported_colorspaces(int index) const;
  void set_supported_colorspaces(int index, ::EStreamColorspace value);
  void add_supported_colorspaces(::EStreamColorspace value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_colorspaces() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_colorspaces();

  // optional string system_info = 1;
  bool has_system_info() const;
  private:
  bool _internal_has_system_info() const;
  public:
  void clear_system_info();
  const std::string& system_info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_system_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_system_info();
  PROTOBUF_NODISCARD std::string* release_system_info();
  void set_allocated_system_info(std::string* system_info);
  private:
  const std::string& _internal_system_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_system_info(const std::string& value);
  std::string* _internal_mutable_system_info();
  public:

  // optional int32 maximum_decode_bitrate_kbps = 3;
  bool has_maximum_decode_bitrate_kbps() const;
  private:
  bool _internal_has_maximum_decode_bitrate_kbps() const;
  public:
  void clear_maximum_decode_bitrate_kbps();
  int32_t maximum_decode_bitrate_kbps() const;
  void set_maximum_decode_bitrate_kbps(int32_t value);
  private:
  int32_t _internal_maximum_decode_bitrate_kbps() const;
  void _internal_set_maximum_decode_bitrate_kbps(int32_t value);
  public:

  // optional int32 maximum_burst_bitrate_kbps = 4;
  bool has_maximum_burst_bitrate_kbps() const;
  private:
  bool _internal_has_maximum_burst_bitrate_kbps() const;
  public:
  void clear_maximum_burst_bitrate_kbps();
  int32_t maximum_burst_bitrate_kbps() const;
  void set_maximum_burst_bitrate_kbps(int32_t value);
  private:
  int32_t _internal_maximum_burst_bitrate_kbps() const;
  void _internal_set_maximum_burst_bitrate_kbps(int32_t value);
  public:

  // optional bool system_can_suspend = 2;
  bool has_system_can_suspend() const;
  private:
  bool _internal_has_system_can_suspend() const;
  public:
  void clear_system_can_suspend();
  bool system_can_suspend() const;
  void set_system_can_suspend(bool value);
  private:
  bool _internal_system_can_suspend() const;
  void _internal_set_system_can_suspend(bool value);
  public:

  // optional bool supports_video_hevc = 5;
  bool has_supports_video_hevc() const;
  private:
  bool _internal_has_supports_video_hevc() const;
  public:
  void clear_supports_video_hevc();
  bool supports_video_hevc() const;
  void set_supports_video_hevc(bool value);
  private:
  bool _internal_supports_video_hevc() const;
  void _internal_set_supports_video_hevc(bool value);
  public:

  // optional bool disable_steam_store = 6;
  bool has_disable_steam_store() const;
  private:
  bool _internal_has_disable_steam_store() const;
  public:
  void clear_disable_steam_store();
  bool disable_steam_store() const;
  void set_disable_steam_store(bool value);
  private:
  bool _internal_disable_steam_store() const;
  void _internal_set_disable_steam_store(bool value);
  public:

  // optional bool disable_client_cursor = 7;
  bool has_disable_client_cursor() const;
  private:
  bool _internal_has_disable_client_cursor() const;
  public:
  void clear_disable_client_cursor();
  bool disable_client_cursor() const;
  void set_disable_client_cursor(bool value);
  private:
  bool _internal_disable_client_cursor() const;
  void _internal_set_disable_client_cursor(bool value);
  public:

  // optional bool disable_intel_hardware_encoding = 8;
  bool has_disable_intel_hardware_encoding() const;
  private:
  bool _internal_has_disable_intel_hardware_encoding() const;
  public:
  void clear_disable_intel_hardware_encoding();
  bool disable_intel_hardware_encoding() const;
  void set_disable_intel_hardware_encoding(bool value);
  private:
  bool _internal_disable_intel_hardware_encoding() const;
  void _internal_set_disable_intel_hardware_encoding(bool value);
  public:

  // optional bool disable_amd_hardware_encoding = 9;
  bool has_disable_amd_hardware_encoding() const;
  private:
  bool _internal_has_disable_amd_hardware_encoding() const;
  public:
  void clear_disable_amd_hardware_encoding();
  bool disable_amd_hardware_encoding() const;
  void set_disable_amd_hardware_encoding(bool value);
  private:
  bool _internal_disable_amd_hardware_encoding() const;
  void _internal_set_disable_amd_hardware_encoding(bool value);
  public:

  // optional bool disable_nvidia_hardware_encoding = 10;
  bool has_disable_nvidia_hardware_encoding() const;
  private:
  bool _internal_has_disable_nvidia_hardware_encoding() const;
  public:
  void clear_disable_nvidia_hardware_encoding();
  bool disable_nvidia_hardware_encoding() const;
  void set_disable_nvidia_hardware_encoding(bool value);
  private:
  bool _internal_disable_nvidia_hardware_encoding() const;
  void _internal_set_disable_nvidia_hardware_encoding(bool value);
  public:

  // optional bool has_on_screen_keyboard = 12;
  bool has_has_on_screen_keyboard() const;
  private:
  bool _internal_has_has_on_screen_keyboard() const;
  public:
  void clear_has_on_screen_keyboard();
  bool has_on_screen_keyboard() const;
  void set_has_on_screen_keyboard(bool value);
  private:
  bool _internal_has_on_screen_keyboard() const;
  void _internal_set_has_on_screen_keyboard(bool value);
  public:

  // optional int32 form_factor = 11;
  bool has_form_factor() const;
  private:
  bool _internal_has_form_factor() const;
  public:
  void clear_form_factor();
  int32_t form_factor() const;
  void set_form_factor(int32_t value);
  private:
  int32_t _internal_form_factor() const;
  void _internal_set_form_factor(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingClientCaps)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_colorspaces_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr system_info_;
  int32_t maximum_decode_bitrate_kbps_;
  int32_t maximum_burst_bitrate_kbps_;
  bool system_can_suspend_;
  bool supports_video_hevc_;
  bool disable_steam_store_;
  bool disable_client_cursor_;
  bool disable_intel_hardware_encoding_;
  bool disable_amd_hardware_encoding_;
  bool disable_nvidia_hardware_encoding_;
  bool has_on_screen_keyboard_;
  int32_t form_factor_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingClientConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingClientConfig) */ {
 public:
  inline CStreamingClientConfig() : CStreamingClientConfig(nullptr) {}
  ~CStreamingClientConfig() override;
  explicit constexpr CStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingClientConfig(const CStreamingClientConfig& from);
  CStreamingClientConfig(CStreamingClientConfig&& from) noexcept
    : CStreamingClientConfig() {
    *this = ::std::move(from);
  }

  inline CStreamingClientConfig& operator=(const CStreamingClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingClientConfig& operator=(CStreamingClientConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingClientConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingClientConfig* internal_default_instance() {
    return reinterpret_cast<const CStreamingClientConfig*>(
               &_CStreamingClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CStreamingClientConfig& a, CStreamingClientConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingClientConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingClientConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingClientConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingClientConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingClientConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingClientConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingClientConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingClientConfig";
  }
  protected:
  explicit CStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerOverlayHotkeyFieldNumber = 16,
    kMaximumResolutionXFieldNumber = 2,
    kMaximumResolutionYFieldNumber = 3,
    kMaximumFramerateNumeratorFieldNumber = 4,
    kMaximumFramerateDenominatorFieldNumber = 5,
    kEnablePerformanceOverlayFieldNumber = 8,
    kEnableVideoHevcFieldNumber = 13,
    kEnableMicrophoneStreamingFieldNumber = 15,
    kEnableTouchControllerOBSOLETEFieldNumber = 17,
    kP2PScopeFieldNumber = 19,
    kEnableAudioUncompressedFieldNumber = 20,
    kEnablePerformanceIconsFieldNumber = 14,
    kQualityFieldNumber = 1,
    kMaximumBitrateKbpsFieldNumber = 6,
    kEnableHardwareDecodingFieldNumber = 7,
    kEnableVideoStreamingFieldNumber = 9,
    kEnableAudioStreamingFieldNumber = 10,
    kEnableInputStreamingFieldNumber = 11,
    kAudioChannelsFieldNumber = 12,
  };
  // optional string controller_overlay_hotkey = 16;
  bool has_controller_overlay_hotkey() const;
  private:
  bool _internal_has_controller_overlay_hotkey() const;
  public:
  void clear_controller_overlay_hotkey();
  const std::string& controller_overlay_hotkey() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_overlay_hotkey(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_overlay_hotkey();
  PROTOBUF_NODISCARD std::string* release_controller_overlay_hotkey();
  void set_allocated_controller_overlay_hotkey(std::string* controller_overlay_hotkey);
  private:
  const std::string& _internal_controller_overlay_hotkey() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_overlay_hotkey(const std::string& value);
  std::string* _internal_mutable_controller_overlay_hotkey();
  public:

  // optional uint32 maximum_resolution_x = 2;
  bool has_maximum_resolution_x() const;
  private:
  bool _internal_has_maximum_resolution_x() const;
  public:
  void clear_maximum_resolution_x();
  uint32_t maximum_resolution_x() const;
  void set_maximum_resolution_x(uint32_t value);
  private:
  uint32_t _internal_maximum_resolution_x() const;
  void _internal_set_maximum_resolution_x(uint32_t value);
  public:

  // optional uint32 maximum_resolution_y = 3;
  bool has_maximum_resolution_y() const;
  private:
  bool _internal_has_maximum_resolution_y() const;
  public:
  void clear_maximum_resolution_y();
  uint32_t maximum_resolution_y() const;
  void set_maximum_resolution_y(uint32_t value);
  private:
  uint32_t _internal_maximum_resolution_y() const;
  void _internal_set_maximum_resolution_y(uint32_t value);
  public:

  // optional uint32 maximum_framerate_numerator = 4;
  bool has_maximum_framerate_numerator() const;
  private:
  bool _internal_has_maximum_framerate_numerator() const;
  public:
  void clear_maximum_framerate_numerator();
  uint32_t maximum_framerate_numerator() const;
  void set_maximum_framerate_numerator(uint32_t value);
  private:
  uint32_t _internal_maximum_framerate_numerator() const;
  void _internal_set_maximum_framerate_numerator(uint32_t value);
  public:

  // optional uint32 maximum_framerate_denominator = 5;
  bool has_maximum_framerate_denominator() const;
  private:
  bool _internal_has_maximum_framerate_denominator() const;
  public:
  void clear_maximum_framerate_denominator();
  uint32_t maximum_framerate_denominator() const;
  void set_maximum_framerate_denominator(uint32_t value);
  private:
  uint32_t _internal_maximum_framerate_denominator() const;
  void _internal_set_maximum_framerate_denominator(uint32_t value);
  public:

  // optional bool enable_performance_overlay = 8 [default = false];
  bool has_enable_performance_overlay() const;
  private:
  bool _internal_has_enable_performance_overlay() const;
  public:
  void clear_enable_performance_overlay();
  bool enable_performance_overlay() const;
  void set_enable_performance_overlay(bool value);
  private:
  bool _internal_enable_performance_overlay() const;
  void _internal_set_enable_performance_overlay(bool value);
  public:

  // optional bool enable_video_hevc = 13 [default = false];
  bool has_enable_video_hevc() const;
  private:
  bool _internal_has_enable_video_hevc() const;
  public:
  void clear_enable_video_hevc();
  bool enable_video_hevc() const;
  void set_enable_video_hevc(bool value);
  private:
  bool _internal_enable_video_hevc() const;
  void _internal_set_enable_video_hevc(bool value);
  public:

  // optional bool enable_microphone_streaming = 15 [default = false];
  bool has_enable_microphone_streaming() const;
  private:
  bool _internal_has_enable_microphone_streaming() const;
  public:
  void clear_enable_microphone_streaming();
  bool enable_microphone_streaming() const;
  void set_enable_microphone_streaming(bool value);
  private:
  bool _internal_enable_microphone_streaming() const;
  void _internal_set_enable_microphone_streaming(bool value);
  public:

  // optional bool enable_touch_controller_OBSOLETE = 17 [default = false];
  bool has_enable_touch_controller_obsolete() const;
  private:
  bool _internal_has_enable_touch_controller_obsolete() const;
  public:
  void clear_enable_touch_controller_obsolete();
  bool enable_touch_controller_obsolete() const;
  void set_enable_touch_controller_obsolete(bool value);
  private:
  bool _internal_enable_touch_controller_obsolete() const;
  void _internal_set_enable_touch_controller_obsolete(bool value);
  public:

  // optional .EStreamP2PScope p2p_scope = 19 [default = k_EStreamP2PScopeAutomatic];
  bool has_p2p_scope() const;
  private:
  bool _internal_has_p2p_scope() const;
  public:
  void clear_p2p_scope();
  ::EStreamP2PScope p2p_scope() const;
  void set_p2p_scope(::EStreamP2PScope value);
  private:
  ::EStreamP2PScope _internal_p2p_scope() const;
  void _internal_set_p2p_scope(::EStreamP2PScope value);
  public:

  // optional bool enable_audio_uncompressed = 20 [default = false];
  bool has_enable_audio_uncompressed() const;
  private:
  bool _internal_has_enable_audio_uncompressed() const;
  public:
  void clear_enable_audio_uncompressed();
  bool enable_audio_uncompressed() const;
  void set_enable_audio_uncompressed(bool value);
  private:
  bool _internal_enable_audio_uncompressed() const;
  void _internal_set_enable_audio_uncompressed(bool value);
  public:

  // optional bool enable_performance_icons = 14 [default = true];
  bool has_enable_performance_icons() const;
  private:
  bool _internal_has_enable_performance_icons() const;
  public:
  void clear_enable_performance_icons();
  bool enable_performance_icons() const;
  void set_enable_performance_icons(bool value);
  private:
  bool _internal_enable_performance_icons() const;
  void _internal_set_enable_performance_icons(bool value);
  public:

  // optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
  bool has_quality() const;
  private:
  bool _internal_has_quality() const;
  public:
  void clear_quality();
  ::EStreamQualityPreference quality() const;
  void set_quality(::EStreamQualityPreference value);
  private:
  ::EStreamQualityPreference _internal_quality() const;
  void _internal_set_quality(::EStreamQualityPreference value);
  public:

  // optional int32 maximum_bitrate_kbps = 6 [default = -1];
  bool has_maximum_bitrate_kbps() const;
  private:
  bool _internal_has_maximum_bitrate_kbps() const;
  public:
  void clear_maximum_bitrate_kbps();
  int32_t maximum_bitrate_kbps() const;
  void set_maximum_bitrate_kbps(int32_t value);
  private:
  int32_t _internal_maximum_bitrate_kbps() const;
  void _internal_set_maximum_bitrate_kbps(int32_t value);
  public:

  // optional bool enable_hardware_decoding = 7 [default = true];
  bool has_enable_hardware_decoding() const;
  private:
  bool _internal_has_enable_hardware_decoding() const;
  public:
  void clear_enable_hardware_decoding();
  bool enable_hardware_decoding() const;
  void set_enable_hardware_decoding(bool value);
  private:
  bool _internal_enable_hardware_decoding() const;
  void _internal_set_enable_hardware_decoding(bool value);
  public:

  // optional bool enable_video_streaming = 9 [default = true];
  bool has_enable_video_streaming() const;
  private:
  bool _internal_has_enable_video_streaming() const;
  public:
  void clear_enable_video_streaming();
  bool enable_video_streaming() const;
  void set_enable_video_streaming(bool value);
  private:
  bool _internal_enable_video_streaming() const;
  void _internal_set_enable_video_streaming(bool value);
  public:

  // optional bool enable_audio_streaming = 10 [default = true];
  bool has_enable_audio_streaming() const;
  private:
  bool _internal_has_enable_audio_streaming() const;
  public:
  void clear_enable_audio_streaming();
  bool enable_audio_streaming() const;
  void set_enable_audio_streaming(bool value);
  private:
  bool _internal_enable_audio_streaming() const;
  void _internal_set_enable_audio_streaming(bool value);
  public:

  // optional bool enable_input_streaming = 11 [default = true];
  bool has_enable_input_streaming() const;
  private:
  bool _internal_has_enable_input_streaming() const;
  public:
  void clear_enable_input_streaming();
  bool enable_input_streaming() const;
  void set_enable_input_streaming(bool value);
  private:
  bool _internal_enable_input_streaming() const;
  void _internal_set_enable_input_streaming(bool value);
  public:

  // optional int32 audio_channels = 12 [default = 2];
  bool has_audio_channels() const;
  private:
  bool _internal_has_audio_channels() const;
  public:
  void clear_audio_channels();
  int32_t audio_channels() const;
  void set_audio_channels(int32_t value);
  private:
  int32_t _internal_audio_channels() const;
  void _internal_set_audio_channels(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingClientConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_overlay_hotkey_;
  uint32_t maximum_resolution_x_;
  uint32_t maximum_resolution_y_;
  uint32_t maximum_framerate_numerator_;
  uint32_t maximum_framerate_denominator_;
  bool enable_performance_overlay_;
  bool enable_video_hevc_;
  bool enable_microphone_streaming_;
  bool enable_touch_controller_obsolete_;
  int p2p_scope_;
  bool enable_audio_uncompressed_;
  bool enable_performance_icons_;
  int quality_;
  int32_t maximum_bitrate_kbps_;
  bool enable_hardware_decoding_;
  bool enable_video_streaming_;
  bool enable_audio_streaming_;
  bool enable_input_streaming_;
  int32_t audio_channels_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingServerConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingServerConfig) */ {
 public:
  inline CStreamingServerConfig() : CStreamingServerConfig(nullptr) {}
  ~CStreamingServerConfig() override;
  explicit constexpr CStreamingServerConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingServerConfig(const CStreamingServerConfig& from);
  CStreamingServerConfig(CStreamingServerConfig&& from) noexcept
    : CStreamingServerConfig() {
    *this = ::std::move(from);
  }

  inline CStreamingServerConfig& operator=(const CStreamingServerConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingServerConfig& operator=(CStreamingServerConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingServerConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingServerConfig* internal_default_instance() {
    return reinterpret_cast<const CStreamingServerConfig*>(
               &_CStreamingServerConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(CStreamingServerConfig& a, CStreamingServerConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingServerConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingServerConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingServerConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingServerConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingServerConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingServerConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingServerConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingServerConfig";
  }
  protected:
  explicit CStreamingServerConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChangeDesktopResolutionFieldNumber = 1,
    kDynamicallyAdjustResolutionFieldNumber = 2,
    kEnableCaptureNvfbcFieldNumber = 3,
    kEnableHardwareEncodingNvidiaFieldNumber = 4,
    kEnableHardwareEncodingAmdFieldNumber = 5,
    kEnableHardwareEncodingIntelFieldNumber = 6,
    kEnableTrafficPriorityFieldNumber = 8,
    kSoftwareEncodingThreadsFieldNumber = 7,
    kHostPlayAudioFieldNumber = 9,
  };
  // optional bool change_desktop_resolution = 1;
  bool has_change_desktop_resolution() const;
  private:
  bool _internal_has_change_desktop_resolution() const;
  public:
  void clear_change_desktop_resolution();
  bool change_desktop_resolution() const;
  void set_change_desktop_resolution(bool value);
  private:
  bool _internal_change_desktop_resolution() const;
  void _internal_set_change_desktop_resolution(bool value);
  public:

  // optional bool dynamically_adjust_resolution = 2;
  bool has_dynamically_adjust_resolution() const;
  private:
  bool _internal_has_dynamically_adjust_resolution() const;
  public:
  void clear_dynamically_adjust_resolution();
  bool dynamically_adjust_resolution() const;
  void set_dynamically_adjust_resolution(bool value);
  private:
  bool _internal_dynamically_adjust_resolution() const;
  void _internal_set_dynamically_adjust_resolution(bool value);
  public:

  // optional bool enable_capture_nvfbc = 3;
  bool has_enable_capture_nvfbc() const;
  private:
  bool _internal_has_enable_capture_nvfbc() const;
  public:
  void clear_enable_capture_nvfbc();
  bool enable_capture_nvfbc() const;
  void set_enable_capture_nvfbc(bool value);
  private:
  bool _internal_enable_capture_nvfbc() const;
  void _internal_set_enable_capture_nvfbc(bool value);
  public:

  // optional bool enable_hardware_encoding_nvidia = 4;
  bool has_enable_hardware_encoding_nvidia() const;
  private:
  bool _internal_has_enable_hardware_encoding_nvidia() const;
  public:
  void clear_enable_hardware_encoding_nvidia();
  bool enable_hardware_encoding_nvidia() const;
  void set_enable_hardware_encoding_nvidia(bool value);
  private:
  bool _internal_enable_hardware_encoding_nvidia() const;
  void _internal_set_enable_hardware_encoding_nvidia(bool value);
  public:

  // optional bool enable_hardware_encoding_amd = 5;
  bool has_enable_hardware_encoding_amd() const;
  private:
  bool _internal_has_enable_hardware_encoding_amd() const;
  public:
  void clear_enable_hardware_encoding_amd();
  bool enable_hardware_encoding_amd() const;
  void set_enable_hardware_encoding_amd(bool value);
  private:
  bool _internal_enable_hardware_encoding_amd() const;
  void _internal_set_enable_hardware_encoding_amd(bool value);
  public:

  // optional bool enable_hardware_encoding_intel = 6;
  bool has_enable_hardware_encoding_intel() const;
  private:
  bool _internal_has_enable_hardware_encoding_intel() const;
  public:
  void clear_enable_hardware_encoding_intel();
  bool enable_hardware_encoding_intel() const;
  void set_enable_hardware_encoding_intel(bool value);
  private:
  bool _internal_enable_hardware_encoding_intel() const;
  void _internal_set_enable_hardware_encoding_intel(bool value);
  public:

  // optional bool enable_traffic_priority = 8;
  bool has_enable_traffic_priority() const;
  private:
  bool _internal_has_enable_traffic_priority() const;
  public:
  void clear_enable_traffic_priority();
  bool enable_traffic_priority() const;
  void set_enable_traffic_priority(bool value);
  private:
  bool _internal_enable_traffic_priority() const;
  void _internal_set_enable_traffic_priority(bool value);
  public:

  // optional int32 software_encoding_threads = 7;
  bool has_software_encoding_threads() const;
  private:
  bool _internal_has_software_encoding_threads() const;
  public:
  void clear_software_encoding_threads();
  int32_t software_encoding_threads() const;
  void set_software_encoding_threads(int32_t value);
  private:
  int32_t _internal_software_encoding_threads() const;
  void _internal_set_software_encoding_threads(int32_t value);
  public:

  // optional .EStreamHostPlayAudioPreference host_play_audio = 9 [default = k_EStreamHostPlayAudioDefault];
  bool has_host_play_audio() const;
  private:
  bool _internal_has_host_play_audio() const;
  public:
  void clear_host_play_audio();
  ::EStreamHostPlayAudioPreference host_play_audio() const;
  void set_host_play_audio(::EStreamHostPlayAudioPreference value);
  private:
  ::EStreamHostPlayAudioPreference _internal_host_play_audio() const;
  void _internal_set_host_play_audio(::EStreamHostPlayAudioPreference value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingServerConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool change_desktop_resolution_;
  bool dynamically_adjust_resolution_;
  bool enable_capture_nvfbc_;
  bool enable_hardware_encoding_nvidia_;
  bool enable_hardware_encoding_amd_;
  bool enable_hardware_encoding_intel_;
  bool enable_traffic_priority_;
  int32_t software_encoding_threads_;
  int host_play_audio_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CNegotiatedConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CNegotiatedConfig) */ {
 public:
  inline CNegotiatedConfig() : CNegotiatedConfig(nullptr) {}
  ~CNegotiatedConfig() override;
  explicit constexpr CNegotiatedConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNegotiatedConfig(const CNegotiatedConfig& from);
  CNegotiatedConfig(CNegotiatedConfig&& from) noexcept
    : CNegotiatedConfig() {
    *this = ::std::move(from);
  }

  inline CNegotiatedConfig& operator=(const CNegotiatedConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNegotiatedConfig& operator=(CNegotiatedConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNegotiatedConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNegotiatedConfig* internal_default_instance() {
    return reinterpret_cast<const CNegotiatedConfig*>(
               &_CNegotiatedConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(CNegotiatedConfig& a, CNegotiatedConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CNegotiatedConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNegotiatedConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNegotiatedConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNegotiatedConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNegotiatedConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CNegotiatedConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiatedConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CNegotiatedConfig";
  }
  protected:
  explicit CNegotiatedConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvailableVideoModesFieldNumber = 4,
    kSelectedAudioCodecFieldNumber = 2,
    kSelectedVideoCodecFieldNumber = 3,
    kReliableDataFieldNumber = 1,
    kEnableRemoteHidFieldNumber = 5,
    kEnableTouchInputFieldNumber = 6,
    kDisableClientCursorFieldNumber = 7,
  };
  // repeated .CStreamVideoMode available_video_modes = 4;
  int available_video_modes_size() const;
  private:
  int _internal_available_video_modes_size() const;
  public:
  void clear_available_video_modes();
  ::CStreamVideoMode* mutable_available_video_modes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamVideoMode >*
      mutable_available_video_modes();
  private:
  const ::CStreamVideoMode& _internal_available_video_modes(int index) const;
  ::CStreamVideoMode* _internal_add_available_video_modes();
  public:
  const ::CStreamVideoMode& available_video_modes(int index) const;
  ::CStreamVideoMode* add_available_video_modes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamVideoMode >&
      available_video_modes() const;

  // optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
  bool has_selected_audio_codec() const;
  private:
  bool _internal_has_selected_audio_codec() const;
  public:
  void clear_selected_audio_codec();
  ::EStreamAudioCodec selected_audio_codec() const;
  void set_selected_audio_codec(::EStreamAudioCodec value);
  private:
  ::EStreamAudioCodec _internal_selected_audio_codec() const;
  void _internal_set_selected_audio_codec(::EStreamAudioCodec value);
  public:

  // optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
  bool has_selected_video_codec() const;
  private:
  bool _internal_has_selected_video_codec() const;
  public:
  void clear_selected_video_codec();
  ::EStreamVideoCodec selected_video_codec() const;
  void set_selected_video_codec(::EStreamVideoCodec value);
  private:
  ::EStreamVideoCodec _internal_selected_video_codec() const;
  void _internal_set_selected_video_codec(::EStreamVideoCodec value);
  public:

  // optional bool reliable_data = 1;
  bool has_reliable_data() const;
  private:
  bool _internal_has_reliable_data() const;
  public:
  void clear_reliable_data();
  bool reliable_data() const;
  void set_reliable_data(bool value);
  private:
  bool _internal_reliable_data() const;
  void _internal_set_reliable_data(bool value);
  public:

  // optional bool enable_remote_hid = 5;
  bool has_enable_remote_hid() const;
  private:
  bool _internal_has_enable_remote_hid() const;
  public:
  void clear_enable_remote_hid();
  bool enable_remote_hid() const;
  void set_enable_remote_hid(bool value);
  private:
  bool _internal_enable_remote_hid() const;
  void _internal_set_enable_remote_hid(bool value);
  public:

  // optional bool enable_touch_input = 6;
  bool has_enable_touch_input() const;
  private:
  bool _internal_has_enable_touch_input() const;
  public:
  void clear_enable_touch_input();
  bool enable_touch_input() const;
  void set_enable_touch_input(bool value);
  private:
  bool _internal_enable_touch_input() const;
  void _internal_set_enable_touch_input(bool value);
  public:

  // optional bool disable_client_cursor = 7;
  bool has_disable_client_cursor() const;
  private:
  bool _internal_has_disable_client_cursor() const;
  public:
  void clear_disable_client_cursor();
  bool disable_client_cursor() const;
  void set_disable_client_cursor(bool value);
  private:
  bool _internal_disable_client_cursor() const;
  void _internal_set_disable_client_cursor(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CNegotiatedConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamVideoMode > available_video_modes_;
  int selected_audio_codec_;
  int selected_video_codec_;
  bool reliable_data_;
  bool enable_remote_hid_;
  bool enable_touch_input_;
  bool disable_client_cursor_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CNegotiationInitMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CNegotiationInitMsg) */ {
 public:
  inline CNegotiationInitMsg() : CNegotiationInitMsg(nullptr) {}
  ~CNegotiationInitMsg() override;
  explicit constexpr CNegotiationInitMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNegotiationInitMsg(const CNegotiationInitMsg& from);
  CNegotiationInitMsg(CNegotiationInitMsg&& from) noexcept
    : CNegotiationInitMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationInitMsg& operator=(const CNegotiationInitMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNegotiationInitMsg& operator=(CNegotiationInitMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNegotiationInitMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNegotiationInitMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationInitMsg*>(
               &_CNegotiationInitMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(CNegotiationInitMsg& a, CNegotiationInitMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CNegotiationInitMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNegotiationInitMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNegotiationInitMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNegotiationInitMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNegotiationInitMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CNegotiationInitMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiationInitMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CNegotiationInitMsg";
  }
  protected:
  explicit CNegotiationInitMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSupportedAudioCodecsFieldNumber = 2,
    kSupportedVideoCodecsFieldNumber = 3,
    kReliableDataFieldNumber = 1,
    kSupportsRemoteHidFieldNumber = 4,
    kSupportsTouchInputFieldNumber = 5,
  };
  // repeated .EStreamAudioCodec supported_audio_codecs = 2;
  int supported_audio_codecs_size() const;
  private:
  int _internal_supported_audio_codecs_size() const;
  public:
  void clear_supported_audio_codecs();
  private:
  ::EStreamAudioCodec _internal_supported_audio_codecs(int index) const;
  void _internal_add_supported_audio_codecs(::EStreamAudioCodec value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_audio_codecs();
  public:
  ::EStreamAudioCodec supported_audio_codecs(int index) const;
  void set_supported_audio_codecs(int index, ::EStreamAudioCodec value);
  void add_supported_audio_codecs(::EStreamAudioCodec value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_audio_codecs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_audio_codecs();

  // repeated .EStreamVideoCodec supported_video_codecs = 3;
  int supported_video_codecs_size() const;
  private:
  int _internal_supported_video_codecs_size() const;
  public:
  void clear_supported_video_codecs();
  private:
  ::EStreamVideoCodec _internal_supported_video_codecs(int index) const;
  void _internal_add_supported_video_codecs(::EStreamVideoCodec value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* _internal_mutable_supported_video_codecs();
  public:
  ::EStreamVideoCodec supported_video_codecs(int index) const;
  void set_supported_video_codecs(int index, ::EStreamVideoCodec value);
  void add_supported_video_codecs(::EStreamVideoCodec value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>& supported_video_codecs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>* mutable_supported_video_codecs();

  // optional bool reliable_data = 1;
  bool has_reliable_data() const;
  private:
  bool _internal_has_reliable_data() const;
  public:
  void clear_reliable_data();
  bool reliable_data() const;
  void set_reliable_data(bool value);
  private:
  bool _internal_reliable_data() const;
  void _internal_set_reliable_data(bool value);
  public:

  // optional bool supports_remote_hid = 4;
  bool has_supports_remote_hid() const;
  private:
  bool _internal_has_supports_remote_hid() const;
  public:
  void clear_supports_remote_hid();
  bool supports_remote_hid() const;
  void set_supports_remote_hid(bool value);
  private:
  bool _internal_supports_remote_hid() const;
  void _internal_set_supports_remote_hid(bool value);
  public:

  // optional bool supports_touch_input = 5;
  bool has_supports_touch_input() const;
  private:
  bool _internal_has_supports_touch_input() const;
  public:
  void clear_supports_touch_input();
  bool supports_touch_input() const;
  void set_supports_touch_input(bool value);
  private:
  bool _internal_supports_touch_input() const;
  void _internal_set_supports_touch_input(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CNegotiationInitMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_audio_codecs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField<int> supported_video_codecs_;
  bool reliable_data_;
  bool supports_remote_hid_;
  bool supports_touch_input_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CNegotiationSetConfigMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CNegotiationSetConfigMsg) */ {
 public:
  inline CNegotiationSetConfigMsg() : CNegotiationSetConfigMsg(nullptr) {}
  ~CNegotiationSetConfigMsg() override;
  explicit constexpr CNegotiationSetConfigMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNegotiationSetConfigMsg(const CNegotiationSetConfigMsg& from);
  CNegotiationSetConfigMsg(CNegotiationSetConfigMsg&& from) noexcept
    : CNegotiationSetConfigMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationSetConfigMsg& operator=(const CNegotiationSetConfigMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNegotiationSetConfigMsg& operator=(CNegotiationSetConfigMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNegotiationSetConfigMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNegotiationSetConfigMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationSetConfigMsg*>(
               &_CNegotiationSetConfigMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(CNegotiationSetConfigMsg& a, CNegotiationSetConfigMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CNegotiationSetConfigMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNegotiationSetConfigMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNegotiationSetConfigMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNegotiationSetConfigMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CNegotiationSetConfigMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CNegotiationSetConfigMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CNegotiationSetConfigMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CNegotiationSetConfigMsg";
  }
  protected:
  explicit CNegotiationSetConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
    kStreamingClientConfigFieldNumber = 2,
    kStreamingClientCapsFieldNumber = 3,
  };
  // required .CNegotiatedConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::CNegotiatedConfig& config() const;
  PROTOBUF_NODISCARD ::CNegotiatedConfig* release_config();
  ::CNegotiatedConfig* mutable_config();
  void set_allocated_config(::CNegotiatedConfig* config);
  private:
  const ::CNegotiatedConfig& _internal_config() const;
  ::CNegotiatedConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::CNegotiatedConfig* config);
  ::CNegotiatedConfig* unsafe_arena_release_config();

  // optional .CStreamingClientConfig streaming_client_config = 2;
  bool has_streaming_client_config() const;
  private:
  bool _internal_has_streaming_client_config() const;
  public:
  void clear_streaming_client_config();
  const ::CStreamingClientConfig& streaming_client_config() const;
  PROTOBUF_NODISCARD ::CStreamingClientConfig* release_streaming_client_config();
  ::CStreamingClientConfig* mutable_streaming_client_config();
  void set_allocated_streaming_client_config(::CStreamingClientConfig* streaming_client_config);
  private:
  const ::CStreamingClientConfig& _internal_streaming_client_config() const;
  ::CStreamingClientConfig* _internal_mutable_streaming_client_config();
  public:
  void unsafe_arena_set_allocated_streaming_client_config(
      ::CStreamingClientConfig* streaming_client_config);
  ::CStreamingClientConfig* unsafe_arena_release_streaming_client_config();

  // optional .CStreamingClientCaps streaming_client_caps = 3;
  bool has_streaming_client_caps() const;
  private:
  bool _internal_has_streaming_client_caps() const;
  public:
  void clear_streaming_client_caps();
  const ::CStreamingClientCaps& streaming_client_caps() const;
  PROTOBUF_NODISCARD ::CStreamingClientCaps* release_streaming_client_caps();
  ::CStreamingClientCaps* mutable_streaming_client_caps();
  void set_allocated_streaming_client_caps(::CStreamingClientCaps* streaming_client_caps);
  private:
  const ::CStreamingClientCaps& _internal_streaming_client_caps() const;
  ::CStreamingClientCaps* _internal_mutable_streaming_client_caps();
  public:
  void unsafe_arena_set_allocated_streaming_client_caps(
      ::CStreamingClientCaps* streaming_client_caps);
  ::CStreamingClientCaps* unsafe_arena_release_streaming_client_caps();

  // @@protoc_insertion_point(class_scope:CNegotiationSetConfigMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CNegotiatedConfig* config_;
  ::CStreamingClientConfig* streaming_client_config_;
  ::CStreamingClientCaps* streaming_client_caps_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CNegotiationCompleteMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CNegotiationCompleteMsg) */ {
 public:
  inline CNegotiationCompleteMsg() : CNegotiationCompleteMsg(nullptr) {}
  explicit constexpr CNegotiationCompleteMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CNegotiationCompleteMsg(const CNegotiationCompleteMsg& from);
  CNegotiationCompleteMsg(CNegotiationCompleteMsg&& from) noexcept
    : CNegotiationCompleteMsg() {
    *this = ::std::move(from);
  }

  inline CNegotiationCompleteMsg& operator=(const CNegotiationCompleteMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CNegotiationCompleteMsg& operator=(CNegotiationCompleteMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CNegotiationCompleteMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CNegotiationCompleteMsg* internal_default_instance() {
    return reinterpret_cast<const CNegotiationCompleteMsg*>(
               &_CNegotiationCompleteMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(CNegotiationCompleteMsg& a, CNegotiationCompleteMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CNegotiationCompleteMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CNegotiationCompleteMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CNegotiationCompleteMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CNegotiationCompleteMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CNegotiationCompleteMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CNegotiationCompleteMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CNegotiationCompleteMsg";
  }
  protected:
  explicit CNegotiationCompleteMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CNegotiationCompleteMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStartAudioDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStartAudioDataMsg) */ {
 public:
  inline CStartAudioDataMsg() : CStartAudioDataMsg(nullptr) {}
  ~CStartAudioDataMsg() override;
  explicit constexpr CStartAudioDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStartAudioDataMsg(const CStartAudioDataMsg& from);
  CStartAudioDataMsg(CStartAudioDataMsg&& from) noexcept
    : CStartAudioDataMsg() {
    *this = ::std::move(from);
  }

  inline CStartAudioDataMsg& operator=(const CStartAudioDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStartAudioDataMsg& operator=(CStartAudioDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStartAudioDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStartAudioDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStartAudioDataMsg*>(
               &_CStartAudioDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(CStartAudioDataMsg& a, CStartAudioDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStartAudioDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStartAudioDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStartAudioDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStartAudioDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStartAudioDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStartAudioDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartAudioDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStartAudioDataMsg";
  }
  protected:
  explicit CStartAudioDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecDataFieldNumber = 4,
    kChannelFieldNumber = 2,
    kCodecFieldNumber = 3,
    kFrequencyFieldNumber = 5,
    kChannelsFieldNumber = 6,
  };
  // optional bytes codec_data = 4;
  bool has_codec_data() const;
  private:
  bool _internal_has_codec_data() const;
  public:
  void clear_codec_data();
  const std::string& codec_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codec_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codec_data();
  PROTOBUF_NODISCARD std::string* release_codec_data();
  void set_allocated_codec_data(std::string* codec_data);
  private:
  const std::string& _internal_codec_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec_data(const std::string& value);
  std::string* _internal_mutable_codec_data();
  public:

  // required uint32 channel = 2;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
  bool has_codec() const;
  private:
  bool _internal_has_codec() const;
  public:
  void clear_codec();
  ::EStreamAudioCodec codec() const;
  void set_codec(::EStreamAudioCodec value);
  private:
  ::EStreamAudioCodec _internal_codec() const;
  void _internal_set_codec(::EStreamAudioCodec value);
  public:

  // optional uint32 frequency = 5;
  bool has_frequency() const;
  private:
  bool _internal_has_frequency() const;
  public:
  void clear_frequency();
  uint32_t frequency() const;
  void set_frequency(uint32_t value);
  private:
  uint32_t _internal_frequency() const;
  void _internal_set_frequency(uint32_t value);
  public:

  // optional uint32 channels = 6;
  bool has_channels() const;
  private:
  bool _internal_has_channels() const;
  public:
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStartAudioDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codec_data_;
  uint32_t channel_;
  int codec_;
  uint32_t frequency_;
  uint32_t channels_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStopAudioDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CStopAudioDataMsg) */ {
 public:
  inline CStopAudioDataMsg() : CStopAudioDataMsg(nullptr) {}
  explicit constexpr CStopAudioDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStopAudioDataMsg(const CStopAudioDataMsg& from);
  CStopAudioDataMsg(CStopAudioDataMsg&& from) noexcept
    : CStopAudioDataMsg() {
    *this = ::std::move(from);
  }

  inline CStopAudioDataMsg& operator=(const CStopAudioDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStopAudioDataMsg& operator=(CStopAudioDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStopAudioDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStopAudioDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStopAudioDataMsg*>(
               &_CStopAudioDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(CStopAudioDataMsg& a, CStopAudioDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStopAudioDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStopAudioDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStopAudioDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStopAudioDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CStopAudioDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CStopAudioDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStopAudioDataMsg";
  }
  protected:
  explicit CStopAudioDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopAudioDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStartVideoDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStartVideoDataMsg) */ {
 public:
  inline CStartVideoDataMsg() : CStartVideoDataMsg(nullptr) {}
  ~CStartVideoDataMsg() override;
  explicit constexpr CStartVideoDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStartVideoDataMsg(const CStartVideoDataMsg& from);
  CStartVideoDataMsg(CStartVideoDataMsg&& from) noexcept
    : CStartVideoDataMsg() {
    *this = ::std::move(from);
  }

  inline CStartVideoDataMsg& operator=(const CStartVideoDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStartVideoDataMsg& operator=(CStartVideoDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStartVideoDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStartVideoDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStartVideoDataMsg*>(
               &_CStartVideoDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(CStartVideoDataMsg& a, CStartVideoDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStartVideoDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStartVideoDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStartVideoDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStartVideoDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStartVideoDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStartVideoDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartVideoDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStartVideoDataMsg";
  }
  protected:
  explicit CStartVideoDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCodecDataFieldNumber = 3,
    kChannelFieldNumber = 1,
    kCodecFieldNumber = 2,
    kWidthFieldNumber = 4,
    kHeightFieldNumber = 5,
  };
  // optional bytes codec_data = 3;
  bool has_codec_data() const;
  private:
  bool _internal_has_codec_data() const;
  public:
  void clear_codec_data();
  const std::string& codec_data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_codec_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_codec_data();
  PROTOBUF_NODISCARD std::string* release_codec_data();
  void set_allocated_codec_data(std::string* codec_data);
  private:
  const std::string& _internal_codec_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_codec_data(const std::string& value);
  std::string* _internal_mutable_codec_data();
  public:

  // required uint32 channel = 1;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
  bool has_codec() const;
  private:
  bool _internal_has_codec() const;
  public:
  void clear_codec();
  ::EStreamVideoCodec codec() const;
  void set_codec(::EStreamVideoCodec value);
  private:
  ::EStreamVideoCodec _internal_codec() const;
  void _internal_set_codec(::EStreamVideoCodec value);
  public:

  // optional uint32 width = 4;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 5;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStartVideoDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr codec_data_;
  uint32_t channel_;
  int codec_;
  uint32_t width_;
  uint32_t height_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStopVideoDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CStopVideoDataMsg) */ {
 public:
  inline CStopVideoDataMsg() : CStopVideoDataMsg(nullptr) {}
  explicit constexpr CStopVideoDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStopVideoDataMsg(const CStopVideoDataMsg& from);
  CStopVideoDataMsg(CStopVideoDataMsg&& from) noexcept
    : CStopVideoDataMsg() {
    *this = ::std::move(from);
  }

  inline CStopVideoDataMsg& operator=(const CStopVideoDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStopVideoDataMsg& operator=(CStopVideoDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStopVideoDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStopVideoDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStopVideoDataMsg*>(
               &_CStopVideoDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(CStopVideoDataMsg& a, CStopVideoDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStopVideoDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStopVideoDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStopVideoDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStopVideoDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CStopVideoDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CStopVideoDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStopVideoDataMsg";
  }
  protected:
  explicit CStopVideoDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopVideoDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStartNeptuneDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStartNeptuneDataMsg) */ {
 public:
  inline CStartNeptuneDataMsg() : CStartNeptuneDataMsg(nullptr) {}
  ~CStartNeptuneDataMsg() override;
  explicit constexpr CStartNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStartNeptuneDataMsg(const CStartNeptuneDataMsg& from);
  CStartNeptuneDataMsg(CStartNeptuneDataMsg&& from) noexcept
    : CStartNeptuneDataMsg() {
    *this = ::std::move(from);
  }

  inline CStartNeptuneDataMsg& operator=(const CStartNeptuneDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStartNeptuneDataMsg& operator=(CStartNeptuneDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStartNeptuneDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStartNeptuneDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStartNeptuneDataMsg*>(
               &_CStartNeptuneDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(CStartNeptuneDataMsg& a, CStartNeptuneDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStartNeptuneDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStartNeptuneDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStartNeptuneDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStartNeptuneDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStartNeptuneDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStartNeptuneDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStartNeptuneDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStartNeptuneDataMsg";
  }
  protected:
  explicit CStartNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelFieldNumber = 1,
  };
  // required uint32 channel = 1;
  bool has_channel() const;
  private:
  bool _internal_has_channel() const;
  public:
  void clear_channel();
  uint32_t channel() const;
  void set_channel(uint32_t value);
  private:
  uint32_t _internal_channel() const;
  void _internal_set_channel(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStartNeptuneDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t channel_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStopNeptuneDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CStopNeptuneDataMsg) */ {
 public:
  inline CStopNeptuneDataMsg() : CStopNeptuneDataMsg(nullptr) {}
  explicit constexpr CStopNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStopNeptuneDataMsg(const CStopNeptuneDataMsg& from);
  CStopNeptuneDataMsg(CStopNeptuneDataMsg&& from) noexcept
    : CStopNeptuneDataMsg() {
    *this = ::std::move(from);
  }

  inline CStopNeptuneDataMsg& operator=(const CStopNeptuneDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStopNeptuneDataMsg& operator=(CStopNeptuneDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStopNeptuneDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStopNeptuneDataMsg* internal_default_instance() {
    return reinterpret_cast<const CStopNeptuneDataMsg*>(
               &_CStopNeptuneDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(CStopNeptuneDataMsg& a, CStopNeptuneDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStopNeptuneDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStopNeptuneDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStopNeptuneDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStopNeptuneDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CStopNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CStopNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStopNeptuneDataMsg";
  }
  protected:
  explicit CStopNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopNeptuneDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CRecordedInput final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRecordedInput) */ {
 public:
  inline CRecordedInput() : CRecordedInput(nullptr) {}
  ~CRecordedInput() override;
  explicit constexpr CRecordedInput(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CRecordedInput(const CRecordedInput& from);
  CRecordedInput(CRecordedInput&& from) noexcept
    : CRecordedInput() {
    *this = ::std::move(from);
  }

  inline CRecordedInput& operator=(const CRecordedInput& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRecordedInput& operator=(CRecordedInput&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CRecordedInput& default_instance() {
    return *internal_default_instance();
  }
  enum DataCase {
    kFingerDown = 3,
    kFingerMotion = 4,
    kFingerUp = 5,
    kMouseMotion = 6,
    kMouseWheel = 7,
    kMouseDown = 8,
    kMouseUp = 9,
    kKeyDown = 10,
    kKeyUp = 11,
    kText = 12,
    kHid = 13,
    DATA_NOT_SET = 0,
  };

  static inline const CRecordedInput* internal_default_instance() {
    return reinterpret_cast<const CRecordedInput*>(
               &_CRecordedInput_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(CRecordedInput& a, CRecordedInput& b) {
    a.Swap(&b);
  }
  inline void Swap(CRecordedInput* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CRecordedInput* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CRecordedInput* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CRecordedInput>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CRecordedInput& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CRecordedInput& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRecordedInput* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRecordedInput";
  }
  protected:
  explicit CRecordedInput(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimestampFieldNumber = 2,
    kTypeFieldNumber = 1,
    kFingerDownFieldNumber = 3,
    kFingerMotionFieldNumber = 4,
    kFingerUpFieldNumber = 5,
    kMouseMotionFieldNumber = 6,
    kMouseWheelFieldNumber = 7,
    kMouseDownFieldNumber = 8,
    kMouseUpFieldNumber = 9,
    kKeyDownFieldNumber = 10,
    kKeyUpFieldNumber = 11,
    kTextFieldNumber = 12,
    kHidFieldNumber = 13,
  };
  // optional uint32 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // optional .EStreamControlMessage type = 1 [default = k_EStreamControlAuthenticationRequest];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::EStreamControlMessage type() const;
  void set_type(::EStreamControlMessage value);
  private:
  ::EStreamControlMessage _internal_type() const;
  void _internal_set_type(::EStreamControlMessage value);
  public:

  // .CInputTouchFingerDownMsg finger_down = 3;
  bool has_finger_down() const;
  private:
  bool _internal_has_finger_down() const;
  public:
  void clear_finger_down();
  const ::CInputTouchFingerDownMsg& finger_down() const;
  PROTOBUF_NODISCARD ::CInputTouchFingerDownMsg* release_finger_down();
  ::CInputTouchFingerDownMsg* mutable_finger_down();
  void set_allocated_finger_down(::CInputTouchFingerDownMsg* finger_down);
  private:
  const ::CInputTouchFingerDownMsg& _internal_finger_down() const;
  ::CInputTouchFingerDownMsg* _internal_mutable_finger_down();
  public:
  void unsafe_arena_set_allocated_finger_down(
      ::CInputTouchFingerDownMsg* finger_down);
  ::CInputTouchFingerDownMsg* unsafe_arena_release_finger_down();

  // .CInputTouchFingerMotionMsg finger_motion = 4;
  bool has_finger_motion() const;
  private:
  bool _internal_has_finger_motion() const;
  public:
  void clear_finger_motion();
  const ::CInputTouchFingerMotionMsg& finger_motion() const;
  PROTOBUF_NODISCARD ::CInputTouchFingerMotionMsg* release_finger_motion();
  ::CInputTouchFingerMotionMsg* mutable_finger_motion();
  void set_allocated_finger_motion(::CInputTouchFingerMotionMsg* finger_motion);
  private:
  const ::CInputTouchFingerMotionMsg& _internal_finger_motion() const;
  ::CInputTouchFingerMotionMsg* _internal_mutable_finger_motion();
  public:
  void unsafe_arena_set_allocated_finger_motion(
      ::CInputTouchFingerMotionMsg* finger_motion);
  ::CInputTouchFingerMotionMsg* unsafe_arena_release_finger_motion();

  // .CInputTouchFingerUpMsg finger_up = 5;
  bool has_finger_up() const;
  private:
  bool _internal_has_finger_up() const;
  public:
  void clear_finger_up();
  const ::CInputTouchFingerUpMsg& finger_up() const;
  PROTOBUF_NODISCARD ::CInputTouchFingerUpMsg* release_finger_up();
  ::CInputTouchFingerUpMsg* mutable_finger_up();
  void set_allocated_finger_up(::CInputTouchFingerUpMsg* finger_up);
  private:
  const ::CInputTouchFingerUpMsg& _internal_finger_up() const;
  ::CInputTouchFingerUpMsg* _internal_mutable_finger_up();
  public:
  void unsafe_arena_set_allocated_finger_up(
      ::CInputTouchFingerUpMsg* finger_up);
  ::CInputTouchFingerUpMsg* unsafe_arena_release_finger_up();

  // .CInputMouseMotionMsg mouse_motion = 6;
  bool has_mouse_motion() const;
  private:
  bool _internal_has_mouse_motion() const;
  public:
  void clear_mouse_motion();
  const ::CInputMouseMotionMsg& mouse_motion() const;
  PROTOBUF_NODISCARD ::CInputMouseMotionMsg* release_mouse_motion();
  ::CInputMouseMotionMsg* mutable_mouse_motion();
  void set_allocated_mouse_motion(::CInputMouseMotionMsg* mouse_motion);
  private:
  const ::CInputMouseMotionMsg& _internal_mouse_motion() const;
  ::CInputMouseMotionMsg* _internal_mutable_mouse_motion();
  public:
  void unsafe_arena_set_allocated_mouse_motion(
      ::CInputMouseMotionMsg* mouse_motion);
  ::CInputMouseMotionMsg* unsafe_arena_release_mouse_motion();

  // .CInputMouseWheelMsg mouse_wheel = 7;
  bool has_mouse_wheel() const;
  private:
  bool _internal_has_mouse_wheel() const;
  public:
  void clear_mouse_wheel();
  const ::CInputMouseWheelMsg& mouse_wheel() const;
  PROTOBUF_NODISCARD ::CInputMouseWheelMsg* release_mouse_wheel();
  ::CInputMouseWheelMsg* mutable_mouse_wheel();
  void set_allocated_mouse_wheel(::CInputMouseWheelMsg* mouse_wheel);
  private:
  const ::CInputMouseWheelMsg& _internal_mouse_wheel() const;
  ::CInputMouseWheelMsg* _internal_mutable_mouse_wheel();
  public:
  void unsafe_arena_set_allocated_mouse_wheel(
      ::CInputMouseWheelMsg* mouse_wheel);
  ::CInputMouseWheelMsg* unsafe_arena_release_mouse_wheel();

  // .CInputMouseDownMsg mouse_down = 8;
  bool has_mouse_down() const;
  private:
  bool _internal_has_mouse_down() const;
  public:
  void clear_mouse_down();
  const ::CInputMouseDownMsg& mouse_down() const;
  PROTOBUF_NODISCARD ::CInputMouseDownMsg* release_mouse_down();
  ::CInputMouseDownMsg* mutable_mouse_down();
  void set_allocated_mouse_down(::CInputMouseDownMsg* mouse_down);
  private:
  const ::CInputMouseDownMsg& _internal_mouse_down() const;
  ::CInputMouseDownMsg* _internal_mutable_mouse_down();
  public:
  void unsafe_arena_set_allocated_mouse_down(
      ::CInputMouseDownMsg* mouse_down);
  ::CInputMouseDownMsg* unsafe_arena_release_mouse_down();

  // .CInputMouseUpMsg mouse_up = 9;
  bool has_mouse_up() const;
  private:
  bool _internal_has_mouse_up() const;
  public:
  void clear_mouse_up();
  const ::CInputMouseUpMsg& mouse_up() const;
  PROTOBUF_NODISCARD ::CInputMouseUpMsg* release_mouse_up();
  ::CInputMouseUpMsg* mutable_mouse_up();
  void set_allocated_mouse_up(::CInputMouseUpMsg* mouse_up);
  private:
  const ::CInputMouseUpMsg& _internal_mouse_up() const;
  ::CInputMouseUpMsg* _internal_mutable_mouse_up();
  public:
  void unsafe_arena_set_allocated_mouse_up(
      ::CInputMouseUpMsg* mouse_up);
  ::CInputMouseUpMsg* unsafe_arena_release_mouse_up();

  // .CInputKeyDownMsg key_down = 10;
  bool has_key_down() const;
  private:
  bool _internal_has_key_down() const;
  public:
  void clear_key_down();
  const ::CInputKeyDownMsg& key_down() const;
  PROTOBUF_NODISCARD ::CInputKeyDownMsg* release_key_down();
  ::CInputKeyDownMsg* mutable_key_down();
  void set_allocated_key_down(::CInputKeyDownMsg* key_down);
  private:
  const ::CInputKeyDownMsg& _internal_key_down() const;
  ::CInputKeyDownMsg* _internal_mutable_key_down();
  public:
  void unsafe_arena_set_allocated_key_down(
      ::CInputKeyDownMsg* key_down);
  ::CInputKeyDownMsg* unsafe_arena_release_key_down();

  // .CInputKeyUpMsg key_up = 11;
  bool has_key_up() const;
  private:
  bool _internal_has_key_up() const;
  public:
  void clear_key_up();
  const ::CInputKeyUpMsg& key_up() const;
  PROTOBUF_NODISCARD ::CInputKeyUpMsg* release_key_up();
  ::CInputKeyUpMsg* mutable_key_up();
  void set_allocated_key_up(::CInputKeyUpMsg* key_up);
  private:
  const ::CInputKeyUpMsg& _internal_key_up() const;
  ::CInputKeyUpMsg* _internal_mutable_key_up();
  public:
  void unsafe_arena_set_allocated_key_up(
      ::CInputKeyUpMsg* key_up);
  ::CInputKeyUpMsg* unsafe_arena_release_key_up();

  // .CInputTextMsg text = 12;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const ::CInputTextMsg& text() const;
  PROTOBUF_NODISCARD ::CInputTextMsg* release_text();
  ::CInputTextMsg* mutable_text();
  void set_allocated_text(::CInputTextMsg* text);
  private:
  const ::CInputTextMsg& _internal_text() const;
  ::CInputTextMsg* _internal_mutable_text();
  public:
  void unsafe_arena_set_allocated_text(
      ::CInputTextMsg* text);
  ::CInputTextMsg* unsafe_arena_release_text();

  // .CRemoteHIDMsg hid = 13;
  bool has_hid() const;
  private:
  bool _internal_has_hid() const;
  public:
  void clear_hid();
  const ::CRemoteHIDMsg& hid() const;
  PROTOBUF_NODISCARD ::CRemoteHIDMsg* release_hid();
  ::CRemoteHIDMsg* mutable_hid();
  void set_allocated_hid(::CRemoteHIDMsg* hid);
  private:
  const ::CRemoteHIDMsg& _internal_hid() const;
  ::CRemoteHIDMsg* _internal_mutable_hid();
  public:
  void unsafe_arena_set_allocated_hid(
      ::CRemoteHIDMsg* hid);
  ::CRemoteHIDMsg* unsafe_arena_release_hid();

  void clear_data();
  DataCase data_case() const;
  // @@protoc_insertion_point(class_scope:CRecordedInput)
 private:
  class _Internal;
  void set_has_finger_down();
  void set_has_finger_motion();
  void set_has_finger_up();
  void set_has_mouse_motion();
  void set_has_mouse_wheel();
  void set_has_mouse_down();
  void set_has_mouse_up();
  void set_has_key_down();
  void set_has_key_up();
  void set_has_text();
  void set_has_hid();

  inline bool has_data() const;
  inline void clear_has_data();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t timestamp_;
  int type_;
  union DataUnion {
    constexpr DataUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::CInputTouchFingerDownMsg* finger_down_;
    ::CInputTouchFingerMotionMsg* finger_motion_;
    ::CInputTouchFingerUpMsg* finger_up_;
    ::CInputMouseMotionMsg* mouse_motion_;
    ::CInputMouseWheelMsg* mouse_wheel_;
    ::CInputMouseDownMsg* mouse_down_;
    ::CInputMouseUpMsg* mouse_up_;
    ::CInputKeyDownMsg* key_down_;
    ::CInputKeyUpMsg* key_up_;
    ::CInputTextMsg* text_;
    ::CRemoteHIDMsg* hid_;
  } data_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CRecordedInputStream final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRecordedInputStream) */ {
 public:
  inline CRecordedInputStream() : CRecordedInputStream(nullptr) {}
  ~CRecordedInputStream() override;
  explicit constexpr CRecordedInputStream(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CRecordedInputStream(const CRecordedInputStream& from);
  CRecordedInputStream(CRecordedInputStream&& from) noexcept
    : CRecordedInputStream() {
    *this = ::std::move(from);
  }

  inline CRecordedInputStream& operator=(const CRecordedInputStream& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRecordedInputStream& operator=(CRecordedInputStream&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CRecordedInputStream& default_instance() {
    return *internal_default_instance();
  }
  static inline const CRecordedInputStream* internal_default_instance() {
    return reinterpret_cast<const CRecordedInputStream*>(
               &_CRecordedInputStream_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CRecordedInputStream& a, CRecordedInputStream& b) {
    a.Swap(&b);
  }
  inline void Swap(CRecordedInputStream* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CRecordedInputStream* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CRecordedInputStream* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CRecordedInputStream>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CRecordedInputStream& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CRecordedInputStream& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRecordedInputStream* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRecordedInputStream";
  }
  protected:
  explicit CRecordedInputStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .CRecordedInput entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::CRecordedInput* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRecordedInput >*
      mutable_entries();
  private:
  const ::CRecordedInput& _internal_entries(int index) const;
  ::CRecordedInput* _internal_add_entries();
  public:
  const ::CRecordedInput& entries(int index) const;
  ::CRecordedInput* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRecordedInput >&
      entries() const;

  // @@protoc_insertion_point(class_scope:CRecordedInputStream)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRecordedInput > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputLatencyTestMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputLatencyTestMsg) */ {
 public:
  inline CInputLatencyTestMsg() : CInputLatencyTestMsg(nullptr) {}
  ~CInputLatencyTestMsg() override;
  explicit constexpr CInputLatencyTestMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputLatencyTestMsg(const CInputLatencyTestMsg& from);
  CInputLatencyTestMsg(CInputLatencyTestMsg&& from) noexcept
    : CInputLatencyTestMsg() {
    *this = ::std::move(from);
  }

  inline CInputLatencyTestMsg& operator=(const CInputLatencyTestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputLatencyTestMsg& operator=(CInputLatencyTestMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputLatencyTestMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputLatencyTestMsg* internal_default_instance() {
    return reinterpret_cast<const CInputLatencyTestMsg*>(
               &_CInputLatencyTestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CInputLatencyTestMsg& a, CInputLatencyTestMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputLatencyTestMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputLatencyTestMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputLatencyTestMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputLatencyTestMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputLatencyTestMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputLatencyTestMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputLatencyTestMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputLatencyTestMsg";
  }
  protected:
  explicit CInputLatencyTestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kColorFieldNumber = 2,
  };
  // required uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // optional uint32 color = 2;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  uint32_t color() const;
  void set_color(uint32_t value);
  private:
  uint32_t _internal_color() const;
  void _internal_set_color(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInputLatencyTestMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  uint32_t color_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputTouchFingerDownMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputTouchFingerDownMsg) */ {
 public:
  inline CInputTouchFingerDownMsg() : CInputTouchFingerDownMsg(nullptr) {}
  ~CInputTouchFingerDownMsg() override;
  explicit constexpr CInputTouchFingerDownMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputTouchFingerDownMsg(const CInputTouchFingerDownMsg& from);
  CInputTouchFingerDownMsg(CInputTouchFingerDownMsg&& from) noexcept
    : CInputTouchFingerDownMsg() {
    *this = ::std::move(from);
  }

  inline CInputTouchFingerDownMsg& operator=(const CInputTouchFingerDownMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputTouchFingerDownMsg& operator=(CInputTouchFingerDownMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputTouchFingerDownMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputTouchFingerDownMsg* internal_default_instance() {
    return reinterpret_cast<const CInputTouchFingerDownMsg*>(
               &_CInputTouchFingerDownMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(CInputTouchFingerDownMsg& a, CInputTouchFingerDownMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputTouchFingerDownMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputTouchFingerDownMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputTouchFingerDownMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputTouchFingerDownMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputTouchFingerDownMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputTouchFingerDownMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputTouchFingerDownMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputTouchFingerDownMsg";
  }
  protected:
  explicit CInputTouchFingerDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFingeridFieldNumber = 2,
    kInputMarkFieldNumber = 1,
    kXNormalizedFieldNumber = 3,
    kYNormalizedFieldNumber = 4,
  };
  // optional uint64 fingerid = 2;
  bool has_fingerid() const;
  private:
  bool _internal_has_fingerid() const;
  public:
  void clear_fingerid();
  uint64_t fingerid() const;
  void set_fingerid(uint64_t value);
  private:
  uint64_t _internal_fingerid() const;
  void _internal_set_fingerid(uint64_t value);
  public:

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // optional float x_normalized = 3;
  bool has_x_normalized() const;
  private:
  bool _internal_has_x_normalized() const;
  public:
  void clear_x_normalized();
  float x_normalized() const;
  void set_x_normalized(float value);
  private:
  float _internal_x_normalized() const;
  void _internal_set_x_normalized(float value);
  public:

  // optional float y_normalized = 4;
  bool has_y_normalized() const;
  private:
  bool _internal_has_y_normalized() const;
  public:
  void clear_y_normalized();
  float y_normalized() const;
  void set_y_normalized(float value);
  private:
  float _internal_y_normalized() const;
  void _internal_set_y_normalized(float value);
  public:

  // @@protoc_insertion_point(class_scope:CInputTouchFingerDownMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t fingerid_;
  uint32_t input_mark_;
  float x_normalized_;
  float y_normalized_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputTouchFingerMotionMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputTouchFingerMotionMsg) */ {
 public:
  inline CInputTouchFingerMotionMsg() : CInputTouchFingerMotionMsg(nullptr) {}
  ~CInputTouchFingerMotionMsg() override;
  explicit constexpr CInputTouchFingerMotionMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputTouchFingerMotionMsg(const CInputTouchFingerMotionMsg& from);
  CInputTouchFingerMotionMsg(CInputTouchFingerMotionMsg&& from) noexcept
    : CInputTouchFingerMotionMsg() {
    *this = ::std::move(from);
  }

  inline CInputTouchFingerMotionMsg& operator=(const CInputTouchFingerMotionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputTouchFingerMotionMsg& operator=(CInputTouchFingerMotionMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputTouchFingerMotionMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputTouchFingerMotionMsg* internal_default_instance() {
    return reinterpret_cast<const CInputTouchFingerMotionMsg*>(
               &_CInputTouchFingerMotionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(CInputTouchFingerMotionMsg& a, CInputTouchFingerMotionMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputTouchFingerMotionMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputTouchFingerMotionMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputTouchFingerMotionMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputTouchFingerMotionMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputTouchFingerMotionMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputTouchFingerMotionMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputTouchFingerMotionMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputTouchFingerMotionMsg";
  }
  protected:
  explicit CInputTouchFingerMotionMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFingeridFieldNumber = 2,
    kInputMarkFieldNumber = 1,
    kXNormalizedFieldNumber = 3,
    kYNormalizedFieldNumber = 4,
  };
  // optional uint64 fingerid = 2;
  bool has_fingerid() const;
  private:
  bool _internal_has_fingerid() const;
  public:
  void clear_fingerid();
  uint64_t fingerid() const;
  void set_fingerid(uint64_t value);
  private:
  uint64_t _internal_fingerid() const;
  void _internal_set_fingerid(uint64_t value);
  public:

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // optional float x_normalized = 3;
  bool has_x_normalized() const;
  private:
  bool _internal_has_x_normalized() const;
  public:
  void clear_x_normalized();
  float x_normalized() const;
  void set_x_normalized(float value);
  private:
  float _internal_x_normalized() const;
  void _internal_set_x_normalized(float value);
  public:

  // optional float y_normalized = 4;
  bool has_y_normalized() const;
  private:
  bool _internal_has_y_normalized() const;
  public:
  void clear_y_normalized();
  float y_normalized() const;
  void set_y_normalized(float value);
  private:
  float _internal_y_normalized() const;
  void _internal_set_y_normalized(float value);
  public:

  // @@protoc_insertion_point(class_scope:CInputTouchFingerMotionMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t fingerid_;
  uint32_t input_mark_;
  float x_normalized_;
  float y_normalized_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputTouchFingerUpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputTouchFingerUpMsg) */ {
 public:
  inline CInputTouchFingerUpMsg() : CInputTouchFingerUpMsg(nullptr) {}
  ~CInputTouchFingerUpMsg() override;
  explicit constexpr CInputTouchFingerUpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputTouchFingerUpMsg(const CInputTouchFingerUpMsg& from);
  CInputTouchFingerUpMsg(CInputTouchFingerUpMsg&& from) noexcept
    : CInputTouchFingerUpMsg() {
    *this = ::std::move(from);
  }

  inline CInputTouchFingerUpMsg& operator=(const CInputTouchFingerUpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputTouchFingerUpMsg& operator=(CInputTouchFingerUpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputTouchFingerUpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputTouchFingerUpMsg* internal_default_instance() {
    return reinterpret_cast<const CInputTouchFingerUpMsg*>(
               &_CInputTouchFingerUpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(CInputTouchFingerUpMsg& a, CInputTouchFingerUpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputTouchFingerUpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputTouchFingerUpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputTouchFingerUpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputTouchFingerUpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputTouchFingerUpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputTouchFingerUpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputTouchFingerUpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputTouchFingerUpMsg";
  }
  protected:
  explicit CInputTouchFingerUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFingeridFieldNumber = 2,
    kInputMarkFieldNumber = 1,
    kXNormalizedFieldNumber = 3,
    kYNormalizedFieldNumber = 4,
  };
  // optional uint64 fingerid = 2;
  bool has_fingerid() const;
  private:
  bool _internal_has_fingerid() const;
  public:
  void clear_fingerid();
  uint64_t fingerid() const;
  void set_fingerid(uint64_t value);
  private:
  uint64_t _internal_fingerid() const;
  void _internal_set_fingerid(uint64_t value);
  public:

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // optional float x_normalized = 3;
  bool has_x_normalized() const;
  private:
  bool _internal_has_x_normalized() const;
  public:
  void clear_x_normalized();
  float x_normalized() const;
  void set_x_normalized(float value);
  private:
  float _internal_x_normalized() const;
  void _internal_set_x_normalized(float value);
  public:

  // optional float y_normalized = 4;
  bool has_y_normalized() const;
  private:
  bool _internal_has_y_normalized() const;
  public:
  void clear_y_normalized();
  float y_normalized() const;
  void set_y_normalized(float value);
  private:
  float _internal_y_normalized() const;
  void _internal_set_y_normalized(float value);
  public:

  // @@protoc_insertion_point(class_scope:CInputTouchFingerUpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t fingerid_;
  uint32_t input_mark_;
  float x_normalized_;
  float y_normalized_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputMouseMotionMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputMouseMotionMsg) */ {
 public:
  inline CInputMouseMotionMsg() : CInputMouseMotionMsg(nullptr) {}
  ~CInputMouseMotionMsg() override;
  explicit constexpr CInputMouseMotionMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputMouseMotionMsg(const CInputMouseMotionMsg& from);
  CInputMouseMotionMsg(CInputMouseMotionMsg&& from) noexcept
    : CInputMouseMotionMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseMotionMsg& operator=(const CInputMouseMotionMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputMouseMotionMsg& operator=(CInputMouseMotionMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputMouseMotionMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputMouseMotionMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseMotionMsg*>(
               &_CInputMouseMotionMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(CInputMouseMotionMsg& a, CInputMouseMotionMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputMouseMotionMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputMouseMotionMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputMouseMotionMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputMouseMotionMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputMouseMotionMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputMouseMotionMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseMotionMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputMouseMotionMsg";
  }
  protected:
  explicit CInputMouseMotionMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kXNormalizedFieldNumber = 2,
    kYNormalizedFieldNumber = 3,
    kDxFieldNumber = 4,
    kDyFieldNumber = 5,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // optional float x_normalized = 2;
  bool has_x_normalized() const;
  private:
  bool _internal_has_x_normalized() const;
  public:
  void clear_x_normalized();
  float x_normalized() const;
  void set_x_normalized(float value);
  private:
  float _internal_x_normalized() const;
  void _internal_set_x_normalized(float value);
  public:

  // optional float y_normalized = 3;
  bool has_y_normalized() const;
  private:
  bool _internal_has_y_normalized() const;
  public:
  void clear_y_normalized();
  float y_normalized() const;
  void set_y_normalized(float value);
  private:
  float _internal_y_normalized() const;
  void _internal_set_y_normalized(float value);
  public:

  // optional int32 dx = 4;
  bool has_dx() const;
  private:
  bool _internal_has_dx() const;
  public:
  void clear_dx();
  int32_t dx() const;
  void set_dx(int32_t value);
  private:
  int32_t _internal_dx() const;
  void _internal_set_dx(int32_t value);
  public:

  // optional int32 dy = 5;
  bool has_dy() const;
  private:
  bool _internal_has_dy() const;
  public:
  void clear_dy();
  int32_t dy() const;
  void set_dy(int32_t value);
  private:
  int32_t _internal_dy() const;
  void _internal_set_dy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInputMouseMotionMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  float x_normalized_;
  float y_normalized_;
  int32_t dx_;
  int32_t dy_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputMouseWheelMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputMouseWheelMsg) */ {
 public:
  inline CInputMouseWheelMsg() : CInputMouseWheelMsg(nullptr) {}
  ~CInputMouseWheelMsg() override;
  explicit constexpr CInputMouseWheelMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputMouseWheelMsg(const CInputMouseWheelMsg& from);
  CInputMouseWheelMsg(CInputMouseWheelMsg&& from) noexcept
    : CInputMouseWheelMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseWheelMsg& operator=(const CInputMouseWheelMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputMouseWheelMsg& operator=(CInputMouseWheelMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputMouseWheelMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputMouseWheelMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseWheelMsg*>(
               &_CInputMouseWheelMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(CInputMouseWheelMsg& a, CInputMouseWheelMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputMouseWheelMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputMouseWheelMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputMouseWheelMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputMouseWheelMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputMouseWheelMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputMouseWheelMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseWheelMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputMouseWheelMsg";
  }
  protected:
  explicit CInputMouseWheelMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kDirectionFieldNumber = 2,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  ::EStreamMouseWheelDirection direction() const;
  void set_direction(::EStreamMouseWheelDirection value);
  private:
  ::EStreamMouseWheelDirection _internal_direction() const;
  void _internal_set_direction(::EStreamMouseWheelDirection value);
  public:

  // @@protoc_insertion_point(class_scope:CInputMouseWheelMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  int direction_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputMouseDownMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputMouseDownMsg) */ {
 public:
  inline CInputMouseDownMsg() : CInputMouseDownMsg(nullptr) {}
  ~CInputMouseDownMsg() override;
  explicit constexpr CInputMouseDownMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputMouseDownMsg(const CInputMouseDownMsg& from);
  CInputMouseDownMsg(CInputMouseDownMsg&& from) noexcept
    : CInputMouseDownMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseDownMsg& operator=(const CInputMouseDownMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputMouseDownMsg& operator=(CInputMouseDownMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputMouseDownMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputMouseDownMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseDownMsg*>(
               &_CInputMouseDownMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(CInputMouseDownMsg& a, CInputMouseDownMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputMouseDownMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputMouseDownMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputMouseDownMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputMouseDownMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputMouseDownMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputMouseDownMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseDownMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputMouseDownMsg";
  }
  protected:
  explicit CInputMouseDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kButtonFieldNumber = 2,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  bool has_button() const;
  private:
  bool _internal_has_button() const;
  public:
  void clear_button();
  ::EStreamMouseButton button() const;
  void set_button(::EStreamMouseButton value);
  private:
  ::EStreamMouseButton _internal_button() const;
  void _internal_set_button(::EStreamMouseButton value);
  public:

  // @@protoc_insertion_point(class_scope:CInputMouseDownMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  int button_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputMouseUpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputMouseUpMsg) */ {
 public:
  inline CInputMouseUpMsg() : CInputMouseUpMsg(nullptr) {}
  ~CInputMouseUpMsg() override;
  explicit constexpr CInputMouseUpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputMouseUpMsg(const CInputMouseUpMsg& from);
  CInputMouseUpMsg(CInputMouseUpMsg&& from) noexcept
    : CInputMouseUpMsg() {
    *this = ::std::move(from);
  }

  inline CInputMouseUpMsg& operator=(const CInputMouseUpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputMouseUpMsg& operator=(CInputMouseUpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputMouseUpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputMouseUpMsg* internal_default_instance() {
    return reinterpret_cast<const CInputMouseUpMsg*>(
               &_CInputMouseUpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(CInputMouseUpMsg& a, CInputMouseUpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputMouseUpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputMouseUpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputMouseUpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputMouseUpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputMouseUpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputMouseUpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputMouseUpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputMouseUpMsg";
  }
  protected:
  explicit CInputMouseUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kButtonFieldNumber = 2,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
  bool has_button() const;
  private:
  bool _internal_has_button() const;
  public:
  void clear_button();
  ::EStreamMouseButton button() const;
  void set_button(::EStreamMouseButton value);
  private:
  ::EStreamMouseButton _internal_button() const;
  void _internal_set_button(::EStreamMouseButton value);
  public:

  // @@protoc_insertion_point(class_scope:CInputMouseUpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  int button_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputKeyDownMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputKeyDownMsg) */ {
 public:
  inline CInputKeyDownMsg() : CInputKeyDownMsg(nullptr) {}
  ~CInputKeyDownMsg() override;
  explicit constexpr CInputKeyDownMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputKeyDownMsg(const CInputKeyDownMsg& from);
  CInputKeyDownMsg(CInputKeyDownMsg&& from) noexcept
    : CInputKeyDownMsg() {
    *this = ::std::move(from);
  }

  inline CInputKeyDownMsg& operator=(const CInputKeyDownMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputKeyDownMsg& operator=(CInputKeyDownMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputKeyDownMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputKeyDownMsg* internal_default_instance() {
    return reinterpret_cast<const CInputKeyDownMsg*>(
               &_CInputKeyDownMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(CInputKeyDownMsg& a, CInputKeyDownMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputKeyDownMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputKeyDownMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputKeyDownMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputKeyDownMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputKeyDownMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputKeyDownMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputKeyDownMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputKeyDownMsg";
  }
  protected:
  explicit CInputKeyDownMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kScancodeFieldNumber = 2,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required uint32 scancode = 2;
  bool has_scancode() const;
  private:
  bool _internal_has_scancode() const;
  public:
  void clear_scancode();
  uint32_t scancode() const;
  void set_scancode(uint32_t value);
  private:
  uint32_t _internal_scancode() const;
  void _internal_set_scancode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInputKeyDownMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  uint32_t scancode_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputKeyUpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputKeyUpMsg) */ {
 public:
  inline CInputKeyUpMsg() : CInputKeyUpMsg(nullptr) {}
  ~CInputKeyUpMsg() override;
  explicit constexpr CInputKeyUpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputKeyUpMsg(const CInputKeyUpMsg& from);
  CInputKeyUpMsg(CInputKeyUpMsg&& from) noexcept
    : CInputKeyUpMsg() {
    *this = ::std::move(from);
  }

  inline CInputKeyUpMsg& operator=(const CInputKeyUpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputKeyUpMsg& operator=(CInputKeyUpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputKeyUpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputKeyUpMsg* internal_default_instance() {
    return reinterpret_cast<const CInputKeyUpMsg*>(
               &_CInputKeyUpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(CInputKeyUpMsg& a, CInputKeyUpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputKeyUpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputKeyUpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputKeyUpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputKeyUpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputKeyUpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputKeyUpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputKeyUpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputKeyUpMsg";
  }
  protected:
  explicit CInputKeyUpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInputMarkFieldNumber = 1,
    kScancodeFieldNumber = 2,
  };
  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required uint32 scancode = 2;
  bool has_scancode() const;
  private:
  bool _internal_has_scancode() const;
  public:
  void clear_scancode();
  uint32_t scancode() const;
  void set_scancode(uint32_t value);
  private:
  uint32_t _internal_scancode() const;
  void _internal_set_scancode(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInputKeyUpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t input_mark_;
  uint32_t scancode_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CInputTextMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CInputTextMsg) */ {
 public:
  inline CInputTextMsg() : CInputTextMsg(nullptr) {}
  ~CInputTextMsg() override;
  explicit constexpr CInputTextMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CInputTextMsg(const CInputTextMsg& from);
  CInputTextMsg(CInputTextMsg&& from) noexcept
    : CInputTextMsg() {
    *this = ::std::move(from);
  }

  inline CInputTextMsg& operator=(const CInputTextMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CInputTextMsg& operator=(CInputTextMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CInputTextMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CInputTextMsg* internal_default_instance() {
    return reinterpret_cast<const CInputTextMsg*>(
               &_CInputTextMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(CInputTextMsg& a, CInputTextMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CInputTextMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CInputTextMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CInputTextMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CInputTextMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CInputTextMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CInputTextMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CInputTextMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CInputTextMsg";
  }
  protected:
  explicit CInputTextMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextUtf8FieldNumber = 2,
    kInputMarkFieldNumber = 1,
  };
  // required string text_utf8 = 2;
  bool has_text_utf8() const;
  private:
  bool _internal_has_text_utf8() const;
  public:
  void clear_text_utf8();
  const std::string& text_utf8() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text_utf8(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text_utf8();
  PROTOBUF_NODISCARD std::string* release_text_utf8();
  void set_allocated_text_utf8(std::string* text_utf8);
  private:
  const std::string& _internal_text_utf8() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text_utf8(const std::string& value);
  std::string* _internal_mutable_text_utf8();
  public:

  // optional uint32 input_mark = 1;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CInputTextMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_utf8_;
  uint32_t input_mark_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetTitleMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetTitleMsg) */ {
 public:
  inline CSetTitleMsg() : CSetTitleMsg(nullptr) {}
  ~CSetTitleMsg() override;
  explicit constexpr CSetTitleMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetTitleMsg(const CSetTitleMsg& from);
  CSetTitleMsg(CSetTitleMsg&& from) noexcept
    : CSetTitleMsg() {
    *this = ::std::move(from);
  }

  inline CSetTitleMsg& operator=(const CSetTitleMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetTitleMsg& operator=(CSetTitleMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetTitleMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetTitleMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTitleMsg*>(
               &_CSetTitleMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(CSetTitleMsg& a, CSetTitleMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetTitleMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetTitleMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetTitleMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetTitleMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetTitleMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetTitleMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTitleMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetTitleMsg";
  }
  protected:
  explicit CSetTitleMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTextFieldNumber = 1,
  };
  // optional string text = 1;
  bool has_text() const;
  private:
  bool _internal_has_text() const;
  public:
  void clear_text();
  const std::string& text() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_text(ArgT0&& arg0, ArgT... args);
  std::string* mutable_text();
  PROTOBUF_NODISCARD std::string* release_text();
  void set_allocated_text(std::string* text);
  private:
  const std::string& _internal_text() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_text(const std::string& value);
  std::string* _internal_mutable_text();
  public:

  // @@protoc_insertion_point(class_scope:CSetTitleMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr text_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetCaptureSizeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetCaptureSizeMsg) */ {
 public:
  inline CSetCaptureSizeMsg() : CSetCaptureSizeMsg(nullptr) {}
  ~CSetCaptureSizeMsg() override;
  explicit constexpr CSetCaptureSizeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetCaptureSizeMsg(const CSetCaptureSizeMsg& from);
  CSetCaptureSizeMsg(CSetCaptureSizeMsg&& from) noexcept
    : CSetCaptureSizeMsg() {
    *this = ::std::move(from);
  }

  inline CSetCaptureSizeMsg& operator=(const CSetCaptureSizeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetCaptureSizeMsg& operator=(CSetCaptureSizeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetCaptureSizeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetCaptureSizeMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCaptureSizeMsg*>(
               &_CSetCaptureSizeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CSetCaptureSizeMsg& a, CSetCaptureSizeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetCaptureSizeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetCaptureSizeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetCaptureSizeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetCaptureSizeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetCaptureSizeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetCaptureSizeMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCaptureSizeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetCaptureSizeMsg";
  }
  protected:
  explicit CSetCaptureSizeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetCaptureSizeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetIconMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetIconMsg) */ {
 public:
  inline CSetIconMsg() : CSetIconMsg(nullptr) {}
  ~CSetIconMsg() override;
  explicit constexpr CSetIconMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetIconMsg(const CSetIconMsg& from);
  CSetIconMsg(CSetIconMsg&& from) noexcept
    : CSetIconMsg() {
    *this = ::std::move(from);
  }

  inline CSetIconMsg& operator=(const CSetIconMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetIconMsg& operator=(CSetIconMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetIconMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetIconMsg* internal_default_instance() {
    return reinterpret_cast<const CSetIconMsg*>(
               &_CSetIconMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(CSetIconMsg& a, CSetIconMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetIconMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetIconMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetIconMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetIconMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetIconMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetIconMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetIconMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetIconMsg";
  }
  protected:
  explicit CSetIconMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 3,
    kWidthFieldNumber = 1,
    kHeightFieldNumber = 2,
  };
  // optional bytes image = 3;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // optional int32 width = 1;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 2;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetIconMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  int32_t width_;
  int32_t height_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetFlashStateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetFlashStateMsg) */ {
 public:
  inline CSetFlashStateMsg() : CSetFlashStateMsg(nullptr) {}
  ~CSetFlashStateMsg() override;
  explicit constexpr CSetFlashStateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetFlashStateMsg(const CSetFlashStateMsg& from);
  CSetFlashStateMsg(CSetFlashStateMsg&& from) noexcept
    : CSetFlashStateMsg() {
    *this = ::std::move(from);
  }

  inline CSetFlashStateMsg& operator=(const CSetFlashStateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetFlashStateMsg& operator=(CSetFlashStateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetFlashStateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetFlashStateMsg* internal_default_instance() {
    return reinterpret_cast<const CSetFlashStateMsg*>(
               &_CSetFlashStateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(CSetFlashStateMsg& a, CSetFlashStateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetFlashStateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetFlashStateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetFlashStateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetFlashStateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetFlashStateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetFlashStateMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetFlashStateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetFlashStateMsg";
  }
  protected:
  explicit CSetFlashStateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFlagsFieldNumber = 1,
    kCountFieldNumber = 2,
    kTimeoutMsFieldNumber = 3,
  };
  // optional uint32 flags = 1;
  bool has_flags() const;
  private:
  bool _internal_has_flags() const;
  public:
  void clear_flags();
  uint32_t flags() const;
  void set_flags(uint32_t value);
  private:
  uint32_t _internal_flags() const;
  void _internal_set_flags(uint32_t value);
  public:

  // optional uint32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  uint32_t count() const;
  void set_count(uint32_t value);
  private:
  uint32_t _internal_count() const;
  void _internal_set_count(uint32_t value);
  public:

  // optional uint32 timeout_ms = 3;
  bool has_timeout_ms() const;
  private:
  bool _internal_has_timeout_ms() const;
  public:
  void clear_timeout_ms();
  uint32_t timeout_ms() const;
  void set_timeout_ms(uint32_t value);
  private:
  uint32_t _internal_timeout_ms() const;
  void _internal_set_timeout_ms(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetFlashStateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t flags_;
  uint32_t count_;
  uint32_t timeout_ms_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CShowCursorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CShowCursorMsg) */ {
 public:
  inline CShowCursorMsg() : CShowCursorMsg(nullptr) {}
  ~CShowCursorMsg() override;
  explicit constexpr CShowCursorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CShowCursorMsg(const CShowCursorMsg& from);
  CShowCursorMsg(CShowCursorMsg&& from) noexcept
    : CShowCursorMsg() {
    *this = ::std::move(from);
  }

  inline CShowCursorMsg& operator=(const CShowCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CShowCursorMsg& operator=(CShowCursorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CShowCursorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CShowCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CShowCursorMsg*>(
               &_CShowCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(CShowCursorMsg& a, CShowCursorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CShowCursorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CShowCursorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CShowCursorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CShowCursorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CShowCursorMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CShowCursorMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CShowCursorMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CShowCursorMsg";
  }
  protected:
  explicit CShowCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXNormalizedFieldNumber = 1,
    kYNormalizedFieldNumber = 2,
  };
  // optional float x_normalized = 1;
  bool has_x_normalized() const;
  private:
  bool _internal_has_x_normalized() const;
  public:
  void clear_x_normalized();
  float x_normalized() const;
  void set_x_normalized(float value);
  private:
  float _internal_x_normalized() const;
  void _internal_set_x_normalized(float value);
  public:

  // optional float y_normalized = 2;
  bool has_y_normalized() const;
  private:
  bool _internal_has_y_normalized() const;
  public:
  void clear_y_normalized();
  float y_normalized() const;
  void set_y_normalized(float value);
  private:
  float _internal_y_normalized() const;
  void _internal_set_y_normalized(float value);
  public:

  // @@protoc_insertion_point(class_scope:CShowCursorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float x_normalized_;
  float y_normalized_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CHideCursorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CHideCursorMsg) */ {
 public:
  inline CHideCursorMsg() : CHideCursorMsg(nullptr) {}
  explicit constexpr CHideCursorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CHideCursorMsg(const CHideCursorMsg& from);
  CHideCursorMsg(CHideCursorMsg&& from) noexcept
    : CHideCursorMsg() {
    *this = ::std::move(from);
  }

  inline CHideCursorMsg& operator=(const CHideCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CHideCursorMsg& operator=(CHideCursorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CHideCursorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CHideCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CHideCursorMsg*>(
               &_CHideCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(CHideCursorMsg& a, CHideCursorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CHideCursorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CHideCursorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CHideCursorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CHideCursorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CHideCursorMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CHideCursorMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CHideCursorMsg";
  }
  protected:
  explicit CHideCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CHideCursorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetCursorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetCursorMsg) */ {
 public:
  inline CSetCursorMsg() : CSetCursorMsg(nullptr) {}
  ~CSetCursorMsg() override;
  explicit constexpr CSetCursorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetCursorMsg(const CSetCursorMsg& from);
  CSetCursorMsg(CSetCursorMsg&& from) noexcept
    : CSetCursorMsg() {
    *this = ::std::move(from);
  }

  inline CSetCursorMsg& operator=(const CSetCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetCursorMsg& operator=(CSetCursorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetCursorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCursorMsg*>(
               &_CSetCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(CSetCursorMsg& a, CSetCursorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetCursorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetCursorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetCursorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetCursorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetCursorMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetCursorMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCursorMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetCursorMsg";
  }
  protected:
  explicit CSetCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCursorIdFieldNumber = 1,
  };
  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  private:
  bool _internal_has_cursor_id() const;
  public:
  void clear_cursor_id();
  uint64_t cursor_id() const;
  void set_cursor_id(uint64_t value);
  private:
  uint64_t _internal_cursor_id() const;
  void _internal_set_cursor_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetCursorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t cursor_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CGetCursorImageMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGetCursorImageMsg) */ {
 public:
  inline CGetCursorImageMsg() : CGetCursorImageMsg(nullptr) {}
  ~CGetCursorImageMsg() override;
  explicit constexpr CGetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGetCursorImageMsg(const CGetCursorImageMsg& from);
  CGetCursorImageMsg(CGetCursorImageMsg&& from) noexcept
    : CGetCursorImageMsg() {
    *this = ::std::move(from);
  }

  inline CGetCursorImageMsg& operator=(const CGetCursorImageMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGetCursorImageMsg& operator=(CGetCursorImageMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGetCursorImageMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGetCursorImageMsg* internal_default_instance() {
    return reinterpret_cast<const CGetCursorImageMsg*>(
               &_CGetCursorImageMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(CGetCursorImageMsg& a, CGetCursorImageMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CGetCursorImageMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGetCursorImageMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGetCursorImageMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGetCursorImageMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGetCursorImageMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CGetCursorImageMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetCursorImageMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGetCursorImageMsg";
  }
  protected:
  explicit CGetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCursorIdFieldNumber = 1,
  };
  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  private:
  bool _internal_has_cursor_id() const;
  public:
  void clear_cursor_id();
  uint64_t cursor_id() const;
  void set_cursor_id(uint64_t value);
  private:
  uint64_t _internal_cursor_id() const;
  void _internal_set_cursor_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGetCursorImageMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t cursor_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetCursorImageMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetCursorImageMsg) */ {
 public:
  inline CSetCursorImageMsg() : CSetCursorImageMsg(nullptr) {}
  ~CSetCursorImageMsg() override;
  explicit constexpr CSetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetCursorImageMsg(const CSetCursorImageMsg& from);
  CSetCursorImageMsg(CSetCursorImageMsg&& from) noexcept
    : CSetCursorImageMsg() {
    *this = ::std::move(from);
  }

  inline CSetCursorImageMsg& operator=(const CSetCursorImageMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetCursorImageMsg& operator=(CSetCursorImageMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetCursorImageMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetCursorImageMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCursorImageMsg*>(
               &_CSetCursorImageMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(CSetCursorImageMsg& a, CSetCursorImageMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetCursorImageMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetCursorImageMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetCursorImageMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetCursorImageMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetCursorImageMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetCursorImageMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCursorImageMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetCursorImageMsg";
  }
  protected:
  explicit CSetCursorImageMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kImageFieldNumber = 6,
    kCursorIdFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
    kHotXFieldNumber = 4,
    kHotYFieldNumber = 5,
  };
  // optional bytes image = 6;
  bool has_image() const;
  private:
  bool _internal_has_image() const;
  public:
  void clear_image();
  const std::string& image() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_image(ArgT0&& arg0, ArgT... args);
  std::string* mutable_image();
  PROTOBUF_NODISCARD std::string* release_image();
  void set_allocated_image(std::string* image);
  private:
  const std::string& _internal_image() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_image(const std::string& value);
  std::string* _internal_mutable_image();
  public:

  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  private:
  bool _internal_has_cursor_id() const;
  public:
  void clear_cursor_id();
  uint64_t cursor_id() const;
  void set_cursor_id(uint64_t value);
  private:
  uint64_t _internal_cursor_id() const;
  void _internal_set_cursor_id(uint64_t value);
  public:

  // optional int32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  int32_t width() const;
  void set_width(int32_t value);
  private:
  int32_t _internal_width() const;
  void _internal_set_width(int32_t value);
  public:

  // optional int32 height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  int32_t height() const;
  void set_height(int32_t value);
  private:
  int32_t _internal_height() const;
  void _internal_set_height(int32_t value);
  public:

  // optional int32 hot_x = 4;
  bool has_hot_x() const;
  private:
  bool _internal_has_hot_x() const;
  public:
  void clear_hot_x();
  int32_t hot_x() const;
  void set_hot_x(int32_t value);
  private:
  int32_t _internal_hot_x() const;
  void _internal_set_hot_x(int32_t value);
  public:

  // optional int32 hot_y = 5;
  bool has_hot_y() const;
  private:
  bool _internal_has_hot_y() const;
  public:
  void clear_hot_y();
  int32_t hot_y() const;
  void set_hot_y(int32_t value);
  private:
  int32_t _internal_hot_y() const;
  void _internal_set_hot_y(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetCursorImageMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr image_;
  uint64_t cursor_id_;
  int32_t width_;
  int32_t height_;
  int32_t hot_x_;
  int32_t hot_y_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVideoDecoderInfoMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVideoDecoderInfoMsg) */ {
 public:
  inline CVideoDecoderInfoMsg() : CVideoDecoderInfoMsg(nullptr) {}
  ~CVideoDecoderInfoMsg() override;
  explicit constexpr CVideoDecoderInfoMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVideoDecoderInfoMsg(const CVideoDecoderInfoMsg& from);
  CVideoDecoderInfoMsg(CVideoDecoderInfoMsg&& from) noexcept
    : CVideoDecoderInfoMsg() {
    *this = ::std::move(from);
  }

  inline CVideoDecoderInfoMsg& operator=(const CVideoDecoderInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVideoDecoderInfoMsg& operator=(CVideoDecoderInfoMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVideoDecoderInfoMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVideoDecoderInfoMsg* internal_default_instance() {
    return reinterpret_cast<const CVideoDecoderInfoMsg*>(
               &_CVideoDecoderInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(CVideoDecoderInfoMsg& a, CVideoDecoderInfoMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CVideoDecoderInfoMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVideoDecoderInfoMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVideoDecoderInfoMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVideoDecoderInfoMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVideoDecoderInfoMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVideoDecoderInfoMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoDecoderInfoMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVideoDecoderInfoMsg";
  }
  protected:
  explicit CVideoDecoderInfoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kThreadsFieldNumber = 2,
  };
  // optional string info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // optional int32 threads = 2;
  bool has_threads() const;
  private:
  bool _internal_has_threads() const;
  public:
  void clear_threads();
  int32_t threads() const;
  void set_threads(int32_t value);
  private:
  int32_t _internal_threads() const;
  void _internal_set_threads(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CVideoDecoderInfoMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  int32_t threads_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVideoEncoderInfoMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVideoEncoderInfoMsg) */ {
 public:
  inline CVideoEncoderInfoMsg() : CVideoEncoderInfoMsg(nullptr) {}
  ~CVideoEncoderInfoMsg() override;
  explicit constexpr CVideoEncoderInfoMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVideoEncoderInfoMsg(const CVideoEncoderInfoMsg& from);
  CVideoEncoderInfoMsg(CVideoEncoderInfoMsg&& from) noexcept
    : CVideoEncoderInfoMsg() {
    *this = ::std::move(from);
  }

  inline CVideoEncoderInfoMsg& operator=(const CVideoEncoderInfoMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVideoEncoderInfoMsg& operator=(CVideoEncoderInfoMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVideoEncoderInfoMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVideoEncoderInfoMsg* internal_default_instance() {
    return reinterpret_cast<const CVideoEncoderInfoMsg*>(
               &_CVideoEncoderInfoMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(CVideoEncoderInfoMsg& a, CVideoEncoderInfoMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CVideoEncoderInfoMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVideoEncoderInfoMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVideoEncoderInfoMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVideoEncoderInfoMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVideoEncoderInfoMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVideoEncoderInfoMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoEncoderInfoMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVideoEncoderInfoMsg";
  }
  protected:
  explicit CVideoEncoderInfoMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
  };
  // optional string info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const std::string& info() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_info(ArgT0&& arg0, ArgT... args);
  std::string* mutable_info();
  PROTOBUF_NODISCARD std::string* release_info();
  void set_allocated_info(std::string* info);
  private:
  const std::string& _internal_info() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_info(const std::string& value);
  std::string* _internal_mutable_info();
  public:

  // @@protoc_insertion_point(class_scope:CVideoEncoderInfoMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr info_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CPauseMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CPauseMsg) */ {
 public:
  inline CPauseMsg() : CPauseMsg(nullptr) {}
  explicit constexpr CPauseMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPauseMsg(const CPauseMsg& from);
  CPauseMsg(CPauseMsg&& from) noexcept
    : CPauseMsg() {
    *this = ::std::move(from);
  }

  inline CPauseMsg& operator=(const CPauseMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPauseMsg& operator=(CPauseMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPauseMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPauseMsg* internal_default_instance() {
    return reinterpret_cast<const CPauseMsg*>(
               &_CPauseMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(CPauseMsg& a, CPauseMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CPauseMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPauseMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPauseMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPauseMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CPauseMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CPauseMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CPauseMsg";
  }
  protected:
  explicit CPauseMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CPauseMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CResumeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CResumeMsg) */ {
 public:
  inline CResumeMsg() : CResumeMsg(nullptr) {}
  explicit constexpr CResumeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CResumeMsg(const CResumeMsg& from);
  CResumeMsg(CResumeMsg&& from) noexcept
    : CResumeMsg() {
    *this = ::std::move(from);
  }

  inline CResumeMsg& operator=(const CResumeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CResumeMsg& operator=(CResumeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CResumeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CResumeMsg* internal_default_instance() {
    return reinterpret_cast<const CResumeMsg*>(
               &_CResumeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(CResumeMsg& a, CResumeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CResumeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CResumeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CResumeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CResumeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CResumeMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CResumeMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CResumeMsg";
  }
  protected:
  explicit CResumeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CResumeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CEnableHighResCaptureMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CEnableHighResCaptureMsg) */ {
 public:
  inline CEnableHighResCaptureMsg() : CEnableHighResCaptureMsg(nullptr) {}
  explicit constexpr CEnableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CEnableHighResCaptureMsg(const CEnableHighResCaptureMsg& from);
  CEnableHighResCaptureMsg(CEnableHighResCaptureMsg&& from) noexcept
    : CEnableHighResCaptureMsg() {
    *this = ::std::move(from);
  }

  inline CEnableHighResCaptureMsg& operator=(const CEnableHighResCaptureMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CEnableHighResCaptureMsg& operator=(CEnableHighResCaptureMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CEnableHighResCaptureMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CEnableHighResCaptureMsg* internal_default_instance() {
    return reinterpret_cast<const CEnableHighResCaptureMsg*>(
               &_CEnableHighResCaptureMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(CEnableHighResCaptureMsg& a, CEnableHighResCaptureMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CEnableHighResCaptureMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CEnableHighResCaptureMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CEnableHighResCaptureMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CEnableHighResCaptureMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CEnableHighResCaptureMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CEnableHighResCaptureMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CEnableHighResCaptureMsg";
  }
  protected:
  explicit CEnableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CEnableHighResCaptureMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CDisableHighResCaptureMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CDisableHighResCaptureMsg) */ {
 public:
  inline CDisableHighResCaptureMsg() : CDisableHighResCaptureMsg(nullptr) {}
  explicit constexpr CDisableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDisableHighResCaptureMsg(const CDisableHighResCaptureMsg& from);
  CDisableHighResCaptureMsg(CDisableHighResCaptureMsg&& from) noexcept
    : CDisableHighResCaptureMsg() {
    *this = ::std::move(from);
  }

  inline CDisableHighResCaptureMsg& operator=(const CDisableHighResCaptureMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDisableHighResCaptureMsg& operator=(CDisableHighResCaptureMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDisableHighResCaptureMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDisableHighResCaptureMsg* internal_default_instance() {
    return reinterpret_cast<const CDisableHighResCaptureMsg*>(
               &_CDisableHighResCaptureMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(CDisableHighResCaptureMsg& a, CDisableHighResCaptureMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CDisableHighResCaptureMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDisableHighResCaptureMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDisableHighResCaptureMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDisableHighResCaptureMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CDisableHighResCaptureMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CDisableHighResCaptureMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDisableHighResCaptureMsg";
  }
  protected:
  explicit CDisableHighResCaptureMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CDisableHighResCaptureMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CEnableNeptuneDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CEnableNeptuneDataMsg) */ {
 public:
  inline CEnableNeptuneDataMsg() : CEnableNeptuneDataMsg(nullptr) {}
  explicit constexpr CEnableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CEnableNeptuneDataMsg(const CEnableNeptuneDataMsg& from);
  CEnableNeptuneDataMsg(CEnableNeptuneDataMsg&& from) noexcept
    : CEnableNeptuneDataMsg() {
    *this = ::std::move(from);
  }

  inline CEnableNeptuneDataMsg& operator=(const CEnableNeptuneDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CEnableNeptuneDataMsg& operator=(CEnableNeptuneDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CEnableNeptuneDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CEnableNeptuneDataMsg* internal_default_instance() {
    return reinterpret_cast<const CEnableNeptuneDataMsg*>(
               &_CEnableNeptuneDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(CEnableNeptuneDataMsg& a, CEnableNeptuneDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CEnableNeptuneDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CEnableNeptuneDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CEnableNeptuneDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CEnableNeptuneDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CEnableNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CEnableNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CEnableNeptuneDataMsg";
  }
  protected:
  explicit CEnableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CEnableNeptuneDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CDisableNeptuneDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CDisableNeptuneDataMsg) */ {
 public:
  inline CDisableNeptuneDataMsg() : CDisableNeptuneDataMsg(nullptr) {}
  explicit constexpr CDisableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDisableNeptuneDataMsg(const CDisableNeptuneDataMsg& from);
  CDisableNeptuneDataMsg(CDisableNeptuneDataMsg&& from) noexcept
    : CDisableNeptuneDataMsg() {
    *this = ::std::move(from);
  }

  inline CDisableNeptuneDataMsg& operator=(const CDisableNeptuneDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDisableNeptuneDataMsg& operator=(CDisableNeptuneDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDisableNeptuneDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDisableNeptuneDataMsg* internal_default_instance() {
    return reinterpret_cast<const CDisableNeptuneDataMsg*>(
               &_CDisableNeptuneDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(CDisableNeptuneDataMsg& a, CDisableNeptuneDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CDisableNeptuneDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDisableNeptuneDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDisableNeptuneDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDisableNeptuneDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CDisableNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CDisableNeptuneDataMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDisableNeptuneDataMsg";
  }
  protected:
  explicit CDisableNeptuneDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CDisableNeptuneDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CPauseControllerInputMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CPauseControllerInputMsg) */ {
 public:
  inline CPauseControllerInputMsg() : CPauseControllerInputMsg(nullptr) {}
  explicit constexpr CPauseControllerInputMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CPauseControllerInputMsg(const CPauseControllerInputMsg& from);
  CPauseControllerInputMsg(CPauseControllerInputMsg&& from) noexcept
    : CPauseControllerInputMsg() {
    *this = ::std::move(from);
  }

  inline CPauseControllerInputMsg& operator=(const CPauseControllerInputMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CPauseControllerInputMsg& operator=(CPauseControllerInputMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CPauseControllerInputMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CPauseControllerInputMsg* internal_default_instance() {
    return reinterpret_cast<const CPauseControllerInputMsg*>(
               &_CPauseControllerInputMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(CPauseControllerInputMsg& a, CPauseControllerInputMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CPauseControllerInputMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CPauseControllerInputMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CPauseControllerInputMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CPauseControllerInputMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CPauseControllerInputMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CPauseControllerInputMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CPauseControllerInputMsg";
  }
  protected:
  explicit CPauseControllerInputMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CPauseControllerInputMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CResumeControllerInputMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CResumeControllerInputMsg) */ {
 public:
  inline CResumeControllerInputMsg() : CResumeControllerInputMsg(nullptr) {}
  explicit constexpr CResumeControllerInputMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CResumeControllerInputMsg(const CResumeControllerInputMsg& from);
  CResumeControllerInputMsg(CResumeControllerInputMsg&& from) noexcept
    : CResumeControllerInputMsg() {
    *this = ::std::move(from);
  }

  inline CResumeControllerInputMsg& operator=(const CResumeControllerInputMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CResumeControllerInputMsg& operator=(CResumeControllerInputMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CResumeControllerInputMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CResumeControllerInputMsg* internal_default_instance() {
    return reinterpret_cast<const CResumeControllerInputMsg*>(
               &_CResumeControllerInputMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(CResumeControllerInputMsg& a, CResumeControllerInputMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CResumeControllerInputMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CResumeControllerInputMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CResumeControllerInputMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CResumeControllerInputMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CResumeControllerInputMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CResumeControllerInputMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CResumeControllerInputMsg";
  }
  protected:
  explicit CResumeControllerInputMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CResumeControllerInputMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CToggleMagnificationMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CToggleMagnificationMsg) */ {
 public:
  inline CToggleMagnificationMsg() : CToggleMagnificationMsg(nullptr) {}
  explicit constexpr CToggleMagnificationMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CToggleMagnificationMsg(const CToggleMagnificationMsg& from);
  CToggleMagnificationMsg(CToggleMagnificationMsg&& from) noexcept
    : CToggleMagnificationMsg() {
    *this = ::std::move(from);
  }

  inline CToggleMagnificationMsg& operator=(const CToggleMagnificationMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CToggleMagnificationMsg& operator=(CToggleMagnificationMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CToggleMagnificationMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CToggleMagnificationMsg* internal_default_instance() {
    return reinterpret_cast<const CToggleMagnificationMsg*>(
               &_CToggleMagnificationMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(CToggleMagnificationMsg& a, CToggleMagnificationMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CToggleMagnificationMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CToggleMagnificationMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CToggleMagnificationMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CToggleMagnificationMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CToggleMagnificationMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CToggleMagnificationMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CToggleMagnificationMsg";
  }
  protected:
  explicit CToggleMagnificationMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CToggleMagnificationMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetCapslockMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetCapslockMsg) */ {
 public:
  inline CSetCapslockMsg() : CSetCapslockMsg(nullptr) {}
  ~CSetCapslockMsg() override;
  explicit constexpr CSetCapslockMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetCapslockMsg(const CSetCapslockMsg& from);
  CSetCapslockMsg(CSetCapslockMsg&& from) noexcept
    : CSetCapslockMsg() {
    *this = ::std::move(from);
  }

  inline CSetCapslockMsg& operator=(const CSetCapslockMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetCapslockMsg& operator=(CSetCapslockMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetCapslockMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetCapslockMsg* internal_default_instance() {
    return reinterpret_cast<const CSetCapslockMsg*>(
               &_CSetCapslockMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(CSetCapslockMsg& a, CSetCapslockMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetCapslockMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetCapslockMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetCapslockMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetCapslockMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetCapslockMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetCapslockMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetCapslockMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetCapslockMsg";
  }
  protected:
  explicit CSetCapslockMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPressedFieldNumber = 1,
  };
  // optional bool pressed = 1;
  bool has_pressed() const;
  private:
  bool _internal_has_pressed() const;
  public:
  void clear_pressed();
  bool pressed() const;
  void set_pressed(bool value);
  private:
  bool _internal_pressed() const;
  void _internal_set_pressed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSetCapslockMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool pressed_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingKeymapEntry final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingKeymapEntry) */ {
 public:
  inline CStreamingKeymapEntry() : CStreamingKeymapEntry(nullptr) {}
  ~CStreamingKeymapEntry() override;
  explicit constexpr CStreamingKeymapEntry(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingKeymapEntry(const CStreamingKeymapEntry& from);
  CStreamingKeymapEntry(CStreamingKeymapEntry&& from) noexcept
    : CStreamingKeymapEntry() {
    *this = ::std::move(from);
  }

  inline CStreamingKeymapEntry& operator=(const CStreamingKeymapEntry& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingKeymapEntry& operator=(CStreamingKeymapEntry&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingKeymapEntry& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingKeymapEntry* internal_default_instance() {
    return reinterpret_cast<const CStreamingKeymapEntry*>(
               &_CStreamingKeymapEntry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(CStreamingKeymapEntry& a, CStreamingKeymapEntry& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingKeymapEntry* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingKeymapEntry* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingKeymapEntry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingKeymapEntry>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingKeymapEntry& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingKeymapEntry& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingKeymapEntry* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingKeymapEntry";
  }
  protected:
  explicit CStreamingKeymapEntry(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScancodeFieldNumber = 1,
    kNormalKeycodeFieldNumber = 2,
    kShiftKeycodeFieldNumber = 3,
    kCapslockKeycodeFieldNumber = 4,
    kShiftCapslockKeycodeFieldNumber = 5,
    kAltgrKeycodeFieldNumber = 6,
    kAltgrShiftKeycodeFieldNumber = 7,
    kAltgrCapslockKeycodeFieldNumber = 8,
    kAltgrShiftCapslockKeycodeFieldNumber = 9,
  };
  // optional int32 scancode = 1;
  bool has_scancode() const;
  private:
  bool _internal_has_scancode() const;
  public:
  void clear_scancode();
  int32_t scancode() const;
  void set_scancode(int32_t value);
  private:
  int32_t _internal_scancode() const;
  void _internal_set_scancode(int32_t value);
  public:

  // optional int32 normal_keycode = 2;
  bool has_normal_keycode() const;
  private:
  bool _internal_has_normal_keycode() const;
  public:
  void clear_normal_keycode();
  int32_t normal_keycode() const;
  void set_normal_keycode(int32_t value);
  private:
  int32_t _internal_normal_keycode() const;
  void _internal_set_normal_keycode(int32_t value);
  public:

  // optional int32 shift_keycode = 3;
  bool has_shift_keycode() const;
  private:
  bool _internal_has_shift_keycode() const;
  public:
  void clear_shift_keycode();
  int32_t shift_keycode() const;
  void set_shift_keycode(int32_t value);
  private:
  int32_t _internal_shift_keycode() const;
  void _internal_set_shift_keycode(int32_t value);
  public:

  // optional int32 capslock_keycode = 4;
  bool has_capslock_keycode() const;
  private:
  bool _internal_has_capslock_keycode() const;
  public:
  void clear_capslock_keycode();
  int32_t capslock_keycode() const;
  void set_capslock_keycode(int32_t value);
  private:
  int32_t _internal_capslock_keycode() const;
  void _internal_set_capslock_keycode(int32_t value);
  public:

  // optional int32 shift_capslock_keycode = 5;
  bool has_shift_capslock_keycode() const;
  private:
  bool _internal_has_shift_capslock_keycode() const;
  public:
  void clear_shift_capslock_keycode();
  int32_t shift_capslock_keycode() const;
  void set_shift_capslock_keycode(int32_t value);
  private:
  int32_t _internal_shift_capslock_keycode() const;
  void _internal_set_shift_capslock_keycode(int32_t value);
  public:

  // optional int32 altgr_keycode = 6;
  bool has_altgr_keycode() const;
  private:
  bool _internal_has_altgr_keycode() const;
  public:
  void clear_altgr_keycode();
  int32_t altgr_keycode() const;
  void set_altgr_keycode(int32_t value);
  private:
  int32_t _internal_altgr_keycode() const;
  void _internal_set_altgr_keycode(int32_t value);
  public:

  // optional int32 altgr_shift_keycode = 7;
  bool has_altgr_shift_keycode() const;
  private:
  bool _internal_has_altgr_shift_keycode() const;
  public:
  void clear_altgr_shift_keycode();
  int32_t altgr_shift_keycode() const;
  void set_altgr_shift_keycode(int32_t value);
  private:
  int32_t _internal_altgr_shift_keycode() const;
  void _internal_set_altgr_shift_keycode(int32_t value);
  public:

  // optional int32 altgr_capslock_keycode = 8;
  bool has_altgr_capslock_keycode() const;
  private:
  bool _internal_has_altgr_capslock_keycode() const;
  public:
  void clear_altgr_capslock_keycode();
  int32_t altgr_capslock_keycode() const;
  void set_altgr_capslock_keycode(int32_t value);
  private:
  int32_t _internal_altgr_capslock_keycode() const;
  void _internal_set_altgr_capslock_keycode(int32_t value);
  public:

  // optional int32 altgr_shift_capslock_keycode = 9;
  bool has_altgr_shift_capslock_keycode() const;
  private:
  bool _internal_has_altgr_shift_capslock_keycode() const;
  public:
  void clear_altgr_shift_capslock_keycode();
  int32_t altgr_shift_capslock_keycode() const;
  void set_altgr_shift_capslock_keycode(int32_t value);
  private:
  int32_t _internal_altgr_shift_capslock_keycode() const;
  void _internal_set_altgr_shift_capslock_keycode(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingKeymapEntry)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t scancode_;
  int32_t normal_keycode_;
  int32_t shift_keycode_;
  int32_t capslock_keycode_;
  int32_t shift_capslock_keycode_;
  int32_t altgr_keycode_;
  int32_t altgr_shift_keycode_;
  int32_t altgr_capslock_keycode_;
  int32_t altgr_shift_capslock_keycode_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingKeymap final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingKeymap) */ {
 public:
  inline CStreamingKeymap() : CStreamingKeymap(nullptr) {}
  ~CStreamingKeymap() override;
  explicit constexpr CStreamingKeymap(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingKeymap(const CStreamingKeymap& from);
  CStreamingKeymap(CStreamingKeymap&& from) noexcept
    : CStreamingKeymap() {
    *this = ::std::move(from);
  }

  inline CStreamingKeymap& operator=(const CStreamingKeymap& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingKeymap& operator=(CStreamingKeymap&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingKeymap& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingKeymap* internal_default_instance() {
    return reinterpret_cast<const CStreamingKeymap*>(
               &_CStreamingKeymap_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(CStreamingKeymap& a, CStreamingKeymap& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingKeymap* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingKeymap* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingKeymap* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingKeymap>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingKeymap& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingKeymap& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingKeymap* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingKeymap";
  }
  protected:
  explicit CStreamingKeymap(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEntriesFieldNumber = 1,
  };
  // repeated .CStreamingKeymapEntry entries = 1;
  int entries_size() const;
  private:
  int _internal_entries_size() const;
  public:
  void clear_entries();
  ::CStreamingKeymapEntry* mutable_entries(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamingKeymapEntry >*
      mutable_entries();
  private:
  const ::CStreamingKeymapEntry& _internal_entries(int index) const;
  ::CStreamingKeymapEntry* _internal_add_entries();
  public:
  const ::CStreamingKeymapEntry& entries(int index) const;
  ::CStreamingKeymapEntry* add_entries();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamingKeymapEntry >&
      entries() const;

  // @@protoc_insertion_point(class_scope:CStreamingKeymap)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamingKeymapEntry > entries_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetKeymapMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetKeymapMsg) */ {
 public:
  inline CSetKeymapMsg() : CSetKeymapMsg(nullptr) {}
  ~CSetKeymapMsg() override;
  explicit constexpr CSetKeymapMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetKeymapMsg(const CSetKeymapMsg& from);
  CSetKeymapMsg(CSetKeymapMsg&& from) noexcept
    : CSetKeymapMsg() {
    *this = ::std::move(from);
  }

  inline CSetKeymapMsg& operator=(const CSetKeymapMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetKeymapMsg& operator=(CSetKeymapMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetKeymapMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetKeymapMsg* internal_default_instance() {
    return reinterpret_cast<const CSetKeymapMsg*>(
               &_CSetKeymapMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(CSetKeymapMsg& a, CSetKeymapMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetKeymapMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetKeymapMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetKeymapMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetKeymapMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetKeymapMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetKeymapMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetKeymapMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetKeymapMsg";
  }
  protected:
  explicit CSetKeymapMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeymapFieldNumber = 1,
  };
  // optional .CStreamingKeymap keymap = 1;
  bool has_keymap() const;
  private:
  bool _internal_has_keymap() const;
  public:
  void clear_keymap();
  const ::CStreamingKeymap& keymap() const;
  PROTOBUF_NODISCARD ::CStreamingKeymap* release_keymap();
  ::CStreamingKeymap* mutable_keymap();
  void set_allocated_keymap(::CStreamingKeymap* keymap);
  private:
  const ::CStreamingKeymap& _internal_keymap() const;
  ::CStreamingKeymap* _internal_mutable_keymap();
  public:
  void unsafe_arena_set_allocated_keymap(
      ::CStreamingKeymap* keymap);
  ::CStreamingKeymap* unsafe_arena_release_keymap();

  // @@protoc_insertion_point(class_scope:CSetKeymapMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CStreamingKeymap* keymap_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStopRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CStopRequest) */ {
 public:
  inline CStopRequest() : CStopRequest(nullptr) {}
  explicit constexpr CStopRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStopRequest(const CStopRequest& from);
  CStopRequest(CStopRequest&& from) noexcept
    : CStopRequest() {
    *this = ::std::move(from);
  }

  inline CStopRequest& operator=(const CStopRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStopRequest& operator=(CStopRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStopRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStopRequest* internal_default_instance() {
    return reinterpret_cast<const CStopRequest*>(
               &_CStopRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(CStopRequest& a, CStopRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CStopRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStopRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStopRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStopRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CStopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CStopRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStopRequest";
  }
  protected:
  explicit CStopRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CStopRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CQuitRequest final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CQuitRequest) */ {
 public:
  inline CQuitRequest() : CQuitRequest(nullptr) {}
  explicit constexpr CQuitRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CQuitRequest(const CQuitRequest& from);
  CQuitRequest(CQuitRequest&& from) noexcept
    : CQuitRequest() {
    *this = ::std::move(from);
  }

  inline CQuitRequest& operator=(const CQuitRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CQuitRequest& operator=(CQuitRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CQuitRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CQuitRequest* internal_default_instance() {
    return reinterpret_cast<const CQuitRequest*>(
               &_CQuitRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(CQuitRequest& a, CQuitRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CQuitRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CQuitRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CQuitRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CQuitRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CQuitRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CQuitRequest& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CQuitRequest";
  }
  protected:
  explicit CQuitRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CQuitRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CDeleteCursorMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDeleteCursorMsg) */ {
 public:
  inline CDeleteCursorMsg() : CDeleteCursorMsg(nullptr) {}
  ~CDeleteCursorMsg() override;
  explicit constexpr CDeleteCursorMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDeleteCursorMsg(const CDeleteCursorMsg& from);
  CDeleteCursorMsg(CDeleteCursorMsg&& from) noexcept
    : CDeleteCursorMsg() {
    *this = ::std::move(from);
  }

  inline CDeleteCursorMsg& operator=(const CDeleteCursorMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDeleteCursorMsg& operator=(CDeleteCursorMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDeleteCursorMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDeleteCursorMsg* internal_default_instance() {
    return reinterpret_cast<const CDeleteCursorMsg*>(
               &_CDeleteCursorMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(CDeleteCursorMsg& a, CDeleteCursorMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CDeleteCursorMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDeleteCursorMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDeleteCursorMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDeleteCursorMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDeleteCursorMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CDeleteCursorMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDeleteCursorMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDeleteCursorMsg";
  }
  protected:
  explicit CDeleteCursorMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCursorIdFieldNumber = 1,
  };
  // required uint64 cursor_id = 1;
  bool has_cursor_id() const;
  private:
  bool _internal_has_cursor_id() const;
  public:
  void clear_cursor_id();
  uint64_t cursor_id() const;
  void set_cursor_id(uint64_t value);
  private:
  uint64_t _internal_cursor_id() const;
  void _internal_set_cursor_id(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CDeleteCursorMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint64_t cursor_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetStreamingClientConfig final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetStreamingClientConfig) */ {
 public:
  inline CSetStreamingClientConfig() : CSetStreamingClientConfig(nullptr) {}
  ~CSetStreamingClientConfig() override;
  explicit constexpr CSetStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetStreamingClientConfig(const CSetStreamingClientConfig& from);
  CSetStreamingClientConfig(CSetStreamingClientConfig&& from) noexcept
    : CSetStreamingClientConfig() {
    *this = ::std::move(from);
  }

  inline CSetStreamingClientConfig& operator=(const CSetStreamingClientConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetStreamingClientConfig& operator=(CSetStreamingClientConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetStreamingClientConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetStreamingClientConfig* internal_default_instance() {
    return reinterpret_cast<const CSetStreamingClientConfig*>(
               &_CSetStreamingClientConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(CSetStreamingClientConfig& a, CSetStreamingClientConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetStreamingClientConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetStreamingClientConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetStreamingClientConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetStreamingClientConfig>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetStreamingClientConfig& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetStreamingClientConfig& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetStreamingClientConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetStreamingClientConfig";
  }
  protected:
  explicit CSetStreamingClientConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigFieldNumber = 1,
  };
  // required .CStreamingClientConfig config = 1;
  bool has_config() const;
  private:
  bool _internal_has_config() const;
  public:
  void clear_config();
  const ::CStreamingClientConfig& config() const;
  PROTOBUF_NODISCARD ::CStreamingClientConfig* release_config();
  ::CStreamingClientConfig* mutable_config();
  void set_allocated_config(::CStreamingClientConfig* config);
  private:
  const ::CStreamingClientConfig& _internal_config() const;
  ::CStreamingClientConfig* _internal_mutable_config();
  public:
  void unsafe_arena_set_allocated_config(
      ::CStreamingClientConfig* config);
  ::CStreamingClientConfig* unsafe_arena_release_config();

  // @@protoc_insertion_point(class_scope:CSetStreamingClientConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::CStreamingClientConfig* config_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetQoSMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetQoSMsg) */ {
 public:
  inline CSetQoSMsg() : CSetQoSMsg(nullptr) {}
  ~CSetQoSMsg() override;
  explicit constexpr CSetQoSMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetQoSMsg(const CSetQoSMsg& from);
  CSetQoSMsg(CSetQoSMsg&& from) noexcept
    : CSetQoSMsg() {
    *this = ::std::move(from);
  }

  inline CSetQoSMsg& operator=(const CSetQoSMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetQoSMsg& operator=(CSetQoSMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetQoSMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetQoSMsg* internal_default_instance() {
    return reinterpret_cast<const CSetQoSMsg*>(
               &_CSetQoSMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    65;

  friend void swap(CSetQoSMsg& a, CSetQoSMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetQoSMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetQoSMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetQoSMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetQoSMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetQoSMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetQoSMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetQoSMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetQoSMsg";
  }
  protected:
  explicit CSetQoSMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUseQosFieldNumber = 1,
  };
  // required bool use_qos = 1;
  bool has_use_qos() const;
  private:
  bool _internal_has_use_qos() const;
  public:
  void clear_use_qos();
  bool use_qos() const;
  void set_use_qos(bool value);
  private:
  bool _internal_use_qos() const;
  void _internal_set_use_qos(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSetQoSMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool use_qos_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetTargetFramerateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetTargetFramerateMsg) */ {
 public:
  inline CSetTargetFramerateMsg() : CSetTargetFramerateMsg(nullptr) {}
  ~CSetTargetFramerateMsg() override;
  explicit constexpr CSetTargetFramerateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetTargetFramerateMsg(const CSetTargetFramerateMsg& from);
  CSetTargetFramerateMsg(CSetTargetFramerateMsg&& from) noexcept
    : CSetTargetFramerateMsg() {
    *this = ::std::move(from);
  }

  inline CSetTargetFramerateMsg& operator=(const CSetTargetFramerateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetTargetFramerateMsg& operator=(CSetTargetFramerateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetTargetFramerateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetTargetFramerateMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTargetFramerateMsg*>(
               &_CSetTargetFramerateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    66;

  friend void swap(CSetTargetFramerateMsg& a, CSetTargetFramerateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetTargetFramerateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetTargetFramerateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetTargetFramerateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetTargetFramerateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetTargetFramerateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetTargetFramerateMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTargetFramerateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetTargetFramerateMsg";
  }
  protected:
  explicit CSetTargetFramerateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFramerateFieldNumber = 1,
    kReasonsFieldNumber = 2,
    kFramerateNumeratorFieldNumber = 3,
    kFramerateDenominatorFieldNumber = 4,
  };
  // required uint32 framerate = 1;
  bool has_framerate() const;
  private:
  bool _internal_has_framerate() const;
  public:
  void clear_framerate();
  uint32_t framerate() const;
  void set_framerate(uint32_t value);
  private:
  uint32_t _internal_framerate() const;
  void _internal_set_framerate(uint32_t value);
  public:

  // optional uint32 reasons = 2;
  bool has_reasons() const;
  private:
  bool _internal_has_reasons() const;
  public:
  void clear_reasons();
  uint32_t reasons() const;
  void set_reasons(uint32_t value);
  private:
  uint32_t _internal_reasons() const;
  void _internal_set_reasons(uint32_t value);
  public:

  // optional uint32 framerate_numerator = 3;
  bool has_framerate_numerator() const;
  private:
  bool _internal_has_framerate_numerator() const;
  public:
  void clear_framerate_numerator();
  uint32_t framerate_numerator() const;
  void set_framerate_numerator(uint32_t value);
  private:
  uint32_t _internal_framerate_numerator() const;
  void _internal_set_framerate_numerator(uint32_t value);
  public:

  // optional uint32 framerate_denominator = 4;
  bool has_framerate_denominator() const;
  private:
  bool _internal_has_framerate_denominator() const;
  public:
  void clear_framerate_denominator();
  uint32_t framerate_denominator() const;
  void set_framerate_denominator(uint32_t value);
  private:
  uint32_t _internal_framerate_denominator() const;
  void _internal_set_framerate_denominator(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetTargetFramerateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t framerate_;
  uint32_t reasons_;
  uint32_t framerate_numerator_;
  uint32_t framerate_denominator_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetTargetBitrateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetTargetBitrateMsg) */ {
 public:
  inline CSetTargetBitrateMsg() : CSetTargetBitrateMsg(nullptr) {}
  ~CSetTargetBitrateMsg() override;
  explicit constexpr CSetTargetBitrateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetTargetBitrateMsg(const CSetTargetBitrateMsg& from);
  CSetTargetBitrateMsg(CSetTargetBitrateMsg&& from) noexcept
    : CSetTargetBitrateMsg() {
    *this = ::std::move(from);
  }

  inline CSetTargetBitrateMsg& operator=(const CSetTargetBitrateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetTargetBitrateMsg& operator=(CSetTargetBitrateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetTargetBitrateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetTargetBitrateMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTargetBitrateMsg*>(
               &_CSetTargetBitrateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    67;

  friend void swap(CSetTargetBitrateMsg& a, CSetTargetBitrateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetTargetBitrateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetTargetBitrateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetTargetBitrateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetTargetBitrateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetTargetBitrateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetTargetBitrateMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTargetBitrateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetTargetBitrateMsg";
  }
  protected:
  explicit CSetTargetBitrateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitrateFieldNumber = 1,
  };
  // required int32 bitrate = 1;
  bool has_bitrate() const;
  private:
  bool _internal_has_bitrate() const;
  public:
  void clear_bitrate();
  int32_t bitrate() const;
  void set_bitrate(int32_t value);
  private:
  int32_t _internal_bitrate() const;
  void _internal_set_bitrate(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetTargetBitrateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t bitrate_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class COverlayEnabledMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:COverlayEnabledMsg) */ {
 public:
  inline COverlayEnabledMsg() : COverlayEnabledMsg(nullptr) {}
  ~COverlayEnabledMsg() override;
  explicit constexpr COverlayEnabledMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  COverlayEnabledMsg(const COverlayEnabledMsg& from);
  COverlayEnabledMsg(COverlayEnabledMsg&& from) noexcept
    : COverlayEnabledMsg() {
    *this = ::std::move(from);
  }

  inline COverlayEnabledMsg& operator=(const COverlayEnabledMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline COverlayEnabledMsg& operator=(COverlayEnabledMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const COverlayEnabledMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const COverlayEnabledMsg* internal_default_instance() {
    return reinterpret_cast<const COverlayEnabledMsg*>(
               &_COverlayEnabledMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    68;

  friend void swap(COverlayEnabledMsg& a, COverlayEnabledMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(COverlayEnabledMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(COverlayEnabledMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  COverlayEnabledMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<COverlayEnabledMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const COverlayEnabledMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const COverlayEnabledMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(COverlayEnabledMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "COverlayEnabledMsg";
  }
  protected:
  explicit COverlayEnabledMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // required bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:COverlayEnabledMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetGammaRampMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetGammaRampMsg) */ {
 public:
  inline CSetGammaRampMsg() : CSetGammaRampMsg(nullptr) {}
  ~CSetGammaRampMsg() override;
  explicit constexpr CSetGammaRampMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetGammaRampMsg(const CSetGammaRampMsg& from);
  CSetGammaRampMsg(CSetGammaRampMsg&& from) noexcept
    : CSetGammaRampMsg() {
    *this = ::std::move(from);
  }

  inline CSetGammaRampMsg& operator=(const CSetGammaRampMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetGammaRampMsg& operator=(CSetGammaRampMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetGammaRampMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetGammaRampMsg* internal_default_instance() {
    return reinterpret_cast<const CSetGammaRampMsg*>(
               &_CSetGammaRampMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    69;

  friend void swap(CSetGammaRampMsg& a, CSetGammaRampMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetGammaRampMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetGammaRampMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetGammaRampMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetGammaRampMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetGammaRampMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetGammaRampMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetGammaRampMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetGammaRampMsg";
  }
  protected:
  explicit CSetGammaRampMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGammaRampFieldNumber = 1,
  };
  // optional bytes gamma_ramp = 1;
  bool has_gamma_ramp() const;
  private:
  bool _internal_has_gamma_ramp() const;
  public:
  void clear_gamma_ramp();
  const std::string& gamma_ramp() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_gamma_ramp(ArgT0&& arg0, ArgT... args);
  std::string* mutable_gamma_ramp();
  PROTOBUF_NODISCARD std::string* release_gamma_ramp();
  void set_allocated_gamma_ramp(std::string* gamma_ramp);
  private:
  const std::string& _internal_gamma_ramp() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_gamma_ramp(const std::string& value);
  std::string* _internal_mutable_gamma_ramp();
  public:

  // @@protoc_insertion_point(class_scope:CSetGammaRampMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr gamma_ramp_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetActivityMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetActivityMsg) */ {
 public:
  inline CSetActivityMsg() : CSetActivityMsg(nullptr) {}
  ~CSetActivityMsg() override;
  explicit constexpr CSetActivityMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetActivityMsg(const CSetActivityMsg& from);
  CSetActivityMsg(CSetActivityMsg&& from) noexcept
    : CSetActivityMsg() {
    *this = ::std::move(from);
  }

  inline CSetActivityMsg& operator=(const CSetActivityMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetActivityMsg& operator=(CSetActivityMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetActivityMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetActivityMsg* internal_default_instance() {
    return reinterpret_cast<const CSetActivityMsg*>(
               &_CSetActivityMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    70;

  friend void swap(CSetActivityMsg& a, CSetActivityMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetActivityMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetActivityMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetActivityMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetActivityMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetActivityMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetActivityMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetActivityMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetActivityMsg";
  }
  protected:
  explicit CSetActivityMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGameNameFieldNumber = 4,
    kGameidFieldNumber = 3,
    kAppidFieldNumber = 2,
    kActivityFieldNumber = 1,
  };
  // optional string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional uint64 gameid = 3;
  bool has_gameid() const;
  private:
  bool _internal_has_gameid() const;
  public:
  void clear_gameid();
  uint64_t gameid() const;
  void set_gameid(uint64_t value);
  private:
  uint64_t _internal_gameid() const;
  void _internal_set_gameid(uint64_t value);
  public:

  // optional uint32 appid = 2;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
  bool has_activity() const;
  private:
  bool _internal_has_activity() const;
  public:
  void clear_activity();
  ::EStreamActivity activity() const;
  void set_activity(::EStreamActivity value);
  private:
  ::EStreamActivity _internal_activity() const;
  void _internal_set_activity(::EStreamActivity value);
  public:

  // @@protoc_insertion_point(class_scope:CSetActivityMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  uint64_t gameid_;
  uint32_t appid_;
  int activity_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSystemSuspendMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CSystemSuspendMsg) */ {
 public:
  inline CSystemSuspendMsg() : CSystemSuspendMsg(nullptr) {}
  explicit constexpr CSystemSuspendMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSystemSuspendMsg(const CSystemSuspendMsg& from);
  CSystemSuspendMsg(CSystemSuspendMsg&& from) noexcept
    : CSystemSuspendMsg() {
    *this = ::std::move(from);
  }

  inline CSystemSuspendMsg& operator=(const CSystemSuspendMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSystemSuspendMsg& operator=(CSystemSuspendMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSystemSuspendMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSystemSuspendMsg* internal_default_instance() {
    return reinterpret_cast<const CSystemSuspendMsg*>(
               &_CSystemSuspendMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    71;

  friend void swap(CSystemSuspendMsg& a, CSystemSuspendMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSystemSuspendMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSystemSuspendMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSystemSuspendMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSystemSuspendMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CSystemSuspendMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CSystemSuspendMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSystemSuspendMsg";
  }
  protected:
  explicit CSystemSuspendMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CSystemSuspendMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVirtualHereRequestMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVirtualHereRequestMsg) */ {
 public:
  inline CVirtualHereRequestMsg() : CVirtualHereRequestMsg(nullptr) {}
  ~CVirtualHereRequestMsg() override;
  explicit constexpr CVirtualHereRequestMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVirtualHereRequestMsg(const CVirtualHereRequestMsg& from);
  CVirtualHereRequestMsg(CVirtualHereRequestMsg&& from) noexcept
    : CVirtualHereRequestMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereRequestMsg& operator=(const CVirtualHereRequestMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVirtualHereRequestMsg& operator=(CVirtualHereRequestMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVirtualHereRequestMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVirtualHereRequestMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereRequestMsg*>(
               &_CVirtualHereRequestMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    72;

  friend void swap(CVirtualHereRequestMsg& a, CVirtualHereRequestMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CVirtualHereRequestMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVirtualHereRequestMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVirtualHereRequestMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVirtualHereRequestMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVirtualHereRequestMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVirtualHereRequestMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereRequestMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVirtualHereRequestMsg";
  }
  protected:
  explicit CVirtualHereRequestMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHostnameFieldNumber = 1,
  };
  // optional string hostname = 1;
  bool has_hostname() const;
  private:
  bool _internal_has_hostname() const;
  public:
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_NODISCARD std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // @@protoc_insertion_point(class_scope:CVirtualHereRequestMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVirtualHereReadyMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVirtualHereReadyMsg) */ {
 public:
  inline CVirtualHereReadyMsg() : CVirtualHereReadyMsg(nullptr) {}
  ~CVirtualHereReadyMsg() override;
  explicit constexpr CVirtualHereReadyMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVirtualHereReadyMsg(const CVirtualHereReadyMsg& from);
  CVirtualHereReadyMsg(CVirtualHereReadyMsg&& from) noexcept
    : CVirtualHereReadyMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereReadyMsg& operator=(const CVirtualHereReadyMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVirtualHereReadyMsg& operator=(CVirtualHereReadyMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVirtualHereReadyMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVirtualHereReadyMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereReadyMsg*>(
               &_CVirtualHereReadyMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    73;

  friend void swap(CVirtualHereReadyMsg& a, CVirtualHereReadyMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CVirtualHereReadyMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVirtualHereReadyMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVirtualHereReadyMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVirtualHereReadyMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVirtualHereReadyMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVirtualHereReadyMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereReadyMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVirtualHereReadyMsg";
  }
  protected:
  explicit CVirtualHereReadyMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLicensedDeviceCountFieldNumber = 1,
  };
  // optional uint32 licensed_device_count = 1;
  bool has_licensed_device_count() const;
  private:
  bool _internal_has_licensed_device_count() const;
  public:
  void clear_licensed_device_count();
  uint32_t licensed_device_count() const;
  void set_licensed_device_count(uint32_t value);
  private:
  uint32_t _internal_licensed_device_count() const;
  void _internal_set_licensed_device_count(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CVirtualHereReadyMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t licensed_device_count_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVirtualHereShareDeviceMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVirtualHereShareDeviceMsg) */ {
 public:
  inline CVirtualHereShareDeviceMsg() : CVirtualHereShareDeviceMsg(nullptr) {}
  ~CVirtualHereShareDeviceMsg() override;
  explicit constexpr CVirtualHereShareDeviceMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVirtualHereShareDeviceMsg(const CVirtualHereShareDeviceMsg& from);
  CVirtualHereShareDeviceMsg(CVirtualHereShareDeviceMsg&& from) noexcept
    : CVirtualHereShareDeviceMsg() {
    *this = ::std::move(from);
  }

  inline CVirtualHereShareDeviceMsg& operator=(const CVirtualHereShareDeviceMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVirtualHereShareDeviceMsg& operator=(CVirtualHereShareDeviceMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVirtualHereShareDeviceMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVirtualHereShareDeviceMsg* internal_default_instance() {
    return reinterpret_cast<const CVirtualHereShareDeviceMsg*>(
               &_CVirtualHereShareDeviceMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    74;

  friend void swap(CVirtualHereShareDeviceMsg& a, CVirtualHereShareDeviceMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CVirtualHereShareDeviceMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVirtualHereShareDeviceMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVirtualHereShareDeviceMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVirtualHereShareDeviceMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVirtualHereShareDeviceMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVirtualHereShareDeviceMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVirtualHereShareDeviceMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVirtualHereShareDeviceMsg";
  }
  protected:
  explicit CVirtualHereShareDeviceMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceAddressFieldNumber = 1,
  };
  // optional string device_address = 1;
  bool has_device_address() const;
  private:
  bool _internal_has_device_address() const;
  public:
  void clear_device_address();
  const std::string& device_address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_address();
  PROTOBUF_NODISCARD std::string* release_device_address();
  void set_allocated_device_address(std::string* device_address);
  private:
  const std::string& _internal_device_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_address(const std::string& value);
  std::string* _internal_mutable_device_address();
  public:

  // @@protoc_insertion_point(class_scope:CVirtualHereShareDeviceMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_address_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetSpectatorModeMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetSpectatorModeMsg) */ {
 public:
  inline CSetSpectatorModeMsg() : CSetSpectatorModeMsg(nullptr) {}
  ~CSetSpectatorModeMsg() override;
  explicit constexpr CSetSpectatorModeMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetSpectatorModeMsg(const CSetSpectatorModeMsg& from);
  CSetSpectatorModeMsg(CSetSpectatorModeMsg&& from) noexcept
    : CSetSpectatorModeMsg() {
    *this = ::std::move(from);
  }

  inline CSetSpectatorModeMsg& operator=(const CSetSpectatorModeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetSpectatorModeMsg& operator=(CSetSpectatorModeMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetSpectatorModeMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetSpectatorModeMsg* internal_default_instance() {
    return reinterpret_cast<const CSetSpectatorModeMsg*>(
               &_CSetSpectatorModeMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    75;

  friend void swap(CSetSpectatorModeMsg& a, CSetSpectatorModeMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetSpectatorModeMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetSpectatorModeMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetSpectatorModeMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetSpectatorModeMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetSpectatorModeMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetSpectatorModeMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetSpectatorModeMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetSpectatorModeMsg";
  }
  protected:
  explicit CSetSpectatorModeMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledFieldNumber = 1,
  };
  // optional bool enabled = 1;
  bool has_enabled() const;
  private:
  bool _internal_has_enabled() const;
  public:
  void clear_enabled();
  bool enabled() const;
  void set_enabled(bool value);
  private:
  bool _internal_enabled() const;
  void _internal_set_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSetSpectatorModeMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool enabled_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CRemoteHIDMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRemoteHIDMsg) */ {
 public:
  inline CRemoteHIDMsg() : CRemoteHIDMsg(nullptr) {}
  ~CRemoteHIDMsg() override;
  explicit constexpr CRemoteHIDMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CRemoteHIDMsg(const CRemoteHIDMsg& from);
  CRemoteHIDMsg(CRemoteHIDMsg&& from) noexcept
    : CRemoteHIDMsg() {
    *this = ::std::move(from);
  }

  inline CRemoteHIDMsg& operator=(const CRemoteHIDMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRemoteHIDMsg& operator=(CRemoteHIDMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CRemoteHIDMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CRemoteHIDMsg* internal_default_instance() {
    return reinterpret_cast<const CRemoteHIDMsg*>(
               &_CRemoteHIDMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    76;

  friend void swap(CRemoteHIDMsg& a, CRemoteHIDMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CRemoteHIDMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CRemoteHIDMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CRemoteHIDMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CRemoteHIDMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CRemoteHIDMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CRemoteHIDMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRemoteHIDMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRemoteHIDMsg";
  }
  protected:
  explicit CRemoteHIDMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 1,
    kActiveInputFieldNumber = 2,
  };
  // optional bytes data = 1;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bool active_input = 2;
  bool has_active_input() const;
  private:
  bool _internal_has_active_input() const;
  public:
  void clear_active_input();
  bool active_input() const;
  void set_active_input(bool value);
  private:
  bool _internal_active_input() const;
  void _internal_set_active_input(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CRemoteHIDMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  bool active_input_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTouchConfigActiveMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTouchConfigActiveMsg) */ {
 public:
  inline CTouchConfigActiveMsg() : CTouchConfigActiveMsg(nullptr) {}
  ~CTouchConfigActiveMsg() override;
  explicit constexpr CTouchConfigActiveMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTouchConfigActiveMsg(const CTouchConfigActiveMsg& from);
  CTouchConfigActiveMsg(CTouchConfigActiveMsg&& from) noexcept
    : CTouchConfigActiveMsg() {
    *this = ::std::move(from);
  }

  inline CTouchConfigActiveMsg& operator=(const CTouchConfigActiveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTouchConfigActiveMsg& operator=(CTouchConfigActiveMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTouchConfigActiveMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTouchConfigActiveMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchConfigActiveMsg*>(
               &_CTouchConfigActiveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    77;

  friend void swap(CTouchConfigActiveMsg& a, CTouchConfigActiveMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CTouchConfigActiveMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTouchConfigActiveMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTouchConfigActiveMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTouchConfigActiveMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTouchConfigActiveMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTouchConfigActiveMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchConfigActiveMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTouchConfigActiveMsg";
  }
  protected:
  explicit CTouchConfigActiveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kRevisionFieldNumber = 2,
    kCreatorFieldNumber = 3,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 revision = 2;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  uint32_t revision() const;
  void set_revision(uint32_t value);
  private:
  uint32_t _internal_revision() const;
  void _internal_set_revision(uint32_t value);
  public:

  // optional uint64 creator = 3;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  uint64_t creator() const;
  void set_creator(uint64_t value);
  private:
  uint64_t _internal_creator() const;
  void _internal_set_creator(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTouchConfigActiveMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  uint32_t revision_;
  uint64_t creator_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CGetTouchConfigDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGetTouchConfigDataMsg) */ {
 public:
  inline CGetTouchConfigDataMsg() : CGetTouchConfigDataMsg(nullptr) {}
  ~CGetTouchConfigDataMsg() override;
  explicit constexpr CGetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGetTouchConfigDataMsg(const CGetTouchConfigDataMsg& from);
  CGetTouchConfigDataMsg(CGetTouchConfigDataMsg&& from) noexcept
    : CGetTouchConfigDataMsg() {
    *this = ::std::move(from);
  }

  inline CGetTouchConfigDataMsg& operator=(const CGetTouchConfigDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGetTouchConfigDataMsg& operator=(CGetTouchConfigDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGetTouchConfigDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGetTouchConfigDataMsg* internal_default_instance() {
    return reinterpret_cast<const CGetTouchConfigDataMsg*>(
               &_CGetTouchConfigDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    78;

  friend void swap(CGetTouchConfigDataMsg& a, CGetTouchConfigDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CGetTouchConfigDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGetTouchConfigDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGetTouchConfigDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGetTouchConfigDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGetTouchConfigDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CGetTouchConfigDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetTouchConfigDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGetTouchConfigDataMsg";
  }
  protected:
  explicit CGetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGetTouchConfigDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetTouchConfigDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetTouchConfigDataMsg) */ {
 public:
  inline CSetTouchConfigDataMsg() : CSetTouchConfigDataMsg(nullptr) {}
  ~CSetTouchConfigDataMsg() override;
  explicit constexpr CSetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetTouchConfigDataMsg(const CSetTouchConfigDataMsg& from);
  CSetTouchConfigDataMsg(CSetTouchConfigDataMsg&& from) noexcept
    : CSetTouchConfigDataMsg() {
    *this = ::std::move(from);
  }

  inline CSetTouchConfigDataMsg& operator=(const CSetTouchConfigDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetTouchConfigDataMsg& operator=(CSetTouchConfigDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetTouchConfigDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetTouchConfigDataMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTouchConfigDataMsg*>(
               &_CSetTouchConfigDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    79;

  friend void swap(CSetTouchConfigDataMsg& a, CSetTouchConfigDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetTouchConfigDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetTouchConfigDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetTouchConfigDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetTouchConfigDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetTouchConfigDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetTouchConfigDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTouchConfigDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetTouchConfigDataMsg";
  }
  protected:
  explicit CSetTouchConfigDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kLayoutFieldNumber = 4,
    kAppidFieldNumber = 1,
    kRevisionFieldNumber = 2,
    kCreatorFieldNumber = 5,
  };
  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional bytes layout = 4;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const std::string& layout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layout();
  PROTOBUF_NODISCARD std::string* release_layout();
  void set_allocated_layout(std::string* layout);
  private:
  const std::string& _internal_layout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* _internal_mutable_layout();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 revision = 2;
  bool has_revision() const;
  private:
  bool _internal_has_revision() const;
  public:
  void clear_revision();
  uint32_t revision() const;
  void set_revision(uint32_t value);
  private:
  uint32_t _internal_revision() const;
  void _internal_set_revision(uint32_t value);
  public:

  // optional uint64 creator = 5;
  bool has_creator() const;
  private:
  bool _internal_has_creator() const;
  public:
  void clear_creator();
  uint64_t creator() const;
  void set_creator(uint64_t value);
  private:
  uint64_t _internal_creator() const;
  void _internal_set_creator(uint64_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetTouchConfigDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layout_;
  uint32_t appid_;
  uint32_t revision_;
  uint64_t creator_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSaveTouchConfigLayoutMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSaveTouchConfigLayoutMsg) */ {
 public:
  inline CSaveTouchConfigLayoutMsg() : CSaveTouchConfigLayoutMsg(nullptr) {}
  ~CSaveTouchConfigLayoutMsg() override;
  explicit constexpr CSaveTouchConfigLayoutMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSaveTouchConfigLayoutMsg(const CSaveTouchConfigLayoutMsg& from);
  CSaveTouchConfigLayoutMsg(CSaveTouchConfigLayoutMsg&& from) noexcept
    : CSaveTouchConfigLayoutMsg() {
    *this = ::std::move(from);
  }

  inline CSaveTouchConfigLayoutMsg& operator=(const CSaveTouchConfigLayoutMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSaveTouchConfigLayoutMsg& operator=(CSaveTouchConfigLayoutMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSaveTouchConfigLayoutMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSaveTouchConfigLayoutMsg* internal_default_instance() {
    return reinterpret_cast<const CSaveTouchConfigLayoutMsg*>(
               &_CSaveTouchConfigLayoutMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    80;

  friend void swap(CSaveTouchConfigLayoutMsg& a, CSaveTouchConfigLayoutMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSaveTouchConfigLayoutMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSaveTouchConfigLayoutMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSaveTouchConfigLayoutMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSaveTouchConfigLayoutMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSaveTouchConfigLayoutMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSaveTouchConfigLayoutMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSaveTouchConfigLayoutMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSaveTouchConfigLayoutMsg";
  }
  protected:
  explicit CSaveTouchConfigLayoutMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayoutFieldNumber = 4,
    kAppidFieldNumber = 1,
  };
  // optional bytes layout = 4;
  bool has_layout() const;
  private:
  bool _internal_has_layout() const;
  public:
  void clear_layout();
  const std::string& layout() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_layout(ArgT0&& arg0, ArgT... args);
  std::string* mutable_layout();
  PROTOBUF_NODISCARD std::string* release_layout();
  void set_allocated_layout(std::string* layout);
  private:
  const std::string& _internal_layout() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_layout(const std::string& value);
  std::string* _internal_mutable_layout();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSaveTouchConfigLayoutMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr layout_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTouchActionSetActiveMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTouchActionSetActiveMsg) */ {
 public:
  inline CTouchActionSetActiveMsg() : CTouchActionSetActiveMsg(nullptr) {}
  ~CTouchActionSetActiveMsg() override;
  explicit constexpr CTouchActionSetActiveMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTouchActionSetActiveMsg(const CTouchActionSetActiveMsg& from);
  CTouchActionSetActiveMsg(CTouchActionSetActiveMsg&& from) noexcept
    : CTouchActionSetActiveMsg() {
    *this = ::std::move(from);
  }

  inline CTouchActionSetActiveMsg& operator=(const CTouchActionSetActiveMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTouchActionSetActiveMsg& operator=(CTouchActionSetActiveMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTouchActionSetActiveMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTouchActionSetActiveMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchActionSetActiveMsg*>(
               &_CTouchActionSetActiveMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    81;

  friend void swap(CTouchActionSetActiveMsg& a, CTouchActionSetActiveMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CTouchActionSetActiveMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTouchActionSetActiveMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTouchActionSetActiveMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTouchActionSetActiveMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTouchActionSetActiveMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTouchActionSetActiveMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchActionSetActiveMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTouchActionSetActiveMsg";
  }
  protected:
  explicit CTouchActionSetActiveMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kActionsetIdFieldNumber = 2,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional int32 actionset_id = 2;
  bool has_actionset_id() const;
  private:
  bool _internal_has_actionset_id() const;
  public:
  void clear_actionset_id();
  int32_t actionset_id() const;
  void set_actionset_id(int32_t value);
  private:
  int32_t _internal_actionset_id() const;
  void _internal_set_actionset_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTouchActionSetActiveMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  int32_t actionset_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTouchActionSetLayerAddedMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTouchActionSetLayerAddedMsg) */ {
 public:
  inline CTouchActionSetLayerAddedMsg() : CTouchActionSetLayerAddedMsg(nullptr) {}
  ~CTouchActionSetLayerAddedMsg() override;
  explicit constexpr CTouchActionSetLayerAddedMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTouchActionSetLayerAddedMsg(const CTouchActionSetLayerAddedMsg& from);
  CTouchActionSetLayerAddedMsg(CTouchActionSetLayerAddedMsg&& from) noexcept
    : CTouchActionSetLayerAddedMsg() {
    *this = ::std::move(from);
  }

  inline CTouchActionSetLayerAddedMsg& operator=(const CTouchActionSetLayerAddedMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTouchActionSetLayerAddedMsg& operator=(CTouchActionSetLayerAddedMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTouchActionSetLayerAddedMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTouchActionSetLayerAddedMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchActionSetLayerAddedMsg*>(
               &_CTouchActionSetLayerAddedMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    82;

  friend void swap(CTouchActionSetLayerAddedMsg& a, CTouchActionSetLayerAddedMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CTouchActionSetLayerAddedMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTouchActionSetLayerAddedMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTouchActionSetLayerAddedMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTouchActionSetLayerAddedMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTouchActionSetLayerAddedMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTouchActionSetLayerAddedMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchActionSetLayerAddedMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTouchActionSetLayerAddedMsg";
  }
  protected:
  explicit CTouchActionSetLayerAddedMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kActionsetIdFieldNumber = 2,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional int32 actionset_id = 2;
  bool has_actionset_id() const;
  private:
  bool _internal_has_actionset_id() const;
  public:
  void clear_actionset_id();
  int32_t actionset_id() const;
  void set_actionset_id(int32_t value);
  private:
  int32_t _internal_actionset_id() const;
  void _internal_set_actionset_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTouchActionSetLayerAddedMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  int32_t actionset_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTouchActionSetLayerRemovedMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTouchActionSetLayerRemovedMsg) */ {
 public:
  inline CTouchActionSetLayerRemovedMsg() : CTouchActionSetLayerRemovedMsg(nullptr) {}
  ~CTouchActionSetLayerRemovedMsg() override;
  explicit constexpr CTouchActionSetLayerRemovedMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTouchActionSetLayerRemovedMsg(const CTouchActionSetLayerRemovedMsg& from);
  CTouchActionSetLayerRemovedMsg(CTouchActionSetLayerRemovedMsg&& from) noexcept
    : CTouchActionSetLayerRemovedMsg() {
    *this = ::std::move(from);
  }

  inline CTouchActionSetLayerRemovedMsg& operator=(const CTouchActionSetLayerRemovedMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTouchActionSetLayerRemovedMsg& operator=(CTouchActionSetLayerRemovedMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTouchActionSetLayerRemovedMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTouchActionSetLayerRemovedMsg* internal_default_instance() {
    return reinterpret_cast<const CTouchActionSetLayerRemovedMsg*>(
               &_CTouchActionSetLayerRemovedMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    83;

  friend void swap(CTouchActionSetLayerRemovedMsg& a, CTouchActionSetLayerRemovedMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CTouchActionSetLayerRemovedMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTouchActionSetLayerRemovedMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTouchActionSetLayerRemovedMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTouchActionSetLayerRemovedMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTouchActionSetLayerRemovedMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTouchActionSetLayerRemovedMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTouchActionSetLayerRemovedMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTouchActionSetLayerRemovedMsg";
  }
  protected:
  explicit CTouchActionSetLayerRemovedMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAppidFieldNumber = 1,
    kActionsetIdFieldNumber = 2,
  };
  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional int32 actionset_id = 2;
  bool has_actionset_id() const;
  private:
  bool _internal_has_actionset_id() const;
  public:
  void clear_actionset_id();
  int32_t actionset_id() const;
  void set_actionset_id(int32_t value);
  private:
  int32_t _internal_actionset_id() const;
  void _internal_set_actionset_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTouchActionSetLayerRemovedMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t appid_;
  int32_t actionset_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CGetTouchIconDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CGetTouchIconDataMsg) */ {
 public:
  inline CGetTouchIconDataMsg() : CGetTouchIconDataMsg(nullptr) {}
  ~CGetTouchIconDataMsg() override;
  explicit constexpr CGetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CGetTouchIconDataMsg(const CGetTouchIconDataMsg& from);
  CGetTouchIconDataMsg(CGetTouchIconDataMsg&& from) noexcept
    : CGetTouchIconDataMsg() {
    *this = ::std::move(from);
  }

  inline CGetTouchIconDataMsg& operator=(const CGetTouchIconDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CGetTouchIconDataMsg& operator=(CGetTouchIconDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CGetTouchIconDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CGetTouchIconDataMsg* internal_default_instance() {
    return reinterpret_cast<const CGetTouchIconDataMsg*>(
               &_CGetTouchIconDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    84;

  friend void swap(CGetTouchIconDataMsg& a, CGetTouchIconDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CGetTouchIconDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CGetTouchIconDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CGetTouchIconDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CGetTouchIconDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CGetTouchIconDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CGetTouchIconDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CGetTouchIconDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CGetTouchIconDataMsg";
  }
  protected:
  explicit CGetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconFieldNumber = 2,
    kAppidFieldNumber = 1,
  };
  // optional string icon = 2;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CGetTouchIconDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetTouchIconDataMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetTouchIconDataMsg) */ {
 public:
  inline CSetTouchIconDataMsg() : CSetTouchIconDataMsg(nullptr) {}
  ~CSetTouchIconDataMsg() override;
  explicit constexpr CSetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetTouchIconDataMsg(const CSetTouchIconDataMsg& from);
  CSetTouchIconDataMsg(CSetTouchIconDataMsg&& from) noexcept
    : CSetTouchIconDataMsg() {
    *this = ::std::move(from);
  }

  inline CSetTouchIconDataMsg& operator=(const CSetTouchIconDataMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetTouchIconDataMsg& operator=(CSetTouchIconDataMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetTouchIconDataMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetTouchIconDataMsg* internal_default_instance() {
    return reinterpret_cast<const CSetTouchIconDataMsg*>(
               &_CSetTouchIconDataMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    85;

  friend void swap(CSetTouchIconDataMsg& a, CSetTouchIconDataMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetTouchIconDataMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetTouchIconDataMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetTouchIconDataMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetTouchIconDataMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetTouchIconDataMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetTouchIconDataMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetTouchIconDataMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetTouchIconDataMsg";
  }
  protected:
  explicit CSetTouchIconDataMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIconFieldNumber = 2,
    kDataFieldNumber = 3,
    kAppidFieldNumber = 1,
  };
  // optional string icon = 2;
  bool has_icon() const;
  private:
  bool _internal_has_icon() const;
  public:
  void clear_icon();
  const std::string& icon() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_icon(ArgT0&& arg0, ArgT... args);
  std::string* mutable_icon();
  PROTOBUF_NODISCARD std::string* release_icon();
  void set_allocated_icon(std::string* icon);
  private:
  const std::string& _internal_icon() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_icon(const std::string& value);
  std::string* _internal_mutable_icon();
  public:

  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetTouchIconDataMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr icon_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CRemotePlayTogetherGroupUpdateMsg_Player final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRemotePlayTogetherGroupUpdateMsg.Player) */ {
 public:
  inline CRemotePlayTogetherGroupUpdateMsg_Player() : CRemotePlayTogetherGroupUpdateMsg_Player(nullptr) {}
  ~CRemotePlayTogetherGroupUpdateMsg_Player() override;
  explicit constexpr CRemotePlayTogetherGroupUpdateMsg_Player(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CRemotePlayTogetherGroupUpdateMsg_Player(const CRemotePlayTogetherGroupUpdateMsg_Player& from);
  CRemotePlayTogetherGroupUpdateMsg_Player(CRemotePlayTogetherGroupUpdateMsg_Player&& from) noexcept
    : CRemotePlayTogetherGroupUpdateMsg_Player() {
    *this = ::std::move(from);
  }

  inline CRemotePlayTogetherGroupUpdateMsg_Player& operator=(const CRemotePlayTogetherGroupUpdateMsg_Player& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRemotePlayTogetherGroupUpdateMsg_Player& operator=(CRemotePlayTogetherGroupUpdateMsg_Player&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CRemotePlayTogetherGroupUpdateMsg_Player& default_instance() {
    return *internal_default_instance();
  }
  static inline const CRemotePlayTogetherGroupUpdateMsg_Player* internal_default_instance() {
    return reinterpret_cast<const CRemotePlayTogetherGroupUpdateMsg_Player*>(
               &_CRemotePlayTogetherGroupUpdateMsg_Player_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    86;

  friend void swap(CRemotePlayTogetherGroupUpdateMsg_Player& a, CRemotePlayTogetherGroupUpdateMsg_Player& b) {
    a.Swap(&b);
  }
  inline void Swap(CRemotePlayTogetherGroupUpdateMsg_Player* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CRemotePlayTogetherGroupUpdateMsg_Player* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CRemotePlayTogetherGroupUpdateMsg_Player* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CRemotePlayTogetherGroupUpdateMsg_Player>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CRemotePlayTogetherGroupUpdateMsg_Player& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CRemotePlayTogetherGroupUpdateMsg_Player& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRemotePlayTogetherGroupUpdateMsg_Player* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRemotePlayTogetherGroupUpdateMsg.Player";
  }
  protected:
  explicit CRemotePlayTogetherGroupUpdateMsg_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerSlotsFieldNumber = 6,
    kAvatarHashFieldNumber = 7,
    kAccountidFieldNumber = 1,
    kGuestidFieldNumber = 2,
    kKeyboardEnabledFieldNumber = 3,
    kMouseEnabledFieldNumber = 4,
    kControllerEnabledFieldNumber = 5,
  };
  // repeated uint32 controller_slots = 6;
  int controller_slots_size() const;
  private:
  int _internal_controller_slots_size() const;
  public:
  void clear_controller_slots();
  private:
  uint32_t _internal_controller_slots(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_controller_slots() const;
  void _internal_add_controller_slots(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_controller_slots();
  public:
  uint32_t controller_slots(int index) const;
  void set_controller_slots(int index, uint32_t value);
  void add_controller_slots(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      controller_slots() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_controller_slots();

  // optional bytes avatar_hash = 7;
  bool has_avatar_hash() const;
  private:
  bool _internal_has_avatar_hash() const;
  public:
  void clear_avatar_hash();
  const std::string& avatar_hash() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_hash(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_hash();
  PROTOBUF_NODISCARD std::string* release_avatar_hash();
  void set_allocated_avatar_hash(std::string* avatar_hash);
  private:
  const std::string& _internal_avatar_hash() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_hash(const std::string& value);
  std::string* _internal_mutable_avatar_hash();
  public:

  // optional uint32 accountid = 1;
  bool has_accountid() const;
  private:
  bool _internal_has_accountid() const;
  public:
  void clear_accountid();
  uint32_t accountid() const;
  void set_accountid(uint32_t value);
  private:
  uint32_t _internal_accountid() const;
  void _internal_set_accountid(uint32_t value);
  public:

  // optional uint32 guestid = 2;
  bool has_guestid() const;
  private:
  bool _internal_has_guestid() const;
  public:
  void clear_guestid();
  uint32_t guestid() const;
  void set_guestid(uint32_t value);
  private:
  uint32_t _internal_guestid() const;
  void _internal_set_guestid(uint32_t value);
  public:

  // optional bool keyboard_enabled = 3;
  bool has_keyboard_enabled() const;
  private:
  bool _internal_has_keyboard_enabled() const;
  public:
  void clear_keyboard_enabled();
  bool keyboard_enabled() const;
  void set_keyboard_enabled(bool value);
  private:
  bool _internal_keyboard_enabled() const;
  void _internal_set_keyboard_enabled(bool value);
  public:

  // optional bool mouse_enabled = 4;
  bool has_mouse_enabled() const;
  private:
  bool _internal_has_mouse_enabled() const;
  public:
  void clear_mouse_enabled();
  bool mouse_enabled() const;
  void set_mouse_enabled(bool value);
  private:
  bool _internal_mouse_enabled() const;
  void _internal_set_mouse_enabled(bool value);
  public:

  // optional bool controller_enabled = 5;
  bool has_controller_enabled() const;
  private:
  bool _internal_has_controller_enabled() const;
  public:
  void clear_controller_enabled();
  bool controller_enabled() const;
  void set_controller_enabled(bool value);
  private:
  bool _internal_controller_enabled() const;
  void _internal_set_controller_enabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CRemotePlayTogetherGroupUpdateMsg.Player)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > controller_slots_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_hash_;
  uint32_t accountid_;
  uint32_t guestid_;
  bool keyboard_enabled_;
  bool mouse_enabled_;
  bool controller_enabled_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CRemotePlayTogetherGroupUpdateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CRemotePlayTogetherGroupUpdateMsg) */ {
 public:
  inline CRemotePlayTogetherGroupUpdateMsg() : CRemotePlayTogetherGroupUpdateMsg(nullptr) {}
  ~CRemotePlayTogetherGroupUpdateMsg() override;
  explicit constexpr CRemotePlayTogetherGroupUpdateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CRemotePlayTogetherGroupUpdateMsg(const CRemotePlayTogetherGroupUpdateMsg& from);
  CRemotePlayTogetherGroupUpdateMsg(CRemotePlayTogetherGroupUpdateMsg&& from) noexcept
    : CRemotePlayTogetherGroupUpdateMsg() {
    *this = ::std::move(from);
  }

  inline CRemotePlayTogetherGroupUpdateMsg& operator=(const CRemotePlayTogetherGroupUpdateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CRemotePlayTogetherGroupUpdateMsg& operator=(CRemotePlayTogetherGroupUpdateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CRemotePlayTogetherGroupUpdateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CRemotePlayTogetherGroupUpdateMsg* internal_default_instance() {
    return reinterpret_cast<const CRemotePlayTogetherGroupUpdateMsg*>(
               &_CRemotePlayTogetherGroupUpdateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    87;

  friend void swap(CRemotePlayTogetherGroupUpdateMsg& a, CRemotePlayTogetherGroupUpdateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CRemotePlayTogetherGroupUpdateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CRemotePlayTogetherGroupUpdateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CRemotePlayTogetherGroupUpdateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CRemotePlayTogetherGroupUpdateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CRemotePlayTogetherGroupUpdateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CRemotePlayTogetherGroupUpdateMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CRemotePlayTogetherGroupUpdateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CRemotePlayTogetherGroupUpdateMsg";
  }
  protected:
  explicit CRemotePlayTogetherGroupUpdateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CRemotePlayTogetherGroupUpdateMsg_Player Player;

  // accessors -------------------------------------------------------

  enum : int {
    kPlayersFieldNumber = 1,
    kMiniprofileLocationFieldNumber = 3,
    kGameNameFieldNumber = 4,
    kAvatarLocationFieldNumber = 5,
    kPlayerIndexFieldNumber = 2,
  };
  // repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;
  int players_size() const;
  private:
  int _internal_players_size() const;
  public:
  void clear_players();
  ::CRemotePlayTogetherGroupUpdateMsg_Player* mutable_players(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRemotePlayTogetherGroupUpdateMsg_Player >*
      mutable_players();
  private:
  const ::CRemotePlayTogetherGroupUpdateMsg_Player& _internal_players(int index) const;
  ::CRemotePlayTogetherGroupUpdateMsg_Player* _internal_add_players();
  public:
  const ::CRemotePlayTogetherGroupUpdateMsg_Player& players(int index) const;
  ::CRemotePlayTogetherGroupUpdateMsg_Player* add_players();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRemotePlayTogetherGroupUpdateMsg_Player >&
      players() const;

  // optional string miniprofile_location = 3;
  bool has_miniprofile_location() const;
  private:
  bool _internal_has_miniprofile_location() const;
  public:
  void clear_miniprofile_location();
  const std::string& miniprofile_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_miniprofile_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_miniprofile_location();
  PROTOBUF_NODISCARD std::string* release_miniprofile_location();
  void set_allocated_miniprofile_location(std::string* miniprofile_location);
  private:
  const std::string& _internal_miniprofile_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_miniprofile_location(const std::string& value);
  std::string* _internal_mutable_miniprofile_location();
  public:

  // optional string game_name = 4;
  bool has_game_name() const;
  private:
  bool _internal_has_game_name() const;
  public:
  void clear_game_name();
  const std::string& game_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_game_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_game_name();
  PROTOBUF_NODISCARD std::string* release_game_name();
  void set_allocated_game_name(std::string* game_name);
  private:
  const std::string& _internal_game_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_game_name(const std::string& value);
  std::string* _internal_mutable_game_name();
  public:

  // optional string avatar_location = 5;
  bool has_avatar_location() const;
  private:
  bool _internal_has_avatar_location() const;
  public:
  void clear_avatar_location();
  const std::string& avatar_location() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_location(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_location();
  PROTOBUF_NODISCARD std::string* release_avatar_location();
  void set_allocated_avatar_location(std::string* avatar_location);
  private:
  const std::string& _internal_avatar_location() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_location(const std::string& value);
  std::string* _internal_mutable_avatar_location();
  public:

  // optional int32 player_index = 2;
  bool has_player_index() const;
  private:
  bool _internal_has_player_index() const;
  public:
  void clear_player_index();
  int32_t player_index() const;
  void set_player_index(int32_t value);
  private:
  int32_t _internal_player_index() const;
  void _internal_set_player_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CRemotePlayTogetherGroupUpdateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRemotePlayTogetherGroupUpdateMsg_Player > players_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr miniprofile_location_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr game_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_location_;
  int32_t player_index_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetInputTemporarilyDisabledMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetInputTemporarilyDisabledMsg) */ {
 public:
  inline CSetInputTemporarilyDisabledMsg() : CSetInputTemporarilyDisabledMsg(nullptr) {}
  ~CSetInputTemporarilyDisabledMsg() override;
  explicit constexpr CSetInputTemporarilyDisabledMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetInputTemporarilyDisabledMsg(const CSetInputTemporarilyDisabledMsg& from);
  CSetInputTemporarilyDisabledMsg(CSetInputTemporarilyDisabledMsg&& from) noexcept
    : CSetInputTemporarilyDisabledMsg() {
    *this = ::std::move(from);
  }

  inline CSetInputTemporarilyDisabledMsg& operator=(const CSetInputTemporarilyDisabledMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetInputTemporarilyDisabledMsg& operator=(CSetInputTemporarilyDisabledMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetInputTemporarilyDisabledMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetInputTemporarilyDisabledMsg* internal_default_instance() {
    return reinterpret_cast<const CSetInputTemporarilyDisabledMsg*>(
               &_CSetInputTemporarilyDisabledMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    88;

  friend void swap(CSetInputTemporarilyDisabledMsg& a, CSetInputTemporarilyDisabledMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetInputTemporarilyDisabledMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetInputTemporarilyDisabledMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetInputTemporarilyDisabledMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetInputTemporarilyDisabledMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetInputTemporarilyDisabledMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetInputTemporarilyDisabledMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetInputTemporarilyDisabledMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetInputTemporarilyDisabledMsg";
  }
  protected:
  explicit CSetInputTemporarilyDisabledMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisabledFieldNumber = 1,
  };
  // optional bool disabled = 1;
  bool has_disabled() const;
  private:
  bool _internal_has_disabled() const;
  public:
  void clear_disabled();
  bool disabled() const;
  void set_disabled(bool value);
  private:
  bool _internal_disabled() const;
  void _internal_set_disabled(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CSetInputTemporarilyDisabledMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  bool disabled_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetQualityOverrideMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetQualityOverrideMsg) */ {
 public:
  inline CSetQualityOverrideMsg() : CSetQualityOverrideMsg(nullptr) {}
  ~CSetQualityOverrideMsg() override;
  explicit constexpr CSetQualityOverrideMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetQualityOverrideMsg(const CSetQualityOverrideMsg& from);
  CSetQualityOverrideMsg(CSetQualityOverrideMsg&& from) noexcept
    : CSetQualityOverrideMsg() {
    *this = ::std::move(from);
  }

  inline CSetQualityOverrideMsg& operator=(const CSetQualityOverrideMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetQualityOverrideMsg& operator=(CSetQualityOverrideMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetQualityOverrideMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetQualityOverrideMsg* internal_default_instance() {
    return reinterpret_cast<const CSetQualityOverrideMsg*>(
               &_CSetQualityOverrideMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    89;

  friend void swap(CSetQualityOverrideMsg& a, CSetQualityOverrideMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetQualityOverrideMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetQualityOverrideMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetQualityOverrideMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetQualityOverrideMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetQualityOverrideMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetQualityOverrideMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetQualityOverrideMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetQualityOverrideMsg";
  }
  protected:
  explicit CSetQualityOverrideMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional int32 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetQualityOverrideMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t value_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CSetBitrateOverrideMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CSetBitrateOverrideMsg) */ {
 public:
  inline CSetBitrateOverrideMsg() : CSetBitrateOverrideMsg(nullptr) {}
  ~CSetBitrateOverrideMsg() override;
  explicit constexpr CSetBitrateOverrideMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSetBitrateOverrideMsg(const CSetBitrateOverrideMsg& from);
  CSetBitrateOverrideMsg(CSetBitrateOverrideMsg&& from) noexcept
    : CSetBitrateOverrideMsg() {
    *this = ::std::move(from);
  }

  inline CSetBitrateOverrideMsg& operator=(const CSetBitrateOverrideMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSetBitrateOverrideMsg& operator=(CSetBitrateOverrideMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CSetBitrateOverrideMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSetBitrateOverrideMsg* internal_default_instance() {
    return reinterpret_cast<const CSetBitrateOverrideMsg*>(
               &_CSetBitrateOverrideMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    90;

  friend void swap(CSetBitrateOverrideMsg& a, CSetBitrateOverrideMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CSetBitrateOverrideMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSetBitrateOverrideMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSetBitrateOverrideMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSetBitrateOverrideMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CSetBitrateOverrideMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CSetBitrateOverrideMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CSetBitrateOverrideMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CSetBitrateOverrideMsg";
  }
  protected:
  explicit CSetBitrateOverrideMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // optional int32 value = 1;
  bool has_value() const;
  private:
  bool _internal_has_value() const;
  public:
  void clear_value();
  int32_t value() const;
  void set_value(int32_t value);
  private:
  int32_t _internal_value() const;
  void _internal_set_value(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CSetBitrateOverrideMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int32_t value_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CShowOnScreenKeyboardMsg final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:CShowOnScreenKeyboardMsg) */ {
 public:
  inline CShowOnScreenKeyboardMsg() : CShowOnScreenKeyboardMsg(nullptr) {}
  explicit constexpr CShowOnScreenKeyboardMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CShowOnScreenKeyboardMsg(const CShowOnScreenKeyboardMsg& from);
  CShowOnScreenKeyboardMsg(CShowOnScreenKeyboardMsg&& from) noexcept
    : CShowOnScreenKeyboardMsg() {
    *this = ::std::move(from);
  }

  inline CShowOnScreenKeyboardMsg& operator=(const CShowOnScreenKeyboardMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CShowOnScreenKeyboardMsg& operator=(CShowOnScreenKeyboardMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CShowOnScreenKeyboardMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CShowOnScreenKeyboardMsg* internal_default_instance() {
    return reinterpret_cast<const CShowOnScreenKeyboardMsg*>(
               &_CShowOnScreenKeyboardMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    91;

  friend void swap(CShowOnScreenKeyboardMsg& a, CShowOnScreenKeyboardMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CShowOnScreenKeyboardMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CShowOnScreenKeyboardMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CShowOnScreenKeyboardMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CShowOnScreenKeyboardMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const CShowOnScreenKeyboardMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const CShowOnScreenKeyboardMsg& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CShowOnScreenKeyboardMsg";
  }
  protected:
  explicit CShowOnScreenKeyboardMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:CShowOnScreenKeyboardMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerPersonalizationUpdateMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerPersonalizationUpdateMsg) */ {
 public:
  inline CControllerPersonalizationUpdateMsg() : CControllerPersonalizationUpdateMsg(nullptr) {}
  ~CControllerPersonalizationUpdateMsg() override;
  explicit constexpr CControllerPersonalizationUpdateMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerPersonalizationUpdateMsg(const CControllerPersonalizationUpdateMsg& from);
  CControllerPersonalizationUpdateMsg(CControllerPersonalizationUpdateMsg&& from) noexcept
    : CControllerPersonalizationUpdateMsg() {
    *this = ::std::move(from);
  }

  inline CControllerPersonalizationUpdateMsg& operator=(const CControllerPersonalizationUpdateMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerPersonalizationUpdateMsg& operator=(CControllerPersonalizationUpdateMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerPersonalizationUpdateMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerPersonalizationUpdateMsg* internal_default_instance() {
    return reinterpret_cast<const CControllerPersonalizationUpdateMsg*>(
               &_CControllerPersonalizationUpdateMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    92;

  friend void swap(CControllerPersonalizationUpdateMsg& a, CControllerPersonalizationUpdateMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerPersonalizationUpdateMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerPersonalizationUpdateMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerPersonalizationUpdateMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerPersonalizationUpdateMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerPersonalizationUpdateMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerPersonalizationUpdateMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerPersonalizationUpdateMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerPersonalizationUpdateMsg";
  }
  protected:
  explicit CControllerPersonalizationUpdateMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kControllerPathFieldNumber = 1,
    kControllerNameFieldNumber = 2,
    kReverseDiamondButtonLayoutFieldNumber = 3,
  };
  // optional string controller_path = 1;
  bool has_controller_path() const;
  private:
  bool _internal_has_controller_path() const;
  public:
  void clear_controller_path();
  const std::string& controller_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_path();
  PROTOBUF_NODISCARD std::string* release_controller_path();
  void set_allocated_controller_path(std::string* controller_path);
  private:
  const std::string& _internal_controller_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_path(const std::string& value);
  std::string* _internal_mutable_controller_path();
  public:

  // optional string controller_name = 2;
  bool has_controller_name() const;
  private:
  bool _internal_has_controller_name() const;
  public:
  void clear_controller_name();
  const std::string& controller_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controller_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controller_name();
  PROTOBUF_NODISCARD std::string* release_controller_name();
  void set_allocated_controller_name(std::string* controller_name);
  private:
  const std::string& _internal_controller_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controller_name(const std::string& value);
  std::string* _internal_mutable_controller_name();
  public:

  // optional bool reverse_diamond_button_layout = 3;
  bool has_reverse_diamond_button_layout() const;
  private:
  bool _internal_has_reverse_diamond_button_layout() const;
  public:
  void clear_reverse_diamond_button_layout();
  bool reverse_diamond_button_layout() const;
  void set_reverse_diamond_button_layout(bool value);
  private:
  bool _internal_reverse_diamond_button_layout() const;
  void _internal_set_reverse_diamond_button_layout(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CControllerPersonalizationUpdateMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controller_name_;
  bool reverse_diamond_button_layout_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamDataLostMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamDataLostMsg) */ {
 public:
  inline CStreamDataLostMsg() : CStreamDataLostMsg(nullptr) {}
  ~CStreamDataLostMsg() override;
  explicit constexpr CStreamDataLostMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamDataLostMsg(const CStreamDataLostMsg& from);
  CStreamDataLostMsg(CStreamDataLostMsg&& from) noexcept
    : CStreamDataLostMsg() {
    *this = ::std::move(from);
  }

  inline CStreamDataLostMsg& operator=(const CStreamDataLostMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamDataLostMsg& operator=(CStreamDataLostMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamDataLostMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamDataLostMsg* internal_default_instance() {
    return reinterpret_cast<const CStreamDataLostMsg*>(
               &_CStreamDataLostMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    93;

  friend void swap(CStreamDataLostMsg& a, CStreamDataLostMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamDataLostMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamDataLostMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamDataLostMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamDataLostMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamDataLostMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamDataLostMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamDataLostMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamDataLostMsg";
  }
  protected:
  explicit CStreamDataLostMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPacketsFieldNumber = 1,
  };
  // repeated uint32 packets = 1;
  int packets_size() const;
  private:
  int _internal_packets_size() const;
  public:
  void clear_packets();
  private:
  uint32_t _internal_packets(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      _internal_packets() const;
  void _internal_add_packets(uint32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      _internal_mutable_packets();
  public:
  uint32_t packets(int index) const;
  void set_packets(int index, uint32_t value);
  void add_packets(uint32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
      packets() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
      mutable_packets();

  // @@protoc_insertion_point(class_scope:CStreamDataLostMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t > packets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CAudioFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CAudioFormat) */ {
 public:
  inline CAudioFormat() : CAudioFormat(nullptr) {}
  ~CAudioFormat() override;
  explicit constexpr CAudioFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CAudioFormat(const CAudioFormat& from);
  CAudioFormat(CAudioFormat&& from) noexcept
    : CAudioFormat() {
    *this = ::std::move(from);
  }

  inline CAudioFormat& operator=(const CAudioFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CAudioFormat& operator=(CAudioFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CAudioFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CAudioFormat* internal_default_instance() {
    return reinterpret_cast<const CAudioFormat*>(
               &_CAudioFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    94;

  friend void swap(CAudioFormat& a, CAudioFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(CAudioFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CAudioFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CAudioFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CAudioFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CAudioFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CAudioFormat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CAudioFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CAudioFormat";
  }
  protected:
  explicit CAudioFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kFrequencyFieldNumber = 2,
    kChannelsFieldNumber = 3,
  };
  // required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::EAudioFormat format() const;
  void set_format(::EAudioFormat value);
  private:
  ::EAudioFormat _internal_format() const;
  void _internal_set_format(::EAudioFormat value);
  public:

  // optional uint32 frequency = 2;
  bool has_frequency() const;
  private:
  bool _internal_has_frequency() const;
  public:
  void clear_frequency();
  uint32_t frequency() const;
  void set_frequency(uint32_t value);
  private:
  uint32_t _internal_frequency() const;
  void _internal_set_frequency(uint32_t value);
  public:

  // optional uint32 channels = 3;
  bool has_channels() const;
  private:
  bool _internal_has_channels() const;
  public:
  void clear_channels();
  uint32_t channels() const;
  void set_channels(uint32_t value);
  private:
  uint32_t _internal_channels() const;
  void _internal_set_channels(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CAudioFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int format_;
  uint32_t frequency_;
  uint32_t channels_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CVideoFormat final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CVideoFormat) */ {
 public:
  inline CVideoFormat() : CVideoFormat(nullptr) {}
  ~CVideoFormat() override;
  explicit constexpr CVideoFormat(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CVideoFormat(const CVideoFormat& from);
  CVideoFormat(CVideoFormat&& from) noexcept
    : CVideoFormat() {
    *this = ::std::move(from);
  }

  inline CVideoFormat& operator=(const CVideoFormat& from) {
    CopyFrom(from);
    return *this;
  }
  inline CVideoFormat& operator=(CVideoFormat&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CVideoFormat& default_instance() {
    return *internal_default_instance();
  }
  static inline const CVideoFormat* internal_default_instance() {
    return reinterpret_cast<const CVideoFormat*>(
               &_CVideoFormat_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    95;

  friend void swap(CVideoFormat& a, CVideoFormat& b) {
    a.Swap(&b);
  }
  inline void Swap(CVideoFormat* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CVideoFormat* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CVideoFormat* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CVideoFormat>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CVideoFormat& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CVideoFormat& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CVideoFormat* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CVideoFormat";
  }
  protected:
  explicit CVideoFormat(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kWidthFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::EVideoFormat format() const;
  void set_format(::EVideoFormat value);
  private:
  ::EVideoFormat _internal_format() const;
  void _internal_set_format(::EVideoFormat value);
  public:

  // optional uint32 width = 2;
  bool has_width() const;
  private:
  bool _internal_has_width() const;
  public:
  void clear_width();
  uint32_t width() const;
  void set_width(uint32_t value);
  private:
  uint32_t _internal_width() const;
  void _internal_set_width(uint32_t value);
  public:

  // optional uint32 height = 3;
  bool has_height() const;
  private:
  bool _internal_has_height() const;
  public:
  void clear_height();
  uint32_t height() const;
  void set_height(uint32_t value);
  private:
  uint32_t _internal_height() const;
  void _internal_set_height(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CVideoFormat)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int format_;
  uint32_t width_;
  uint32_t height_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CFrameEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CFrameEvent) */ {
 public:
  inline CFrameEvent() : CFrameEvent(nullptr) {}
  ~CFrameEvent() override;
  explicit constexpr CFrameEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CFrameEvent(const CFrameEvent& from);
  CFrameEvent(CFrameEvent&& from) noexcept
    : CFrameEvent() {
    *this = ::std::move(from);
  }

  inline CFrameEvent& operator=(const CFrameEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline CFrameEvent& operator=(CFrameEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CFrameEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const CFrameEvent* internal_default_instance() {
    return reinterpret_cast<const CFrameEvent*>(
               &_CFrameEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    96;

  friend void swap(CFrameEvent& a, CFrameEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(CFrameEvent* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CFrameEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CFrameEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CFrameEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CFrameEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CFrameEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameEvent* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CFrameEvent";
  }
  protected:
  explicit CFrameEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventIdFieldNumber = 1,
    kTimestampFieldNumber = 2,
  };
  // required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
  bool has_event_id() const;
  private:
  bool _internal_has_event_id() const;
  public:
  void clear_event_id();
  ::EStreamFrameEvent event_id() const;
  void set_event_id(::EStreamFrameEvent value);
  private:
  ::EStreamFrameEvent _internal_event_id() const;
  void _internal_set_event_id(::EStreamFrameEvent value);
  public:

  // required uint32 timestamp = 2;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  uint32_t timestamp() const;
  void set_timestamp(uint32_t value);
  private:
  uint32_t _internal_timestamp() const;
  void _internal_set_timestamp(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CFrameEvent)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int event_id_;
  uint32_t timestamp_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CFrameStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CFrameStats) */ {
 public:
  inline CFrameStats() : CFrameStats(nullptr) {}
  ~CFrameStats() override;
  explicit constexpr CFrameStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CFrameStats(const CFrameStats& from);
  CFrameStats(CFrameStats&& from) noexcept
    : CFrameStats() {
    *this = ::std::move(from);
  }

  inline CFrameStats& operator=(const CFrameStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CFrameStats& operator=(CFrameStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CFrameStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CFrameStats* internal_default_instance() {
    return reinterpret_cast<const CFrameStats*>(
               &_CFrameStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    97;

  friend void swap(CFrameStats& a, CFrameStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CFrameStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CFrameStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CFrameStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CFrameStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CFrameStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CFrameStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CFrameStats";
  }
  protected:
  explicit CFrameStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kFrameIdFieldNumber = 1,
    kInputMarkFieldNumber = 2,
    kResultFieldNumber = 4,
    kFrameStartDeltaFieldNumber = 5,
    kFrameDisplayDeltaFieldNumber = 6,
    kPingTimeFieldNumber = 7,
    kServerBitrateFieldNumber = 8,
    kClientBitrateFieldNumber = 9,
    kLinkBandwidthFieldNumber = 10,
    kPacketLossFieldNumber = 11,
    kFrameSizeFieldNumber = 12,
  };
  // repeated .CFrameEvent events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::CFrameEvent* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameEvent >*
      mutable_events();
  private:
  const ::CFrameEvent& _internal_events(int index) const;
  ::CFrameEvent* _internal_add_events();
  public:
  const ::CFrameEvent& events(int index) const;
  ::CFrameEvent* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameEvent >&
      events() const;

  // required uint32 frame_id = 1;
  bool has_frame_id() const;
  private:
  bool _internal_has_frame_id() const;
  public:
  void clear_frame_id();
  uint32_t frame_id() const;
  void set_frame_id(uint32_t value);
  private:
  uint32_t _internal_frame_id() const;
  void _internal_set_frame_id(uint32_t value);
  public:

  // optional uint32 input_mark = 2;
  bool has_input_mark() const;
  private:
  bool _internal_has_input_mark() const;
  public:
  void clear_input_mark();
  uint32_t input_mark() const;
  void set_input_mark(uint32_t value);
  private:
  uint32_t _internal_input_mark() const;
  void _internal_set_input_mark(uint32_t value);
  public:

  // required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
  bool has_result() const;
  private:
  bool _internal_has_result() const;
  public:
  void clear_result();
  ::EStreamFrameResult result() const;
  void set_result(::EStreamFrameResult value);
  private:
  ::EStreamFrameResult _internal_result() const;
  void _internal_set_result(::EStreamFrameResult value);
  public:

  // optional float frame_start_delta = 5;
  bool has_frame_start_delta() const;
  private:
  bool _internal_has_frame_start_delta() const;
  public:
  void clear_frame_start_delta();
  float frame_start_delta() const;
  void set_frame_start_delta(float value);
  private:
  float _internal_frame_start_delta() const;
  void _internal_set_frame_start_delta(float value);
  public:

  // optional float frame_display_delta = 6;
  bool has_frame_display_delta() const;
  private:
  bool _internal_has_frame_display_delta() const;
  public:
  void clear_frame_display_delta();
  float frame_display_delta() const;
  void set_frame_display_delta(float value);
  private:
  float _internal_frame_display_delta() const;
  void _internal_set_frame_display_delta(float value);
  public:

  // optional float ping_time = 7;
  bool has_ping_time() const;
  private:
  bool _internal_has_ping_time() const;
  public:
  void clear_ping_time();
  float ping_time() const;
  void set_ping_time(float value);
  private:
  float _internal_ping_time() const;
  void _internal_set_ping_time(float value);
  public:

  // optional float server_bitrate = 8;
  bool has_server_bitrate() const;
  private:
  bool _internal_has_server_bitrate() const;
  public:
  void clear_server_bitrate();
  float server_bitrate() const;
  void set_server_bitrate(float value);
  private:
  float _internal_server_bitrate() const;
  void _internal_set_server_bitrate(float value);
  public:

  // optional float client_bitrate = 9;
  bool has_client_bitrate() const;
  private:
  bool _internal_has_client_bitrate() const;
  public:
  void clear_client_bitrate();
  float client_bitrate() const;
  void set_client_bitrate(float value);
  private:
  float _internal_client_bitrate() const;
  void _internal_set_client_bitrate(float value);
  public:

  // optional float link_bandwidth = 10;
  bool has_link_bandwidth() const;
  private:
  bool _internal_has_link_bandwidth() const;
  public:
  void clear_link_bandwidth();
  float link_bandwidth() const;
  void set_link_bandwidth(float value);
  private:
  float _internal_link_bandwidth() const;
  void _internal_set_link_bandwidth(float value);
  public:

  // optional float packet_loss = 11;
  bool has_packet_loss() const;
  private:
  bool _internal_has_packet_loss() const;
  public:
  void clear_packet_loss();
  float packet_loss() const;
  void set_packet_loss(float value);
  private:
  float _internal_packet_loss() const;
  void _internal_set_packet_loss(float value);
  public:

  // optional uint32 frame_size = 12;
  bool has_frame_size() const;
  private:
  bool _internal_has_frame_size() const;
  public:
  void clear_frame_size();
  uint32_t frame_size() const;
  void set_frame_size(uint32_t value);
  private:
  uint32_t _internal_frame_size() const;
  void _internal_set_frame_size(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CFrameStats)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameEvent > events_;
  uint32_t frame_id_;
  uint32_t input_mark_;
  int result_;
  float frame_start_delta_;
  float frame_display_delta_;
  float ping_time_;
  float server_bitrate_;
  float client_bitrate_;
  float link_bandwidth_;
  float packet_loss_;
  uint32_t frame_size_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CFrameStatAccumulatedValue final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CFrameStatAccumulatedValue) */ {
 public:
  inline CFrameStatAccumulatedValue() : CFrameStatAccumulatedValue(nullptr) {}
  ~CFrameStatAccumulatedValue() override;
  explicit constexpr CFrameStatAccumulatedValue(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CFrameStatAccumulatedValue(const CFrameStatAccumulatedValue& from);
  CFrameStatAccumulatedValue(CFrameStatAccumulatedValue&& from) noexcept
    : CFrameStatAccumulatedValue() {
    *this = ::std::move(from);
  }

  inline CFrameStatAccumulatedValue& operator=(const CFrameStatAccumulatedValue& from) {
    CopyFrom(from);
    return *this;
  }
  inline CFrameStatAccumulatedValue& operator=(CFrameStatAccumulatedValue&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CFrameStatAccumulatedValue& default_instance() {
    return *internal_default_instance();
  }
  static inline const CFrameStatAccumulatedValue* internal_default_instance() {
    return reinterpret_cast<const CFrameStatAccumulatedValue*>(
               &_CFrameStatAccumulatedValue_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    98;

  friend void swap(CFrameStatAccumulatedValue& a, CFrameStatAccumulatedValue& b) {
    a.Swap(&b);
  }
  inline void Swap(CFrameStatAccumulatedValue* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CFrameStatAccumulatedValue* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CFrameStatAccumulatedValue* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CFrameStatAccumulatedValue>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CFrameStatAccumulatedValue& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CFrameStatAccumulatedValue& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStatAccumulatedValue* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CFrameStatAccumulatedValue";
  }
  protected:
  explicit CFrameStatAccumulatedValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatTypeFieldNumber = 1,
    kCountFieldNumber = 2,
    kAverageFieldNumber = 3,
    kStddevFieldNumber = 4,
  };
  // required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
  bool has_stat_type() const;
  private:
  bool _internal_has_stat_type() const;
  public:
  void clear_stat_type();
  ::EFrameAccumulatedStat stat_type() const;
  void set_stat_type(::EFrameAccumulatedStat value);
  private:
  ::EFrameAccumulatedStat _internal_stat_type() const;
  void _internal_set_stat_type(::EFrameAccumulatedStat value);
  public:

  // required int32 count = 2;
  bool has_count() const;
  private:
  bool _internal_has_count() const;
  public:
  void clear_count();
  int32_t count() const;
  void set_count(int32_t value);
  private:
  int32_t _internal_count() const;
  void _internal_set_count(int32_t value);
  public:

  // required float average = 3;
  bool has_average() const;
  private:
  bool _internal_has_average() const;
  public:
  void clear_average();
  float average() const;
  void set_average(float value);
  private:
  float _internal_average() const;
  void _internal_set_average(float value);
  public:

  // optional float stddev = 4;
  bool has_stddev() const;
  private:
  bool _internal_has_stddev() const;
  public:
  void clear_stddev();
  float stddev() const;
  void set_stddev(float value);
  private:
  float _internal_stddev() const;
  void _internal_set_stddev(float value);
  public:

  // @@protoc_insertion_point(class_scope:CFrameStatAccumulatedValue)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int stat_type_;
  int32_t count_;
  float average_;
  float stddev_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CFrameStatsListMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CFrameStatsListMsg) */ {
 public:
  inline CFrameStatsListMsg() : CFrameStatsListMsg(nullptr) {}
  ~CFrameStatsListMsg() override;
  explicit constexpr CFrameStatsListMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CFrameStatsListMsg(const CFrameStatsListMsg& from);
  CFrameStatsListMsg(CFrameStatsListMsg&& from) noexcept
    : CFrameStatsListMsg() {
    *this = ::std::move(from);
  }

  inline CFrameStatsListMsg& operator=(const CFrameStatsListMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CFrameStatsListMsg& operator=(CFrameStatsListMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CFrameStatsListMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CFrameStatsListMsg* internal_default_instance() {
    return reinterpret_cast<const CFrameStatsListMsg*>(
               &_CFrameStatsListMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    99;

  friend void swap(CFrameStatsListMsg& a, CFrameStatsListMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CFrameStatsListMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CFrameStatsListMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CFrameStatsListMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CFrameStatsListMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CFrameStatsListMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CFrameStatsListMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CFrameStatsListMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CFrameStatsListMsg";
  }
  protected:
  explicit CFrameStatsListMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStatsFieldNumber = 2,
    kAccumulatedStatsFieldNumber = 3,
    kDataTypeFieldNumber = 1,
    kLatestFrameIdFieldNumber = 4,
  };
  // repeated .CFrameStats stats = 2;
  int stats_size() const;
  private:
  int _internal_stats_size() const;
  public:
  void clear_stats();
  ::CFrameStats* mutable_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStats >*
      mutable_stats();
  private:
  const ::CFrameStats& _internal_stats(int index) const;
  ::CFrameStats* _internal_add_stats();
  public:
  const ::CFrameStats& stats(int index) const;
  ::CFrameStats* add_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStats >&
      stats() const;

  // repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
  int accumulated_stats_size() const;
  private:
  int _internal_accumulated_stats_size() const;
  public:
  void clear_accumulated_stats();
  ::CFrameStatAccumulatedValue* mutable_accumulated_stats(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStatAccumulatedValue >*
      mutable_accumulated_stats();
  private:
  const ::CFrameStatAccumulatedValue& _internal_accumulated_stats(int index) const;
  ::CFrameStatAccumulatedValue* _internal_add_accumulated_stats();
  public:
  const ::CFrameStatAccumulatedValue& accumulated_stats(int index) const;
  ::CFrameStatAccumulatedValue* add_accumulated_stats();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStatAccumulatedValue >&
      accumulated_stats() const;

  // required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
  bool has_data_type() const;
  private:
  bool _internal_has_data_type() const;
  public:
  void clear_data_type();
  ::EStreamingDataType data_type() const;
  void set_data_type(::EStreamingDataType value);
  private:
  ::EStreamingDataType _internal_data_type() const;
  void _internal_set_data_type(::EStreamingDataType value);
  public:

  // required int32 latest_frame_id = 4;
  bool has_latest_frame_id() const;
  private:
  bool _internal_has_latest_frame_id() const;
  public:
  void clear_latest_frame_id();
  int32_t latest_frame_id() const;
  void set_latest_frame_id(int32_t value);
  private:
  int32_t _internal_latest_frame_id() const;
  void _internal_set_latest_frame_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CFrameStatsListMsg)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStats > stats_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStatAccumulatedValue > accumulated_stats_;
  int data_type_;
  int32_t latest_frame_id_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CStreamingSessionStats final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CStreamingSessionStats) */ {
 public:
  inline CStreamingSessionStats() : CStreamingSessionStats(nullptr) {}
  ~CStreamingSessionStats() override;
  explicit constexpr CStreamingSessionStats(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CStreamingSessionStats(const CStreamingSessionStats& from);
  CStreamingSessionStats(CStreamingSessionStats&& from) noexcept
    : CStreamingSessionStats() {
    *this = ::std::move(from);
  }

  inline CStreamingSessionStats& operator=(const CStreamingSessionStats& from) {
    CopyFrom(from);
    return *this;
  }
  inline CStreamingSessionStats& operator=(CStreamingSessionStats&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CStreamingSessionStats& default_instance() {
    return *internal_default_instance();
  }
  static inline const CStreamingSessionStats* internal_default_instance() {
    return reinterpret_cast<const CStreamingSessionStats*>(
               &_CStreamingSessionStats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    100;

  friend void swap(CStreamingSessionStats& a, CStreamingSessionStats& b) {
    a.Swap(&b);
  }
  inline void Swap(CStreamingSessionStats* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CStreamingSessionStats* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CStreamingSessionStats* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CStreamingSessionStats>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CStreamingSessionStats& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CStreamingSessionStats& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CStreamingSessionStats* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CStreamingSessionStats";
  }
  protected:
  explicit CStreamingSessionStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFrameLossPercentageFieldNumber = 1,
    kAverageNetworkTimeMsFieldNumber = 2,
    kStddevNetworkTimeMsFieldNumber = 3,
  };
  // optional float frame_loss_percentage = 1;
  bool has_frame_loss_percentage() const;
  private:
  bool _internal_has_frame_loss_percentage() const;
  public:
  void clear_frame_loss_percentage();
  float frame_loss_percentage() const;
  void set_frame_loss_percentage(float value);
  private:
  float _internal_frame_loss_percentage() const;
  void _internal_set_frame_loss_percentage(float value);
  public:

  // optional float average_network_time_ms = 2;
  bool has_average_network_time_ms() const;
  private:
  bool _internal_has_average_network_time_ms() const;
  public:
  void clear_average_network_time_ms();
  float average_network_time_ms() const;
  void set_average_network_time_ms(float value);
  private:
  float _internal_average_network_time_ms() const;
  void _internal_set_average_network_time_ms(float value);
  public:

  // optional float stddev_network_time_ms = 3;
  bool has_stddev_network_time_ms() const;
  private:
  bool _internal_has_stddev_network_time_ms() const;
  public:
  void clear_stddev_network_time_ms();
  float stddev_network_time_ms() const;
  void set_stddev_network_time_ms(float value);
  private:
  float _internal_stddev_network_time_ms() const;
  void _internal_set_stddev_network_time_ms(float value);
  public:

  // @@protoc_insertion_point(class_scope:CStreamingSessionStats)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  float frame_loss_percentage_;
  float average_network_time_ms_;
  float stddev_network_time_ms_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CDebugDumpMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CDebugDumpMsg) */ {
 public:
  inline CDebugDumpMsg() : CDebugDumpMsg(nullptr) {}
  ~CDebugDumpMsg() override;
  explicit constexpr CDebugDumpMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CDebugDumpMsg(const CDebugDumpMsg& from);
  CDebugDumpMsg(CDebugDumpMsg&& from) noexcept
    : CDebugDumpMsg() {
    *this = ::std::move(from);
  }

  inline CDebugDumpMsg& operator=(const CDebugDumpMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CDebugDumpMsg& operator=(CDebugDumpMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CDebugDumpMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CDebugDumpMsg* internal_default_instance() {
    return reinterpret_cast<const CDebugDumpMsg*>(
               &_CDebugDumpMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    101;

  friend void swap(CDebugDumpMsg& a, CDebugDumpMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CDebugDumpMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CDebugDumpMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CDebugDumpMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CDebugDumpMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CDebugDumpMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CDebugDumpMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CDebugDumpMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CDebugDumpMsg";
  }
  protected:
  explicit CDebugDumpMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScreenshotFieldNumber = 1,
  };
  // optional bytes screenshot = 1;
  bool has_screenshot() const;
  private:
  bool _internal_has_screenshot() const;
  public:
  void clear_screenshot();
  const std::string& screenshot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_screenshot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_screenshot();
  PROTOBUF_NODISCARD std::string* release_screenshot();
  void set_allocated_screenshot(std::string* screenshot);
  private:
  const std::string& _internal_screenshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_screenshot(const std::string& value);
  std::string* _internal_mutable_screenshot();
  public:

  // @@protoc_insertion_point(class_scope:CDebugDumpMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr screenshot_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CLogMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CLogMsg) */ {
 public:
  inline CLogMsg() : CLogMsg(nullptr) {}
  ~CLogMsg() override;
  explicit constexpr CLogMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLogMsg(const CLogMsg& from);
  CLogMsg(CLogMsg&& from) noexcept
    : CLogMsg() {
    *this = ::std::move(from);
  }

  inline CLogMsg& operator=(const CLogMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLogMsg& operator=(CLogMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLogMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLogMsg* internal_default_instance() {
    return reinterpret_cast<const CLogMsg*>(
               &_CLogMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    102;

  friend void swap(CLogMsg& a, CLogMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CLogMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLogMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CLogMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CLogMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLogMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CLogMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLogMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CLogMsg";
  }
  protected:
  explicit CLogMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // optional string message = 2;
  bool has_message() const;
  private:
  bool _internal_has_message() const;
  public:
  void clear_message();
  const std::string& message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_message();
  PROTOBUF_NODISCARD std::string* release_message();
  void set_allocated_message(std::string* message);
  private:
  const std::string& _internal_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_message(const std::string& value);
  std::string* _internal_mutable_message();
  public:

  // optional int32 type = 1;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  int32_t type() const;
  void set_type(int32_t value);
  private:
  int32_t _internal_type() const;
  void _internal_set_type(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CLogMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  int32_t type_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CLogUploadMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CLogUploadMsg) */ {
 public:
  inline CLogUploadMsg() : CLogUploadMsg(nullptr) {}
  ~CLogUploadMsg() override;
  explicit constexpr CLogUploadMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CLogUploadMsg(const CLogUploadMsg& from);
  CLogUploadMsg(CLogUploadMsg&& from) noexcept
    : CLogUploadMsg() {
    *this = ::std::move(from);
  }

  inline CLogUploadMsg& operator=(const CLogUploadMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CLogUploadMsg& operator=(CLogUploadMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CLogUploadMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CLogUploadMsg* internal_default_instance() {
    return reinterpret_cast<const CLogUploadMsg*>(
               &_CLogUploadMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    103;

  friend void swap(CLogUploadMsg& a, CLogUploadMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CLogUploadMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CLogUploadMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CLogUploadMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CLogUploadMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CLogUploadMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CLogUploadMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CLogUploadMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CLogUploadMsg";
  }
  protected:
  explicit CLogUploadMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDataFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // optional bytes data = 3;
  bool has_data() const;
  private:
  bool _internal_has_data() const;
  public:
  void clear_data();
  const std::string& data() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_data(ArgT0&& arg0, ArgT... args);
  std::string* mutable_data();
  PROTOBUF_NODISCARD std::string* release_data();
  void set_allocated_data(std::string* data);
  private:
  const std::string& _internal_data() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_data(const std::string& value);
  std::string* _internal_mutable_data();
  public:

  // optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::ELogFileType type() const;
  void set_type(::ELogFileType value);
  private:
  ::ELogFileType _internal_type() const;
  void _internal_set_type(::ELogFileType value);
  public:

  // @@protoc_insertion_point(class_scope:CLogUploadMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr data_;
  int type_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTransportSignalMsg_WebRTCMessage_Candidate final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTransportSignalMsg.WebRTCMessage.Candidate) */ {
 public:
  inline CTransportSignalMsg_WebRTCMessage_Candidate() : CTransportSignalMsg_WebRTCMessage_Candidate(nullptr) {}
  ~CTransportSignalMsg_WebRTCMessage_Candidate() override;
  explicit constexpr CTransportSignalMsg_WebRTCMessage_Candidate(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTransportSignalMsg_WebRTCMessage_Candidate(const CTransportSignalMsg_WebRTCMessage_Candidate& from);
  CTransportSignalMsg_WebRTCMessage_Candidate(CTransportSignalMsg_WebRTCMessage_Candidate&& from) noexcept
    : CTransportSignalMsg_WebRTCMessage_Candidate() {
    *this = ::std::move(from);
  }

  inline CTransportSignalMsg_WebRTCMessage_Candidate& operator=(const CTransportSignalMsg_WebRTCMessage_Candidate& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTransportSignalMsg_WebRTCMessage_Candidate& operator=(CTransportSignalMsg_WebRTCMessage_Candidate&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTransportSignalMsg_WebRTCMessage_Candidate& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTransportSignalMsg_WebRTCMessage_Candidate* internal_default_instance() {
    return reinterpret_cast<const CTransportSignalMsg_WebRTCMessage_Candidate*>(
               &_CTransportSignalMsg_WebRTCMessage_Candidate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    104;

  friend void swap(CTransportSignalMsg_WebRTCMessage_Candidate& a, CTransportSignalMsg_WebRTCMessage_Candidate& b) {
    a.Swap(&b);
  }
  inline void Swap(CTransportSignalMsg_WebRTCMessage_Candidate* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTransportSignalMsg_WebRTCMessage_Candidate* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTransportSignalMsg_WebRTCMessage_Candidate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTransportSignalMsg_WebRTCMessage_Candidate>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTransportSignalMsg_WebRTCMessage_Candidate& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTransportSignalMsg_WebRTCMessage_Candidate& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTransportSignalMsg_WebRTCMessage_Candidate* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTransportSignalMsg.WebRTCMessage.Candidate";
  }
  protected:
  explicit CTransportSignalMsg_WebRTCMessage_Candidate(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSdpMidFieldNumber = 1,
    kCandidateFieldNumber = 3,
    kSdpMlineIndexFieldNumber = 2,
  };
  // optional string sdp_mid = 1;
  bool has_sdp_mid() const;
  private:
  bool _internal_has_sdp_mid() const;
  public:
  void clear_sdp_mid();
  const std::string& sdp_mid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sdp_mid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sdp_mid();
  PROTOBUF_NODISCARD std::string* release_sdp_mid();
  void set_allocated_sdp_mid(std::string* sdp_mid);
  private:
  const std::string& _internal_sdp_mid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sdp_mid(const std::string& value);
  std::string* _internal_mutable_sdp_mid();
  public:

  // optional string candidate = 3;
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const std::string& candidate() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_candidate(ArgT0&& arg0, ArgT... args);
  std::string* mutable_candidate();
  PROTOBUF_NODISCARD std::string* release_candidate();
  void set_allocated_candidate(std::string* candidate);
  private:
  const std::string& _internal_candidate() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_candidate(const std::string& value);
  std::string* _internal_mutable_candidate();
  public:

  // optional int32 sdp_mline_index = 2;
  bool has_sdp_mline_index() const;
  private:
  bool _internal_has_sdp_mline_index() const;
  public:
  void clear_sdp_mline_index();
  int32_t sdp_mline_index() const;
  void set_sdp_mline_index(int32_t value);
  private:
  int32_t _internal_sdp_mline_index() const;
  void _internal_set_sdp_mline_index(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CTransportSignalMsg.WebRTCMessage.Candidate)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sdp_mid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr candidate_;
  int32_t sdp_mline_index_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTransportSignalMsg_WebRTCMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTransportSignalMsg.WebRTCMessage) */ {
 public:
  inline CTransportSignalMsg_WebRTCMessage() : CTransportSignalMsg_WebRTCMessage(nullptr) {}
  ~CTransportSignalMsg_WebRTCMessage() override;
  explicit constexpr CTransportSignalMsg_WebRTCMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTransportSignalMsg_WebRTCMessage(const CTransportSignalMsg_WebRTCMessage& from);
  CTransportSignalMsg_WebRTCMessage(CTransportSignalMsg_WebRTCMessage&& from) noexcept
    : CTransportSignalMsg_WebRTCMessage() {
    *this = ::std::move(from);
  }

  inline CTransportSignalMsg_WebRTCMessage& operator=(const CTransportSignalMsg_WebRTCMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTransportSignalMsg_WebRTCMessage& operator=(CTransportSignalMsg_WebRTCMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTransportSignalMsg_WebRTCMessage& default_instance() {
    return *internal_default_instance();
  }
  enum MsgCase {
    kGreeting = 1,
    kOffer = 2,
    kAnswer = 3,
    kCandidate = 4,
    MSG_NOT_SET = 0,
  };

  static inline const CTransportSignalMsg_WebRTCMessage* internal_default_instance() {
    return reinterpret_cast<const CTransportSignalMsg_WebRTCMessage*>(
               &_CTransportSignalMsg_WebRTCMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    105;

  friend void swap(CTransportSignalMsg_WebRTCMessage& a, CTransportSignalMsg_WebRTCMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(CTransportSignalMsg_WebRTCMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTransportSignalMsg_WebRTCMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTransportSignalMsg_WebRTCMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTransportSignalMsg_WebRTCMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTransportSignalMsg_WebRTCMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTransportSignalMsg_WebRTCMessage& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTransportSignalMsg_WebRTCMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTransportSignalMsg.WebRTCMessage";
  }
  protected:
  explicit CTransportSignalMsg_WebRTCMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CTransportSignalMsg_WebRTCMessage_Candidate Candidate;

  // accessors -------------------------------------------------------

  enum : int {
    kGreetingFieldNumber = 1,
    kOfferFieldNumber = 2,
    kAnswerFieldNumber = 3,
    kCandidateFieldNumber = 4,
  };
  // bool greeting = 1;
  bool has_greeting() const;
  private:
  bool _internal_has_greeting() const;
  public:
  void clear_greeting();
  bool greeting() const;
  void set_greeting(bool value);
  private:
  bool _internal_greeting() const;
  void _internal_set_greeting(bool value);
  public:

  // string offer = 2;
  bool has_offer() const;
  private:
  bool _internal_has_offer() const;
  public:
  void clear_offer();
  const std::string& offer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_offer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_offer();
  PROTOBUF_NODISCARD std::string* release_offer();
  void set_allocated_offer(std::string* offer);
  private:
  const std::string& _internal_offer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_offer(const std::string& value);
  std::string* _internal_mutable_offer();
  public:

  // string answer = 3;
  bool has_answer() const;
  private:
  bool _internal_has_answer() const;
  public:
  void clear_answer();
  const std::string& answer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_answer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_answer();
  PROTOBUF_NODISCARD std::string* release_answer();
  void set_allocated_answer(std::string* answer);
  private:
  const std::string& _internal_answer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_answer(const std::string& value);
  std::string* _internal_mutable_answer();
  public:

  // .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;
  bool has_candidate() const;
  private:
  bool _internal_has_candidate() const;
  public:
  void clear_candidate();
  const ::CTransportSignalMsg_WebRTCMessage_Candidate& candidate() const;
  PROTOBUF_NODISCARD ::CTransportSignalMsg_WebRTCMessage_Candidate* release_candidate();
  ::CTransportSignalMsg_WebRTCMessage_Candidate* mutable_candidate();
  void set_allocated_candidate(::CTransportSignalMsg_WebRTCMessage_Candidate* candidate);
  private:
  const ::CTransportSignalMsg_WebRTCMessage_Candidate& _internal_candidate() const;
  ::CTransportSignalMsg_WebRTCMessage_Candidate* _internal_mutable_candidate();
  public:
  void unsafe_arena_set_allocated_candidate(
      ::CTransportSignalMsg_WebRTCMessage_Candidate* candidate);
  ::CTransportSignalMsg_WebRTCMessage_Candidate* unsafe_arena_release_candidate();

  void clear_msg();
  MsgCase msg_case() const;
  // @@protoc_insertion_point(class_scope:CTransportSignalMsg.WebRTCMessage)
 private:
  class _Internal;
  void set_has_greeting();
  void set_has_offer();
  void set_has_answer();
  void set_has_candidate();

  inline bool has_msg() const;
  inline void clear_has_msg();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MsgUnion {
    constexpr MsgUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    bool greeting_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr offer_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr answer_;
    ::CTransportSignalMsg_WebRTCMessage_Candidate* candidate_;
  } msg_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CTransportSignalMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CTransportSignalMsg) */ {
 public:
  inline CTransportSignalMsg() : CTransportSignalMsg(nullptr) {}
  ~CTransportSignalMsg() override;
  explicit constexpr CTransportSignalMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CTransportSignalMsg(const CTransportSignalMsg& from);
  CTransportSignalMsg(CTransportSignalMsg&& from) noexcept
    : CTransportSignalMsg() {
    *this = ::std::move(from);
  }

  inline CTransportSignalMsg& operator=(const CTransportSignalMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CTransportSignalMsg& operator=(CTransportSignalMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CTransportSignalMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CTransportSignalMsg* internal_default_instance() {
    return reinterpret_cast<const CTransportSignalMsg*>(
               &_CTransportSignalMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    106;

  friend void swap(CTransportSignalMsg& a, CTransportSignalMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CTransportSignalMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CTransportSignalMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CTransportSignalMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CTransportSignalMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CTransportSignalMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CTransportSignalMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CTransportSignalMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CTransportSignalMsg";
  }
  protected:
  explicit CTransportSignalMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CTransportSignalMsg_WebRTCMessage WebRTCMessage;

  // accessors -------------------------------------------------------

  enum : int {
    kSdrFieldNumber = 2,
    kWebrtcFieldNumber = 1,
  };
  // repeated bytes sdr = 2;
  int sdr_size() const;
  private:
  int _internal_sdr_size() const;
  public:
  void clear_sdr();
  const std::string& sdr(int index) const;
  std::string* mutable_sdr(int index);
  void set_sdr(int index, const std::string& value);
  void set_sdr(int index, std::string&& value);
  void set_sdr(int index, const char* value);
  void set_sdr(int index, const void* value, size_t size);
  std::string* add_sdr();
  void add_sdr(const std::string& value);
  void add_sdr(std::string&& value);
  void add_sdr(const char* value);
  void add_sdr(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& sdr() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_sdr();
  private:
  const std::string& _internal_sdr(int index) const;
  std::string* _internal_add_sdr();
  public:

  // optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;
  bool has_webrtc() const;
  private:
  bool _internal_has_webrtc() const;
  public:
  void clear_webrtc();
  const ::CTransportSignalMsg_WebRTCMessage& webrtc() const;
  PROTOBUF_NODISCARD ::CTransportSignalMsg_WebRTCMessage* release_webrtc();
  ::CTransportSignalMsg_WebRTCMessage* mutable_webrtc();
  void set_allocated_webrtc(::CTransportSignalMsg_WebRTCMessage* webrtc);
  private:
  const ::CTransportSignalMsg_WebRTCMessage& _internal_webrtc() const;
  ::CTransportSignalMsg_WebRTCMessage* _internal_mutable_webrtc();
  public:
  void unsafe_arena_set_allocated_webrtc(
      ::CTransportSignalMsg_WebRTCMessage* webrtc);
  ::CTransportSignalMsg_WebRTCMessage* unsafe_arena_release_webrtc();

  // @@protoc_insertion_point(class_scope:CTransportSignalMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> sdr_;
  ::CTransportSignalMsg_WebRTCMessage* webrtc_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerConfigMsg_ControllerConfigResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerConfigMsg.ControllerConfigResponse) */ {
 public:
  inline CControllerConfigMsg_ControllerConfigResponse() : CControllerConfigMsg_ControllerConfigResponse(nullptr) {}
  ~CControllerConfigMsg_ControllerConfigResponse() override;
  explicit constexpr CControllerConfigMsg_ControllerConfigResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerConfigMsg_ControllerConfigResponse(const CControllerConfigMsg_ControllerConfigResponse& from);
  CControllerConfigMsg_ControllerConfigResponse(CControllerConfigMsg_ControllerConfigResponse&& from) noexcept
    : CControllerConfigMsg_ControllerConfigResponse() {
    *this = ::std::move(from);
  }

  inline CControllerConfigMsg_ControllerConfigResponse& operator=(const CControllerConfigMsg_ControllerConfigResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerConfigMsg_ControllerConfigResponse& operator=(CControllerConfigMsg_ControllerConfigResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerConfigMsg_ControllerConfigResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerConfigMsg_ControllerConfigResponse* internal_default_instance() {
    return reinterpret_cast<const CControllerConfigMsg_ControllerConfigResponse*>(
               &_CControllerConfigMsg_ControllerConfigResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    107;

  friend void swap(CControllerConfigMsg_ControllerConfigResponse& a, CControllerConfigMsg_ControllerConfigResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerConfigMsg_ControllerConfigResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerConfigMsg_ControllerConfigResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerConfigMsg_ControllerConfigResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerConfigMsg_ControllerConfigResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerConfigMsg_ControllerConfigResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerConfigMsg_ControllerConfigResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerConfigMsg_ControllerConfigResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerConfigMsg.ControllerConfigResponse";
  }
  protected:
  explicit CControllerConfigMsg_ControllerConfigResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigURLFieldNumber = 2,
    kControllerDataFieldNumber = 4,
    kAppidFieldNumber = 1,
    kControllerTypeFieldNumber = 3,
    kSelectionOrderFieldNumber = 5,
    kActionBlockFieldNumber = 6,
  };
  // optional string configURL = 2;
  bool has_configurl() const;
  private:
  bool _internal_has_configurl() const;
  public:
  void clear_configurl();
  const std::string& configurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configurl();
  PROTOBUF_NODISCARD std::string* release_configurl();
  void set_allocated_configurl(std::string* configurl);
  private:
  const std::string& _internal_configurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configurl(const std::string& value);
  std::string* _internal_mutable_configurl();
  public:

  // optional string controllerData = 4;
  bool has_controllerdata() const;
  private:
  bool _internal_has_controllerdata() const;
  public:
  void clear_controllerdata();
  const std::string& controllerdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controllerdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controllerdata();
  PROTOBUF_NODISCARD std::string* release_controllerdata();
  void set_allocated_controllerdata(std::string* controllerdata);
  private:
  const std::string& _internal_controllerdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controllerdata(const std::string& value);
  std::string* _internal_mutable_controllerdata();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 controllerType = 3;
  bool has_controllertype() const;
  private:
  bool _internal_has_controllertype() const;
  public:
  void clear_controllertype();
  uint32_t controllertype() const;
  void set_controllertype(uint32_t value);
  private:
  uint32_t _internal_controllertype() const;
  void _internal_set_controllertype(uint32_t value);
  public:

  // optional uint32 selectionOrder = 5;
  bool has_selectionorder() const;
  private:
  bool _internal_has_selectionorder() const;
  public:
  void clear_selectionorder();
  uint32_t selectionorder() const;
  void set_selectionorder(uint32_t value);
  private:
  uint32_t _internal_selectionorder() const;
  void _internal_set_selectionorder(uint32_t value);
  public:

  // optional bool actionBlock = 6;
  bool has_actionblock() const;
  private:
  bool _internal_has_actionblock() const;
  public:
  void clear_actionblock();
  bool actionblock() const;
  void set_actionblock(bool value);
  private:
  bool _internal_actionblock() const;
  void _internal_set_actionblock(bool value);
  public:

  // @@protoc_insertion_point(class_scope:CControllerConfigMsg.ControllerConfigResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controllerdata_;
  uint32_t appid_;
  uint32_t controllertype_;
  uint32_t selectionorder_;
  bool actionblock_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerConfigMsg_ControllerPersonalizationResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerConfigMsg.ControllerPersonalizationResponse) */ {
 public:
  inline CControllerConfigMsg_ControllerPersonalizationResponse() : CControllerConfigMsg_ControllerPersonalizationResponse(nullptr) {}
  ~CControllerConfigMsg_ControllerPersonalizationResponse() override;
  explicit constexpr CControllerConfigMsg_ControllerPersonalizationResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerConfigMsg_ControllerPersonalizationResponse(const CControllerConfigMsg_ControllerPersonalizationResponse& from);
  CControllerConfigMsg_ControllerPersonalizationResponse(CControllerConfigMsg_ControllerPersonalizationResponse&& from) noexcept
    : CControllerConfigMsg_ControllerPersonalizationResponse() {
    *this = ::std::move(from);
  }

  inline CControllerConfigMsg_ControllerPersonalizationResponse& operator=(const CControllerConfigMsg_ControllerPersonalizationResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerConfigMsg_ControllerPersonalizationResponse& operator=(CControllerConfigMsg_ControllerPersonalizationResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerConfigMsg_ControllerPersonalizationResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerConfigMsg_ControllerPersonalizationResponse* internal_default_instance() {
    return reinterpret_cast<const CControllerConfigMsg_ControllerPersonalizationResponse*>(
               &_CControllerConfigMsg_ControllerPersonalizationResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    108;

  friend void swap(CControllerConfigMsg_ControllerPersonalizationResponse& a, CControllerConfigMsg_ControllerPersonalizationResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerConfigMsg_ControllerPersonalizationResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerConfigMsg_ControllerPersonalizationResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerConfigMsg_ControllerPersonalizationResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerConfigMsg_ControllerPersonalizationResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerConfigMsg_ControllerPersonalizationResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerConfigMsg_ControllerPersonalizationResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerConfigMsg_ControllerPersonalizationResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerConfigMsg.ControllerPersonalizationResponse";
  }
  protected:
  explicit CControllerConfigMsg_ControllerPersonalizationResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPersonalizationDataFieldNumber = 1,
  };
  // optional string personalizationData = 1;
  bool has_personalizationdata() const;
  private:
  bool _internal_has_personalizationdata() const;
  public:
  void clear_personalizationdata();
  const std::string& personalizationdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_personalizationdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_personalizationdata();
  PROTOBUF_NODISCARD std::string* release_personalizationdata();
  void set_allocated_personalizationdata(std::string* personalizationdata);
  private:
  const std::string& _internal_personalizationdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_personalizationdata(const std::string& value);
  std::string* _internal_mutable_personalizationdata();
  public:

  // @@protoc_insertion_point(class_scope:CControllerConfigMsg.ControllerPersonalizationResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr personalizationdata_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerConfigMsg_ControllerActiveConfigChangeResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerConfigMsg.ControllerActiveConfigChangeResponse) */ {
 public:
  inline CControllerConfigMsg_ControllerActiveConfigChangeResponse() : CControllerConfigMsg_ControllerActiveConfigChangeResponse(nullptr) {}
  ~CControllerConfigMsg_ControllerActiveConfigChangeResponse() override;
  explicit constexpr CControllerConfigMsg_ControllerActiveConfigChangeResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerConfigMsg_ControllerActiveConfigChangeResponse(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from);
  CControllerConfigMsg_ControllerActiveConfigChangeResponse(CControllerConfigMsg_ControllerActiveConfigChangeResponse&& from) noexcept
    : CControllerConfigMsg_ControllerActiveConfigChangeResponse() {
    *this = ::std::move(from);
  }

  inline CControllerConfigMsg_ControllerActiveConfigChangeResponse& operator=(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerConfigMsg_ControllerActiveConfigChangeResponse& operator=(CControllerConfigMsg_ControllerActiveConfigChangeResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerConfigMsg_ControllerActiveConfigChangeResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerConfigMsg_ControllerActiveConfigChangeResponse* internal_default_instance() {
    return reinterpret_cast<const CControllerConfigMsg_ControllerActiveConfigChangeResponse*>(
               &_CControllerConfigMsg_ControllerActiveConfigChangeResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    109;

  friend void swap(CControllerConfigMsg_ControllerActiveConfigChangeResponse& a, CControllerConfigMsg_ControllerActiveConfigChangeResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerConfigMsg_ControllerActiveConfigChangeResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerConfigMsg_ControllerActiveConfigChangeResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerConfigMsg_ControllerActiveConfigChangeResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerConfigMsg_ControllerActiveConfigChangeResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerConfigMsg_ControllerActiveConfigChangeResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerConfigMsg_ControllerActiveConfigChangeResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerConfigMsg.ControllerActiveConfigChangeResponse";
  }
  protected:
  explicit CControllerConfigMsg_ControllerActiveConfigChangeResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigURLFieldNumber = 2,
    kControllerDataFieldNumber = 4,
    kControllerTypeFieldNumber = 3,
    kSelectionOrderFieldNumber = 5,
  };
  // optional string configURL = 2;
  bool has_configurl() const;
  private:
  bool _internal_has_configurl() const;
  public:
  void clear_configurl();
  const std::string& configurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configurl();
  PROTOBUF_NODISCARD std::string* release_configurl();
  void set_allocated_configurl(std::string* configurl);
  private:
  const std::string& _internal_configurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configurl(const std::string& value);
  std::string* _internal_mutable_configurl();
  public:

  // optional string controllerData = 4;
  bool has_controllerdata() const;
  private:
  bool _internal_has_controllerdata() const;
  public:
  void clear_controllerdata();
  const std::string& controllerdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controllerdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controllerdata();
  PROTOBUF_NODISCARD std::string* release_controllerdata();
  void set_allocated_controllerdata(std::string* controllerdata);
  private:
  const std::string& _internal_controllerdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controllerdata(const std::string& value);
  std::string* _internal_mutable_controllerdata();
  public:

  // optional uint32 controllerType = 3;
  bool has_controllertype() const;
  private:
  bool _internal_has_controllertype() const;
  public:
  void clear_controllertype();
  uint32_t controllertype() const;
  void set_controllertype(uint32_t value);
  private:
  uint32_t _internal_controllertype() const;
  void _internal_set_controllertype(uint32_t value);
  public:

  // optional uint32 selectionOrder = 5;
  bool has_selectionorder() const;
  private:
  bool _internal_has_selectionorder() const;
  public:
  void clear_selectionorder();
  uint32_t selectionorder() const;
  void set_selectionorder(uint32_t value);
  private:
  uint32_t _internal_selectionorder() const;
  void _internal_set_selectionorder(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CControllerConfigMsg.ControllerActiveConfigChangeResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controllerdata_;
  uint32_t controllertype_;
  uint32_t selectionorder_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerConfigMsg_ControllerActiveConfigMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerConfigMsg.ControllerActiveConfigMsg) */ {
 public:
  inline CControllerConfigMsg_ControllerActiveConfigMsg() : CControllerConfigMsg_ControllerActiveConfigMsg(nullptr) {}
  ~CControllerConfigMsg_ControllerActiveConfigMsg() override;
  explicit constexpr CControllerConfigMsg_ControllerActiveConfigMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerConfigMsg_ControllerActiveConfigMsg(const CControllerConfigMsg_ControllerActiveConfigMsg& from);
  CControllerConfigMsg_ControllerActiveConfigMsg(CControllerConfigMsg_ControllerActiveConfigMsg&& from) noexcept
    : CControllerConfigMsg_ControllerActiveConfigMsg() {
    *this = ::std::move(from);
  }

  inline CControllerConfigMsg_ControllerActiveConfigMsg& operator=(const CControllerConfigMsg_ControllerActiveConfigMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerConfigMsg_ControllerActiveConfigMsg& operator=(CControllerConfigMsg_ControllerActiveConfigMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerConfigMsg_ControllerActiveConfigMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerConfigMsg_ControllerActiveConfigMsg* internal_default_instance() {
    return reinterpret_cast<const CControllerConfigMsg_ControllerActiveConfigMsg*>(
               &_CControllerConfigMsg_ControllerActiveConfigMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    110;

  friend void swap(CControllerConfigMsg_ControllerActiveConfigMsg& a, CControllerConfigMsg_ControllerActiveConfigMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerConfigMsg_ControllerActiveConfigMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerConfigMsg_ControllerActiveConfigMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerConfigMsg_ControllerActiveConfigMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerConfigMsg_ControllerActiveConfigMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerConfigMsg_ControllerActiveConfigMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerConfigMsg_ControllerActiveConfigMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerConfigMsg_ControllerActiveConfigMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerConfigMsg.ControllerActiveConfigMsg";
  }
  protected:
  explicit CControllerConfigMsg_ControllerActiveConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kConfigURLFieldNumber = 2,
    kControllerDataFieldNumber = 4,
    kAppidFieldNumber = 1,
    kControllerTypeFieldNumber = 3,
  };
  // optional string configURL = 2;
  bool has_configurl() const;
  private:
  bool _internal_has_configurl() const;
  public:
  void clear_configurl();
  const std::string& configurl() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_configurl(ArgT0&& arg0, ArgT... args);
  std::string* mutable_configurl();
  PROTOBUF_NODISCARD std::string* release_configurl();
  void set_allocated_configurl(std::string* configurl);
  private:
  const std::string& _internal_configurl() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_configurl(const std::string& value);
  std::string* _internal_mutable_configurl();
  public:

  // optional string controllerData = 4;
  bool has_controllerdata() const;
  private:
  bool _internal_has_controllerdata() const;
  public:
  void clear_controllerdata();
  const std::string& controllerdata() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controllerdata(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controllerdata();
  PROTOBUF_NODISCARD std::string* release_controllerdata();
  void set_allocated_controllerdata(std::string* controllerdata);
  private:
  const std::string& _internal_controllerdata() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controllerdata(const std::string& value);
  std::string* _internal_mutable_controllerdata();
  public:

  // optional uint32 appid = 1;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // optional uint32 controllerType = 3;
  bool has_controllertype() const;
  private:
  bool _internal_has_controllertype() const;
  public:
  void clear_controllertype();
  uint32_t controllertype() const;
  void set_controllertype(uint32_t value);
  private:
  uint32_t _internal_controllertype() const;
  void _internal_set_controllertype(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CControllerConfigMsg.ControllerActiveConfigMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr configurl_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controllerdata_;
  uint32_t appid_;
  uint32_t controllertype_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// -------------------------------------------------------------------

class CControllerConfigMsg final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:CControllerConfigMsg) */ {
 public:
  inline CControllerConfigMsg() : CControllerConfigMsg(nullptr) {}
  ~CControllerConfigMsg() override;
  explicit constexpr CControllerConfigMsg(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CControllerConfigMsg(const CControllerConfigMsg& from);
  CControllerConfigMsg(CControllerConfigMsg&& from) noexcept
    : CControllerConfigMsg() {
    *this = ::std::move(from);
  }

  inline CControllerConfigMsg& operator=(const CControllerConfigMsg& from) {
    CopyFrom(from);
    return *this;
  }
  inline CControllerConfigMsg& operator=(CControllerConfigMsg&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CControllerConfigMsg& default_instance() {
    return *internal_default_instance();
  }
  static inline const CControllerConfigMsg* internal_default_instance() {
    return reinterpret_cast<const CControllerConfigMsg*>(
               &_CControllerConfigMsg_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    111;

  friend void swap(CControllerConfigMsg& a, CControllerConfigMsg& b) {
    a.Swap(&b);
  }
  inline void Swap(CControllerConfigMsg* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CControllerConfigMsg* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CControllerConfigMsg* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CControllerConfigMsg>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CControllerConfigMsg& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CControllerConfigMsg& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CControllerConfigMsg* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "CControllerConfigMsg";
  }
  protected:
  explicit CControllerConfigMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef CControllerConfigMsg_ControllerConfigResponse ControllerConfigResponse;
  typedef CControllerConfigMsg_ControllerPersonalizationResponse ControllerPersonalizationResponse;
  typedef CControllerConfigMsg_ControllerActiveConfigChangeResponse ControllerActiveConfigChangeResponse;
  typedef CControllerConfigMsg_ControllerActiveConfigMsg ControllerActiveConfigMsg;

  // accessors -------------------------------------------------------

  enum : int {
    kConfigResponseFieldNumber = 6,
    kControllerPathFieldNumber = 2,
    kPersonalizationResponseFieldNumber = 4,
    kActiveConfigChangeMsgFieldNumber = 7,
    kTypeFieldNumber = 1,
    kAppidFieldNumber = 3,
  };
  // repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;
  int configresponse_size() const;
  private:
  int _internal_configresponse_size() const;
  public:
  void clear_configresponse();
  ::CControllerConfigMsg_ControllerConfigResponse* mutable_configresponse(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CControllerConfigMsg_ControllerConfigResponse >*
      mutable_configresponse();
  private:
  const ::CControllerConfigMsg_ControllerConfigResponse& _internal_configresponse(int index) const;
  ::CControllerConfigMsg_ControllerConfigResponse* _internal_add_configresponse();
  public:
  const ::CControllerConfigMsg_ControllerConfigResponse& configresponse(int index) const;
  ::CControllerConfigMsg_ControllerConfigResponse* add_configresponse();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CControllerConfigMsg_ControllerConfigResponse >&
      configresponse() const;

  // optional string controllerPath = 2;
  bool has_controllerpath() const;
  private:
  bool _internal_has_controllerpath() const;
  public:
  void clear_controllerpath();
  const std::string& controllerpath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_controllerpath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_controllerpath();
  PROTOBUF_NODISCARD std::string* release_controllerpath();
  void set_allocated_controllerpath(std::string* controllerpath);
  private:
  const std::string& _internal_controllerpath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_controllerpath(const std::string& value);
  std::string* _internal_mutable_controllerpath();
  public:

  // optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;
  bool has_personalizationresponse() const;
  private:
  bool _internal_has_personalizationresponse() const;
  public:
  void clear_personalizationresponse();
  const ::CControllerConfigMsg_ControllerPersonalizationResponse& personalizationresponse() const;
  PROTOBUF_NODISCARD ::CControllerConfigMsg_ControllerPersonalizationResponse* release_personalizationresponse();
  ::CControllerConfigMsg_ControllerPersonalizationResponse* mutable_personalizationresponse();
  void set_allocated_personalizationresponse(::CControllerConfigMsg_ControllerPersonalizationResponse* personalizationresponse);
  private:
  const ::CControllerConfigMsg_ControllerPersonalizationResponse& _internal_personalizationresponse() const;
  ::CControllerConfigMsg_ControllerPersonalizationResponse* _internal_mutable_personalizationresponse();
  public:
  void unsafe_arena_set_allocated_personalizationresponse(
      ::CControllerConfigMsg_ControllerPersonalizationResponse* personalizationresponse);
  ::CControllerConfigMsg_ControllerPersonalizationResponse* unsafe_arena_release_personalizationresponse();

  // optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;
  bool has_activeconfigchangemsg() const;
  private:
  bool _internal_has_activeconfigchangemsg() const;
  public:
  void clear_activeconfigchangemsg();
  const ::CControllerConfigMsg_ControllerActiveConfigMsg& activeconfigchangemsg() const;
  PROTOBUF_NODISCARD ::CControllerConfigMsg_ControllerActiveConfigMsg* release_activeconfigchangemsg();
  ::CControllerConfigMsg_ControllerActiveConfigMsg* mutable_activeconfigchangemsg();
  void set_allocated_activeconfigchangemsg(::CControllerConfigMsg_ControllerActiveConfigMsg* activeconfigchangemsg);
  private:
  const ::CControllerConfigMsg_ControllerActiveConfigMsg& _internal_activeconfigchangemsg() const;
  ::CControllerConfigMsg_ControllerActiveConfigMsg* _internal_mutable_activeconfigchangemsg();
  public:
  void unsafe_arena_set_allocated_activeconfigchangemsg(
      ::CControllerConfigMsg_ControllerActiveConfigMsg* activeconfigchangemsg);
  ::CControllerConfigMsg_ControllerActiveConfigMsg* unsafe_arena_release_activeconfigchangemsg();

  // required .EStreamControllerConfigMsg type = 1 [default = k_EStreamControllerConfigMsg_RequestConfigsForApp];
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::EStreamControllerConfigMsg type() const;
  void set_type(::EStreamControllerConfigMsg value);
  private:
  ::EStreamControllerConfigMsg _internal_type() const;
  void _internal_set_type(::EStreamControllerConfigMsg value);
  public:

  // optional uint32 appid = 3;
  bool has_appid() const;
  private:
  bool _internal_has_appid() const;
  public:
  void clear_appid();
  uint32_t appid() const;
  void set_appid(uint32_t value);
  private:
  uint32_t _internal_appid() const;
  void _internal_set_appid(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:CControllerConfigMsg)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CControllerConfigMsg_ControllerConfigResponse > configresponse_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr controllerpath_;
  ::CControllerConfigMsg_ControllerPersonalizationResponse* personalizationresponse_;
  ::CControllerConfigMsg_ControllerActiveConfigMsg* activeconfigchangemsg_;
  int type_;
  uint32_t appid_;
  friend struct ::TableStruct_steammessages_5fremoteplay_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// CDiscoveryPingRequest

// optional uint32 sequence = 1;
inline bool CDiscoveryPingRequest::_internal_has_sequence() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDiscoveryPingRequest::has_sequence() const {
  return _internal_has_sequence();
}
inline void CDiscoveryPingRequest::clear_sequence() {
  sequence_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CDiscoveryPingRequest::_internal_sequence() const {
  return sequence_;
}
inline uint32_t CDiscoveryPingRequest::sequence() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingRequest.sequence)
  return _internal_sequence();
}
inline void CDiscoveryPingRequest::_internal_set_sequence(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  sequence_ = value;
}
inline void CDiscoveryPingRequest::set_sequence(uint32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:CDiscoveryPingRequest.sequence)
}

// optional uint32 packet_size_requested = 2;
inline bool CDiscoveryPingRequest::_internal_has_packet_size_requested() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDiscoveryPingRequest::has_packet_size_requested() const {
  return _internal_has_packet_size_requested();
}
inline void CDiscoveryPingRequest::clear_packet_size_requested() {
  packet_size_requested_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CDiscoveryPingRequest::_internal_packet_size_requested() const {
  return packet_size_requested_;
}
inline uint32_t CDiscoveryPingRequest::packet_size_requested() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingRequest.packet_size_requested)
  return _internal_packet_size_requested();
}
inline void CDiscoveryPingRequest::_internal_set_packet_size_requested(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  packet_size_requested_ = value;
}
inline void CDiscoveryPingRequest::set_packet_size_requested(uint32_t value) {
  _internal_set_packet_size_requested(value);
  // @@protoc_insertion_point(field_set:CDiscoveryPingRequest.packet_size_requested)
}

// -------------------------------------------------------------------

// CDiscoveryPingResponse

// optional uint32 sequence = 1;
inline bool CDiscoveryPingResponse::_internal_has_sequence() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDiscoveryPingResponse::has_sequence() const {
  return _internal_has_sequence();
}
inline void CDiscoveryPingResponse::clear_sequence() {
  sequence_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CDiscoveryPingResponse::_internal_sequence() const {
  return sequence_;
}
inline uint32_t CDiscoveryPingResponse::sequence() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingResponse.sequence)
  return _internal_sequence();
}
inline void CDiscoveryPingResponse::_internal_set_sequence(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  sequence_ = value;
}
inline void CDiscoveryPingResponse::set_sequence(uint32_t value) {
  _internal_set_sequence(value);
  // @@protoc_insertion_point(field_set:CDiscoveryPingResponse.sequence)
}

// optional uint32 packet_size_received = 2;
inline bool CDiscoveryPingResponse::_internal_has_packet_size_received() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CDiscoveryPingResponse::has_packet_size_received() const {
  return _internal_has_packet_size_received();
}
inline void CDiscoveryPingResponse::clear_packet_size_received() {
  packet_size_received_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CDiscoveryPingResponse::_internal_packet_size_received() const {
  return packet_size_received_;
}
inline uint32_t CDiscoveryPingResponse::packet_size_received() const {
  // @@protoc_insertion_point(field_get:CDiscoveryPingResponse.packet_size_received)
  return _internal_packet_size_received();
}
inline void CDiscoveryPingResponse::_internal_set_packet_size_received(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  packet_size_received_ = value;
}
inline void CDiscoveryPingResponse::set_packet_size_received(uint32_t value) {
  _internal_set_packet_size_received(value);
  // @@protoc_insertion_point(field_set:CDiscoveryPingResponse.packet_size_received)
}

// -------------------------------------------------------------------

// CStreamingClientHandshakeInfo

// optional int32 network_test = 2;
inline bool CStreamingClientHandshakeInfo::_internal_has_network_test() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingClientHandshakeInfo::has_network_test() const {
  return _internal_has_network_test();
}
inline void CStreamingClientHandshakeInfo::clear_network_test() {
  network_test_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CStreamingClientHandshakeInfo::_internal_network_test() const {
  return network_test_;
}
inline int32_t CStreamingClientHandshakeInfo::network_test() const {
  // @@protoc_insertion_point(field_get:CStreamingClientHandshakeInfo.network_test)
  return _internal_network_test();
}
inline void CStreamingClientHandshakeInfo::_internal_set_network_test(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  network_test_ = value;
}
inline void CStreamingClientHandshakeInfo::set_network_test(int32_t value) {
  _internal_set_network_test(value);
  // @@protoc_insertion_point(field_set:CStreamingClientHandshakeInfo.network_test)
}

// -------------------------------------------------------------------

// CClientHandshakeMsg

// required .CStreamingClientHandshakeInfo info = 1;
inline bool CClientHandshakeMsg::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool CClientHandshakeMsg::has_info() const {
  return _internal_has_info();
}
inline void CClientHandshakeMsg::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CStreamingClientHandshakeInfo& CClientHandshakeMsg::_internal_info() const {
  const ::CStreamingClientHandshakeInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingClientHandshakeInfo&>(
      ::_CStreamingClientHandshakeInfo_default_instance_);
}
inline const ::CStreamingClientHandshakeInfo& CClientHandshakeMsg::info() const {
  // @@protoc_insertion_point(field_get:CClientHandshakeMsg.info)
  return _internal_info();
}
inline void CClientHandshakeMsg::unsafe_arena_set_allocated_info(
    ::CStreamingClientHandshakeInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CClientHandshakeMsg.info)
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::release_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingClientHandshakeInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:CClientHandshakeMsg.info)
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingClientHandshakeInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingClientHandshakeInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::CStreamingClientHandshakeInfo* CClientHandshakeMsg::mutable_info() {
  ::CStreamingClientHandshakeInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CClientHandshakeMsg.info)
  return _msg;
}
inline void CClientHandshakeMsg::set_allocated_info(::CStreamingClientHandshakeInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingClientHandshakeInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CClientHandshakeMsg.info)
}

// -------------------------------------------------------------------

// CStreamingServerHandshakeInfo

// optional int32 mtu = 1;
inline bool CStreamingServerHandshakeInfo::_internal_has_mtu() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingServerHandshakeInfo::has_mtu() const {
  return _internal_has_mtu();
}
inline void CStreamingServerHandshakeInfo::clear_mtu() {
  mtu_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CStreamingServerHandshakeInfo::_internal_mtu() const {
  return mtu_;
}
inline int32_t CStreamingServerHandshakeInfo::mtu() const {
  // @@protoc_insertion_point(field_get:CStreamingServerHandshakeInfo.mtu)
  return _internal_mtu();
}
inline void CStreamingServerHandshakeInfo::_internal_set_mtu(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  mtu_ = value;
}
inline void CStreamingServerHandshakeInfo::set_mtu(int32_t value) {
  _internal_set_mtu(value);
  // @@protoc_insertion_point(field_set:CStreamingServerHandshakeInfo.mtu)
}

// -------------------------------------------------------------------

// CServerHandshakeMsg

// required .CStreamingServerHandshakeInfo info = 1;
inline bool CServerHandshakeMsg::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || info_ != nullptr);
  return value;
}
inline bool CServerHandshakeMsg::has_info() const {
  return _internal_has_info();
}
inline void CServerHandshakeMsg::clear_info() {
  if (info_ != nullptr) info_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CStreamingServerHandshakeInfo& CServerHandshakeMsg::_internal_info() const {
  const ::CStreamingServerHandshakeInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingServerHandshakeInfo&>(
      ::_CStreamingServerHandshakeInfo_default_instance_);
}
inline const ::CStreamingServerHandshakeInfo& CServerHandshakeMsg::info() const {
  // @@protoc_insertion_point(field_get:CServerHandshakeMsg.info)
  return _internal_info();
}
inline void CServerHandshakeMsg::unsafe_arena_set_allocated_info(
    ::CStreamingServerHandshakeInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CServerHandshakeMsg.info)
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::release_info() {
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingServerHandshakeInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:CServerHandshakeMsg.info)
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingServerHandshakeInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingServerHandshakeInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::CStreamingServerHandshakeInfo* CServerHandshakeMsg::mutable_info() {
  ::CStreamingServerHandshakeInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CServerHandshakeMsg.info)
  return _msg;
}
inline void CServerHandshakeMsg::set_allocated_info(::CStreamingServerHandshakeInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingServerHandshakeInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:CServerHandshakeMsg.info)
}

// -------------------------------------------------------------------

// CAuthenticationRequestMsg

// optional bytes token = 1;
inline bool CAuthenticationRequestMsg::_internal_has_token() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationRequestMsg::has_token() const {
  return _internal_has_token();
}
inline void CAuthenticationRequestMsg::clear_token() {
  token_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CAuthenticationRequestMsg::token() const {
  // @@protoc_insertion_point(field_get:CAuthenticationRequestMsg.token)
  return _internal_token();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CAuthenticationRequestMsg::set_token(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 token_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CAuthenticationRequestMsg.token)
}
inline std::string* CAuthenticationRequestMsg::mutable_token() {
  std::string* _s = _internal_mutable_token();
  // @@protoc_insertion_point(field_mutable:CAuthenticationRequestMsg.token)
  return _s;
}
inline const std::string& CAuthenticationRequestMsg::_internal_token() const {
  return token_.Get();
}
inline void CAuthenticationRequestMsg::_internal_set_token(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CAuthenticationRequestMsg::_internal_mutable_token() {
  _has_bits_[0] |= 0x00000001u;
  return token_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CAuthenticationRequestMsg::release_token() {
  // @@protoc_insertion_point(field_release:CAuthenticationRequestMsg.token)
  if (!_internal_has_token()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = token_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CAuthenticationRequestMsg::set_allocated_token(std::string* token) {
  if (token != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  token_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), token,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (token_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CAuthenticationRequestMsg.token)
}

// optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
inline bool CAuthenticationRequestMsg::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAuthenticationRequestMsg::has_version() const {
  return _internal_has_version();
}
inline void CAuthenticationRequestMsg::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EStreamVersion CAuthenticationRequestMsg::_internal_version() const {
  return static_cast< ::EStreamVersion >(version_);
}
inline ::EStreamVersion CAuthenticationRequestMsg::version() const {
  // @@protoc_insertion_point(field_get:CAuthenticationRequestMsg.version)
  return _internal_version();
}
inline void CAuthenticationRequestMsg::_internal_set_version(::EStreamVersion value) {
  assert(::EStreamVersion_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  version_ = value;
}
inline void CAuthenticationRequestMsg::set_version(::EStreamVersion value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CAuthenticationRequestMsg.version)
}

// optional uint64 steamid = 3;
inline bool CAuthenticationRequestMsg::_internal_has_steamid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthenticationRequestMsg::has_steamid() const {
  return _internal_has_steamid();
}
inline void CAuthenticationRequestMsg::clear_steamid() {
  steamid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CAuthenticationRequestMsg::_internal_steamid() const {
  return steamid_;
}
inline uint64_t CAuthenticationRequestMsg::steamid() const {
  // @@protoc_insertion_point(field_get:CAuthenticationRequestMsg.steamid)
  return _internal_steamid();
}
inline void CAuthenticationRequestMsg::_internal_set_steamid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  steamid_ = value;
}
inline void CAuthenticationRequestMsg::set_steamid(uint64_t value) {
  _internal_set_steamid(value);
  // @@protoc_insertion_point(field_set:CAuthenticationRequestMsg.steamid)
}

// -------------------------------------------------------------------

// CAuthenticationResponseMsg

// optional .CAuthenticationResponseMsg.AuthenticationResult result = 1 [default = SUCCEEDED];
inline bool CAuthenticationResponseMsg::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAuthenticationResponseMsg::has_result() const {
  return _internal_has_result();
}
inline void CAuthenticationResponseMsg::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::_internal_result() const {
  return static_cast< ::CAuthenticationResponseMsg_AuthenticationResult >(result_);
}
inline ::CAuthenticationResponseMsg_AuthenticationResult CAuthenticationResponseMsg::result() const {
  // @@protoc_insertion_point(field_get:CAuthenticationResponseMsg.result)
  return _internal_result();
}
inline void CAuthenticationResponseMsg::_internal_set_result(::CAuthenticationResponseMsg_AuthenticationResult value) {
  assert(::CAuthenticationResponseMsg_AuthenticationResult_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  result_ = value;
}
inline void CAuthenticationResponseMsg::set_result(::CAuthenticationResponseMsg_AuthenticationResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CAuthenticationResponseMsg.result)
}

// optional .EStreamVersion version = 2 [default = k_EStreamVersionNone];
inline bool CAuthenticationResponseMsg::_internal_has_version() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAuthenticationResponseMsg::has_version() const {
  return _internal_has_version();
}
inline void CAuthenticationResponseMsg::clear_version() {
  version_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamVersion CAuthenticationResponseMsg::_internal_version() const {
  return static_cast< ::EStreamVersion >(version_);
}
inline ::EStreamVersion CAuthenticationResponseMsg::version() const {
  // @@protoc_insertion_point(field_get:CAuthenticationResponseMsg.version)
  return _internal_version();
}
inline void CAuthenticationResponseMsg::_internal_set_version(::EStreamVersion value) {
  assert(::EStreamVersion_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  version_ = value;
}
inline void CAuthenticationResponseMsg::set_version(::EStreamVersion value) {
  _internal_set_version(value);
  // @@protoc_insertion_point(field_set:CAuthenticationResponseMsg.version)
}

// -------------------------------------------------------------------

// CKeepAliveMsg

// -------------------------------------------------------------------

// CStartNetworkTestMsg

// optional uint32 frames = 1;
inline bool CStartNetworkTestMsg::_internal_has_frames() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStartNetworkTestMsg::has_frames() const {
  return _internal_has_frames();
}
inline void CStartNetworkTestMsg::clear_frames() {
  frames_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStartNetworkTestMsg::_internal_frames() const {
  return frames_;
}
inline uint32_t CStartNetworkTestMsg::frames() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.frames)
  return _internal_frames();
}
inline void CStartNetworkTestMsg::_internal_set_frames(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  frames_ = value;
}
inline void CStartNetworkTestMsg::set_frames(uint32_t value) {
  _internal_set_frames(value);
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.frames)
}

// optional uint32 framerate = 2;
inline bool CStartNetworkTestMsg::_internal_has_framerate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStartNetworkTestMsg::has_framerate() const {
  return _internal_has_framerate();
}
inline void CStartNetworkTestMsg::clear_framerate() {
  framerate_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStartNetworkTestMsg::_internal_framerate() const {
  return framerate_;
}
inline uint32_t CStartNetworkTestMsg::framerate() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.framerate)
  return _internal_framerate();
}
inline void CStartNetworkTestMsg::_internal_set_framerate(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  framerate_ = value;
}
inline void CStartNetworkTestMsg::set_framerate(uint32_t value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.framerate)
}

// optional uint32 bitrate_kbps = 3;
inline bool CStartNetworkTestMsg::_internal_has_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStartNetworkTestMsg::has_bitrate_kbps() const {
  return _internal_has_bitrate_kbps();
}
inline void CStartNetworkTestMsg::clear_bitrate_kbps() {
  bitrate_kbps_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CStartNetworkTestMsg::_internal_bitrate_kbps() const {
  return bitrate_kbps_;
}
inline uint32_t CStartNetworkTestMsg::bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.bitrate_kbps)
  return _internal_bitrate_kbps();
}
inline void CStartNetworkTestMsg::_internal_set_bitrate_kbps(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  bitrate_kbps_ = value;
}
inline void CStartNetworkTestMsg::set_bitrate_kbps(uint32_t value) {
  _internal_set_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.bitrate_kbps)
}

// optional uint32 burst_bitrate_kbps = 4;
inline bool CStartNetworkTestMsg::_internal_has_burst_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStartNetworkTestMsg::has_burst_bitrate_kbps() const {
  return _internal_has_burst_bitrate_kbps();
}
inline void CStartNetworkTestMsg::clear_burst_bitrate_kbps() {
  burst_bitrate_kbps_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStartNetworkTestMsg::_internal_burst_bitrate_kbps() const {
  return burst_bitrate_kbps_;
}
inline uint32_t CStartNetworkTestMsg::burst_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.burst_bitrate_kbps)
  return _internal_burst_bitrate_kbps();
}
inline void CStartNetworkTestMsg::_internal_set_burst_bitrate_kbps(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  burst_bitrate_kbps_ = value;
}
inline void CStartNetworkTestMsg::set_burst_bitrate_kbps(uint32_t value) {
  _internal_set_burst_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.burst_bitrate_kbps)
}

// optional bool bandwidth_test = 5;
inline bool CStartNetworkTestMsg::_internal_has_bandwidth_test() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStartNetworkTestMsg::has_bandwidth_test() const {
  return _internal_has_bandwidth_test();
}
inline void CStartNetworkTestMsg::clear_bandwidth_test() {
  bandwidth_test_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CStartNetworkTestMsg::_internal_bandwidth_test() const {
  return bandwidth_test_;
}
inline bool CStartNetworkTestMsg::bandwidth_test() const {
  // @@protoc_insertion_point(field_get:CStartNetworkTestMsg.bandwidth_test)
  return _internal_bandwidth_test();
}
inline void CStartNetworkTestMsg::_internal_set_bandwidth_test(bool value) {
  _has_bits_[0] |= 0x00000010u;
  bandwidth_test_ = value;
}
inline void CStartNetworkTestMsg::set_bandwidth_test(bool value) {
  _internal_set_bandwidth_test(value);
  // @@protoc_insertion_point(field_set:CStartNetworkTestMsg.bandwidth_test)
}

// -------------------------------------------------------------------

// CStreamVideoMode

// required uint32 width = 1;
inline bool CStreamVideoMode::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamVideoMode::has_width() const {
  return _internal_has_width();
}
inline void CStreamVideoMode::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStreamVideoMode::_internal_width() const {
  return width_;
}
inline uint32_t CStreamVideoMode::width() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.width)
  return _internal_width();
}
inline void CStreamVideoMode::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void CStreamVideoMode::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CStreamVideoMode.width)
}

// required uint32 height = 2;
inline bool CStreamVideoMode::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamVideoMode::has_height() const {
  return _internal_has_height();
}
inline void CStreamVideoMode::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStreamVideoMode::_internal_height() const {
  return height_;
}
inline uint32_t CStreamVideoMode::height() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.height)
  return _internal_height();
}
inline void CStreamVideoMode::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void CStreamVideoMode::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CStreamVideoMode.height)
}

// optional uint32 refresh_rate = 3;
inline bool CStreamVideoMode::_internal_has_refresh_rate() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamVideoMode::has_refresh_rate() const {
  return _internal_has_refresh_rate();
}
inline void CStreamVideoMode::clear_refresh_rate() {
  refresh_rate_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CStreamVideoMode::_internal_refresh_rate() const {
  return refresh_rate_;
}
inline uint32_t CStreamVideoMode::refresh_rate() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate)
  return _internal_refresh_rate();
}
inline void CStreamVideoMode::_internal_set_refresh_rate(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  refresh_rate_ = value;
}
inline void CStreamVideoMode::set_refresh_rate(uint32_t value) {
  _internal_set_refresh_rate(value);
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate)
}

// optional uint32 refresh_rate_numerator = 4;
inline bool CStreamVideoMode::_internal_has_refresh_rate_numerator() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStreamVideoMode::has_refresh_rate_numerator() const {
  return _internal_has_refresh_rate_numerator();
}
inline void CStreamVideoMode::clear_refresh_rate_numerator() {
  refresh_rate_numerator_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStreamVideoMode::_internal_refresh_rate_numerator() const {
  return refresh_rate_numerator_;
}
inline uint32_t CStreamVideoMode::refresh_rate_numerator() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate_numerator)
  return _internal_refresh_rate_numerator();
}
inline void CStreamVideoMode::_internal_set_refresh_rate_numerator(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  refresh_rate_numerator_ = value;
}
inline void CStreamVideoMode::set_refresh_rate_numerator(uint32_t value) {
  _internal_set_refresh_rate_numerator(value);
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate_numerator)
}

// optional uint32 refresh_rate_denominator = 5;
inline bool CStreamVideoMode::_internal_has_refresh_rate_denominator() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStreamVideoMode::has_refresh_rate_denominator() const {
  return _internal_has_refresh_rate_denominator();
}
inline void CStreamVideoMode::clear_refresh_rate_denominator() {
  refresh_rate_denominator_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CStreamVideoMode::_internal_refresh_rate_denominator() const {
  return refresh_rate_denominator_;
}
inline uint32_t CStreamVideoMode::refresh_rate_denominator() const {
  // @@protoc_insertion_point(field_get:CStreamVideoMode.refresh_rate_denominator)
  return _internal_refresh_rate_denominator();
}
inline void CStreamVideoMode::_internal_set_refresh_rate_denominator(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  refresh_rate_denominator_ = value;
}
inline void CStreamVideoMode::set_refresh_rate_denominator(uint32_t value) {
  _internal_set_refresh_rate_denominator(value);
  // @@protoc_insertion_point(field_set:CStreamVideoMode.refresh_rate_denominator)
}

// -------------------------------------------------------------------

// CStreamingClientCaps

// optional string system_info = 1;
inline bool CStreamingClientCaps::_internal_has_system_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_system_info() const {
  return _internal_has_system_info();
}
inline void CStreamingClientCaps::clear_system_info() {
  system_info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStreamingClientCaps::system_info() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.system_info)
  return _internal_system_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStreamingClientCaps::set_system_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 system_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.system_info)
}
inline std::string* CStreamingClientCaps::mutable_system_info() {
  std::string* _s = _internal_mutable_system_info();
  // @@protoc_insertion_point(field_mutable:CStreamingClientCaps.system_info)
  return _s;
}
inline const std::string& CStreamingClientCaps::_internal_system_info() const {
  return system_info_.Get();
}
inline void CStreamingClientCaps::_internal_set_system_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  system_info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStreamingClientCaps::_internal_mutable_system_info() {
  _has_bits_[0] |= 0x00000001u;
  return system_info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStreamingClientCaps::release_system_info() {
  // @@protoc_insertion_point(field_release:CStreamingClientCaps.system_info)
  if (!_internal_has_system_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = system_info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    system_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStreamingClientCaps::set_allocated_system_info(std::string* system_info) {
  if (system_info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  system_info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), system_info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (system_info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    system_info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStreamingClientCaps.system_info)
}

// optional bool system_can_suspend = 2;
inline bool CStreamingClientCaps::_internal_has_system_can_suspend() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_system_can_suspend() const {
  return _internal_has_system_can_suspend();
}
inline void CStreamingClientCaps::clear_system_can_suspend() {
  system_can_suspend_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CStreamingClientCaps::_internal_system_can_suspend() const {
  return system_can_suspend_;
}
inline bool CStreamingClientCaps::system_can_suspend() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.system_can_suspend)
  return _internal_system_can_suspend();
}
inline void CStreamingClientCaps::_internal_set_system_can_suspend(bool value) {
  _has_bits_[0] |= 0x00000008u;
  system_can_suspend_ = value;
}
inline void CStreamingClientCaps::set_system_can_suspend(bool value) {
  _internal_set_system_can_suspend(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.system_can_suspend)
}

// optional int32 maximum_decode_bitrate_kbps = 3;
inline bool CStreamingClientCaps::_internal_has_maximum_decode_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_maximum_decode_bitrate_kbps() const {
  return _internal_has_maximum_decode_bitrate_kbps();
}
inline void CStreamingClientCaps::clear_maximum_decode_bitrate_kbps() {
  maximum_decode_bitrate_kbps_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CStreamingClientCaps::_internal_maximum_decode_bitrate_kbps() const {
  return maximum_decode_bitrate_kbps_;
}
inline int32_t CStreamingClientCaps::maximum_decode_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.maximum_decode_bitrate_kbps)
  return _internal_maximum_decode_bitrate_kbps();
}
inline void CStreamingClientCaps::_internal_set_maximum_decode_bitrate_kbps(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_decode_bitrate_kbps_ = value;
}
inline void CStreamingClientCaps::set_maximum_decode_bitrate_kbps(int32_t value) {
  _internal_set_maximum_decode_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.maximum_decode_bitrate_kbps)
}

// optional int32 maximum_burst_bitrate_kbps = 4;
inline bool CStreamingClientCaps::_internal_has_maximum_burst_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_maximum_burst_bitrate_kbps() const {
  return _internal_has_maximum_burst_bitrate_kbps();
}
inline void CStreamingClientCaps::clear_maximum_burst_bitrate_kbps() {
  maximum_burst_bitrate_kbps_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CStreamingClientCaps::_internal_maximum_burst_bitrate_kbps() const {
  return maximum_burst_bitrate_kbps_;
}
inline int32_t CStreamingClientCaps::maximum_burst_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.maximum_burst_bitrate_kbps)
  return _internal_maximum_burst_bitrate_kbps();
}
inline void CStreamingClientCaps::_internal_set_maximum_burst_bitrate_kbps(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  maximum_burst_bitrate_kbps_ = value;
}
inline void CStreamingClientCaps::set_maximum_burst_bitrate_kbps(int32_t value) {
  _internal_set_maximum_burst_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.maximum_burst_bitrate_kbps)
}

// optional bool supports_video_hevc = 5;
inline bool CStreamingClientCaps::_internal_has_supports_video_hevc() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_supports_video_hevc() const {
  return _internal_has_supports_video_hevc();
}
inline void CStreamingClientCaps::clear_supports_video_hevc() {
  supports_video_hevc_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CStreamingClientCaps::_internal_supports_video_hevc() const {
  return supports_video_hevc_;
}
inline bool CStreamingClientCaps::supports_video_hevc() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.supports_video_hevc)
  return _internal_supports_video_hevc();
}
inline void CStreamingClientCaps::_internal_set_supports_video_hevc(bool value) {
  _has_bits_[0] |= 0x00000010u;
  supports_video_hevc_ = value;
}
inline void CStreamingClientCaps::set_supports_video_hevc(bool value) {
  _internal_set_supports_video_hevc(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.supports_video_hevc)
}

// optional bool disable_steam_store = 6;
inline bool CStreamingClientCaps::_internal_has_disable_steam_store() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_disable_steam_store() const {
  return _internal_has_disable_steam_store();
}
inline void CStreamingClientCaps::clear_disable_steam_store() {
  disable_steam_store_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CStreamingClientCaps::_internal_disable_steam_store() const {
  return disable_steam_store_;
}
inline bool CStreamingClientCaps::disable_steam_store() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_steam_store)
  return _internal_disable_steam_store();
}
inline void CStreamingClientCaps::_internal_set_disable_steam_store(bool value) {
  _has_bits_[0] |= 0x00000020u;
  disable_steam_store_ = value;
}
inline void CStreamingClientCaps::set_disable_steam_store(bool value) {
  _internal_set_disable_steam_store(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_steam_store)
}

// optional bool disable_client_cursor = 7;
inline bool CStreamingClientCaps::_internal_has_disable_client_cursor() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_disable_client_cursor() const {
  return _internal_has_disable_client_cursor();
}
inline void CStreamingClientCaps::clear_disable_client_cursor() {
  disable_client_cursor_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CStreamingClientCaps::_internal_disable_client_cursor() const {
  return disable_client_cursor_;
}
inline bool CStreamingClientCaps::disable_client_cursor() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_client_cursor)
  return _internal_disable_client_cursor();
}
inline void CStreamingClientCaps::_internal_set_disable_client_cursor(bool value) {
  _has_bits_[0] |= 0x00000040u;
  disable_client_cursor_ = value;
}
inline void CStreamingClientCaps::set_disable_client_cursor(bool value) {
  _internal_set_disable_client_cursor(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_client_cursor)
}

// optional bool disable_intel_hardware_encoding = 8;
inline bool CStreamingClientCaps::_internal_has_disable_intel_hardware_encoding() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_disable_intel_hardware_encoding() const {
  return _internal_has_disable_intel_hardware_encoding();
}
inline void CStreamingClientCaps::clear_disable_intel_hardware_encoding() {
  disable_intel_hardware_encoding_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CStreamingClientCaps::_internal_disable_intel_hardware_encoding() const {
  return disable_intel_hardware_encoding_;
}
inline bool CStreamingClientCaps::disable_intel_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_intel_hardware_encoding)
  return _internal_disable_intel_hardware_encoding();
}
inline void CStreamingClientCaps::_internal_set_disable_intel_hardware_encoding(bool value) {
  _has_bits_[0] |= 0x00000080u;
  disable_intel_hardware_encoding_ = value;
}
inline void CStreamingClientCaps::set_disable_intel_hardware_encoding(bool value) {
  _internal_set_disable_intel_hardware_encoding(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_intel_hardware_encoding)
}

// optional bool disable_amd_hardware_encoding = 9;
inline bool CStreamingClientCaps::_internal_has_disable_amd_hardware_encoding() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_disable_amd_hardware_encoding() const {
  return _internal_has_disable_amd_hardware_encoding();
}
inline void CStreamingClientCaps::clear_disable_amd_hardware_encoding() {
  disable_amd_hardware_encoding_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CStreamingClientCaps::_internal_disable_amd_hardware_encoding() const {
  return disable_amd_hardware_encoding_;
}
inline bool CStreamingClientCaps::disable_amd_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_amd_hardware_encoding)
  return _internal_disable_amd_hardware_encoding();
}
inline void CStreamingClientCaps::_internal_set_disable_amd_hardware_encoding(bool value) {
  _has_bits_[0] |= 0x00000100u;
  disable_amd_hardware_encoding_ = value;
}
inline void CStreamingClientCaps::set_disable_amd_hardware_encoding(bool value) {
  _internal_set_disable_amd_hardware_encoding(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_amd_hardware_encoding)
}

// optional bool disable_nvidia_hardware_encoding = 10;
inline bool CStreamingClientCaps::_internal_has_disable_nvidia_hardware_encoding() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_disable_nvidia_hardware_encoding() const {
  return _internal_has_disable_nvidia_hardware_encoding();
}
inline void CStreamingClientCaps::clear_disable_nvidia_hardware_encoding() {
  disable_nvidia_hardware_encoding_ = false;
  _has_bits_[0] &= ~0x00000200u;
}
inline bool CStreamingClientCaps::_internal_disable_nvidia_hardware_encoding() const {
  return disable_nvidia_hardware_encoding_;
}
inline bool CStreamingClientCaps::disable_nvidia_hardware_encoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.disable_nvidia_hardware_encoding)
  return _internal_disable_nvidia_hardware_encoding();
}
inline void CStreamingClientCaps::_internal_set_disable_nvidia_hardware_encoding(bool value) {
  _has_bits_[0] |= 0x00000200u;
  disable_nvidia_hardware_encoding_ = value;
}
inline void CStreamingClientCaps::set_disable_nvidia_hardware_encoding(bool value) {
  _internal_set_disable_nvidia_hardware_encoding(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.disable_nvidia_hardware_encoding)
}

// optional int32 form_factor = 11;
inline bool CStreamingClientCaps::_internal_has_form_factor() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_form_factor() const {
  return _internal_has_form_factor();
}
inline void CStreamingClientCaps::clear_form_factor() {
  form_factor_ = 0;
  _has_bits_[0] &= ~0x00000800u;
}
inline int32_t CStreamingClientCaps::_internal_form_factor() const {
  return form_factor_;
}
inline int32_t CStreamingClientCaps::form_factor() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.form_factor)
  return _internal_form_factor();
}
inline void CStreamingClientCaps::_internal_set_form_factor(int32_t value) {
  _has_bits_[0] |= 0x00000800u;
  form_factor_ = value;
}
inline void CStreamingClientCaps::set_form_factor(int32_t value) {
  _internal_set_form_factor(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.form_factor)
}

// optional bool has_on_screen_keyboard = 12;
inline bool CStreamingClientCaps::_internal_has_has_on_screen_keyboard() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CStreamingClientCaps::has_has_on_screen_keyboard() const {
  return _internal_has_has_on_screen_keyboard();
}
inline void CStreamingClientCaps::clear_has_on_screen_keyboard() {
  has_on_screen_keyboard_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CStreamingClientCaps::_internal_has_on_screen_keyboard() const {
  return has_on_screen_keyboard_;
}
inline bool CStreamingClientCaps::has_on_screen_keyboard() const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.has_on_screen_keyboard)
  return _internal_has_on_screen_keyboard();
}
inline void CStreamingClientCaps::_internal_set_has_on_screen_keyboard(bool value) {
  _has_bits_[0] |= 0x00000400u;
  has_on_screen_keyboard_ = value;
}
inline void CStreamingClientCaps::set_has_on_screen_keyboard(bool value) {
  _internal_set_has_on_screen_keyboard(value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.has_on_screen_keyboard)
}

// repeated .EStreamColorspace supported_colorspaces = 13;
inline int CStreamingClientCaps::_internal_supported_colorspaces_size() const {
  return supported_colorspaces_.size();
}
inline int CStreamingClientCaps::supported_colorspaces_size() const {
  return _internal_supported_colorspaces_size();
}
inline void CStreamingClientCaps::clear_supported_colorspaces() {
  supported_colorspaces_.Clear();
}
inline ::EStreamColorspace CStreamingClientCaps::_internal_supported_colorspaces(int index) const {
  return static_cast< ::EStreamColorspace >(supported_colorspaces_.Get(index));
}
inline ::EStreamColorspace CStreamingClientCaps::supported_colorspaces(int index) const {
  // @@protoc_insertion_point(field_get:CStreamingClientCaps.supported_colorspaces)
  return _internal_supported_colorspaces(index);
}
inline void CStreamingClientCaps::set_supported_colorspaces(int index, ::EStreamColorspace value) {
  assert(::EStreamColorspace_IsValid(value));
  supported_colorspaces_.Set(index, value);
  // @@protoc_insertion_point(field_set:CStreamingClientCaps.supported_colorspaces)
}
inline void CStreamingClientCaps::_internal_add_supported_colorspaces(::EStreamColorspace value) {
  assert(::EStreamColorspace_IsValid(value));
  supported_colorspaces_.Add(value);
}
inline void CStreamingClientCaps::add_supported_colorspaces(::EStreamColorspace value) {
  _internal_add_supported_colorspaces(value);
  // @@protoc_insertion_point(field_add:CStreamingClientCaps.supported_colorspaces)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CStreamingClientCaps::supported_colorspaces() const {
  // @@protoc_insertion_point(field_list:CStreamingClientCaps.supported_colorspaces)
  return supported_colorspaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CStreamingClientCaps::_internal_mutable_supported_colorspaces() {
  return &supported_colorspaces_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CStreamingClientCaps::mutable_supported_colorspaces() {
  // @@protoc_insertion_point(field_mutable_list:CStreamingClientCaps.supported_colorspaces)
  return _internal_mutable_supported_colorspaces();
}

// -------------------------------------------------------------------

// CStreamingClientConfig

// optional .EStreamQualityPreference quality = 1 [default = k_EStreamQualityBalanced];
inline bool CStreamingClientConfig::_internal_has_quality() const {
  bool value = (_has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_quality() const {
  return _internal_has_quality();
}
inline void CStreamingClientConfig::clear_quality() {
  quality_ = 2;
  _has_bits_[0] &= ~0x00001000u;
}
inline ::EStreamQualityPreference CStreamingClientConfig::_internal_quality() const {
  return static_cast< ::EStreamQualityPreference >(quality_);
}
inline ::EStreamQualityPreference CStreamingClientConfig::quality() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.quality)
  return _internal_quality();
}
inline void CStreamingClientConfig::_internal_set_quality(::EStreamQualityPreference value) {
  assert(::EStreamQualityPreference_IsValid(value));
  _has_bits_[0] |= 0x00001000u;
  quality_ = value;
}
inline void CStreamingClientConfig::set_quality(::EStreamQualityPreference value) {
  _internal_set_quality(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.quality)
}

// optional uint32 maximum_resolution_x = 2;
inline bool CStreamingClientConfig::_internal_has_maximum_resolution_x() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_maximum_resolution_x() const {
  return _internal_has_maximum_resolution_x();
}
inline void CStreamingClientConfig::clear_maximum_resolution_x() {
  maximum_resolution_x_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStreamingClientConfig::_internal_maximum_resolution_x() const {
  return maximum_resolution_x_;
}
inline uint32_t CStreamingClientConfig::maximum_resolution_x() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_resolution_x)
  return _internal_maximum_resolution_x();
}
inline void CStreamingClientConfig::_internal_set_maximum_resolution_x(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  maximum_resolution_x_ = value;
}
inline void CStreamingClientConfig::set_maximum_resolution_x(uint32_t value) {
  _internal_set_maximum_resolution_x(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_resolution_x)
}

// optional uint32 maximum_resolution_y = 3;
inline bool CStreamingClientConfig::_internal_has_maximum_resolution_y() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_maximum_resolution_y() const {
  return _internal_has_maximum_resolution_y();
}
inline void CStreamingClientConfig::clear_maximum_resolution_y() {
  maximum_resolution_y_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CStreamingClientConfig::_internal_maximum_resolution_y() const {
  return maximum_resolution_y_;
}
inline uint32_t CStreamingClientConfig::maximum_resolution_y() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_resolution_y)
  return _internal_maximum_resolution_y();
}
inline void CStreamingClientConfig::_internal_set_maximum_resolution_y(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  maximum_resolution_y_ = value;
}
inline void CStreamingClientConfig::set_maximum_resolution_y(uint32_t value) {
  _internal_set_maximum_resolution_y(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_resolution_y)
}

// optional uint32 maximum_framerate_numerator = 4;
inline bool CStreamingClientConfig::_internal_has_maximum_framerate_numerator() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_maximum_framerate_numerator() const {
  return _internal_has_maximum_framerate_numerator();
}
inline void CStreamingClientConfig::clear_maximum_framerate_numerator() {
  maximum_framerate_numerator_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStreamingClientConfig::_internal_maximum_framerate_numerator() const {
  return maximum_framerate_numerator_;
}
inline uint32_t CStreamingClientConfig::maximum_framerate_numerator() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_framerate_numerator)
  return _internal_maximum_framerate_numerator();
}
inline void CStreamingClientConfig::_internal_set_maximum_framerate_numerator(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  maximum_framerate_numerator_ = value;
}
inline void CStreamingClientConfig::set_maximum_framerate_numerator(uint32_t value) {
  _internal_set_maximum_framerate_numerator(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_framerate_numerator)
}

// optional uint32 maximum_framerate_denominator = 5;
inline bool CStreamingClientConfig::_internal_has_maximum_framerate_denominator() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_maximum_framerate_denominator() const {
  return _internal_has_maximum_framerate_denominator();
}
inline void CStreamingClientConfig::clear_maximum_framerate_denominator() {
  maximum_framerate_denominator_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CStreamingClientConfig::_internal_maximum_framerate_denominator() const {
  return maximum_framerate_denominator_;
}
inline uint32_t CStreamingClientConfig::maximum_framerate_denominator() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_framerate_denominator)
  return _internal_maximum_framerate_denominator();
}
inline void CStreamingClientConfig::_internal_set_maximum_framerate_denominator(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  maximum_framerate_denominator_ = value;
}
inline void CStreamingClientConfig::set_maximum_framerate_denominator(uint32_t value) {
  _internal_set_maximum_framerate_denominator(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_framerate_denominator)
}

// optional int32 maximum_bitrate_kbps = 6 [default = -1];
inline bool CStreamingClientConfig::_internal_has_maximum_bitrate_kbps() const {
  bool value = (_has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_maximum_bitrate_kbps() const {
  return _internal_has_maximum_bitrate_kbps();
}
inline void CStreamingClientConfig::clear_maximum_bitrate_kbps() {
  maximum_bitrate_kbps_ = -1;
  _has_bits_[0] &= ~0x00002000u;
}
inline int32_t CStreamingClientConfig::_internal_maximum_bitrate_kbps() const {
  return maximum_bitrate_kbps_;
}
inline int32_t CStreamingClientConfig::maximum_bitrate_kbps() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.maximum_bitrate_kbps)
  return _internal_maximum_bitrate_kbps();
}
inline void CStreamingClientConfig::_internal_set_maximum_bitrate_kbps(int32_t value) {
  _has_bits_[0] |= 0x00002000u;
  maximum_bitrate_kbps_ = value;
}
inline void CStreamingClientConfig::set_maximum_bitrate_kbps(int32_t value) {
  _internal_set_maximum_bitrate_kbps(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.maximum_bitrate_kbps)
}

// optional bool enable_hardware_decoding = 7 [default = true];
inline bool CStreamingClientConfig::_internal_has_enable_hardware_decoding() const {
  bool value = (_has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_hardware_decoding() const {
  return _internal_has_enable_hardware_decoding();
}
inline void CStreamingClientConfig::clear_enable_hardware_decoding() {
  enable_hardware_decoding_ = true;
  _has_bits_[0] &= ~0x00004000u;
}
inline bool CStreamingClientConfig::_internal_enable_hardware_decoding() const {
  return enable_hardware_decoding_;
}
inline bool CStreamingClientConfig::enable_hardware_decoding() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_hardware_decoding)
  return _internal_enable_hardware_decoding();
}
inline void CStreamingClientConfig::_internal_set_enable_hardware_decoding(bool value) {
  _has_bits_[0] |= 0x00004000u;
  enable_hardware_decoding_ = value;
}
inline void CStreamingClientConfig::set_enable_hardware_decoding(bool value) {
  _internal_set_enable_hardware_decoding(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_hardware_decoding)
}

// optional bool enable_performance_overlay = 8 [default = false];
inline bool CStreamingClientConfig::_internal_has_enable_performance_overlay() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_performance_overlay() const {
  return _internal_has_enable_performance_overlay();
}
inline void CStreamingClientConfig::clear_enable_performance_overlay() {
  enable_performance_overlay_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CStreamingClientConfig::_internal_enable_performance_overlay() const {
  return enable_performance_overlay_;
}
inline bool CStreamingClientConfig::enable_performance_overlay() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_performance_overlay)
  return _internal_enable_performance_overlay();
}
inline void CStreamingClientConfig::_internal_set_enable_performance_overlay(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enable_performance_overlay_ = value;
}
inline void CStreamingClientConfig::set_enable_performance_overlay(bool value) {
  _internal_set_enable_performance_overlay(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_performance_overlay)
}

// optional bool enable_video_streaming = 9 [default = true];
inline bool CStreamingClientConfig::_internal_has_enable_video_streaming() const {
  bool value = (_has_bits_[0] & 0x00008000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_video_streaming() const {
  return _internal_has_enable_video_streaming();
}
inline void CStreamingClientConfig::clear_enable_video_streaming() {
  enable_video_streaming_ = true;
  _has_bits_[0] &= ~0x00008000u;
}
inline bool CStreamingClientConfig::_internal_enable_video_streaming() const {
  return enable_video_streaming_;
}
inline bool CStreamingClientConfig::enable_video_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_video_streaming)
  return _internal_enable_video_streaming();
}
inline void CStreamingClientConfig::_internal_set_enable_video_streaming(bool value) {
  _has_bits_[0] |= 0x00008000u;
  enable_video_streaming_ = value;
}
inline void CStreamingClientConfig::set_enable_video_streaming(bool value) {
  _internal_set_enable_video_streaming(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_video_streaming)
}

// optional bool enable_audio_streaming = 10 [default = true];
inline bool CStreamingClientConfig::_internal_has_enable_audio_streaming() const {
  bool value = (_has_bits_[0] & 0x00010000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_audio_streaming() const {
  return _internal_has_enable_audio_streaming();
}
inline void CStreamingClientConfig::clear_enable_audio_streaming() {
  enable_audio_streaming_ = true;
  _has_bits_[0] &= ~0x00010000u;
}
inline bool CStreamingClientConfig::_internal_enable_audio_streaming() const {
  return enable_audio_streaming_;
}
inline bool CStreamingClientConfig::enable_audio_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_audio_streaming)
  return _internal_enable_audio_streaming();
}
inline void CStreamingClientConfig::_internal_set_enable_audio_streaming(bool value) {
  _has_bits_[0] |= 0x00010000u;
  enable_audio_streaming_ = value;
}
inline void CStreamingClientConfig::set_enable_audio_streaming(bool value) {
  _internal_set_enable_audio_streaming(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_audio_streaming)
}

// optional bool enable_input_streaming = 11 [default = true];
inline bool CStreamingClientConfig::_internal_has_enable_input_streaming() const {
  bool value = (_has_bits_[0] & 0x00020000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_input_streaming() const {
  return _internal_has_enable_input_streaming();
}
inline void CStreamingClientConfig::clear_enable_input_streaming() {
  enable_input_streaming_ = true;
  _has_bits_[0] &= ~0x00020000u;
}
inline bool CStreamingClientConfig::_internal_enable_input_streaming() const {
  return enable_input_streaming_;
}
inline bool CStreamingClientConfig::enable_input_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_input_streaming)
  return _internal_enable_input_streaming();
}
inline void CStreamingClientConfig::_internal_set_enable_input_streaming(bool value) {
  _has_bits_[0] |= 0x00020000u;
  enable_input_streaming_ = value;
}
inline void CStreamingClientConfig::set_enable_input_streaming(bool value) {
  _internal_set_enable_input_streaming(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_input_streaming)
}

// optional int32 audio_channels = 12 [default = 2];
inline bool CStreamingClientConfig::_internal_has_audio_channels() const {
  bool value = (_has_bits_[0] & 0x00040000u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_audio_channels() const {
  return _internal_has_audio_channels();
}
inline void CStreamingClientConfig::clear_audio_channels() {
  audio_channels_ = 2;
  _has_bits_[0] &= ~0x00040000u;
}
inline int32_t CStreamingClientConfig::_internal_audio_channels() const {
  return audio_channels_;
}
inline int32_t CStreamingClientConfig::audio_channels() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.audio_channels)
  return _internal_audio_channels();
}
inline void CStreamingClientConfig::_internal_set_audio_channels(int32_t value) {
  _has_bits_[0] |= 0x00040000u;
  audio_channels_ = value;
}
inline void CStreamingClientConfig::set_audio_channels(int32_t value) {
  _internal_set_audio_channels(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.audio_channels)
}

// optional bool enable_video_hevc = 13 [default = false];
inline bool CStreamingClientConfig::_internal_has_enable_video_hevc() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_video_hevc() const {
  return _internal_has_enable_video_hevc();
}
inline void CStreamingClientConfig::clear_enable_video_hevc() {
  enable_video_hevc_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CStreamingClientConfig::_internal_enable_video_hevc() const {
  return enable_video_hevc_;
}
inline bool CStreamingClientConfig::enable_video_hevc() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_video_hevc)
  return _internal_enable_video_hevc();
}
inline void CStreamingClientConfig::_internal_set_enable_video_hevc(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_video_hevc_ = value;
}
inline void CStreamingClientConfig::set_enable_video_hevc(bool value) {
  _internal_set_enable_video_hevc(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_video_hevc)
}

// optional bool enable_performance_icons = 14 [default = true];
inline bool CStreamingClientConfig::_internal_has_enable_performance_icons() const {
  bool value = (_has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_performance_icons() const {
  return _internal_has_enable_performance_icons();
}
inline void CStreamingClientConfig::clear_enable_performance_icons() {
  enable_performance_icons_ = true;
  _has_bits_[0] &= ~0x00000800u;
}
inline bool CStreamingClientConfig::_internal_enable_performance_icons() const {
  return enable_performance_icons_;
}
inline bool CStreamingClientConfig::enable_performance_icons() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_performance_icons)
  return _internal_enable_performance_icons();
}
inline void CStreamingClientConfig::_internal_set_enable_performance_icons(bool value) {
  _has_bits_[0] |= 0x00000800u;
  enable_performance_icons_ = value;
}
inline void CStreamingClientConfig::set_enable_performance_icons(bool value) {
  _internal_set_enable_performance_icons(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_performance_icons)
}

// optional bool enable_microphone_streaming = 15 [default = false];
inline bool CStreamingClientConfig::_internal_has_enable_microphone_streaming() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_microphone_streaming() const {
  return _internal_has_enable_microphone_streaming();
}
inline void CStreamingClientConfig::clear_enable_microphone_streaming() {
  enable_microphone_streaming_ = false;
  _has_bits_[0] &= ~0x00000080u;
}
inline bool CStreamingClientConfig::_internal_enable_microphone_streaming() const {
  return enable_microphone_streaming_;
}
inline bool CStreamingClientConfig::enable_microphone_streaming() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_microphone_streaming)
  return _internal_enable_microphone_streaming();
}
inline void CStreamingClientConfig::_internal_set_enable_microphone_streaming(bool value) {
  _has_bits_[0] |= 0x00000080u;
  enable_microphone_streaming_ = value;
}
inline void CStreamingClientConfig::set_enable_microphone_streaming(bool value) {
  _internal_set_enable_microphone_streaming(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_microphone_streaming)
}

// optional string controller_overlay_hotkey = 16;
inline bool CStreamingClientConfig::_internal_has_controller_overlay_hotkey() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_controller_overlay_hotkey() const {
  return _internal_has_controller_overlay_hotkey();
}
inline void CStreamingClientConfig::clear_controller_overlay_hotkey() {
  controller_overlay_hotkey_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStreamingClientConfig::controller_overlay_hotkey() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.controller_overlay_hotkey)
  return _internal_controller_overlay_hotkey();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStreamingClientConfig::set_controller_overlay_hotkey(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 controller_overlay_hotkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.controller_overlay_hotkey)
}
inline std::string* CStreamingClientConfig::mutable_controller_overlay_hotkey() {
  std::string* _s = _internal_mutable_controller_overlay_hotkey();
  // @@protoc_insertion_point(field_mutable:CStreamingClientConfig.controller_overlay_hotkey)
  return _s;
}
inline const std::string& CStreamingClientConfig::_internal_controller_overlay_hotkey() const {
  return controller_overlay_hotkey_.Get();
}
inline void CStreamingClientConfig::_internal_set_controller_overlay_hotkey(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  controller_overlay_hotkey_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStreamingClientConfig::_internal_mutable_controller_overlay_hotkey() {
  _has_bits_[0] |= 0x00000001u;
  return controller_overlay_hotkey_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStreamingClientConfig::release_controller_overlay_hotkey() {
  // @@protoc_insertion_point(field_release:CStreamingClientConfig.controller_overlay_hotkey)
  if (!_internal_has_controller_overlay_hotkey()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = controller_overlay_hotkey_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_overlay_hotkey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_overlay_hotkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStreamingClientConfig::set_allocated_controller_overlay_hotkey(std::string* controller_overlay_hotkey) {
  if (controller_overlay_hotkey != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  controller_overlay_hotkey_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_overlay_hotkey,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_overlay_hotkey_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_overlay_hotkey_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStreamingClientConfig.controller_overlay_hotkey)
}

// optional bool enable_touch_controller_OBSOLETE = 17 [default = false];
inline bool CStreamingClientConfig::_internal_has_enable_touch_controller_obsolete() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_touch_controller_obsolete() const {
  return _internal_has_enable_touch_controller_obsolete();
}
inline void CStreamingClientConfig::clear_enable_touch_controller_obsolete() {
  enable_touch_controller_obsolete_ = false;
  _has_bits_[0] &= ~0x00000100u;
}
inline bool CStreamingClientConfig::_internal_enable_touch_controller_obsolete() const {
  return enable_touch_controller_obsolete_;
}
inline bool CStreamingClientConfig::enable_touch_controller_obsolete() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_touch_controller_OBSOLETE)
  return _internal_enable_touch_controller_obsolete();
}
inline void CStreamingClientConfig::_internal_set_enable_touch_controller_obsolete(bool value) {
  _has_bits_[0] |= 0x00000100u;
  enable_touch_controller_obsolete_ = value;
}
inline void CStreamingClientConfig::set_enable_touch_controller_obsolete(bool value) {
  _internal_set_enable_touch_controller_obsolete(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_touch_controller_OBSOLETE)
}

// optional .EStreamP2PScope p2p_scope = 19 [default = k_EStreamP2PScopeAutomatic];
inline bool CStreamingClientConfig::_internal_has_p2p_scope() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_p2p_scope() const {
  return _internal_has_p2p_scope();
}
inline void CStreamingClientConfig::clear_p2p_scope() {
  p2p_scope_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::EStreamP2PScope CStreamingClientConfig::_internal_p2p_scope() const {
  return static_cast< ::EStreamP2PScope >(p2p_scope_);
}
inline ::EStreamP2PScope CStreamingClientConfig::p2p_scope() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.p2p_scope)
  return _internal_p2p_scope();
}
inline void CStreamingClientConfig::_internal_set_p2p_scope(::EStreamP2PScope value) {
  assert(::EStreamP2PScope_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  p2p_scope_ = value;
}
inline void CStreamingClientConfig::set_p2p_scope(::EStreamP2PScope value) {
  _internal_set_p2p_scope(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.p2p_scope)
}

// optional bool enable_audio_uncompressed = 20 [default = false];
inline bool CStreamingClientConfig::_internal_has_enable_audio_uncompressed() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CStreamingClientConfig::has_enable_audio_uncompressed() const {
  return _internal_has_enable_audio_uncompressed();
}
inline void CStreamingClientConfig::clear_enable_audio_uncompressed() {
  enable_audio_uncompressed_ = false;
  _has_bits_[0] &= ~0x00000400u;
}
inline bool CStreamingClientConfig::_internal_enable_audio_uncompressed() const {
  return enable_audio_uncompressed_;
}
inline bool CStreamingClientConfig::enable_audio_uncompressed() const {
  // @@protoc_insertion_point(field_get:CStreamingClientConfig.enable_audio_uncompressed)
  return _internal_enable_audio_uncompressed();
}
inline void CStreamingClientConfig::_internal_set_enable_audio_uncompressed(bool value) {
  _has_bits_[0] |= 0x00000400u;
  enable_audio_uncompressed_ = value;
}
inline void CStreamingClientConfig::set_enable_audio_uncompressed(bool value) {
  _internal_set_enable_audio_uncompressed(value);
  // @@protoc_insertion_point(field_set:CStreamingClientConfig.enable_audio_uncompressed)
}

// -------------------------------------------------------------------

// CStreamingServerConfig

// optional bool change_desktop_resolution = 1;
inline bool CStreamingServerConfig::_internal_has_change_desktop_resolution() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_change_desktop_resolution() const {
  return _internal_has_change_desktop_resolution();
}
inline void CStreamingServerConfig::clear_change_desktop_resolution() {
  change_desktop_resolution_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CStreamingServerConfig::_internal_change_desktop_resolution() const {
  return change_desktop_resolution_;
}
inline bool CStreamingServerConfig::change_desktop_resolution() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.change_desktop_resolution)
  return _internal_change_desktop_resolution();
}
inline void CStreamingServerConfig::_internal_set_change_desktop_resolution(bool value) {
  _has_bits_[0] |= 0x00000001u;
  change_desktop_resolution_ = value;
}
inline void CStreamingServerConfig::set_change_desktop_resolution(bool value) {
  _internal_set_change_desktop_resolution(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.change_desktop_resolution)
}

// optional bool dynamically_adjust_resolution = 2;
inline bool CStreamingServerConfig::_internal_has_dynamically_adjust_resolution() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_dynamically_adjust_resolution() const {
  return _internal_has_dynamically_adjust_resolution();
}
inline void CStreamingServerConfig::clear_dynamically_adjust_resolution() {
  dynamically_adjust_resolution_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CStreamingServerConfig::_internal_dynamically_adjust_resolution() const {
  return dynamically_adjust_resolution_;
}
inline bool CStreamingServerConfig::dynamically_adjust_resolution() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.dynamically_adjust_resolution)
  return _internal_dynamically_adjust_resolution();
}
inline void CStreamingServerConfig::_internal_set_dynamically_adjust_resolution(bool value) {
  _has_bits_[0] |= 0x00000002u;
  dynamically_adjust_resolution_ = value;
}
inline void CStreamingServerConfig::set_dynamically_adjust_resolution(bool value) {
  _internal_set_dynamically_adjust_resolution(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.dynamically_adjust_resolution)
}

// optional bool enable_capture_nvfbc = 3;
inline bool CStreamingServerConfig::_internal_has_enable_capture_nvfbc() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_enable_capture_nvfbc() const {
  return _internal_has_enable_capture_nvfbc();
}
inline void CStreamingServerConfig::clear_enable_capture_nvfbc() {
  enable_capture_nvfbc_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CStreamingServerConfig::_internal_enable_capture_nvfbc() const {
  return enable_capture_nvfbc_;
}
inline bool CStreamingServerConfig::enable_capture_nvfbc() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_capture_nvfbc)
  return _internal_enable_capture_nvfbc();
}
inline void CStreamingServerConfig::_internal_set_enable_capture_nvfbc(bool value) {
  _has_bits_[0] |= 0x00000004u;
  enable_capture_nvfbc_ = value;
}
inline void CStreamingServerConfig::set_enable_capture_nvfbc(bool value) {
  _internal_set_enable_capture_nvfbc(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_capture_nvfbc)
}

// optional bool enable_hardware_encoding_nvidia = 4;
inline bool CStreamingServerConfig::_internal_has_enable_hardware_encoding_nvidia() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_enable_hardware_encoding_nvidia() const {
  return _internal_has_enable_hardware_encoding_nvidia();
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_nvidia() {
  enable_hardware_encoding_nvidia_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CStreamingServerConfig::_internal_enable_hardware_encoding_nvidia() const {
  return enable_hardware_encoding_nvidia_;
}
inline bool CStreamingServerConfig::enable_hardware_encoding_nvidia() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_nvidia)
  return _internal_enable_hardware_encoding_nvidia();
}
inline void CStreamingServerConfig::_internal_set_enable_hardware_encoding_nvidia(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_hardware_encoding_nvidia_ = value;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_nvidia(bool value) {
  _internal_set_enable_hardware_encoding_nvidia(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_nvidia)
}

// optional bool enable_hardware_encoding_amd = 5;
inline bool CStreamingServerConfig::_internal_has_enable_hardware_encoding_amd() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_enable_hardware_encoding_amd() const {
  return _internal_has_enable_hardware_encoding_amd();
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_amd() {
  enable_hardware_encoding_amd_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CStreamingServerConfig::_internal_enable_hardware_encoding_amd() const {
  return enable_hardware_encoding_amd_;
}
inline bool CStreamingServerConfig::enable_hardware_encoding_amd() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_amd)
  return _internal_enable_hardware_encoding_amd();
}
inline void CStreamingServerConfig::_internal_set_enable_hardware_encoding_amd(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_hardware_encoding_amd_ = value;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_amd(bool value) {
  _internal_set_enable_hardware_encoding_amd(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_amd)
}

// optional bool enable_hardware_encoding_intel = 6;
inline bool CStreamingServerConfig::_internal_has_enable_hardware_encoding_intel() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_enable_hardware_encoding_intel() const {
  return _internal_has_enable_hardware_encoding_intel();
}
inline void CStreamingServerConfig::clear_enable_hardware_encoding_intel() {
  enable_hardware_encoding_intel_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CStreamingServerConfig::_internal_enable_hardware_encoding_intel() const {
  return enable_hardware_encoding_intel_;
}
inline bool CStreamingServerConfig::enable_hardware_encoding_intel() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_hardware_encoding_intel)
  return _internal_enable_hardware_encoding_intel();
}
inline void CStreamingServerConfig::_internal_set_enable_hardware_encoding_intel(bool value) {
  _has_bits_[0] |= 0x00000020u;
  enable_hardware_encoding_intel_ = value;
}
inline void CStreamingServerConfig::set_enable_hardware_encoding_intel(bool value) {
  _internal_set_enable_hardware_encoding_intel(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_hardware_encoding_intel)
}

// optional int32 software_encoding_threads = 7;
inline bool CStreamingServerConfig::_internal_has_software_encoding_threads() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_software_encoding_threads() const {
  return _internal_has_software_encoding_threads();
}
inline void CStreamingServerConfig::clear_software_encoding_threads() {
  software_encoding_threads_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t CStreamingServerConfig::_internal_software_encoding_threads() const {
  return software_encoding_threads_;
}
inline int32_t CStreamingServerConfig::software_encoding_threads() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.software_encoding_threads)
  return _internal_software_encoding_threads();
}
inline void CStreamingServerConfig::_internal_set_software_encoding_threads(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  software_encoding_threads_ = value;
}
inline void CStreamingServerConfig::set_software_encoding_threads(int32_t value) {
  _internal_set_software_encoding_threads(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.software_encoding_threads)
}

// optional bool enable_traffic_priority = 8;
inline bool CStreamingServerConfig::_internal_has_enable_traffic_priority() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_enable_traffic_priority() const {
  return _internal_has_enable_traffic_priority();
}
inline void CStreamingServerConfig::clear_enable_traffic_priority() {
  enable_traffic_priority_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool CStreamingServerConfig::_internal_enable_traffic_priority() const {
  return enable_traffic_priority_;
}
inline bool CStreamingServerConfig::enable_traffic_priority() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.enable_traffic_priority)
  return _internal_enable_traffic_priority();
}
inline void CStreamingServerConfig::_internal_set_enable_traffic_priority(bool value) {
  _has_bits_[0] |= 0x00000040u;
  enable_traffic_priority_ = value;
}
inline void CStreamingServerConfig::set_enable_traffic_priority(bool value) {
  _internal_set_enable_traffic_priority(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.enable_traffic_priority)
}

// optional .EStreamHostPlayAudioPreference host_play_audio = 9 [default = k_EStreamHostPlayAudioDefault];
inline bool CStreamingServerConfig::_internal_has_host_play_audio() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CStreamingServerConfig::has_host_play_audio() const {
  return _internal_has_host_play_audio();
}
inline void CStreamingServerConfig::clear_host_play_audio() {
  host_play_audio_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::EStreamHostPlayAudioPreference CStreamingServerConfig::_internal_host_play_audio() const {
  return static_cast< ::EStreamHostPlayAudioPreference >(host_play_audio_);
}
inline ::EStreamHostPlayAudioPreference CStreamingServerConfig::host_play_audio() const {
  // @@protoc_insertion_point(field_get:CStreamingServerConfig.host_play_audio)
  return _internal_host_play_audio();
}
inline void CStreamingServerConfig::_internal_set_host_play_audio(::EStreamHostPlayAudioPreference value) {
  assert(::EStreamHostPlayAudioPreference_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  host_play_audio_ = value;
}
inline void CStreamingServerConfig::set_host_play_audio(::EStreamHostPlayAudioPreference value) {
  _internal_set_host_play_audio(value);
  // @@protoc_insertion_point(field_set:CStreamingServerConfig.host_play_audio)
}

// -------------------------------------------------------------------

// CNegotiatedConfig

// optional bool reliable_data = 1;
inline bool CNegotiatedConfig::_internal_has_reliable_data() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_reliable_data() const {
  return _internal_has_reliable_data();
}
inline void CNegotiatedConfig::clear_reliable_data() {
  reliable_data_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CNegotiatedConfig::_internal_reliable_data() const {
  return reliable_data_;
}
inline bool CNegotiatedConfig::reliable_data() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.reliable_data)
  return _internal_reliable_data();
}
inline void CNegotiatedConfig::_internal_set_reliable_data(bool value) {
  _has_bits_[0] |= 0x00000004u;
  reliable_data_ = value;
}
inline void CNegotiatedConfig::set_reliable_data(bool value) {
  _internal_set_reliable_data(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.reliable_data)
}

// optional .EStreamAudioCodec selected_audio_codec = 2 [default = k_EStreamAudioCodecNone];
inline bool CNegotiatedConfig::_internal_has_selected_audio_codec() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_selected_audio_codec() const {
  return _internal_has_selected_audio_codec();
}
inline void CNegotiatedConfig::clear_selected_audio_codec() {
  selected_audio_codec_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EStreamAudioCodec CNegotiatedConfig::_internal_selected_audio_codec() const {
  return static_cast< ::EStreamAudioCodec >(selected_audio_codec_);
}
inline ::EStreamAudioCodec CNegotiatedConfig::selected_audio_codec() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.selected_audio_codec)
  return _internal_selected_audio_codec();
}
inline void CNegotiatedConfig::_internal_set_selected_audio_codec(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  selected_audio_codec_ = value;
}
inline void CNegotiatedConfig::set_selected_audio_codec(::EStreamAudioCodec value) {
  _internal_set_selected_audio_codec(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.selected_audio_codec)
}

// optional .EStreamVideoCodec selected_video_codec = 3 [default = k_EStreamVideoCodecNone];
inline bool CNegotiatedConfig::_internal_has_selected_video_codec() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_selected_video_codec() const {
  return _internal_has_selected_video_codec();
}
inline void CNegotiatedConfig::clear_selected_video_codec() {
  selected_video_codec_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamVideoCodec CNegotiatedConfig::_internal_selected_video_codec() const {
  return static_cast< ::EStreamVideoCodec >(selected_video_codec_);
}
inline ::EStreamVideoCodec CNegotiatedConfig::selected_video_codec() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.selected_video_codec)
  return _internal_selected_video_codec();
}
inline void CNegotiatedConfig::_internal_set_selected_video_codec(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  selected_video_codec_ = value;
}
inline void CNegotiatedConfig::set_selected_video_codec(::EStreamVideoCodec value) {
  _internal_set_selected_video_codec(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.selected_video_codec)
}

// repeated .CStreamVideoMode available_video_modes = 4;
inline int CNegotiatedConfig::_internal_available_video_modes_size() const {
  return available_video_modes_.size();
}
inline int CNegotiatedConfig::available_video_modes_size() const {
  return _internal_available_video_modes_size();
}
inline void CNegotiatedConfig::clear_available_video_modes() {
  available_video_modes_.Clear();
}
inline ::CStreamVideoMode* CNegotiatedConfig::mutable_available_video_modes(int index) {
  // @@protoc_insertion_point(field_mutable:CNegotiatedConfig.available_video_modes)
  return available_video_modes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamVideoMode >*
CNegotiatedConfig::mutable_available_video_modes() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiatedConfig.available_video_modes)
  return &available_video_modes_;
}
inline const ::CStreamVideoMode& CNegotiatedConfig::_internal_available_video_modes(int index) const {
  return available_video_modes_.Get(index);
}
inline const ::CStreamVideoMode& CNegotiatedConfig::available_video_modes(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.available_video_modes)
  return _internal_available_video_modes(index);
}
inline ::CStreamVideoMode* CNegotiatedConfig::_internal_add_available_video_modes() {
  return available_video_modes_.Add();
}
inline ::CStreamVideoMode* CNegotiatedConfig::add_available_video_modes() {
  ::CStreamVideoMode* _add = _internal_add_available_video_modes();
  // @@protoc_insertion_point(field_add:CNegotiatedConfig.available_video_modes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamVideoMode >&
CNegotiatedConfig::available_video_modes() const {
  // @@protoc_insertion_point(field_list:CNegotiatedConfig.available_video_modes)
  return available_video_modes_;
}

// optional bool enable_remote_hid = 5;
inline bool CNegotiatedConfig::_internal_has_enable_remote_hid() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_enable_remote_hid() const {
  return _internal_has_enable_remote_hid();
}
inline void CNegotiatedConfig::clear_enable_remote_hid() {
  enable_remote_hid_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CNegotiatedConfig::_internal_enable_remote_hid() const {
  return enable_remote_hid_;
}
inline bool CNegotiatedConfig::enable_remote_hid() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.enable_remote_hid)
  return _internal_enable_remote_hid();
}
inline void CNegotiatedConfig::_internal_set_enable_remote_hid(bool value) {
  _has_bits_[0] |= 0x00000008u;
  enable_remote_hid_ = value;
}
inline void CNegotiatedConfig::set_enable_remote_hid(bool value) {
  _internal_set_enable_remote_hid(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.enable_remote_hid)
}

// optional bool enable_touch_input = 6;
inline bool CNegotiatedConfig::_internal_has_enable_touch_input() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_enable_touch_input() const {
  return _internal_has_enable_touch_input();
}
inline void CNegotiatedConfig::clear_enable_touch_input() {
  enable_touch_input_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CNegotiatedConfig::_internal_enable_touch_input() const {
  return enable_touch_input_;
}
inline bool CNegotiatedConfig::enable_touch_input() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.enable_touch_input)
  return _internal_enable_touch_input();
}
inline void CNegotiatedConfig::_internal_set_enable_touch_input(bool value) {
  _has_bits_[0] |= 0x00000010u;
  enable_touch_input_ = value;
}
inline void CNegotiatedConfig::set_enable_touch_input(bool value) {
  _internal_set_enable_touch_input(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.enable_touch_input)
}

// optional bool disable_client_cursor = 7;
inline bool CNegotiatedConfig::_internal_has_disable_client_cursor() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CNegotiatedConfig::has_disable_client_cursor() const {
  return _internal_has_disable_client_cursor();
}
inline void CNegotiatedConfig::clear_disable_client_cursor() {
  disable_client_cursor_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CNegotiatedConfig::_internal_disable_client_cursor() const {
  return disable_client_cursor_;
}
inline bool CNegotiatedConfig::disable_client_cursor() const {
  // @@protoc_insertion_point(field_get:CNegotiatedConfig.disable_client_cursor)
  return _internal_disable_client_cursor();
}
inline void CNegotiatedConfig::_internal_set_disable_client_cursor(bool value) {
  _has_bits_[0] |= 0x00000020u;
  disable_client_cursor_ = value;
}
inline void CNegotiatedConfig::set_disable_client_cursor(bool value) {
  _internal_set_disable_client_cursor(value);
  // @@protoc_insertion_point(field_set:CNegotiatedConfig.disable_client_cursor)
}

// -------------------------------------------------------------------

// CNegotiationInitMsg

// optional bool reliable_data = 1;
inline bool CNegotiationInitMsg::_internal_has_reliable_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CNegotiationInitMsg::has_reliable_data() const {
  return _internal_has_reliable_data();
}
inline void CNegotiationInitMsg::clear_reliable_data() {
  reliable_data_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CNegotiationInitMsg::_internal_reliable_data() const {
  return reliable_data_;
}
inline bool CNegotiationInitMsg::reliable_data() const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.reliable_data)
  return _internal_reliable_data();
}
inline void CNegotiationInitMsg::_internal_set_reliable_data(bool value) {
  _has_bits_[0] |= 0x00000001u;
  reliable_data_ = value;
}
inline void CNegotiationInitMsg::set_reliable_data(bool value) {
  _internal_set_reliable_data(value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.reliable_data)
}

// repeated .EStreamAudioCodec supported_audio_codecs = 2;
inline int CNegotiationInitMsg::_internal_supported_audio_codecs_size() const {
  return supported_audio_codecs_.size();
}
inline int CNegotiationInitMsg::supported_audio_codecs_size() const {
  return _internal_supported_audio_codecs_size();
}
inline void CNegotiationInitMsg::clear_supported_audio_codecs() {
  supported_audio_codecs_.Clear();
}
inline ::EStreamAudioCodec CNegotiationInitMsg::_internal_supported_audio_codecs(int index) const {
  return static_cast< ::EStreamAudioCodec >(supported_audio_codecs_.Get(index));
}
inline ::EStreamAudioCodec CNegotiationInitMsg::supported_audio_codecs(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supported_audio_codecs)
  return _internal_supported_audio_codecs(index);
}
inline void CNegotiationInitMsg::set_supported_audio_codecs(int index, ::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  supported_audio_codecs_.Set(index, value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supported_audio_codecs)
}
inline void CNegotiationInitMsg::_internal_add_supported_audio_codecs(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  supported_audio_codecs_.Add(value);
}
inline void CNegotiationInitMsg::add_supported_audio_codecs(::EStreamAudioCodec value) {
  _internal_add_supported_audio_codecs(value);
  // @@protoc_insertion_point(field_add:CNegotiationInitMsg.supported_audio_codecs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CNegotiationInitMsg::supported_audio_codecs() const {
  // @@protoc_insertion_point(field_list:CNegotiationInitMsg.supported_audio_codecs)
  return supported_audio_codecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CNegotiationInitMsg::_internal_mutable_supported_audio_codecs() {
  return &supported_audio_codecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CNegotiationInitMsg::mutable_supported_audio_codecs() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiationInitMsg.supported_audio_codecs)
  return _internal_mutable_supported_audio_codecs();
}

// repeated .EStreamVideoCodec supported_video_codecs = 3;
inline int CNegotiationInitMsg::_internal_supported_video_codecs_size() const {
  return supported_video_codecs_.size();
}
inline int CNegotiationInitMsg::supported_video_codecs_size() const {
  return _internal_supported_video_codecs_size();
}
inline void CNegotiationInitMsg::clear_supported_video_codecs() {
  supported_video_codecs_.Clear();
}
inline ::EStreamVideoCodec CNegotiationInitMsg::_internal_supported_video_codecs(int index) const {
  return static_cast< ::EStreamVideoCodec >(supported_video_codecs_.Get(index));
}
inline ::EStreamVideoCodec CNegotiationInitMsg::supported_video_codecs(int index) const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supported_video_codecs)
  return _internal_supported_video_codecs(index);
}
inline void CNegotiationInitMsg::set_supported_video_codecs(int index, ::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  supported_video_codecs_.Set(index, value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supported_video_codecs)
}
inline void CNegotiationInitMsg::_internal_add_supported_video_codecs(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  supported_video_codecs_.Add(value);
}
inline void CNegotiationInitMsg::add_supported_video_codecs(::EStreamVideoCodec value) {
  _internal_add_supported_video_codecs(value);
  // @@protoc_insertion_point(field_add:CNegotiationInitMsg.supported_video_codecs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>&
CNegotiationInitMsg::supported_video_codecs() const {
  // @@protoc_insertion_point(field_list:CNegotiationInitMsg.supported_video_codecs)
  return supported_video_codecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CNegotiationInitMsg::_internal_mutable_supported_video_codecs() {
  return &supported_video_codecs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField<int>*
CNegotiationInitMsg::mutable_supported_video_codecs() {
  // @@protoc_insertion_point(field_mutable_list:CNegotiationInitMsg.supported_video_codecs)
  return _internal_mutable_supported_video_codecs();
}

// optional bool supports_remote_hid = 4;
inline bool CNegotiationInitMsg::_internal_has_supports_remote_hid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CNegotiationInitMsg::has_supports_remote_hid() const {
  return _internal_has_supports_remote_hid();
}
inline void CNegotiationInitMsg::clear_supports_remote_hid() {
  supports_remote_hid_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CNegotiationInitMsg::_internal_supports_remote_hid() const {
  return supports_remote_hid_;
}
inline bool CNegotiationInitMsg::supports_remote_hid() const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supports_remote_hid)
  return _internal_supports_remote_hid();
}
inline void CNegotiationInitMsg::_internal_set_supports_remote_hid(bool value) {
  _has_bits_[0] |= 0x00000002u;
  supports_remote_hid_ = value;
}
inline void CNegotiationInitMsg::set_supports_remote_hid(bool value) {
  _internal_set_supports_remote_hid(value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supports_remote_hid)
}

// optional bool supports_touch_input = 5;
inline bool CNegotiationInitMsg::_internal_has_supports_touch_input() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CNegotiationInitMsg::has_supports_touch_input() const {
  return _internal_has_supports_touch_input();
}
inline void CNegotiationInitMsg::clear_supports_touch_input() {
  supports_touch_input_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CNegotiationInitMsg::_internal_supports_touch_input() const {
  return supports_touch_input_;
}
inline bool CNegotiationInitMsg::supports_touch_input() const {
  // @@protoc_insertion_point(field_get:CNegotiationInitMsg.supports_touch_input)
  return _internal_supports_touch_input();
}
inline void CNegotiationInitMsg::_internal_set_supports_touch_input(bool value) {
  _has_bits_[0] |= 0x00000004u;
  supports_touch_input_ = value;
}
inline void CNegotiationInitMsg::set_supports_touch_input(bool value) {
  _internal_set_supports_touch_input(value);
  // @@protoc_insertion_point(field_set:CNegotiationInitMsg.supports_touch_input)
}

// -------------------------------------------------------------------

// CNegotiationSetConfigMsg

// required .CNegotiatedConfig config = 1;
inline bool CNegotiationSetConfigMsg::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool CNegotiationSetConfigMsg::has_config() const {
  return _internal_has_config();
}
inline void CNegotiationSetConfigMsg::clear_config() {
  if (config_ != nullptr) config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CNegotiatedConfig& CNegotiationSetConfigMsg::_internal_config() const {
  const ::CNegotiatedConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::CNegotiatedConfig&>(
      ::_CNegotiatedConfig_default_instance_);
}
inline const ::CNegotiatedConfig& CNegotiationSetConfigMsg::config() const {
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.config)
  return _internal_config();
}
inline void CNegotiationSetConfigMsg::unsafe_arena_set_allocated_config(
    ::CNegotiatedConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CNegotiationSetConfigMsg.config)
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::release_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::CNegotiatedConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.config)
  _has_bits_[0] &= ~0x00000001u;
  ::CNegotiatedConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000001u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::CNegotiatedConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::CNegotiatedConfig* CNegotiationSetConfigMsg::mutable_config() {
  ::CNegotiatedConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.config)
  return _msg;
}
inline void CNegotiationSetConfigMsg::set_allocated_config(::CNegotiatedConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CNegotiatedConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.config)
}

// optional .CStreamingClientConfig streaming_client_config = 2;
inline bool CNegotiationSetConfigMsg::_internal_has_streaming_client_config() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || streaming_client_config_ != nullptr);
  return value;
}
inline bool CNegotiationSetConfigMsg::has_streaming_client_config() const {
  return _internal_has_streaming_client_config();
}
inline void CNegotiationSetConfigMsg::clear_streaming_client_config() {
  if (streaming_client_config_ != nullptr) streaming_client_config_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CStreamingClientConfig& CNegotiationSetConfigMsg::_internal_streaming_client_config() const {
  const ::CStreamingClientConfig* p = streaming_client_config_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingClientConfig&>(
      ::_CStreamingClientConfig_default_instance_);
}
inline const ::CStreamingClientConfig& CNegotiationSetConfigMsg::streaming_client_config() const {
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.streaming_client_config)
  return _internal_streaming_client_config();
}
inline void CNegotiationSetConfigMsg::unsafe_arena_set_allocated_streaming_client_config(
    ::CStreamingClientConfig* streaming_client_config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(streaming_client_config_);
  }
  streaming_client_config_ = streaming_client_config;
  if (streaming_client_config) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CNegotiationSetConfigMsg.streaming_client_config)
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::release_streaming_client_config() {
  _has_bits_[0] &= ~0x00000002u;
  ::CStreamingClientConfig* temp = streaming_client_config_;
  streaming_client_config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::unsafe_arena_release_streaming_client_config() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.streaming_client_config)
  _has_bits_[0] &= ~0x00000002u;
  ::CStreamingClientConfig* temp = streaming_client_config_;
  streaming_client_config_ = nullptr;
  return temp;
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::_internal_mutable_streaming_client_config() {
  _has_bits_[0] |= 0x00000002u;
  if (streaming_client_config_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingClientConfig>(GetArenaForAllocation());
    streaming_client_config_ = p;
  }
  return streaming_client_config_;
}
inline ::CStreamingClientConfig* CNegotiationSetConfigMsg::mutable_streaming_client_config() {
  ::CStreamingClientConfig* _msg = _internal_mutable_streaming_client_config();
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.streaming_client_config)
  return _msg;
}
inline void CNegotiationSetConfigMsg::set_allocated_streaming_client_config(::CStreamingClientConfig* streaming_client_config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete streaming_client_config_;
  }
  if (streaming_client_config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingClientConfig>::GetOwningArena(streaming_client_config);
    if (message_arena != submessage_arena) {
      streaming_client_config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streaming_client_config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  streaming_client_config_ = streaming_client_config;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.streaming_client_config)
}

// optional .CStreamingClientCaps streaming_client_caps = 3;
inline bool CNegotiationSetConfigMsg::_internal_has_streaming_client_caps() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || streaming_client_caps_ != nullptr);
  return value;
}
inline bool CNegotiationSetConfigMsg::has_streaming_client_caps() const {
  return _internal_has_streaming_client_caps();
}
inline void CNegotiationSetConfigMsg::clear_streaming_client_caps() {
  if (streaming_client_caps_ != nullptr) streaming_client_caps_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CStreamingClientCaps& CNegotiationSetConfigMsg::_internal_streaming_client_caps() const {
  const ::CStreamingClientCaps* p = streaming_client_caps_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingClientCaps&>(
      ::_CStreamingClientCaps_default_instance_);
}
inline const ::CStreamingClientCaps& CNegotiationSetConfigMsg::streaming_client_caps() const {
  // @@protoc_insertion_point(field_get:CNegotiationSetConfigMsg.streaming_client_caps)
  return _internal_streaming_client_caps();
}
inline void CNegotiationSetConfigMsg::unsafe_arena_set_allocated_streaming_client_caps(
    ::CStreamingClientCaps* streaming_client_caps) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(streaming_client_caps_);
  }
  streaming_client_caps_ = streaming_client_caps;
  if (streaming_client_caps) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CNegotiationSetConfigMsg.streaming_client_caps)
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::release_streaming_client_caps() {
  _has_bits_[0] &= ~0x00000004u;
  ::CStreamingClientCaps* temp = streaming_client_caps_;
  streaming_client_caps_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::unsafe_arena_release_streaming_client_caps() {
  // @@protoc_insertion_point(field_release:CNegotiationSetConfigMsg.streaming_client_caps)
  _has_bits_[0] &= ~0x00000004u;
  ::CStreamingClientCaps* temp = streaming_client_caps_;
  streaming_client_caps_ = nullptr;
  return temp;
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::_internal_mutable_streaming_client_caps() {
  _has_bits_[0] |= 0x00000004u;
  if (streaming_client_caps_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingClientCaps>(GetArenaForAllocation());
    streaming_client_caps_ = p;
  }
  return streaming_client_caps_;
}
inline ::CStreamingClientCaps* CNegotiationSetConfigMsg::mutable_streaming_client_caps() {
  ::CStreamingClientCaps* _msg = _internal_mutable_streaming_client_caps();
  // @@protoc_insertion_point(field_mutable:CNegotiationSetConfigMsg.streaming_client_caps)
  return _msg;
}
inline void CNegotiationSetConfigMsg::set_allocated_streaming_client_caps(::CStreamingClientCaps* streaming_client_caps) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete streaming_client_caps_;
  }
  if (streaming_client_caps) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingClientCaps>::GetOwningArena(streaming_client_caps);
    if (message_arena != submessage_arena) {
      streaming_client_caps = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, streaming_client_caps, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  streaming_client_caps_ = streaming_client_caps;
  // @@protoc_insertion_point(field_set_allocated:CNegotiationSetConfigMsg.streaming_client_caps)
}

// -------------------------------------------------------------------

// CNegotiationCompleteMsg

// -------------------------------------------------------------------

// CStartAudioDataMsg

// required uint32 channel = 2;
inline bool CStartAudioDataMsg::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStartAudioDataMsg::has_channel() const {
  return _internal_has_channel();
}
inline void CStartAudioDataMsg::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStartAudioDataMsg::_internal_channel() const {
  return channel_;
}
inline uint32_t CStartAudioDataMsg::channel() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.channel)
  return _internal_channel();
}
inline void CStartAudioDataMsg::_internal_set_channel(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  channel_ = value;
}
inline void CStartAudioDataMsg::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.channel)
}

// optional .EStreamAudioCodec codec = 3 [default = k_EStreamAudioCodecNone];
inline bool CStartAudioDataMsg::_internal_has_codec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStartAudioDataMsg::has_codec() const {
  return _internal_has_codec();
}
inline void CStartAudioDataMsg::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EStreamAudioCodec CStartAudioDataMsg::_internal_codec() const {
  return static_cast< ::EStreamAudioCodec >(codec_);
}
inline ::EStreamAudioCodec CStartAudioDataMsg::codec() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.codec)
  return _internal_codec();
}
inline void CStartAudioDataMsg::_internal_set_codec(::EStreamAudioCodec value) {
  assert(::EStreamAudioCodec_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  codec_ = value;
}
inline void CStartAudioDataMsg::set_codec(::EStreamAudioCodec value) {
  _internal_set_codec(value);
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.codec)
}

// optional bytes codec_data = 4;
inline bool CStartAudioDataMsg::_internal_has_codec_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStartAudioDataMsg::has_codec_data() const {
  return _internal_has_codec_data();
}
inline void CStartAudioDataMsg::clear_codec_data() {
  codec_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStartAudioDataMsg::codec_data() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.codec_data)
  return _internal_codec_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStartAudioDataMsg::set_codec_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 codec_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.codec_data)
}
inline std::string* CStartAudioDataMsg::mutable_codec_data() {
  std::string* _s = _internal_mutable_codec_data();
  // @@protoc_insertion_point(field_mutable:CStartAudioDataMsg.codec_data)
  return _s;
}
inline const std::string& CStartAudioDataMsg::_internal_codec_data() const {
  return codec_data_.Get();
}
inline void CStartAudioDataMsg::_internal_set_codec_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  codec_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStartAudioDataMsg::_internal_mutable_codec_data() {
  _has_bits_[0] |= 0x00000001u;
  return codec_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStartAudioDataMsg::release_codec_data() {
  // @@protoc_insertion_point(field_release:CStartAudioDataMsg.codec_data)
  if (!_internal_has_codec_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = codec_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codec_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStartAudioDataMsg::set_allocated_codec_data(std::string* codec_data) {
  if (codec_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  codec_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codec_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codec_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStartAudioDataMsg.codec_data)
}

// optional uint32 frequency = 5;
inline bool CStartAudioDataMsg::_internal_has_frequency() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStartAudioDataMsg::has_frequency() const {
  return _internal_has_frequency();
}
inline void CStartAudioDataMsg::clear_frequency() {
  frequency_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStartAudioDataMsg::_internal_frequency() const {
  return frequency_;
}
inline uint32_t CStartAudioDataMsg::frequency() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.frequency)
  return _internal_frequency();
}
inline void CStartAudioDataMsg::_internal_set_frequency(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  frequency_ = value;
}
inline void CStartAudioDataMsg::set_frequency(uint32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.frequency)
}

// optional uint32 channels = 6;
inline bool CStartAudioDataMsg::_internal_has_channels() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStartAudioDataMsg::has_channels() const {
  return _internal_has_channels();
}
inline void CStartAudioDataMsg::clear_channels() {
  channels_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CStartAudioDataMsg::_internal_channels() const {
  return channels_;
}
inline uint32_t CStartAudioDataMsg::channels() const {
  // @@protoc_insertion_point(field_get:CStartAudioDataMsg.channels)
  return _internal_channels();
}
inline void CStartAudioDataMsg::_internal_set_channels(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  channels_ = value;
}
inline void CStartAudioDataMsg::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:CStartAudioDataMsg.channels)
}

// -------------------------------------------------------------------

// CStopAudioDataMsg

// -------------------------------------------------------------------

// CStartVideoDataMsg

// required uint32 channel = 1;
inline bool CStartVideoDataMsg::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStartVideoDataMsg::has_channel() const {
  return _internal_has_channel();
}
inline void CStartVideoDataMsg::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CStartVideoDataMsg::_internal_channel() const {
  return channel_;
}
inline uint32_t CStartVideoDataMsg::channel() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.channel)
  return _internal_channel();
}
inline void CStartVideoDataMsg::_internal_set_channel(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  channel_ = value;
}
inline void CStartVideoDataMsg::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.channel)
}

// optional .EStreamVideoCodec codec = 2 [default = k_EStreamVideoCodecNone];
inline bool CStartVideoDataMsg::_internal_has_codec() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStartVideoDataMsg::has_codec() const {
  return _internal_has_codec();
}
inline void CStartVideoDataMsg::clear_codec() {
  codec_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EStreamVideoCodec CStartVideoDataMsg::_internal_codec() const {
  return static_cast< ::EStreamVideoCodec >(codec_);
}
inline ::EStreamVideoCodec CStartVideoDataMsg::codec() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.codec)
  return _internal_codec();
}
inline void CStartVideoDataMsg::_internal_set_codec(::EStreamVideoCodec value) {
  assert(::EStreamVideoCodec_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  codec_ = value;
}
inline void CStartVideoDataMsg::set_codec(::EStreamVideoCodec value) {
  _internal_set_codec(value);
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.codec)
}

// optional bytes codec_data = 3;
inline bool CStartVideoDataMsg::_internal_has_codec_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStartVideoDataMsg::has_codec_data() const {
  return _internal_has_codec_data();
}
inline void CStartVideoDataMsg::clear_codec_data() {
  codec_data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CStartVideoDataMsg::codec_data() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.codec_data)
  return _internal_codec_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CStartVideoDataMsg::set_codec_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 codec_data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.codec_data)
}
inline std::string* CStartVideoDataMsg::mutable_codec_data() {
  std::string* _s = _internal_mutable_codec_data();
  // @@protoc_insertion_point(field_mutable:CStartVideoDataMsg.codec_data)
  return _s;
}
inline const std::string& CStartVideoDataMsg::_internal_codec_data() const {
  return codec_data_.Get();
}
inline void CStartVideoDataMsg::_internal_set_codec_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  codec_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CStartVideoDataMsg::_internal_mutable_codec_data() {
  _has_bits_[0] |= 0x00000001u;
  return codec_data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CStartVideoDataMsg::release_codec_data() {
  // @@protoc_insertion_point(field_release:CStartVideoDataMsg.codec_data)
  if (!_internal_has_codec_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = codec_data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codec_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CStartVideoDataMsg::set_allocated_codec_data(std::string* codec_data) {
  if (codec_data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  codec_data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), codec_data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (codec_data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    codec_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CStartVideoDataMsg.codec_data)
}

// optional uint32 width = 4;
inline bool CStartVideoDataMsg::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStartVideoDataMsg::has_width() const {
  return _internal_has_width();
}
inline void CStartVideoDataMsg::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CStartVideoDataMsg::_internal_width() const {
  return width_;
}
inline uint32_t CStartVideoDataMsg::width() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.width)
  return _internal_width();
}
inline void CStartVideoDataMsg::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  width_ = value;
}
inline void CStartVideoDataMsg::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.width)
}

// optional uint32 height = 5;
inline bool CStartVideoDataMsg::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStartVideoDataMsg::has_height() const {
  return _internal_has_height();
}
inline void CStartVideoDataMsg::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CStartVideoDataMsg::_internal_height() const {
  return height_;
}
inline uint32_t CStartVideoDataMsg::height() const {
  // @@protoc_insertion_point(field_get:CStartVideoDataMsg.height)
  return _internal_height();
}
inline void CStartVideoDataMsg::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  height_ = value;
}
inline void CStartVideoDataMsg::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CStartVideoDataMsg.height)
}

// -------------------------------------------------------------------

// CStopVideoDataMsg

// -------------------------------------------------------------------

// CStartNeptuneDataMsg

// required uint32 channel = 1;
inline bool CStartNeptuneDataMsg::_internal_has_channel() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStartNeptuneDataMsg::has_channel() const {
  return _internal_has_channel();
}
inline void CStartNeptuneDataMsg::clear_channel() {
  channel_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CStartNeptuneDataMsg::_internal_channel() const {
  return channel_;
}
inline uint32_t CStartNeptuneDataMsg::channel() const {
  // @@protoc_insertion_point(field_get:CStartNeptuneDataMsg.channel)
  return _internal_channel();
}
inline void CStartNeptuneDataMsg::_internal_set_channel(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  channel_ = value;
}
inline void CStartNeptuneDataMsg::set_channel(uint32_t value) {
  _internal_set_channel(value);
  // @@protoc_insertion_point(field_set:CStartNeptuneDataMsg.channel)
}

// -------------------------------------------------------------------

// CStopNeptuneDataMsg

// -------------------------------------------------------------------

// CRecordedInput

// optional .EStreamControlMessage type = 1 [default = k_EStreamControlAuthenticationRequest];
inline bool CRecordedInput::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CRecordedInput::has_type() const {
  return _internal_has_type();
}
inline void CRecordedInput::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamControlMessage CRecordedInput::_internal_type() const {
  return static_cast< ::EStreamControlMessage >(type_);
}
inline ::EStreamControlMessage CRecordedInput::type() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.type)
  return _internal_type();
}
inline void CRecordedInput::_internal_set_type(::EStreamControlMessage value) {
  assert(::EStreamControlMessage_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void CRecordedInput::set_type(::EStreamControlMessage value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CRecordedInput.type)
}

// optional uint32 timestamp = 2;
inline bool CRecordedInput::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CRecordedInput::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CRecordedInput::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CRecordedInput::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t CRecordedInput::timestamp() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.timestamp)
  return _internal_timestamp();
}
inline void CRecordedInput::_internal_set_timestamp(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  timestamp_ = value;
}
inline void CRecordedInput::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CRecordedInput.timestamp)
}

// .CInputTouchFingerDownMsg finger_down = 3;
inline bool CRecordedInput::_internal_has_finger_down() const {
  return data_case() == kFingerDown;
}
inline bool CRecordedInput::has_finger_down() const {
  return _internal_has_finger_down();
}
inline void CRecordedInput::set_has_finger_down() {
  _oneof_case_[0] = kFingerDown;
}
inline void CRecordedInput::clear_finger_down() {
  if (_internal_has_finger_down()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.finger_down_;
    }
    clear_has_data();
  }
}
inline ::CInputTouchFingerDownMsg* CRecordedInput::release_finger_down() {
  // @@protoc_insertion_point(field_release:CRecordedInput.finger_down)
  if (_internal_has_finger_down()) {
    clear_has_data();
      ::CInputTouchFingerDownMsg* temp = data_.finger_down_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.finger_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputTouchFingerDownMsg& CRecordedInput::_internal_finger_down() const {
  return _internal_has_finger_down()
      ? *data_.finger_down_
      : reinterpret_cast< ::CInputTouchFingerDownMsg&>(::_CInputTouchFingerDownMsg_default_instance_);
}
inline const ::CInputTouchFingerDownMsg& CRecordedInput::finger_down() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.finger_down)
  return _internal_finger_down();
}
inline ::CInputTouchFingerDownMsg* CRecordedInput::unsafe_arena_release_finger_down() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.finger_down)
  if (_internal_has_finger_down()) {
    clear_has_data();
    ::CInputTouchFingerDownMsg* temp = data_.finger_down_;
    data_.finger_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_finger_down(::CInputTouchFingerDownMsg* finger_down) {
  clear_data();
  if (finger_down) {
    set_has_finger_down();
    data_.finger_down_ = finger_down;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.finger_down)
}
inline ::CInputTouchFingerDownMsg* CRecordedInput::_internal_mutable_finger_down() {
  if (!_internal_has_finger_down()) {
    clear_data();
    set_has_finger_down();
    data_.finger_down_ = CreateMaybeMessage< ::CInputTouchFingerDownMsg >(GetArenaForAllocation());
  }
  return data_.finger_down_;
}
inline ::CInputTouchFingerDownMsg* CRecordedInput::mutable_finger_down() {
  ::CInputTouchFingerDownMsg* _msg = _internal_mutable_finger_down();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.finger_down)
  return _msg;
}

// .CInputTouchFingerMotionMsg finger_motion = 4;
inline bool CRecordedInput::_internal_has_finger_motion() const {
  return data_case() == kFingerMotion;
}
inline bool CRecordedInput::has_finger_motion() const {
  return _internal_has_finger_motion();
}
inline void CRecordedInput::set_has_finger_motion() {
  _oneof_case_[0] = kFingerMotion;
}
inline void CRecordedInput::clear_finger_motion() {
  if (_internal_has_finger_motion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.finger_motion_;
    }
    clear_has_data();
  }
}
inline ::CInputTouchFingerMotionMsg* CRecordedInput::release_finger_motion() {
  // @@protoc_insertion_point(field_release:CRecordedInput.finger_motion)
  if (_internal_has_finger_motion()) {
    clear_has_data();
      ::CInputTouchFingerMotionMsg* temp = data_.finger_motion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.finger_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputTouchFingerMotionMsg& CRecordedInput::_internal_finger_motion() const {
  return _internal_has_finger_motion()
      ? *data_.finger_motion_
      : reinterpret_cast< ::CInputTouchFingerMotionMsg&>(::_CInputTouchFingerMotionMsg_default_instance_);
}
inline const ::CInputTouchFingerMotionMsg& CRecordedInput::finger_motion() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.finger_motion)
  return _internal_finger_motion();
}
inline ::CInputTouchFingerMotionMsg* CRecordedInput::unsafe_arena_release_finger_motion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.finger_motion)
  if (_internal_has_finger_motion()) {
    clear_has_data();
    ::CInputTouchFingerMotionMsg* temp = data_.finger_motion_;
    data_.finger_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_finger_motion(::CInputTouchFingerMotionMsg* finger_motion) {
  clear_data();
  if (finger_motion) {
    set_has_finger_motion();
    data_.finger_motion_ = finger_motion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.finger_motion)
}
inline ::CInputTouchFingerMotionMsg* CRecordedInput::_internal_mutable_finger_motion() {
  if (!_internal_has_finger_motion()) {
    clear_data();
    set_has_finger_motion();
    data_.finger_motion_ = CreateMaybeMessage< ::CInputTouchFingerMotionMsg >(GetArenaForAllocation());
  }
  return data_.finger_motion_;
}
inline ::CInputTouchFingerMotionMsg* CRecordedInput::mutable_finger_motion() {
  ::CInputTouchFingerMotionMsg* _msg = _internal_mutable_finger_motion();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.finger_motion)
  return _msg;
}

// .CInputTouchFingerUpMsg finger_up = 5;
inline bool CRecordedInput::_internal_has_finger_up() const {
  return data_case() == kFingerUp;
}
inline bool CRecordedInput::has_finger_up() const {
  return _internal_has_finger_up();
}
inline void CRecordedInput::set_has_finger_up() {
  _oneof_case_[0] = kFingerUp;
}
inline void CRecordedInput::clear_finger_up() {
  if (_internal_has_finger_up()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.finger_up_;
    }
    clear_has_data();
  }
}
inline ::CInputTouchFingerUpMsg* CRecordedInput::release_finger_up() {
  // @@protoc_insertion_point(field_release:CRecordedInput.finger_up)
  if (_internal_has_finger_up()) {
    clear_has_data();
      ::CInputTouchFingerUpMsg* temp = data_.finger_up_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.finger_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputTouchFingerUpMsg& CRecordedInput::_internal_finger_up() const {
  return _internal_has_finger_up()
      ? *data_.finger_up_
      : reinterpret_cast< ::CInputTouchFingerUpMsg&>(::_CInputTouchFingerUpMsg_default_instance_);
}
inline const ::CInputTouchFingerUpMsg& CRecordedInput::finger_up() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.finger_up)
  return _internal_finger_up();
}
inline ::CInputTouchFingerUpMsg* CRecordedInput::unsafe_arena_release_finger_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.finger_up)
  if (_internal_has_finger_up()) {
    clear_has_data();
    ::CInputTouchFingerUpMsg* temp = data_.finger_up_;
    data_.finger_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_finger_up(::CInputTouchFingerUpMsg* finger_up) {
  clear_data();
  if (finger_up) {
    set_has_finger_up();
    data_.finger_up_ = finger_up;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.finger_up)
}
inline ::CInputTouchFingerUpMsg* CRecordedInput::_internal_mutable_finger_up() {
  if (!_internal_has_finger_up()) {
    clear_data();
    set_has_finger_up();
    data_.finger_up_ = CreateMaybeMessage< ::CInputTouchFingerUpMsg >(GetArenaForAllocation());
  }
  return data_.finger_up_;
}
inline ::CInputTouchFingerUpMsg* CRecordedInput::mutable_finger_up() {
  ::CInputTouchFingerUpMsg* _msg = _internal_mutable_finger_up();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.finger_up)
  return _msg;
}

// .CInputMouseMotionMsg mouse_motion = 6;
inline bool CRecordedInput::_internal_has_mouse_motion() const {
  return data_case() == kMouseMotion;
}
inline bool CRecordedInput::has_mouse_motion() const {
  return _internal_has_mouse_motion();
}
inline void CRecordedInput::set_has_mouse_motion() {
  _oneof_case_[0] = kMouseMotion;
}
inline void CRecordedInput::clear_mouse_motion() {
  if (_internal_has_mouse_motion()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.mouse_motion_;
    }
    clear_has_data();
  }
}
inline ::CInputMouseMotionMsg* CRecordedInput::release_mouse_motion() {
  // @@protoc_insertion_point(field_release:CRecordedInput.mouse_motion)
  if (_internal_has_mouse_motion()) {
    clear_has_data();
      ::CInputMouseMotionMsg* temp = data_.mouse_motion_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputMouseMotionMsg& CRecordedInput::_internal_mouse_motion() const {
  return _internal_has_mouse_motion()
      ? *data_.mouse_motion_
      : reinterpret_cast< ::CInputMouseMotionMsg&>(::_CInputMouseMotionMsg_default_instance_);
}
inline const ::CInputMouseMotionMsg& CRecordedInput::mouse_motion() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.mouse_motion)
  return _internal_mouse_motion();
}
inline ::CInputMouseMotionMsg* CRecordedInput::unsafe_arena_release_mouse_motion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.mouse_motion)
  if (_internal_has_mouse_motion()) {
    clear_has_data();
    ::CInputMouseMotionMsg* temp = data_.mouse_motion_;
    data_.mouse_motion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_mouse_motion(::CInputMouseMotionMsg* mouse_motion) {
  clear_data();
  if (mouse_motion) {
    set_has_mouse_motion();
    data_.mouse_motion_ = mouse_motion;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.mouse_motion)
}
inline ::CInputMouseMotionMsg* CRecordedInput::_internal_mutable_mouse_motion() {
  if (!_internal_has_mouse_motion()) {
    clear_data();
    set_has_mouse_motion();
    data_.mouse_motion_ = CreateMaybeMessage< ::CInputMouseMotionMsg >(GetArenaForAllocation());
  }
  return data_.mouse_motion_;
}
inline ::CInputMouseMotionMsg* CRecordedInput::mutable_mouse_motion() {
  ::CInputMouseMotionMsg* _msg = _internal_mutable_mouse_motion();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.mouse_motion)
  return _msg;
}

// .CInputMouseWheelMsg mouse_wheel = 7;
inline bool CRecordedInput::_internal_has_mouse_wheel() const {
  return data_case() == kMouseWheel;
}
inline bool CRecordedInput::has_mouse_wheel() const {
  return _internal_has_mouse_wheel();
}
inline void CRecordedInput::set_has_mouse_wheel() {
  _oneof_case_[0] = kMouseWheel;
}
inline void CRecordedInput::clear_mouse_wheel() {
  if (_internal_has_mouse_wheel()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.mouse_wheel_;
    }
    clear_has_data();
  }
}
inline ::CInputMouseWheelMsg* CRecordedInput::release_mouse_wheel() {
  // @@protoc_insertion_point(field_release:CRecordedInput.mouse_wheel)
  if (_internal_has_mouse_wheel()) {
    clear_has_data();
      ::CInputMouseWheelMsg* temp = data_.mouse_wheel_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_wheel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputMouseWheelMsg& CRecordedInput::_internal_mouse_wheel() const {
  return _internal_has_mouse_wheel()
      ? *data_.mouse_wheel_
      : reinterpret_cast< ::CInputMouseWheelMsg&>(::_CInputMouseWheelMsg_default_instance_);
}
inline const ::CInputMouseWheelMsg& CRecordedInput::mouse_wheel() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.mouse_wheel)
  return _internal_mouse_wheel();
}
inline ::CInputMouseWheelMsg* CRecordedInput::unsafe_arena_release_mouse_wheel() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.mouse_wheel)
  if (_internal_has_mouse_wheel()) {
    clear_has_data();
    ::CInputMouseWheelMsg* temp = data_.mouse_wheel_;
    data_.mouse_wheel_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_mouse_wheel(::CInputMouseWheelMsg* mouse_wheel) {
  clear_data();
  if (mouse_wheel) {
    set_has_mouse_wheel();
    data_.mouse_wheel_ = mouse_wheel;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.mouse_wheel)
}
inline ::CInputMouseWheelMsg* CRecordedInput::_internal_mutable_mouse_wheel() {
  if (!_internal_has_mouse_wheel()) {
    clear_data();
    set_has_mouse_wheel();
    data_.mouse_wheel_ = CreateMaybeMessage< ::CInputMouseWheelMsg >(GetArenaForAllocation());
  }
  return data_.mouse_wheel_;
}
inline ::CInputMouseWheelMsg* CRecordedInput::mutable_mouse_wheel() {
  ::CInputMouseWheelMsg* _msg = _internal_mutable_mouse_wheel();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.mouse_wheel)
  return _msg;
}

// .CInputMouseDownMsg mouse_down = 8;
inline bool CRecordedInput::_internal_has_mouse_down() const {
  return data_case() == kMouseDown;
}
inline bool CRecordedInput::has_mouse_down() const {
  return _internal_has_mouse_down();
}
inline void CRecordedInput::set_has_mouse_down() {
  _oneof_case_[0] = kMouseDown;
}
inline void CRecordedInput::clear_mouse_down() {
  if (_internal_has_mouse_down()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.mouse_down_;
    }
    clear_has_data();
  }
}
inline ::CInputMouseDownMsg* CRecordedInput::release_mouse_down() {
  // @@protoc_insertion_point(field_release:CRecordedInput.mouse_down)
  if (_internal_has_mouse_down()) {
    clear_has_data();
      ::CInputMouseDownMsg* temp = data_.mouse_down_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputMouseDownMsg& CRecordedInput::_internal_mouse_down() const {
  return _internal_has_mouse_down()
      ? *data_.mouse_down_
      : reinterpret_cast< ::CInputMouseDownMsg&>(::_CInputMouseDownMsg_default_instance_);
}
inline const ::CInputMouseDownMsg& CRecordedInput::mouse_down() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.mouse_down)
  return _internal_mouse_down();
}
inline ::CInputMouseDownMsg* CRecordedInput::unsafe_arena_release_mouse_down() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.mouse_down)
  if (_internal_has_mouse_down()) {
    clear_has_data();
    ::CInputMouseDownMsg* temp = data_.mouse_down_;
    data_.mouse_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_mouse_down(::CInputMouseDownMsg* mouse_down) {
  clear_data();
  if (mouse_down) {
    set_has_mouse_down();
    data_.mouse_down_ = mouse_down;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.mouse_down)
}
inline ::CInputMouseDownMsg* CRecordedInput::_internal_mutable_mouse_down() {
  if (!_internal_has_mouse_down()) {
    clear_data();
    set_has_mouse_down();
    data_.mouse_down_ = CreateMaybeMessage< ::CInputMouseDownMsg >(GetArenaForAllocation());
  }
  return data_.mouse_down_;
}
inline ::CInputMouseDownMsg* CRecordedInput::mutable_mouse_down() {
  ::CInputMouseDownMsg* _msg = _internal_mutable_mouse_down();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.mouse_down)
  return _msg;
}

// .CInputMouseUpMsg mouse_up = 9;
inline bool CRecordedInput::_internal_has_mouse_up() const {
  return data_case() == kMouseUp;
}
inline bool CRecordedInput::has_mouse_up() const {
  return _internal_has_mouse_up();
}
inline void CRecordedInput::set_has_mouse_up() {
  _oneof_case_[0] = kMouseUp;
}
inline void CRecordedInput::clear_mouse_up() {
  if (_internal_has_mouse_up()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.mouse_up_;
    }
    clear_has_data();
  }
}
inline ::CInputMouseUpMsg* CRecordedInput::release_mouse_up() {
  // @@protoc_insertion_point(field_release:CRecordedInput.mouse_up)
  if (_internal_has_mouse_up()) {
    clear_has_data();
      ::CInputMouseUpMsg* temp = data_.mouse_up_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.mouse_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputMouseUpMsg& CRecordedInput::_internal_mouse_up() const {
  return _internal_has_mouse_up()
      ? *data_.mouse_up_
      : reinterpret_cast< ::CInputMouseUpMsg&>(::_CInputMouseUpMsg_default_instance_);
}
inline const ::CInputMouseUpMsg& CRecordedInput::mouse_up() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.mouse_up)
  return _internal_mouse_up();
}
inline ::CInputMouseUpMsg* CRecordedInput::unsafe_arena_release_mouse_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.mouse_up)
  if (_internal_has_mouse_up()) {
    clear_has_data();
    ::CInputMouseUpMsg* temp = data_.mouse_up_;
    data_.mouse_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_mouse_up(::CInputMouseUpMsg* mouse_up) {
  clear_data();
  if (mouse_up) {
    set_has_mouse_up();
    data_.mouse_up_ = mouse_up;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.mouse_up)
}
inline ::CInputMouseUpMsg* CRecordedInput::_internal_mutable_mouse_up() {
  if (!_internal_has_mouse_up()) {
    clear_data();
    set_has_mouse_up();
    data_.mouse_up_ = CreateMaybeMessage< ::CInputMouseUpMsg >(GetArenaForAllocation());
  }
  return data_.mouse_up_;
}
inline ::CInputMouseUpMsg* CRecordedInput::mutable_mouse_up() {
  ::CInputMouseUpMsg* _msg = _internal_mutable_mouse_up();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.mouse_up)
  return _msg;
}

// .CInputKeyDownMsg key_down = 10;
inline bool CRecordedInput::_internal_has_key_down() const {
  return data_case() == kKeyDown;
}
inline bool CRecordedInput::has_key_down() const {
  return _internal_has_key_down();
}
inline void CRecordedInput::set_has_key_down() {
  _oneof_case_[0] = kKeyDown;
}
inline void CRecordedInput::clear_key_down() {
  if (_internal_has_key_down()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.key_down_;
    }
    clear_has_data();
  }
}
inline ::CInputKeyDownMsg* CRecordedInput::release_key_down() {
  // @@protoc_insertion_point(field_release:CRecordedInput.key_down)
  if (_internal_has_key_down()) {
    clear_has_data();
      ::CInputKeyDownMsg* temp = data_.key_down_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.key_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputKeyDownMsg& CRecordedInput::_internal_key_down() const {
  return _internal_has_key_down()
      ? *data_.key_down_
      : reinterpret_cast< ::CInputKeyDownMsg&>(::_CInputKeyDownMsg_default_instance_);
}
inline const ::CInputKeyDownMsg& CRecordedInput::key_down() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.key_down)
  return _internal_key_down();
}
inline ::CInputKeyDownMsg* CRecordedInput::unsafe_arena_release_key_down() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.key_down)
  if (_internal_has_key_down()) {
    clear_has_data();
    ::CInputKeyDownMsg* temp = data_.key_down_;
    data_.key_down_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_key_down(::CInputKeyDownMsg* key_down) {
  clear_data();
  if (key_down) {
    set_has_key_down();
    data_.key_down_ = key_down;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.key_down)
}
inline ::CInputKeyDownMsg* CRecordedInput::_internal_mutable_key_down() {
  if (!_internal_has_key_down()) {
    clear_data();
    set_has_key_down();
    data_.key_down_ = CreateMaybeMessage< ::CInputKeyDownMsg >(GetArenaForAllocation());
  }
  return data_.key_down_;
}
inline ::CInputKeyDownMsg* CRecordedInput::mutable_key_down() {
  ::CInputKeyDownMsg* _msg = _internal_mutable_key_down();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.key_down)
  return _msg;
}

// .CInputKeyUpMsg key_up = 11;
inline bool CRecordedInput::_internal_has_key_up() const {
  return data_case() == kKeyUp;
}
inline bool CRecordedInput::has_key_up() const {
  return _internal_has_key_up();
}
inline void CRecordedInput::set_has_key_up() {
  _oneof_case_[0] = kKeyUp;
}
inline void CRecordedInput::clear_key_up() {
  if (_internal_has_key_up()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.key_up_;
    }
    clear_has_data();
  }
}
inline ::CInputKeyUpMsg* CRecordedInput::release_key_up() {
  // @@protoc_insertion_point(field_release:CRecordedInput.key_up)
  if (_internal_has_key_up()) {
    clear_has_data();
      ::CInputKeyUpMsg* temp = data_.key_up_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.key_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputKeyUpMsg& CRecordedInput::_internal_key_up() const {
  return _internal_has_key_up()
      ? *data_.key_up_
      : reinterpret_cast< ::CInputKeyUpMsg&>(::_CInputKeyUpMsg_default_instance_);
}
inline const ::CInputKeyUpMsg& CRecordedInput::key_up() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.key_up)
  return _internal_key_up();
}
inline ::CInputKeyUpMsg* CRecordedInput::unsafe_arena_release_key_up() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.key_up)
  if (_internal_has_key_up()) {
    clear_has_data();
    ::CInputKeyUpMsg* temp = data_.key_up_;
    data_.key_up_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_key_up(::CInputKeyUpMsg* key_up) {
  clear_data();
  if (key_up) {
    set_has_key_up();
    data_.key_up_ = key_up;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.key_up)
}
inline ::CInputKeyUpMsg* CRecordedInput::_internal_mutable_key_up() {
  if (!_internal_has_key_up()) {
    clear_data();
    set_has_key_up();
    data_.key_up_ = CreateMaybeMessage< ::CInputKeyUpMsg >(GetArenaForAllocation());
  }
  return data_.key_up_;
}
inline ::CInputKeyUpMsg* CRecordedInput::mutable_key_up() {
  ::CInputKeyUpMsg* _msg = _internal_mutable_key_up();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.key_up)
  return _msg;
}

// .CInputTextMsg text = 12;
inline bool CRecordedInput::_internal_has_text() const {
  return data_case() == kText;
}
inline bool CRecordedInput::has_text() const {
  return _internal_has_text();
}
inline void CRecordedInput::set_has_text() {
  _oneof_case_[0] = kText;
}
inline void CRecordedInput::clear_text() {
  if (_internal_has_text()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.text_;
    }
    clear_has_data();
  }
}
inline ::CInputTextMsg* CRecordedInput::release_text() {
  // @@protoc_insertion_point(field_release:CRecordedInput.text)
  if (_internal_has_text()) {
    clear_has_data();
      ::CInputTextMsg* temp = data_.text_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CInputTextMsg& CRecordedInput::_internal_text() const {
  return _internal_has_text()
      ? *data_.text_
      : reinterpret_cast< ::CInputTextMsg&>(::_CInputTextMsg_default_instance_);
}
inline const ::CInputTextMsg& CRecordedInput::text() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.text)
  return _internal_text();
}
inline ::CInputTextMsg* CRecordedInput::unsafe_arena_release_text() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.text)
  if (_internal_has_text()) {
    clear_has_data();
    ::CInputTextMsg* temp = data_.text_;
    data_.text_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_text(::CInputTextMsg* text) {
  clear_data();
  if (text) {
    set_has_text();
    data_.text_ = text;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.text)
}
inline ::CInputTextMsg* CRecordedInput::_internal_mutable_text() {
  if (!_internal_has_text()) {
    clear_data();
    set_has_text();
    data_.text_ = CreateMaybeMessage< ::CInputTextMsg >(GetArenaForAllocation());
  }
  return data_.text_;
}
inline ::CInputTextMsg* CRecordedInput::mutable_text() {
  ::CInputTextMsg* _msg = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.text)
  return _msg;
}

// .CRemoteHIDMsg hid = 13;
inline bool CRecordedInput::_internal_has_hid() const {
  return data_case() == kHid;
}
inline bool CRecordedInput::has_hid() const {
  return _internal_has_hid();
}
inline void CRecordedInput::set_has_hid() {
  _oneof_case_[0] = kHid;
}
inline void CRecordedInput::clear_hid() {
  if (_internal_has_hid()) {
    if (GetArenaForAllocation() == nullptr) {
      delete data_.hid_;
    }
    clear_has_data();
  }
}
inline ::CRemoteHIDMsg* CRecordedInput::release_hid() {
  // @@protoc_insertion_point(field_release:CRecordedInput.hid)
  if (_internal_has_hid()) {
    clear_has_data();
      ::CRemoteHIDMsg* temp = data_.hid_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    data_.hid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CRemoteHIDMsg& CRecordedInput::_internal_hid() const {
  return _internal_has_hid()
      ? *data_.hid_
      : reinterpret_cast< ::CRemoteHIDMsg&>(::_CRemoteHIDMsg_default_instance_);
}
inline const ::CRemoteHIDMsg& CRecordedInput::hid() const {
  // @@protoc_insertion_point(field_get:CRecordedInput.hid)
  return _internal_hid();
}
inline ::CRemoteHIDMsg* CRecordedInput::unsafe_arena_release_hid() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CRecordedInput.hid)
  if (_internal_has_hid()) {
    clear_has_data();
    ::CRemoteHIDMsg* temp = data_.hid_;
    data_.hid_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CRecordedInput::unsafe_arena_set_allocated_hid(::CRemoteHIDMsg* hid) {
  clear_data();
  if (hid) {
    set_has_hid();
    data_.hid_ = hid;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CRecordedInput.hid)
}
inline ::CRemoteHIDMsg* CRecordedInput::_internal_mutable_hid() {
  if (!_internal_has_hid()) {
    clear_data();
    set_has_hid();
    data_.hid_ = CreateMaybeMessage< ::CRemoteHIDMsg >(GetArenaForAllocation());
  }
  return data_.hid_;
}
inline ::CRemoteHIDMsg* CRecordedInput::mutable_hid() {
  ::CRemoteHIDMsg* _msg = _internal_mutable_hid();
  // @@protoc_insertion_point(field_mutable:CRecordedInput.hid)
  return _msg;
}

inline bool CRecordedInput::has_data() const {
  return data_case() != DATA_NOT_SET;
}
inline void CRecordedInput::clear_has_data() {
  _oneof_case_[0] = DATA_NOT_SET;
}
inline CRecordedInput::DataCase CRecordedInput::data_case() const {
  return CRecordedInput::DataCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CRecordedInputStream

// repeated .CRecordedInput entries = 1;
inline int CRecordedInputStream::_internal_entries_size() const {
  return entries_.size();
}
inline int CRecordedInputStream::entries_size() const {
  return _internal_entries_size();
}
inline void CRecordedInputStream::clear_entries() {
  entries_.Clear();
}
inline ::CRecordedInput* CRecordedInputStream::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CRecordedInputStream.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRecordedInput >*
CRecordedInputStream::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:CRecordedInputStream.entries)
  return &entries_;
}
inline const ::CRecordedInput& CRecordedInputStream::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::CRecordedInput& CRecordedInputStream::entries(int index) const {
  // @@protoc_insertion_point(field_get:CRecordedInputStream.entries)
  return _internal_entries(index);
}
inline ::CRecordedInput* CRecordedInputStream::_internal_add_entries() {
  return entries_.Add();
}
inline ::CRecordedInput* CRecordedInputStream::add_entries() {
  ::CRecordedInput* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:CRecordedInputStream.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRecordedInput >&
CRecordedInputStream::entries() const {
  // @@protoc_insertion_point(field_list:CRecordedInputStream.entries)
  return entries_;
}

// -------------------------------------------------------------------

// CInputLatencyTestMsg

// required uint32 input_mark = 1;
inline bool CInputLatencyTestMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputLatencyTestMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputLatencyTestMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputLatencyTestMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputLatencyTestMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputLatencyTestMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputLatencyTestMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputLatencyTestMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputLatencyTestMsg.input_mark)
}

// optional uint32 color = 2;
inline bool CInputLatencyTestMsg::_internal_has_color() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputLatencyTestMsg::has_color() const {
  return _internal_has_color();
}
inline void CInputLatencyTestMsg::clear_color() {
  color_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputLatencyTestMsg::_internal_color() const {
  return color_;
}
inline uint32_t CInputLatencyTestMsg::color() const {
  // @@protoc_insertion_point(field_get:CInputLatencyTestMsg.color)
  return _internal_color();
}
inline void CInputLatencyTestMsg::_internal_set_color(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  color_ = value;
}
inline void CInputLatencyTestMsg::set_color(uint32_t value) {
  _internal_set_color(value);
  // @@protoc_insertion_point(field_set:CInputLatencyTestMsg.color)
}

// -------------------------------------------------------------------

// CInputTouchFingerDownMsg

// optional uint32 input_mark = 1;
inline bool CInputTouchFingerDownMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputTouchFingerDownMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputTouchFingerDownMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputTouchFingerDownMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputTouchFingerDownMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerDownMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputTouchFingerDownMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  input_mark_ = value;
}
inline void CInputTouchFingerDownMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerDownMsg.input_mark)
}

// optional uint64 fingerid = 2;
inline bool CInputTouchFingerDownMsg::_internal_has_fingerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputTouchFingerDownMsg::has_fingerid() const {
  return _internal_has_fingerid();
}
inline void CInputTouchFingerDownMsg::clear_fingerid() {
  fingerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CInputTouchFingerDownMsg::_internal_fingerid() const {
  return fingerid_;
}
inline uint64_t CInputTouchFingerDownMsg::fingerid() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerDownMsg.fingerid)
  return _internal_fingerid();
}
inline void CInputTouchFingerDownMsg::_internal_set_fingerid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  fingerid_ = value;
}
inline void CInputTouchFingerDownMsg::set_fingerid(uint64_t value) {
  _internal_set_fingerid(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerDownMsg.fingerid)
}

// optional float x_normalized = 3;
inline bool CInputTouchFingerDownMsg::_internal_has_x_normalized() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CInputTouchFingerDownMsg::has_x_normalized() const {
  return _internal_has_x_normalized();
}
inline void CInputTouchFingerDownMsg::clear_x_normalized() {
  x_normalized_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CInputTouchFingerDownMsg::_internal_x_normalized() const {
  return x_normalized_;
}
inline float CInputTouchFingerDownMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerDownMsg.x_normalized)
  return _internal_x_normalized();
}
inline void CInputTouchFingerDownMsg::_internal_set_x_normalized(float value) {
  _has_bits_[0] |= 0x00000004u;
  x_normalized_ = value;
}
inline void CInputTouchFingerDownMsg::set_x_normalized(float value) {
  _internal_set_x_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerDownMsg.x_normalized)
}

// optional float y_normalized = 4;
inline bool CInputTouchFingerDownMsg::_internal_has_y_normalized() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CInputTouchFingerDownMsg::has_y_normalized() const {
  return _internal_has_y_normalized();
}
inline void CInputTouchFingerDownMsg::clear_y_normalized() {
  y_normalized_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CInputTouchFingerDownMsg::_internal_y_normalized() const {
  return y_normalized_;
}
inline float CInputTouchFingerDownMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerDownMsg.y_normalized)
  return _internal_y_normalized();
}
inline void CInputTouchFingerDownMsg::_internal_set_y_normalized(float value) {
  _has_bits_[0] |= 0x00000008u;
  y_normalized_ = value;
}
inline void CInputTouchFingerDownMsg::set_y_normalized(float value) {
  _internal_set_y_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerDownMsg.y_normalized)
}

// -------------------------------------------------------------------

// CInputTouchFingerMotionMsg

// optional uint32 input_mark = 1;
inline bool CInputTouchFingerMotionMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputTouchFingerMotionMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputTouchFingerMotionMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputTouchFingerMotionMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputTouchFingerMotionMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerMotionMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputTouchFingerMotionMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  input_mark_ = value;
}
inline void CInputTouchFingerMotionMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerMotionMsg.input_mark)
}

// optional uint64 fingerid = 2;
inline bool CInputTouchFingerMotionMsg::_internal_has_fingerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputTouchFingerMotionMsg::has_fingerid() const {
  return _internal_has_fingerid();
}
inline void CInputTouchFingerMotionMsg::clear_fingerid() {
  fingerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CInputTouchFingerMotionMsg::_internal_fingerid() const {
  return fingerid_;
}
inline uint64_t CInputTouchFingerMotionMsg::fingerid() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerMotionMsg.fingerid)
  return _internal_fingerid();
}
inline void CInputTouchFingerMotionMsg::_internal_set_fingerid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  fingerid_ = value;
}
inline void CInputTouchFingerMotionMsg::set_fingerid(uint64_t value) {
  _internal_set_fingerid(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerMotionMsg.fingerid)
}

// optional float x_normalized = 3;
inline bool CInputTouchFingerMotionMsg::_internal_has_x_normalized() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CInputTouchFingerMotionMsg::has_x_normalized() const {
  return _internal_has_x_normalized();
}
inline void CInputTouchFingerMotionMsg::clear_x_normalized() {
  x_normalized_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CInputTouchFingerMotionMsg::_internal_x_normalized() const {
  return x_normalized_;
}
inline float CInputTouchFingerMotionMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerMotionMsg.x_normalized)
  return _internal_x_normalized();
}
inline void CInputTouchFingerMotionMsg::_internal_set_x_normalized(float value) {
  _has_bits_[0] |= 0x00000004u;
  x_normalized_ = value;
}
inline void CInputTouchFingerMotionMsg::set_x_normalized(float value) {
  _internal_set_x_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerMotionMsg.x_normalized)
}

// optional float y_normalized = 4;
inline bool CInputTouchFingerMotionMsg::_internal_has_y_normalized() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CInputTouchFingerMotionMsg::has_y_normalized() const {
  return _internal_has_y_normalized();
}
inline void CInputTouchFingerMotionMsg::clear_y_normalized() {
  y_normalized_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CInputTouchFingerMotionMsg::_internal_y_normalized() const {
  return y_normalized_;
}
inline float CInputTouchFingerMotionMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerMotionMsg.y_normalized)
  return _internal_y_normalized();
}
inline void CInputTouchFingerMotionMsg::_internal_set_y_normalized(float value) {
  _has_bits_[0] |= 0x00000008u;
  y_normalized_ = value;
}
inline void CInputTouchFingerMotionMsg::set_y_normalized(float value) {
  _internal_set_y_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerMotionMsg.y_normalized)
}

// -------------------------------------------------------------------

// CInputTouchFingerUpMsg

// optional uint32 input_mark = 1;
inline bool CInputTouchFingerUpMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputTouchFingerUpMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputTouchFingerUpMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputTouchFingerUpMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputTouchFingerUpMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerUpMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputTouchFingerUpMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  input_mark_ = value;
}
inline void CInputTouchFingerUpMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerUpMsg.input_mark)
}

// optional uint64 fingerid = 2;
inline bool CInputTouchFingerUpMsg::_internal_has_fingerid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputTouchFingerUpMsg::has_fingerid() const {
  return _internal_has_fingerid();
}
inline void CInputTouchFingerUpMsg::clear_fingerid() {
  fingerid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CInputTouchFingerUpMsg::_internal_fingerid() const {
  return fingerid_;
}
inline uint64_t CInputTouchFingerUpMsg::fingerid() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerUpMsg.fingerid)
  return _internal_fingerid();
}
inline void CInputTouchFingerUpMsg::_internal_set_fingerid(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  fingerid_ = value;
}
inline void CInputTouchFingerUpMsg::set_fingerid(uint64_t value) {
  _internal_set_fingerid(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerUpMsg.fingerid)
}

// optional float x_normalized = 3;
inline bool CInputTouchFingerUpMsg::_internal_has_x_normalized() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CInputTouchFingerUpMsg::has_x_normalized() const {
  return _internal_has_x_normalized();
}
inline void CInputTouchFingerUpMsg::clear_x_normalized() {
  x_normalized_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CInputTouchFingerUpMsg::_internal_x_normalized() const {
  return x_normalized_;
}
inline float CInputTouchFingerUpMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerUpMsg.x_normalized)
  return _internal_x_normalized();
}
inline void CInputTouchFingerUpMsg::_internal_set_x_normalized(float value) {
  _has_bits_[0] |= 0x00000004u;
  x_normalized_ = value;
}
inline void CInputTouchFingerUpMsg::set_x_normalized(float value) {
  _internal_set_x_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerUpMsg.x_normalized)
}

// optional float y_normalized = 4;
inline bool CInputTouchFingerUpMsg::_internal_has_y_normalized() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CInputTouchFingerUpMsg::has_y_normalized() const {
  return _internal_has_y_normalized();
}
inline void CInputTouchFingerUpMsg::clear_y_normalized() {
  y_normalized_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CInputTouchFingerUpMsg::_internal_y_normalized() const {
  return y_normalized_;
}
inline float CInputTouchFingerUpMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CInputTouchFingerUpMsg.y_normalized)
  return _internal_y_normalized();
}
inline void CInputTouchFingerUpMsg::_internal_set_y_normalized(float value) {
  _has_bits_[0] |= 0x00000008u;
  y_normalized_ = value;
}
inline void CInputTouchFingerUpMsg::set_y_normalized(float value) {
  _internal_set_y_normalized(value);
  // @@protoc_insertion_point(field_set:CInputTouchFingerUpMsg.y_normalized)
}

// -------------------------------------------------------------------

// CInputMouseMotionMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseMotionMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputMouseMotionMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputMouseMotionMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputMouseMotionMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputMouseMotionMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputMouseMotionMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputMouseMotionMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.input_mark)
}

// optional float x_normalized = 2;
inline bool CInputMouseMotionMsg::_internal_has_x_normalized() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputMouseMotionMsg::has_x_normalized() const {
  return _internal_has_x_normalized();
}
inline void CInputMouseMotionMsg::clear_x_normalized() {
  x_normalized_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CInputMouseMotionMsg::_internal_x_normalized() const {
  return x_normalized_;
}
inline float CInputMouseMotionMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.x_normalized)
  return _internal_x_normalized();
}
inline void CInputMouseMotionMsg::_internal_set_x_normalized(float value) {
  _has_bits_[0] |= 0x00000002u;
  x_normalized_ = value;
}
inline void CInputMouseMotionMsg::set_x_normalized(float value) {
  _internal_set_x_normalized(value);
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.x_normalized)
}

// optional float y_normalized = 3;
inline bool CInputMouseMotionMsg::_internal_has_y_normalized() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CInputMouseMotionMsg::has_y_normalized() const {
  return _internal_has_y_normalized();
}
inline void CInputMouseMotionMsg::clear_y_normalized() {
  y_normalized_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CInputMouseMotionMsg::_internal_y_normalized() const {
  return y_normalized_;
}
inline float CInputMouseMotionMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.y_normalized)
  return _internal_y_normalized();
}
inline void CInputMouseMotionMsg::_internal_set_y_normalized(float value) {
  _has_bits_[0] |= 0x00000004u;
  y_normalized_ = value;
}
inline void CInputMouseMotionMsg::set_y_normalized(float value) {
  _internal_set_y_normalized(value);
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.y_normalized)
}

// optional int32 dx = 4;
inline bool CInputMouseMotionMsg::_internal_has_dx() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CInputMouseMotionMsg::has_dx() const {
  return _internal_has_dx();
}
inline void CInputMouseMotionMsg::clear_dx() {
  dx_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CInputMouseMotionMsg::_internal_dx() const {
  return dx_;
}
inline int32_t CInputMouseMotionMsg::dx() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.dx)
  return _internal_dx();
}
inline void CInputMouseMotionMsg::_internal_set_dx(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  dx_ = value;
}
inline void CInputMouseMotionMsg::set_dx(int32_t value) {
  _internal_set_dx(value);
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.dx)
}

// optional int32 dy = 5;
inline bool CInputMouseMotionMsg::_internal_has_dy() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CInputMouseMotionMsg::has_dy() const {
  return _internal_has_dy();
}
inline void CInputMouseMotionMsg::clear_dy() {
  dy_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CInputMouseMotionMsg::_internal_dy() const {
  return dy_;
}
inline int32_t CInputMouseMotionMsg::dy() const {
  // @@protoc_insertion_point(field_get:CInputMouseMotionMsg.dy)
  return _internal_dy();
}
inline void CInputMouseMotionMsg::_internal_set_dy(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  dy_ = value;
}
inline void CInputMouseMotionMsg::set_dy(int32_t value) {
  _internal_set_dy(value);
  // @@protoc_insertion_point(field_set:CInputMouseMotionMsg.dy)
}

// -------------------------------------------------------------------

// CInputMouseWheelMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseWheelMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputMouseWheelMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputMouseWheelMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputMouseWheelMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputMouseWheelMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseWheelMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputMouseWheelMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputMouseWheelMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputMouseWheelMsg.input_mark)
}

// required .EStreamMouseWheelDirection direction = 2 [default = k_EStreamMouseWheelUp];
inline bool CInputMouseWheelMsg::_internal_has_direction() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputMouseWheelMsg::has_direction() const {
  return _internal_has_direction();
}
inline void CInputMouseWheelMsg::clear_direction() {
  direction_ = 120;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamMouseWheelDirection CInputMouseWheelMsg::_internal_direction() const {
  return static_cast< ::EStreamMouseWheelDirection >(direction_);
}
inline ::EStreamMouseWheelDirection CInputMouseWheelMsg::direction() const {
  // @@protoc_insertion_point(field_get:CInputMouseWheelMsg.direction)
  return _internal_direction();
}
inline void CInputMouseWheelMsg::_internal_set_direction(::EStreamMouseWheelDirection value) {
  assert(::EStreamMouseWheelDirection_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  direction_ = value;
}
inline void CInputMouseWheelMsg::set_direction(::EStreamMouseWheelDirection value) {
  _internal_set_direction(value);
  // @@protoc_insertion_point(field_set:CInputMouseWheelMsg.direction)
}

// -------------------------------------------------------------------

// CInputMouseDownMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseDownMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputMouseDownMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputMouseDownMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputMouseDownMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputMouseDownMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseDownMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputMouseDownMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputMouseDownMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputMouseDownMsg.input_mark)
}

// required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
inline bool CInputMouseDownMsg::_internal_has_button() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputMouseDownMsg::has_button() const {
  return _internal_has_button();
}
inline void CInputMouseDownMsg::clear_button() {
  button_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamMouseButton CInputMouseDownMsg::_internal_button() const {
  return static_cast< ::EStreamMouseButton >(button_);
}
inline ::EStreamMouseButton CInputMouseDownMsg::button() const {
  // @@protoc_insertion_point(field_get:CInputMouseDownMsg.button)
  return _internal_button();
}
inline void CInputMouseDownMsg::_internal_set_button(::EStreamMouseButton value) {
  assert(::EStreamMouseButton_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  button_ = value;
}
inline void CInputMouseDownMsg::set_button(::EStreamMouseButton value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:CInputMouseDownMsg.button)
}

// -------------------------------------------------------------------

// CInputMouseUpMsg

// optional uint32 input_mark = 1;
inline bool CInputMouseUpMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputMouseUpMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputMouseUpMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputMouseUpMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputMouseUpMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputMouseUpMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputMouseUpMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputMouseUpMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputMouseUpMsg.input_mark)
}

// required .EStreamMouseButton button = 2 [default = k_EStreamMouseButtonLeft];
inline bool CInputMouseUpMsg::_internal_has_button() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputMouseUpMsg::has_button() const {
  return _internal_has_button();
}
inline void CInputMouseUpMsg::clear_button() {
  button_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::EStreamMouseButton CInputMouseUpMsg::_internal_button() const {
  return static_cast< ::EStreamMouseButton >(button_);
}
inline ::EStreamMouseButton CInputMouseUpMsg::button() const {
  // @@protoc_insertion_point(field_get:CInputMouseUpMsg.button)
  return _internal_button();
}
inline void CInputMouseUpMsg::_internal_set_button(::EStreamMouseButton value) {
  assert(::EStreamMouseButton_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  button_ = value;
}
inline void CInputMouseUpMsg::set_button(::EStreamMouseButton value) {
  _internal_set_button(value);
  // @@protoc_insertion_point(field_set:CInputMouseUpMsg.button)
}

// -------------------------------------------------------------------

// CInputKeyDownMsg

// optional uint32 input_mark = 1;
inline bool CInputKeyDownMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputKeyDownMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputKeyDownMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputKeyDownMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputKeyDownMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputKeyDownMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputKeyDownMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputKeyDownMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputKeyDownMsg.input_mark)
}

// required uint32 scancode = 2;
inline bool CInputKeyDownMsg::_internal_has_scancode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputKeyDownMsg::has_scancode() const {
  return _internal_has_scancode();
}
inline void CInputKeyDownMsg::clear_scancode() {
  scancode_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputKeyDownMsg::_internal_scancode() const {
  return scancode_;
}
inline uint32_t CInputKeyDownMsg::scancode() const {
  // @@protoc_insertion_point(field_get:CInputKeyDownMsg.scancode)
  return _internal_scancode();
}
inline void CInputKeyDownMsg::_internal_set_scancode(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  scancode_ = value;
}
inline void CInputKeyDownMsg::set_scancode(uint32_t value) {
  _internal_set_scancode(value);
  // @@protoc_insertion_point(field_set:CInputKeyDownMsg.scancode)
}

// -------------------------------------------------------------------

// CInputKeyUpMsg

// optional uint32 input_mark = 1;
inline bool CInputKeyUpMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputKeyUpMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputKeyUpMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CInputKeyUpMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputKeyUpMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputKeyUpMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputKeyUpMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  input_mark_ = value;
}
inline void CInputKeyUpMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputKeyUpMsg.input_mark)
}

// required uint32 scancode = 2;
inline bool CInputKeyUpMsg::_internal_has_scancode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputKeyUpMsg::has_scancode() const {
  return _internal_has_scancode();
}
inline void CInputKeyUpMsg::clear_scancode() {
  scancode_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputKeyUpMsg::_internal_scancode() const {
  return scancode_;
}
inline uint32_t CInputKeyUpMsg::scancode() const {
  // @@protoc_insertion_point(field_get:CInputKeyUpMsg.scancode)
  return _internal_scancode();
}
inline void CInputKeyUpMsg::_internal_set_scancode(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  scancode_ = value;
}
inline void CInputKeyUpMsg::set_scancode(uint32_t value) {
  _internal_set_scancode(value);
  // @@protoc_insertion_point(field_set:CInputKeyUpMsg.scancode)
}

// -------------------------------------------------------------------

// CInputTextMsg

// optional uint32 input_mark = 1;
inline bool CInputTextMsg::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CInputTextMsg::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CInputTextMsg::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CInputTextMsg::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CInputTextMsg::input_mark() const {
  // @@protoc_insertion_point(field_get:CInputTextMsg.input_mark)
  return _internal_input_mark();
}
inline void CInputTextMsg::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  input_mark_ = value;
}
inline void CInputTextMsg::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CInputTextMsg.input_mark)
}

// required string text_utf8 = 2;
inline bool CInputTextMsg::_internal_has_text_utf8() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CInputTextMsg::has_text_utf8() const {
  return _internal_has_text_utf8();
}
inline void CInputTextMsg::clear_text_utf8() {
  text_utf8_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CInputTextMsg::text_utf8() const {
  // @@protoc_insertion_point(field_get:CInputTextMsg.text_utf8)
  return _internal_text_utf8();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CInputTextMsg::set_text_utf8(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_utf8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CInputTextMsg.text_utf8)
}
inline std::string* CInputTextMsg::mutable_text_utf8() {
  std::string* _s = _internal_mutable_text_utf8();
  // @@protoc_insertion_point(field_mutable:CInputTextMsg.text_utf8)
  return _s;
}
inline const std::string& CInputTextMsg::_internal_text_utf8() const {
  return text_utf8_.Get();
}
inline void CInputTextMsg::_internal_set_text_utf8(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_utf8_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CInputTextMsg::_internal_mutable_text_utf8() {
  _has_bits_[0] |= 0x00000001u;
  return text_utf8_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CInputTextMsg::release_text_utf8() {
  // @@protoc_insertion_point(field_release:CInputTextMsg.text_utf8)
  if (!_internal_has_text_utf8()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_utf8_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_utf8_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_utf8_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CInputTextMsg::set_allocated_text_utf8(std::string* text_utf8) {
  if (text_utf8 != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_utf8_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text_utf8,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_utf8_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_utf8_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CInputTextMsg.text_utf8)
}

// -------------------------------------------------------------------

// CSetTitleMsg

// optional string text = 1;
inline bool CSetTitleMsg::_internal_has_text() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetTitleMsg::has_text() const {
  return _internal_has_text();
}
inline void CSetTitleMsg::clear_text() {
  text_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetTitleMsg::text() const {
  // @@protoc_insertion_point(field_get:CSetTitleMsg.text)
  return _internal_text();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetTitleMsg::set_text(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetTitleMsg.text)
}
inline std::string* CSetTitleMsg::mutable_text() {
  std::string* _s = _internal_mutable_text();
  // @@protoc_insertion_point(field_mutable:CSetTitleMsg.text)
  return _s;
}
inline const std::string& CSetTitleMsg::_internal_text() const {
  return text_.Get();
}
inline void CSetTitleMsg::_internal_set_text(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  text_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetTitleMsg::_internal_mutable_text() {
  _has_bits_[0] |= 0x00000001u;
  return text_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetTitleMsg::release_text() {
  // @@protoc_insertion_point(field_release:CSetTitleMsg.text)
  if (!_internal_has_text()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = text_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetTitleMsg::set_allocated_text(std::string* text) {
  if (text != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  text_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), text,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (text_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    text_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetTitleMsg.text)
}

// -------------------------------------------------------------------

// CSetCaptureSizeMsg

// optional int32 width = 1;
inline bool CSetCaptureSizeMsg::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetCaptureSizeMsg::has_width() const {
  return _internal_has_width();
}
inline void CSetCaptureSizeMsg::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CSetCaptureSizeMsg::_internal_width() const {
  return width_;
}
inline int32_t CSetCaptureSizeMsg::width() const {
  // @@protoc_insertion_point(field_get:CSetCaptureSizeMsg.width)
  return _internal_width();
}
inline void CSetCaptureSizeMsg::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  width_ = value;
}
inline void CSetCaptureSizeMsg::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CSetCaptureSizeMsg.width)
}

// optional int32 height = 2;
inline bool CSetCaptureSizeMsg::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetCaptureSizeMsg::has_height() const {
  return _internal_has_height();
}
inline void CSetCaptureSizeMsg::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CSetCaptureSizeMsg::_internal_height() const {
  return height_;
}
inline int32_t CSetCaptureSizeMsg::height() const {
  // @@protoc_insertion_point(field_get:CSetCaptureSizeMsg.height)
  return _internal_height();
}
inline void CSetCaptureSizeMsg::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  height_ = value;
}
inline void CSetCaptureSizeMsg::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CSetCaptureSizeMsg.height)
}

// -------------------------------------------------------------------

// CSetIconMsg

// optional int32 width = 1;
inline bool CSetIconMsg::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetIconMsg::has_width() const {
  return _internal_has_width();
}
inline void CSetIconMsg::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CSetIconMsg::_internal_width() const {
  return width_;
}
inline int32_t CSetIconMsg::width() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.width)
  return _internal_width();
}
inline void CSetIconMsg::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void CSetIconMsg::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CSetIconMsg.width)
}

// optional int32 height = 2;
inline bool CSetIconMsg::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetIconMsg::has_height() const {
  return _internal_has_height();
}
inline void CSetIconMsg::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CSetIconMsg::_internal_height() const {
  return height_;
}
inline int32_t CSetIconMsg::height() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.height)
  return _internal_height();
}
inline void CSetIconMsg::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  height_ = value;
}
inline void CSetIconMsg::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CSetIconMsg.height)
}

// optional bytes image = 3;
inline bool CSetIconMsg::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetIconMsg::has_image() const {
  return _internal_has_image();
}
inline void CSetIconMsg::clear_image() {
  image_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetIconMsg::image() const {
  // @@protoc_insertion_point(field_get:CSetIconMsg.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetIconMsg::set_image(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 image_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetIconMsg.image)
}
inline std::string* CSetIconMsg::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:CSetIconMsg.image)
  return _s;
}
inline const std::string& CSetIconMsg::_internal_image() const {
  return image_.Get();
}
inline void CSetIconMsg::_internal_set_image(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetIconMsg::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000001u;
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetIconMsg::release_image() {
  // @@protoc_insertion_point(field_release:CSetIconMsg.image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetIconMsg::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetIconMsg.image)
}

// -------------------------------------------------------------------

// CSetFlashStateMsg

// optional uint32 flags = 1;
inline bool CSetFlashStateMsg::_internal_has_flags() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetFlashStateMsg::has_flags() const {
  return _internal_has_flags();
}
inline void CSetFlashStateMsg::clear_flags() {
  flags_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSetFlashStateMsg::_internal_flags() const {
  return flags_;
}
inline uint32_t CSetFlashStateMsg::flags() const {
  // @@protoc_insertion_point(field_get:CSetFlashStateMsg.flags)
  return _internal_flags();
}
inline void CSetFlashStateMsg::_internal_set_flags(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  flags_ = value;
}
inline void CSetFlashStateMsg::set_flags(uint32_t value) {
  _internal_set_flags(value);
  // @@protoc_insertion_point(field_set:CSetFlashStateMsg.flags)
}

// optional uint32 count = 2;
inline bool CSetFlashStateMsg::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetFlashStateMsg::has_count() const {
  return _internal_has_count();
}
inline void CSetFlashStateMsg::clear_count() {
  count_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSetFlashStateMsg::_internal_count() const {
  return count_;
}
inline uint32_t CSetFlashStateMsg::count() const {
  // @@protoc_insertion_point(field_get:CSetFlashStateMsg.count)
  return _internal_count();
}
inline void CSetFlashStateMsg::_internal_set_count(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void CSetFlashStateMsg::set_count(uint32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CSetFlashStateMsg.count)
}

// optional uint32 timeout_ms = 3;
inline bool CSetFlashStateMsg::_internal_has_timeout_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetFlashStateMsg::has_timeout_ms() const {
  return _internal_has_timeout_ms();
}
inline void CSetFlashStateMsg::clear_timeout_ms() {
  timeout_ms_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSetFlashStateMsg::_internal_timeout_ms() const {
  return timeout_ms_;
}
inline uint32_t CSetFlashStateMsg::timeout_ms() const {
  // @@protoc_insertion_point(field_get:CSetFlashStateMsg.timeout_ms)
  return _internal_timeout_ms();
}
inline void CSetFlashStateMsg::_internal_set_timeout_ms(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  timeout_ms_ = value;
}
inline void CSetFlashStateMsg::set_timeout_ms(uint32_t value) {
  _internal_set_timeout_ms(value);
  // @@protoc_insertion_point(field_set:CSetFlashStateMsg.timeout_ms)
}

// -------------------------------------------------------------------

// CShowCursorMsg

// optional float x_normalized = 1;
inline bool CShowCursorMsg::_internal_has_x_normalized() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CShowCursorMsg::has_x_normalized() const {
  return _internal_has_x_normalized();
}
inline void CShowCursorMsg::clear_x_normalized() {
  x_normalized_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float CShowCursorMsg::_internal_x_normalized() const {
  return x_normalized_;
}
inline float CShowCursorMsg::x_normalized() const {
  // @@protoc_insertion_point(field_get:CShowCursorMsg.x_normalized)
  return _internal_x_normalized();
}
inline void CShowCursorMsg::_internal_set_x_normalized(float value) {
  _has_bits_[0] |= 0x00000001u;
  x_normalized_ = value;
}
inline void CShowCursorMsg::set_x_normalized(float value) {
  _internal_set_x_normalized(value);
  // @@protoc_insertion_point(field_set:CShowCursorMsg.x_normalized)
}

// optional float y_normalized = 2;
inline bool CShowCursorMsg::_internal_has_y_normalized() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CShowCursorMsg::has_y_normalized() const {
  return _internal_has_y_normalized();
}
inline void CShowCursorMsg::clear_y_normalized() {
  y_normalized_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CShowCursorMsg::_internal_y_normalized() const {
  return y_normalized_;
}
inline float CShowCursorMsg::y_normalized() const {
  // @@protoc_insertion_point(field_get:CShowCursorMsg.y_normalized)
  return _internal_y_normalized();
}
inline void CShowCursorMsg::_internal_set_y_normalized(float value) {
  _has_bits_[0] |= 0x00000002u;
  y_normalized_ = value;
}
inline void CShowCursorMsg::set_y_normalized(float value) {
  _internal_set_y_normalized(value);
  // @@protoc_insertion_point(field_set:CShowCursorMsg.y_normalized)
}

// -------------------------------------------------------------------

// CHideCursorMsg

// -------------------------------------------------------------------

// CSetCursorMsg

// required uint64 cursor_id = 1;
inline bool CSetCursorMsg::_internal_has_cursor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetCursorMsg::has_cursor_id() const {
  return _internal_has_cursor_id();
}
inline void CSetCursorMsg::clear_cursor_id() {
  cursor_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CSetCursorMsg::_internal_cursor_id() const {
  return cursor_id_;
}
inline uint64_t CSetCursorMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CSetCursorMsg.cursor_id)
  return _internal_cursor_id();
}
inline void CSetCursorMsg::_internal_set_cursor_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  cursor_id_ = value;
}
inline void CSetCursorMsg::set_cursor_id(uint64_t value) {
  _internal_set_cursor_id(value);
  // @@protoc_insertion_point(field_set:CSetCursorMsg.cursor_id)
}

// -------------------------------------------------------------------

// CGetCursorImageMsg

// required uint64 cursor_id = 1;
inline bool CGetCursorImageMsg::_internal_has_cursor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CGetCursorImageMsg::has_cursor_id() const {
  return _internal_has_cursor_id();
}
inline void CGetCursorImageMsg::clear_cursor_id() {
  cursor_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CGetCursorImageMsg::_internal_cursor_id() const {
  return cursor_id_;
}
inline uint64_t CGetCursorImageMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CGetCursorImageMsg.cursor_id)
  return _internal_cursor_id();
}
inline void CGetCursorImageMsg::_internal_set_cursor_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  cursor_id_ = value;
}
inline void CGetCursorImageMsg::set_cursor_id(uint64_t value) {
  _internal_set_cursor_id(value);
  // @@protoc_insertion_point(field_set:CGetCursorImageMsg.cursor_id)
}

// -------------------------------------------------------------------

// CSetCursorImageMsg

// required uint64 cursor_id = 1;
inline bool CSetCursorImageMsg::_internal_has_cursor_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_cursor_id() const {
  return _internal_has_cursor_id();
}
inline void CSetCursorImageMsg::clear_cursor_id() {
  cursor_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSetCursorImageMsg::_internal_cursor_id() const {
  return cursor_id_;
}
inline uint64_t CSetCursorImageMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.cursor_id)
  return _internal_cursor_id();
}
inline void CSetCursorImageMsg::_internal_set_cursor_id(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  cursor_id_ = value;
}
inline void CSetCursorImageMsg::set_cursor_id(uint64_t value) {
  _internal_set_cursor_id(value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.cursor_id)
}

// optional int32 width = 2;
inline bool CSetCursorImageMsg::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_width() const {
  return _internal_has_width();
}
inline void CSetCursorImageMsg::clear_width() {
  width_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CSetCursorImageMsg::_internal_width() const {
  return width_;
}
inline int32_t CSetCursorImageMsg::width() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.width)
  return _internal_width();
}
inline void CSetCursorImageMsg::_internal_set_width(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
}
inline void CSetCursorImageMsg::set_width(int32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.width)
}

// optional int32 height = 3;
inline bool CSetCursorImageMsg::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_height() const {
  return _internal_has_height();
}
inline void CSetCursorImageMsg::clear_height() {
  height_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CSetCursorImageMsg::_internal_height() const {
  return height_;
}
inline int32_t CSetCursorImageMsg::height() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.height)
  return _internal_height();
}
inline void CSetCursorImageMsg::_internal_set_height(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  height_ = value;
}
inline void CSetCursorImageMsg::set_height(int32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.height)
}

// optional int32 hot_x = 4;
inline bool CSetCursorImageMsg::_internal_has_hot_x() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_hot_x() const {
  return _internal_has_hot_x();
}
inline void CSetCursorImageMsg::clear_hot_x() {
  hot_x_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CSetCursorImageMsg::_internal_hot_x() const {
  return hot_x_;
}
inline int32_t CSetCursorImageMsg::hot_x() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.hot_x)
  return _internal_hot_x();
}
inline void CSetCursorImageMsg::_internal_set_hot_x(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  hot_x_ = value;
}
inline void CSetCursorImageMsg::set_hot_x(int32_t value) {
  _internal_set_hot_x(value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.hot_x)
}

// optional int32 hot_y = 5;
inline bool CSetCursorImageMsg::_internal_has_hot_y() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_hot_y() const {
  return _internal_has_hot_y();
}
inline void CSetCursorImageMsg::clear_hot_y() {
  hot_y_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CSetCursorImageMsg::_internal_hot_y() const {
  return hot_y_;
}
inline int32_t CSetCursorImageMsg::hot_y() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.hot_y)
  return _internal_hot_y();
}
inline void CSetCursorImageMsg::_internal_set_hot_y(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  hot_y_ = value;
}
inline void CSetCursorImageMsg::set_hot_y(int32_t value) {
  _internal_set_hot_y(value);
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.hot_y)
}

// optional bytes image = 6;
inline bool CSetCursorImageMsg::_internal_has_image() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetCursorImageMsg::has_image() const {
  return _internal_has_image();
}
inline void CSetCursorImageMsg::clear_image() {
  image_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetCursorImageMsg::image() const {
  // @@protoc_insertion_point(field_get:CSetCursorImageMsg.image)
  return _internal_image();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetCursorImageMsg::set_image(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 image_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetCursorImageMsg.image)
}
inline std::string* CSetCursorImageMsg::mutable_image() {
  std::string* _s = _internal_mutable_image();
  // @@protoc_insertion_point(field_mutable:CSetCursorImageMsg.image)
  return _s;
}
inline const std::string& CSetCursorImageMsg::_internal_image() const {
  return image_.Get();
}
inline void CSetCursorImageMsg::_internal_set_image(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  image_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetCursorImageMsg::_internal_mutable_image() {
  _has_bits_[0] |= 0x00000001u;
  return image_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetCursorImageMsg::release_image() {
  // @@protoc_insertion_point(field_release:CSetCursorImageMsg.image)
  if (!_internal_has_image()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = image_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetCursorImageMsg::set_allocated_image(std::string* image) {
  if (image != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  image_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), image,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (image_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    image_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetCursorImageMsg.image)
}

// -------------------------------------------------------------------

// CVideoDecoderInfoMsg

// optional string info = 1;
inline bool CVideoDecoderInfoMsg::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVideoDecoderInfoMsg::has_info() const {
  return _internal_has_info();
}
inline void CVideoDecoderInfoMsg::clear_info() {
  info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CVideoDecoderInfoMsg::info() const {
  // @@protoc_insertion_point(field_get:CVideoDecoderInfoMsg.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CVideoDecoderInfoMsg::set_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVideoDecoderInfoMsg.info)
}
inline std::string* CVideoDecoderInfoMsg::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CVideoDecoderInfoMsg.info)
  return _s;
}
inline const std::string& CVideoDecoderInfoMsg::_internal_info() const {
  return info_.Get();
}
inline void CVideoDecoderInfoMsg::_internal_set_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CVideoDecoderInfoMsg::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CVideoDecoderInfoMsg::release_info() {
  // @@protoc_insertion_point(field_release:CVideoDecoderInfoMsg.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CVideoDecoderInfoMsg::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVideoDecoderInfoMsg.info)
}

// optional int32 threads = 2;
inline bool CVideoDecoderInfoMsg::_internal_has_threads() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CVideoDecoderInfoMsg::has_threads() const {
  return _internal_has_threads();
}
inline void CVideoDecoderInfoMsg::clear_threads() {
  threads_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CVideoDecoderInfoMsg::_internal_threads() const {
  return threads_;
}
inline int32_t CVideoDecoderInfoMsg::threads() const {
  // @@protoc_insertion_point(field_get:CVideoDecoderInfoMsg.threads)
  return _internal_threads();
}
inline void CVideoDecoderInfoMsg::_internal_set_threads(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  threads_ = value;
}
inline void CVideoDecoderInfoMsg::set_threads(int32_t value) {
  _internal_set_threads(value);
  // @@protoc_insertion_point(field_set:CVideoDecoderInfoMsg.threads)
}

// -------------------------------------------------------------------

// CVideoEncoderInfoMsg

// optional string info = 1;
inline bool CVideoEncoderInfoMsg::_internal_has_info() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVideoEncoderInfoMsg::has_info() const {
  return _internal_has_info();
}
inline void CVideoEncoderInfoMsg::clear_info() {
  info_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CVideoEncoderInfoMsg::info() const {
  // @@protoc_insertion_point(field_get:CVideoEncoderInfoMsg.info)
  return _internal_info();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CVideoEncoderInfoMsg::set_info(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVideoEncoderInfoMsg.info)
}
inline std::string* CVideoEncoderInfoMsg::mutable_info() {
  std::string* _s = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:CVideoEncoderInfoMsg.info)
  return _s;
}
inline const std::string& CVideoEncoderInfoMsg::_internal_info() const {
  return info_.Get();
}
inline void CVideoEncoderInfoMsg::_internal_set_info(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  info_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CVideoEncoderInfoMsg::_internal_mutable_info() {
  _has_bits_[0] |= 0x00000001u;
  return info_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CVideoEncoderInfoMsg::release_info() {
  // @@protoc_insertion_point(field_release:CVideoEncoderInfoMsg.info)
  if (!_internal_has_info()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = info_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CVideoEncoderInfoMsg::set_allocated_info(std::string* info) {
  if (info != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  info_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), info,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (info_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    info_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVideoEncoderInfoMsg.info)
}

// -------------------------------------------------------------------

// CPauseMsg

// -------------------------------------------------------------------

// CResumeMsg

// -------------------------------------------------------------------

// CEnableHighResCaptureMsg

// -------------------------------------------------------------------

// CDisableHighResCaptureMsg

// -------------------------------------------------------------------

// CEnableNeptuneDataMsg

// -------------------------------------------------------------------

// CDisableNeptuneDataMsg

// -------------------------------------------------------------------

// CPauseControllerInputMsg

// -------------------------------------------------------------------

// CResumeControllerInputMsg

// -------------------------------------------------------------------

// CToggleMagnificationMsg

// -------------------------------------------------------------------

// CSetCapslockMsg

// optional bool pressed = 1;
inline bool CSetCapslockMsg::_internal_has_pressed() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetCapslockMsg::has_pressed() const {
  return _internal_has_pressed();
}
inline void CSetCapslockMsg::clear_pressed() {
  pressed_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSetCapslockMsg::_internal_pressed() const {
  return pressed_;
}
inline bool CSetCapslockMsg::pressed() const {
  // @@protoc_insertion_point(field_get:CSetCapslockMsg.pressed)
  return _internal_pressed();
}
inline void CSetCapslockMsg::_internal_set_pressed(bool value) {
  _has_bits_[0] |= 0x00000001u;
  pressed_ = value;
}
inline void CSetCapslockMsg::set_pressed(bool value) {
  _internal_set_pressed(value);
  // @@protoc_insertion_point(field_set:CSetCapslockMsg.pressed)
}

// -------------------------------------------------------------------

// CStreamingKeymapEntry

// optional int32 scancode = 1;
inline bool CStreamingKeymapEntry::_internal_has_scancode() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_scancode() const {
  return _internal_has_scancode();
}
inline void CStreamingKeymapEntry::clear_scancode() {
  scancode_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CStreamingKeymapEntry::_internal_scancode() const {
  return scancode_;
}
inline int32_t CStreamingKeymapEntry::scancode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.scancode)
  return _internal_scancode();
}
inline void CStreamingKeymapEntry::_internal_set_scancode(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  scancode_ = value;
}
inline void CStreamingKeymapEntry::set_scancode(int32_t value) {
  _internal_set_scancode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.scancode)
}

// optional int32 normal_keycode = 2;
inline bool CStreamingKeymapEntry::_internal_has_normal_keycode() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_normal_keycode() const {
  return _internal_has_normal_keycode();
}
inline void CStreamingKeymapEntry::clear_normal_keycode() {
  normal_keycode_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CStreamingKeymapEntry::_internal_normal_keycode() const {
  return normal_keycode_;
}
inline int32_t CStreamingKeymapEntry::normal_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.normal_keycode)
  return _internal_normal_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_normal_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  normal_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_normal_keycode(int32_t value) {
  _internal_set_normal_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.normal_keycode)
}

// optional int32 shift_keycode = 3;
inline bool CStreamingKeymapEntry::_internal_has_shift_keycode() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_shift_keycode() const {
  return _internal_has_shift_keycode();
}
inline void CStreamingKeymapEntry::clear_shift_keycode() {
  shift_keycode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CStreamingKeymapEntry::_internal_shift_keycode() const {
  return shift_keycode_;
}
inline int32_t CStreamingKeymapEntry::shift_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.shift_keycode)
  return _internal_shift_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_shift_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  shift_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_shift_keycode(int32_t value) {
  _internal_set_shift_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.shift_keycode)
}

// optional int32 capslock_keycode = 4;
inline bool CStreamingKeymapEntry::_internal_has_capslock_keycode() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_capslock_keycode() const {
  return _internal_has_capslock_keycode();
}
inline void CStreamingKeymapEntry::clear_capslock_keycode() {
  capslock_keycode_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CStreamingKeymapEntry::_internal_capslock_keycode() const {
  return capslock_keycode_;
}
inline int32_t CStreamingKeymapEntry::capslock_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.capslock_keycode)
  return _internal_capslock_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_capslock_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  capslock_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_capslock_keycode(int32_t value) {
  _internal_set_capslock_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.capslock_keycode)
}

// optional int32 shift_capslock_keycode = 5;
inline bool CStreamingKeymapEntry::_internal_has_shift_capslock_keycode() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_shift_capslock_keycode() const {
  return _internal_has_shift_capslock_keycode();
}
inline void CStreamingKeymapEntry::clear_shift_capslock_keycode() {
  shift_capslock_keycode_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline int32_t CStreamingKeymapEntry::_internal_shift_capslock_keycode() const {
  return shift_capslock_keycode_;
}
inline int32_t CStreamingKeymapEntry::shift_capslock_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.shift_capslock_keycode)
  return _internal_shift_capslock_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_shift_capslock_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000010u;
  shift_capslock_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_shift_capslock_keycode(int32_t value) {
  _internal_set_shift_capslock_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.shift_capslock_keycode)
}

// optional int32 altgr_keycode = 6;
inline bool CStreamingKeymapEntry::_internal_has_altgr_keycode() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_altgr_keycode() const {
  return _internal_has_altgr_keycode();
}
inline void CStreamingKeymapEntry::clear_altgr_keycode() {
  altgr_keycode_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline int32_t CStreamingKeymapEntry::_internal_altgr_keycode() const {
  return altgr_keycode_;
}
inline int32_t CStreamingKeymapEntry::altgr_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.altgr_keycode)
  return _internal_altgr_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_altgr_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000020u;
  altgr_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_altgr_keycode(int32_t value) {
  _internal_set_altgr_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.altgr_keycode)
}

// optional int32 altgr_shift_keycode = 7;
inline bool CStreamingKeymapEntry::_internal_has_altgr_shift_keycode() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_altgr_shift_keycode() const {
  return _internal_has_altgr_shift_keycode();
}
inline void CStreamingKeymapEntry::clear_altgr_shift_keycode() {
  altgr_shift_keycode_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline int32_t CStreamingKeymapEntry::_internal_altgr_shift_keycode() const {
  return altgr_shift_keycode_;
}
inline int32_t CStreamingKeymapEntry::altgr_shift_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.altgr_shift_keycode)
  return _internal_altgr_shift_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_altgr_shift_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000040u;
  altgr_shift_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_altgr_shift_keycode(int32_t value) {
  _internal_set_altgr_shift_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.altgr_shift_keycode)
}

// optional int32 altgr_capslock_keycode = 8;
inline bool CStreamingKeymapEntry::_internal_has_altgr_capslock_keycode() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_altgr_capslock_keycode() const {
  return _internal_has_altgr_capslock_keycode();
}
inline void CStreamingKeymapEntry::clear_altgr_capslock_keycode() {
  altgr_capslock_keycode_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline int32_t CStreamingKeymapEntry::_internal_altgr_capslock_keycode() const {
  return altgr_capslock_keycode_;
}
inline int32_t CStreamingKeymapEntry::altgr_capslock_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.altgr_capslock_keycode)
  return _internal_altgr_capslock_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_altgr_capslock_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000080u;
  altgr_capslock_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_altgr_capslock_keycode(int32_t value) {
  _internal_set_altgr_capslock_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.altgr_capslock_keycode)
}

// optional int32 altgr_shift_capslock_keycode = 9;
inline bool CStreamingKeymapEntry::_internal_has_altgr_shift_capslock_keycode() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CStreamingKeymapEntry::has_altgr_shift_capslock_keycode() const {
  return _internal_has_altgr_shift_capslock_keycode();
}
inline void CStreamingKeymapEntry::clear_altgr_shift_capslock_keycode() {
  altgr_shift_capslock_keycode_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline int32_t CStreamingKeymapEntry::_internal_altgr_shift_capslock_keycode() const {
  return altgr_shift_capslock_keycode_;
}
inline int32_t CStreamingKeymapEntry::altgr_shift_capslock_keycode() const {
  // @@protoc_insertion_point(field_get:CStreamingKeymapEntry.altgr_shift_capslock_keycode)
  return _internal_altgr_shift_capslock_keycode();
}
inline void CStreamingKeymapEntry::_internal_set_altgr_shift_capslock_keycode(int32_t value) {
  _has_bits_[0] |= 0x00000100u;
  altgr_shift_capslock_keycode_ = value;
}
inline void CStreamingKeymapEntry::set_altgr_shift_capslock_keycode(int32_t value) {
  _internal_set_altgr_shift_capslock_keycode(value);
  // @@protoc_insertion_point(field_set:CStreamingKeymapEntry.altgr_shift_capslock_keycode)
}

// -------------------------------------------------------------------

// CStreamingKeymap

// repeated .CStreamingKeymapEntry entries = 1;
inline int CStreamingKeymap::_internal_entries_size() const {
  return entries_.size();
}
inline int CStreamingKeymap::entries_size() const {
  return _internal_entries_size();
}
inline void CStreamingKeymap::clear_entries() {
  entries_.Clear();
}
inline ::CStreamingKeymapEntry* CStreamingKeymap::mutable_entries(int index) {
  // @@protoc_insertion_point(field_mutable:CStreamingKeymap.entries)
  return entries_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamingKeymapEntry >*
CStreamingKeymap::mutable_entries() {
  // @@protoc_insertion_point(field_mutable_list:CStreamingKeymap.entries)
  return &entries_;
}
inline const ::CStreamingKeymapEntry& CStreamingKeymap::_internal_entries(int index) const {
  return entries_.Get(index);
}
inline const ::CStreamingKeymapEntry& CStreamingKeymap::entries(int index) const {
  // @@protoc_insertion_point(field_get:CStreamingKeymap.entries)
  return _internal_entries(index);
}
inline ::CStreamingKeymapEntry* CStreamingKeymap::_internal_add_entries() {
  return entries_.Add();
}
inline ::CStreamingKeymapEntry* CStreamingKeymap::add_entries() {
  ::CStreamingKeymapEntry* _add = _internal_add_entries();
  // @@protoc_insertion_point(field_add:CStreamingKeymap.entries)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CStreamingKeymapEntry >&
CStreamingKeymap::entries() const {
  // @@protoc_insertion_point(field_list:CStreamingKeymap.entries)
  return entries_;
}

// -------------------------------------------------------------------

// CSetKeymapMsg

// optional .CStreamingKeymap keymap = 1;
inline bool CSetKeymapMsg::_internal_has_keymap() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || keymap_ != nullptr);
  return value;
}
inline bool CSetKeymapMsg::has_keymap() const {
  return _internal_has_keymap();
}
inline void CSetKeymapMsg::clear_keymap() {
  if (keymap_ != nullptr) keymap_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CStreamingKeymap& CSetKeymapMsg::_internal_keymap() const {
  const ::CStreamingKeymap* p = keymap_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingKeymap&>(
      ::_CStreamingKeymap_default_instance_);
}
inline const ::CStreamingKeymap& CSetKeymapMsg::keymap() const {
  // @@protoc_insertion_point(field_get:CSetKeymapMsg.keymap)
  return _internal_keymap();
}
inline void CSetKeymapMsg::unsafe_arena_set_allocated_keymap(
    ::CStreamingKeymap* keymap) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(keymap_);
  }
  keymap_ = keymap;
  if (keymap) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSetKeymapMsg.keymap)
}
inline ::CStreamingKeymap* CSetKeymapMsg::release_keymap() {
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingKeymap* temp = keymap_;
  keymap_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingKeymap* CSetKeymapMsg::unsafe_arena_release_keymap() {
  // @@protoc_insertion_point(field_release:CSetKeymapMsg.keymap)
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingKeymap* temp = keymap_;
  keymap_ = nullptr;
  return temp;
}
inline ::CStreamingKeymap* CSetKeymapMsg::_internal_mutable_keymap() {
  _has_bits_[0] |= 0x00000001u;
  if (keymap_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingKeymap>(GetArenaForAllocation());
    keymap_ = p;
  }
  return keymap_;
}
inline ::CStreamingKeymap* CSetKeymapMsg::mutable_keymap() {
  ::CStreamingKeymap* _msg = _internal_mutable_keymap();
  // @@protoc_insertion_point(field_mutable:CSetKeymapMsg.keymap)
  return _msg;
}
inline void CSetKeymapMsg::set_allocated_keymap(::CStreamingKeymap* keymap) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete keymap_;
  }
  if (keymap) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingKeymap>::GetOwningArena(keymap);
    if (message_arena != submessage_arena) {
      keymap = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, keymap, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  keymap_ = keymap;
  // @@protoc_insertion_point(field_set_allocated:CSetKeymapMsg.keymap)
}

// -------------------------------------------------------------------

// CStopRequest

// -------------------------------------------------------------------

// CQuitRequest

// -------------------------------------------------------------------

// CDeleteCursorMsg

// required uint64 cursor_id = 1;
inline bool CDeleteCursorMsg::_internal_has_cursor_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDeleteCursorMsg::has_cursor_id() const {
  return _internal_has_cursor_id();
}
inline void CDeleteCursorMsg::clear_cursor_id() {
  cursor_id_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000001u;
}
inline uint64_t CDeleteCursorMsg::_internal_cursor_id() const {
  return cursor_id_;
}
inline uint64_t CDeleteCursorMsg::cursor_id() const {
  // @@protoc_insertion_point(field_get:CDeleteCursorMsg.cursor_id)
  return _internal_cursor_id();
}
inline void CDeleteCursorMsg::_internal_set_cursor_id(uint64_t value) {
  _has_bits_[0] |= 0x00000001u;
  cursor_id_ = value;
}
inline void CDeleteCursorMsg::set_cursor_id(uint64_t value) {
  _internal_set_cursor_id(value);
  // @@protoc_insertion_point(field_set:CDeleteCursorMsg.cursor_id)
}

// -------------------------------------------------------------------

// CSetStreamingClientConfig

// required .CStreamingClientConfig config = 1;
inline bool CSetStreamingClientConfig::_internal_has_config() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || config_ != nullptr);
  return value;
}
inline bool CSetStreamingClientConfig::has_config() const {
  return _internal_has_config();
}
inline void CSetStreamingClientConfig::clear_config() {
  if (config_ != nullptr) config_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CStreamingClientConfig& CSetStreamingClientConfig::_internal_config() const {
  const ::CStreamingClientConfig* p = config_;
  return p != nullptr ? *p : reinterpret_cast<const ::CStreamingClientConfig&>(
      ::_CStreamingClientConfig_default_instance_);
}
inline const ::CStreamingClientConfig& CSetStreamingClientConfig::config() const {
  // @@protoc_insertion_point(field_get:CSetStreamingClientConfig.config)
  return _internal_config();
}
inline void CSetStreamingClientConfig::unsafe_arena_set_allocated_config(
    ::CStreamingClientConfig* config) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  config_ = config;
  if (config) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CSetStreamingClientConfig.config)
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::release_config() {
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingClientConfig* temp = config_;
  config_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::unsafe_arena_release_config() {
  // @@protoc_insertion_point(field_release:CSetStreamingClientConfig.config)
  _has_bits_[0] &= ~0x00000001u;
  ::CStreamingClientConfig* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::_internal_mutable_config() {
  _has_bits_[0] |= 0x00000001u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::CStreamingClientConfig>(GetArenaForAllocation());
    config_ = p;
  }
  return config_;
}
inline ::CStreamingClientConfig* CSetStreamingClientConfig::mutable_config() {
  ::CStreamingClientConfig* _msg = _internal_mutable_config();
  // @@protoc_insertion_point(field_mutable:CSetStreamingClientConfig.config)
  return _msg;
}
inline void CSetStreamingClientConfig::set_allocated_config(::CStreamingClientConfig* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete config_;
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CStreamingClientConfig>::GetOwningArena(config);
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:CSetStreamingClientConfig.config)
}

// -------------------------------------------------------------------

// CSetQoSMsg

// required bool use_qos = 1;
inline bool CSetQoSMsg::_internal_has_use_qos() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetQoSMsg::has_use_qos() const {
  return _internal_has_use_qos();
}
inline void CSetQoSMsg::clear_use_qos() {
  use_qos_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSetQoSMsg::_internal_use_qos() const {
  return use_qos_;
}
inline bool CSetQoSMsg::use_qos() const {
  // @@protoc_insertion_point(field_get:CSetQoSMsg.use_qos)
  return _internal_use_qos();
}
inline void CSetQoSMsg::_internal_set_use_qos(bool value) {
  _has_bits_[0] |= 0x00000001u;
  use_qos_ = value;
}
inline void CSetQoSMsg::set_use_qos(bool value) {
  _internal_set_use_qos(value);
  // @@protoc_insertion_point(field_set:CSetQoSMsg.use_qos)
}

// -------------------------------------------------------------------

// CSetTargetFramerateMsg

// required uint32 framerate = 1;
inline bool CSetTargetFramerateMsg::_internal_has_framerate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetTargetFramerateMsg::has_framerate() const {
  return _internal_has_framerate();
}
inline void CSetTargetFramerateMsg::clear_framerate() {
  framerate_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CSetTargetFramerateMsg::_internal_framerate() const {
  return framerate_;
}
inline uint32_t CSetTargetFramerateMsg::framerate() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate)
  return _internal_framerate();
}
inline void CSetTargetFramerateMsg::_internal_set_framerate(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  framerate_ = value;
}
inline void CSetTargetFramerateMsg::set_framerate(uint32_t value) {
  _internal_set_framerate(value);
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate)
}

// optional uint32 reasons = 2;
inline bool CSetTargetFramerateMsg::_internal_has_reasons() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetTargetFramerateMsg::has_reasons() const {
  return _internal_has_reasons();
}
inline void CSetTargetFramerateMsg::clear_reasons() {
  reasons_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSetTargetFramerateMsg::_internal_reasons() const {
  return reasons_;
}
inline uint32_t CSetTargetFramerateMsg::reasons() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.reasons)
  return _internal_reasons();
}
inline void CSetTargetFramerateMsg::_internal_set_reasons(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  reasons_ = value;
}
inline void CSetTargetFramerateMsg::set_reasons(uint32_t value) {
  _internal_set_reasons(value);
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.reasons)
}

// optional uint32 framerate_numerator = 3;
inline bool CSetTargetFramerateMsg::_internal_has_framerate_numerator() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetTargetFramerateMsg::has_framerate_numerator() const {
  return _internal_has_framerate_numerator();
}
inline void CSetTargetFramerateMsg::clear_framerate_numerator() {
  framerate_numerator_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSetTargetFramerateMsg::_internal_framerate_numerator() const {
  return framerate_numerator_;
}
inline uint32_t CSetTargetFramerateMsg::framerate_numerator() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate_numerator)
  return _internal_framerate_numerator();
}
inline void CSetTargetFramerateMsg::_internal_set_framerate_numerator(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  framerate_numerator_ = value;
}
inline void CSetTargetFramerateMsg::set_framerate_numerator(uint32_t value) {
  _internal_set_framerate_numerator(value);
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate_numerator)
}

// optional uint32 framerate_denominator = 4;
inline bool CSetTargetFramerateMsg::_internal_has_framerate_denominator() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSetTargetFramerateMsg::has_framerate_denominator() const {
  return _internal_has_framerate_denominator();
}
inline void CSetTargetFramerateMsg::clear_framerate_denominator() {
  framerate_denominator_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CSetTargetFramerateMsg::_internal_framerate_denominator() const {
  return framerate_denominator_;
}
inline uint32_t CSetTargetFramerateMsg::framerate_denominator() const {
  // @@protoc_insertion_point(field_get:CSetTargetFramerateMsg.framerate_denominator)
  return _internal_framerate_denominator();
}
inline void CSetTargetFramerateMsg::_internal_set_framerate_denominator(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  framerate_denominator_ = value;
}
inline void CSetTargetFramerateMsg::set_framerate_denominator(uint32_t value) {
  _internal_set_framerate_denominator(value);
  // @@protoc_insertion_point(field_set:CSetTargetFramerateMsg.framerate_denominator)
}

// -------------------------------------------------------------------

// CSetTargetBitrateMsg

// required int32 bitrate = 1;
inline bool CSetTargetBitrateMsg::_internal_has_bitrate() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetTargetBitrateMsg::has_bitrate() const {
  return _internal_has_bitrate();
}
inline void CSetTargetBitrateMsg::clear_bitrate() {
  bitrate_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CSetTargetBitrateMsg::_internal_bitrate() const {
  return bitrate_;
}
inline int32_t CSetTargetBitrateMsg::bitrate() const {
  // @@protoc_insertion_point(field_get:CSetTargetBitrateMsg.bitrate)
  return _internal_bitrate();
}
inline void CSetTargetBitrateMsg::_internal_set_bitrate(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  bitrate_ = value;
}
inline void CSetTargetBitrateMsg::set_bitrate(int32_t value) {
  _internal_set_bitrate(value);
  // @@protoc_insertion_point(field_set:CSetTargetBitrateMsg.bitrate)
}

// -------------------------------------------------------------------

// COverlayEnabledMsg

// required bool enabled = 1;
inline bool COverlayEnabledMsg::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool COverlayEnabledMsg::has_enabled() const {
  return _internal_has_enabled();
}
inline void COverlayEnabledMsg::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool COverlayEnabledMsg::_internal_enabled() const {
  return enabled_;
}
inline bool COverlayEnabledMsg::enabled() const {
  // @@protoc_insertion_point(field_get:COverlayEnabledMsg.enabled)
  return _internal_enabled();
}
inline void COverlayEnabledMsg::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void COverlayEnabledMsg::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:COverlayEnabledMsg.enabled)
}

// -------------------------------------------------------------------

// CSetGammaRampMsg

// optional bytes gamma_ramp = 1;
inline bool CSetGammaRampMsg::_internal_has_gamma_ramp() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetGammaRampMsg::has_gamma_ramp() const {
  return _internal_has_gamma_ramp();
}
inline void CSetGammaRampMsg::clear_gamma_ramp() {
  gamma_ramp_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetGammaRampMsg::gamma_ramp() const {
  // @@protoc_insertion_point(field_get:CSetGammaRampMsg.gamma_ramp)
  return _internal_gamma_ramp();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetGammaRampMsg::set_gamma_ramp(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 gamma_ramp_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetGammaRampMsg.gamma_ramp)
}
inline std::string* CSetGammaRampMsg::mutable_gamma_ramp() {
  std::string* _s = _internal_mutable_gamma_ramp();
  // @@protoc_insertion_point(field_mutable:CSetGammaRampMsg.gamma_ramp)
  return _s;
}
inline const std::string& CSetGammaRampMsg::_internal_gamma_ramp() const {
  return gamma_ramp_.Get();
}
inline void CSetGammaRampMsg::_internal_set_gamma_ramp(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  gamma_ramp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetGammaRampMsg::_internal_mutable_gamma_ramp() {
  _has_bits_[0] |= 0x00000001u;
  return gamma_ramp_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetGammaRampMsg::release_gamma_ramp() {
  // @@protoc_insertion_point(field_release:CSetGammaRampMsg.gamma_ramp)
  if (!_internal_has_gamma_ramp()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = gamma_ramp_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamma_ramp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamma_ramp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetGammaRampMsg::set_allocated_gamma_ramp(std::string* gamma_ramp) {
  if (gamma_ramp != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  gamma_ramp_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), gamma_ramp,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (gamma_ramp_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    gamma_ramp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetGammaRampMsg.gamma_ramp)
}

// -------------------------------------------------------------------

// CSetActivityMsg

// optional .EStreamActivity activity = 1 [default = k_EStreamActivityIdle];
inline bool CSetActivityMsg::_internal_has_activity() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSetActivityMsg::has_activity() const {
  return _internal_has_activity();
}
inline void CSetActivityMsg::clear_activity() {
  activity_ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EStreamActivity CSetActivityMsg::_internal_activity() const {
  return static_cast< ::EStreamActivity >(activity_);
}
inline ::EStreamActivity CSetActivityMsg::activity() const {
  // @@protoc_insertion_point(field_get:CSetActivityMsg.activity)
  return _internal_activity();
}
inline void CSetActivityMsg::_internal_set_activity(::EStreamActivity value) {
  assert(::EStreamActivity_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  activity_ = value;
}
inline void CSetActivityMsg::set_activity(::EStreamActivity value) {
  _internal_set_activity(value);
  // @@protoc_insertion_point(field_set:CSetActivityMsg.activity)
}

// optional uint32 appid = 2;
inline bool CSetActivityMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetActivityMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CSetActivityMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSetActivityMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CSetActivityMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSetActivityMsg.appid)
  return _internal_appid();
}
inline void CSetActivityMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void CSetActivityMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSetActivityMsg.appid)
}

// optional uint64 gameid = 3;
inline bool CSetActivityMsg::_internal_has_gameid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetActivityMsg::has_gameid() const {
  return _internal_has_gameid();
}
inline void CSetActivityMsg::clear_gameid() {
  gameid_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000002u;
}
inline uint64_t CSetActivityMsg::_internal_gameid() const {
  return gameid_;
}
inline uint64_t CSetActivityMsg::gameid() const {
  // @@protoc_insertion_point(field_get:CSetActivityMsg.gameid)
  return _internal_gameid();
}
inline void CSetActivityMsg::_internal_set_gameid(uint64_t value) {
  _has_bits_[0] |= 0x00000002u;
  gameid_ = value;
}
inline void CSetActivityMsg::set_gameid(uint64_t value) {
  _internal_set_gameid(value);
  // @@protoc_insertion_point(field_set:CSetActivityMsg.gameid)
}

// optional string game_name = 4;
inline bool CSetActivityMsg::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetActivityMsg::has_game_name() const {
  return _internal_has_game_name();
}
inline void CSetActivityMsg::clear_game_name() {
  game_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetActivityMsg::game_name() const {
  // @@protoc_insertion_point(field_get:CSetActivityMsg.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetActivityMsg::set_game_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetActivityMsg.game_name)
}
inline std::string* CSetActivityMsg::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:CSetActivityMsg.game_name)
  return _s;
}
inline const std::string& CSetActivityMsg::_internal_game_name() const {
  return game_name_.Get();
}
inline void CSetActivityMsg::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetActivityMsg::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000001u;
  return game_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetActivityMsg::release_game_name() {
  // @@protoc_insertion_point(field_release:CSetActivityMsg.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetActivityMsg::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetActivityMsg.game_name)
}

// -------------------------------------------------------------------

// CSystemSuspendMsg

// -------------------------------------------------------------------

// CVirtualHereRequestMsg

// optional string hostname = 1;
inline bool CVirtualHereRequestMsg::_internal_has_hostname() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVirtualHereRequestMsg::has_hostname() const {
  return _internal_has_hostname();
}
inline void CVirtualHereRequestMsg::clear_hostname() {
  hostname_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CVirtualHereRequestMsg::hostname() const {
  // @@protoc_insertion_point(field_get:CVirtualHereRequestMsg.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CVirtualHereRequestMsg::set_hostname(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVirtualHereRequestMsg.hostname)
}
inline std::string* CVirtualHereRequestMsg::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:CVirtualHereRequestMsg.hostname)
  return _s;
}
inline const std::string& CVirtualHereRequestMsg::_internal_hostname() const {
  return hostname_.Get();
}
inline void CVirtualHereRequestMsg::_internal_set_hostname(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CVirtualHereRequestMsg::_internal_mutable_hostname() {
  _has_bits_[0] |= 0x00000001u;
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CVirtualHereRequestMsg::release_hostname() {
  // @@protoc_insertion_point(field_release:CVirtualHereRequestMsg.hostname)
  if (!_internal_has_hostname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = hostname_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CVirtualHereRequestMsg::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (hostname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    hostname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVirtualHereRequestMsg.hostname)
}

// -------------------------------------------------------------------

// CVirtualHereReadyMsg

// optional uint32 licensed_device_count = 1;
inline bool CVirtualHereReadyMsg::_internal_has_licensed_device_count() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVirtualHereReadyMsg::has_licensed_device_count() const {
  return _internal_has_licensed_device_count();
}
inline void CVirtualHereReadyMsg::clear_licensed_device_count() {
  licensed_device_count_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CVirtualHereReadyMsg::_internal_licensed_device_count() const {
  return licensed_device_count_;
}
inline uint32_t CVirtualHereReadyMsg::licensed_device_count() const {
  // @@protoc_insertion_point(field_get:CVirtualHereReadyMsg.licensed_device_count)
  return _internal_licensed_device_count();
}
inline void CVirtualHereReadyMsg::_internal_set_licensed_device_count(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  licensed_device_count_ = value;
}
inline void CVirtualHereReadyMsg::set_licensed_device_count(uint32_t value) {
  _internal_set_licensed_device_count(value);
  // @@protoc_insertion_point(field_set:CVirtualHereReadyMsg.licensed_device_count)
}

// -------------------------------------------------------------------

// CVirtualHereShareDeviceMsg

// optional string device_address = 1;
inline bool CVirtualHereShareDeviceMsg::_internal_has_device_address() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVirtualHereShareDeviceMsg::has_device_address() const {
  return _internal_has_device_address();
}
inline void CVirtualHereShareDeviceMsg::clear_device_address() {
  device_address_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CVirtualHereShareDeviceMsg::device_address() const {
  // @@protoc_insertion_point(field_get:CVirtualHereShareDeviceMsg.device_address)
  return _internal_device_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CVirtualHereShareDeviceMsg::set_device_address(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 device_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CVirtualHereShareDeviceMsg.device_address)
}
inline std::string* CVirtualHereShareDeviceMsg::mutable_device_address() {
  std::string* _s = _internal_mutable_device_address();
  // @@protoc_insertion_point(field_mutable:CVirtualHereShareDeviceMsg.device_address)
  return _s;
}
inline const std::string& CVirtualHereShareDeviceMsg::_internal_device_address() const {
  return device_address_.Get();
}
inline void CVirtualHereShareDeviceMsg::_internal_set_device_address(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  device_address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CVirtualHereShareDeviceMsg::_internal_mutable_device_address() {
  _has_bits_[0] |= 0x00000001u;
  return device_address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CVirtualHereShareDeviceMsg::release_device_address() {
  // @@protoc_insertion_point(field_release:CVirtualHereShareDeviceMsg.device_address)
  if (!_internal_has_device_address()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = device_address_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CVirtualHereShareDeviceMsg::set_allocated_device_address(std::string* device_address) {
  if (device_address != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  device_address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), device_address,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_address_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    device_address_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CVirtualHereShareDeviceMsg.device_address)
}

// -------------------------------------------------------------------

// CSetSpectatorModeMsg

// optional bool enabled = 1;
inline bool CSetSpectatorModeMsg::_internal_has_enabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetSpectatorModeMsg::has_enabled() const {
  return _internal_has_enabled();
}
inline void CSetSpectatorModeMsg::clear_enabled() {
  enabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSetSpectatorModeMsg::_internal_enabled() const {
  return enabled_;
}
inline bool CSetSpectatorModeMsg::enabled() const {
  // @@protoc_insertion_point(field_get:CSetSpectatorModeMsg.enabled)
  return _internal_enabled();
}
inline void CSetSpectatorModeMsg::_internal_set_enabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  enabled_ = value;
}
inline void CSetSpectatorModeMsg::set_enabled(bool value) {
  _internal_set_enabled(value);
  // @@protoc_insertion_point(field_set:CSetSpectatorModeMsg.enabled)
}

// -------------------------------------------------------------------

// CRemoteHIDMsg

// optional bytes data = 1;
inline bool CRemoteHIDMsg::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CRemoteHIDMsg::has_data() const {
  return _internal_has_data();
}
inline void CRemoteHIDMsg::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CRemoteHIDMsg::data() const {
  // @@protoc_insertion_point(field_get:CRemoteHIDMsg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CRemoteHIDMsg::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRemoteHIDMsg.data)
}
inline std::string* CRemoteHIDMsg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:CRemoteHIDMsg.data)
  return _s;
}
inline const std::string& CRemoteHIDMsg::_internal_data() const {
  return data_.Get();
}
inline void CRemoteHIDMsg::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CRemoteHIDMsg::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CRemoteHIDMsg::release_data() {
  // @@protoc_insertion_point(field_release:CRemoteHIDMsg.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CRemoteHIDMsg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRemoteHIDMsg.data)
}

// optional bool active_input = 2;
inline bool CRemoteHIDMsg::_internal_has_active_input() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CRemoteHIDMsg::has_active_input() const {
  return _internal_has_active_input();
}
inline void CRemoteHIDMsg::clear_active_input() {
  active_input_ = false;
  _has_bits_[0] &= ~0x00000002u;
}
inline bool CRemoteHIDMsg::_internal_active_input() const {
  return active_input_;
}
inline bool CRemoteHIDMsg::active_input() const {
  // @@protoc_insertion_point(field_get:CRemoteHIDMsg.active_input)
  return _internal_active_input();
}
inline void CRemoteHIDMsg::_internal_set_active_input(bool value) {
  _has_bits_[0] |= 0x00000002u;
  active_input_ = value;
}
inline void CRemoteHIDMsg::set_active_input(bool value) {
  _internal_set_active_input(value);
  // @@protoc_insertion_point(field_set:CRemoteHIDMsg.active_input)
}

// -------------------------------------------------------------------

// CTouchConfigActiveMsg

// optional uint32 appid = 1;
inline bool CTouchConfigActiveMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTouchConfigActiveMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CTouchConfigActiveMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CTouchConfigActiveMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CTouchConfigActiveMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchConfigActiveMsg.appid)
  return _internal_appid();
}
inline void CTouchConfigActiveMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CTouchConfigActiveMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CTouchConfigActiveMsg.appid)
}

// optional uint32 revision = 2;
inline bool CTouchConfigActiveMsg::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTouchConfigActiveMsg::has_revision() const {
  return _internal_has_revision();
}
inline void CTouchConfigActiveMsg::clear_revision() {
  revision_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CTouchConfigActiveMsg::_internal_revision() const {
  return revision_;
}
inline uint32_t CTouchConfigActiveMsg::revision() const {
  // @@protoc_insertion_point(field_get:CTouchConfigActiveMsg.revision)
  return _internal_revision();
}
inline void CTouchConfigActiveMsg::_internal_set_revision(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  revision_ = value;
}
inline void CTouchConfigActiveMsg::set_revision(uint32_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:CTouchConfigActiveMsg.revision)
}

// optional uint64 creator = 3;
inline bool CTouchConfigActiveMsg::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CTouchConfigActiveMsg::has_creator() const {
  return _internal_has_creator();
}
inline void CTouchConfigActiveMsg::clear_creator() {
  creator_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000004u;
}
inline uint64_t CTouchConfigActiveMsg::_internal_creator() const {
  return creator_;
}
inline uint64_t CTouchConfigActiveMsg::creator() const {
  // @@protoc_insertion_point(field_get:CTouchConfigActiveMsg.creator)
  return _internal_creator();
}
inline void CTouchConfigActiveMsg::_internal_set_creator(uint64_t value) {
  _has_bits_[0] |= 0x00000004u;
  creator_ = value;
}
inline void CTouchConfigActiveMsg::set_creator(uint64_t value) {
  _internal_set_creator(value);
  // @@protoc_insertion_point(field_set:CTouchConfigActiveMsg.creator)
}

// -------------------------------------------------------------------

// CGetTouchConfigDataMsg

// optional uint32 appid = 1;
inline bool CGetTouchConfigDataMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CGetTouchConfigDataMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CGetTouchConfigDataMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CGetTouchConfigDataMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CGetTouchConfigDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CGetTouchConfigDataMsg.appid)
  return _internal_appid();
}
inline void CGetTouchConfigDataMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CGetTouchConfigDataMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CGetTouchConfigDataMsg.appid)
}

// -------------------------------------------------------------------

// CSetTouchConfigDataMsg

// optional uint32 appid = 1;
inline bool CSetTouchConfigDataMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetTouchConfigDataMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CSetTouchConfigDataMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSetTouchConfigDataMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CSetTouchConfigDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.appid)
  return _internal_appid();
}
inline void CSetTouchConfigDataMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void CSetTouchConfigDataMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.appid)
}

// optional uint32 revision = 2;
inline bool CSetTouchConfigDataMsg::_internal_has_revision() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CSetTouchConfigDataMsg::has_revision() const {
  return _internal_has_revision();
}
inline void CSetTouchConfigDataMsg::clear_revision() {
  revision_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CSetTouchConfigDataMsg::_internal_revision() const {
  return revision_;
}
inline uint32_t CSetTouchConfigDataMsg::revision() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.revision)
  return _internal_revision();
}
inline void CSetTouchConfigDataMsg::_internal_set_revision(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  revision_ = value;
}
inline void CSetTouchConfigDataMsg::set_revision(uint32_t value) {
  _internal_set_revision(value);
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.revision)
}

// optional bytes data = 3;
inline bool CSetTouchConfigDataMsg::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetTouchConfigDataMsg::has_data() const {
  return _internal_has_data();
}
inline void CSetTouchConfigDataMsg::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetTouchConfigDataMsg::data() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetTouchConfigDataMsg::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.data)
}
inline std::string* CSetTouchConfigDataMsg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:CSetTouchConfigDataMsg.data)
  return _s;
}
inline const std::string& CSetTouchConfigDataMsg::_internal_data() const {
  return data_.Get();
}
inline void CSetTouchConfigDataMsg::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetTouchConfigDataMsg::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetTouchConfigDataMsg::release_data() {
  // @@protoc_insertion_point(field_release:CSetTouchConfigDataMsg.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetTouchConfigDataMsg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetTouchConfigDataMsg.data)
}

// optional bytes layout = 4;
inline bool CSetTouchConfigDataMsg::_internal_has_layout() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetTouchConfigDataMsg::has_layout() const {
  return _internal_has_layout();
}
inline void CSetTouchConfigDataMsg::clear_layout() {
  layout_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSetTouchConfigDataMsg::layout() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.layout)
  return _internal_layout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetTouchConfigDataMsg::set_layout(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 layout_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.layout)
}
inline std::string* CSetTouchConfigDataMsg::mutable_layout() {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:CSetTouchConfigDataMsg.layout)
  return _s;
}
inline const std::string& CSetTouchConfigDataMsg::_internal_layout() const {
  return layout_.Get();
}
inline void CSetTouchConfigDataMsg::_internal_set_layout(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  layout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetTouchConfigDataMsg::_internal_mutable_layout() {
  _has_bits_[0] |= 0x00000002u;
  return layout_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetTouchConfigDataMsg::release_layout() {
  // @@protoc_insertion_point(field_release:CSetTouchConfigDataMsg.layout)
  if (!_internal_has_layout()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = layout_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (layout_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetTouchConfigDataMsg::set_allocated_layout(std::string* layout) {
  if (layout != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  layout_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), layout,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (layout_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetTouchConfigDataMsg.layout)
}

// optional uint64 creator = 5;
inline bool CSetTouchConfigDataMsg::_internal_has_creator() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CSetTouchConfigDataMsg::has_creator() const {
  return _internal_has_creator();
}
inline void CSetTouchConfigDataMsg::clear_creator() {
  creator_ = uint64_t{0u};
  _has_bits_[0] &= ~0x00000010u;
}
inline uint64_t CSetTouchConfigDataMsg::_internal_creator() const {
  return creator_;
}
inline uint64_t CSetTouchConfigDataMsg::creator() const {
  // @@protoc_insertion_point(field_get:CSetTouchConfigDataMsg.creator)
  return _internal_creator();
}
inline void CSetTouchConfigDataMsg::_internal_set_creator(uint64_t value) {
  _has_bits_[0] |= 0x00000010u;
  creator_ = value;
}
inline void CSetTouchConfigDataMsg::set_creator(uint64_t value) {
  _internal_set_creator(value);
  // @@protoc_insertion_point(field_set:CSetTouchConfigDataMsg.creator)
}

// -------------------------------------------------------------------

// CSaveTouchConfigLayoutMsg

// optional uint32 appid = 1;
inline bool CSaveTouchConfigLayoutMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSaveTouchConfigLayoutMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CSaveTouchConfigLayoutMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CSaveTouchConfigLayoutMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CSaveTouchConfigLayoutMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSaveTouchConfigLayoutMsg.appid)
  return _internal_appid();
}
inline void CSaveTouchConfigLayoutMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CSaveTouchConfigLayoutMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSaveTouchConfigLayoutMsg.appid)
}

// optional bytes layout = 4;
inline bool CSaveTouchConfigLayoutMsg::_internal_has_layout() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSaveTouchConfigLayoutMsg::has_layout() const {
  return _internal_has_layout();
}
inline void CSaveTouchConfigLayoutMsg::clear_layout() {
  layout_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSaveTouchConfigLayoutMsg::layout() const {
  // @@protoc_insertion_point(field_get:CSaveTouchConfigLayoutMsg.layout)
  return _internal_layout();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSaveTouchConfigLayoutMsg::set_layout(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 layout_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSaveTouchConfigLayoutMsg.layout)
}
inline std::string* CSaveTouchConfigLayoutMsg::mutable_layout() {
  std::string* _s = _internal_mutable_layout();
  // @@protoc_insertion_point(field_mutable:CSaveTouchConfigLayoutMsg.layout)
  return _s;
}
inline const std::string& CSaveTouchConfigLayoutMsg::_internal_layout() const {
  return layout_.Get();
}
inline void CSaveTouchConfigLayoutMsg::_internal_set_layout(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  layout_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSaveTouchConfigLayoutMsg::_internal_mutable_layout() {
  _has_bits_[0] |= 0x00000001u;
  return layout_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSaveTouchConfigLayoutMsg::release_layout() {
  // @@protoc_insertion_point(field_release:CSaveTouchConfigLayoutMsg.layout)
  if (!_internal_has_layout()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = layout_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (layout_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSaveTouchConfigLayoutMsg::set_allocated_layout(std::string* layout) {
  if (layout != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  layout_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), layout,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (layout_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    layout_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSaveTouchConfigLayoutMsg.layout)
}

// -------------------------------------------------------------------

// CTouchActionSetActiveMsg

// optional uint32 appid = 1;
inline bool CTouchActionSetActiveMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTouchActionSetActiveMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CTouchActionSetActiveMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CTouchActionSetActiveMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CTouchActionSetActiveMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetActiveMsg.appid)
  return _internal_appid();
}
inline void CTouchActionSetActiveMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CTouchActionSetActiveMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetActiveMsg.appid)
}

// optional int32 actionset_id = 2;
inline bool CTouchActionSetActiveMsg::_internal_has_actionset_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTouchActionSetActiveMsg::has_actionset_id() const {
  return _internal_has_actionset_id();
}
inline void CTouchActionSetActiveMsg::clear_actionset_id() {
  actionset_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CTouchActionSetActiveMsg::_internal_actionset_id() const {
  return actionset_id_;
}
inline int32_t CTouchActionSetActiveMsg::actionset_id() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetActiveMsg.actionset_id)
  return _internal_actionset_id();
}
inline void CTouchActionSetActiveMsg::_internal_set_actionset_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  actionset_id_ = value;
}
inline void CTouchActionSetActiveMsg::set_actionset_id(int32_t value) {
  _internal_set_actionset_id(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetActiveMsg.actionset_id)
}

// -------------------------------------------------------------------

// CTouchActionSetLayerAddedMsg

// optional uint32 appid = 1;
inline bool CTouchActionSetLayerAddedMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTouchActionSetLayerAddedMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CTouchActionSetLayerAddedMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CTouchActionSetLayerAddedMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CTouchActionSetLayerAddedMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetLayerAddedMsg.appid)
  return _internal_appid();
}
inline void CTouchActionSetLayerAddedMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CTouchActionSetLayerAddedMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetLayerAddedMsg.appid)
}

// optional int32 actionset_id = 2;
inline bool CTouchActionSetLayerAddedMsg::_internal_has_actionset_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTouchActionSetLayerAddedMsg::has_actionset_id() const {
  return _internal_has_actionset_id();
}
inline void CTouchActionSetLayerAddedMsg::clear_actionset_id() {
  actionset_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CTouchActionSetLayerAddedMsg::_internal_actionset_id() const {
  return actionset_id_;
}
inline int32_t CTouchActionSetLayerAddedMsg::actionset_id() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetLayerAddedMsg.actionset_id)
  return _internal_actionset_id();
}
inline void CTouchActionSetLayerAddedMsg::_internal_set_actionset_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  actionset_id_ = value;
}
inline void CTouchActionSetLayerAddedMsg::set_actionset_id(int32_t value) {
  _internal_set_actionset_id(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetLayerAddedMsg.actionset_id)
}

// -------------------------------------------------------------------

// CTouchActionSetLayerRemovedMsg

// optional uint32 appid = 1;
inline bool CTouchActionSetLayerRemovedMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTouchActionSetLayerRemovedMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CTouchActionSetLayerRemovedMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CTouchActionSetLayerRemovedMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CTouchActionSetLayerRemovedMsg::appid() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetLayerRemovedMsg.appid)
  return _internal_appid();
}
inline void CTouchActionSetLayerRemovedMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  appid_ = value;
}
inline void CTouchActionSetLayerRemovedMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetLayerRemovedMsg.appid)
}

// optional int32 actionset_id = 2;
inline bool CTouchActionSetLayerRemovedMsg::_internal_has_actionset_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTouchActionSetLayerRemovedMsg::has_actionset_id() const {
  return _internal_has_actionset_id();
}
inline void CTouchActionSetLayerRemovedMsg::clear_actionset_id() {
  actionset_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CTouchActionSetLayerRemovedMsg::_internal_actionset_id() const {
  return actionset_id_;
}
inline int32_t CTouchActionSetLayerRemovedMsg::actionset_id() const {
  // @@protoc_insertion_point(field_get:CTouchActionSetLayerRemovedMsg.actionset_id)
  return _internal_actionset_id();
}
inline void CTouchActionSetLayerRemovedMsg::_internal_set_actionset_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  actionset_id_ = value;
}
inline void CTouchActionSetLayerRemovedMsg::set_actionset_id(int32_t value) {
  _internal_set_actionset_id(value);
  // @@protoc_insertion_point(field_set:CTouchActionSetLayerRemovedMsg.actionset_id)
}

// -------------------------------------------------------------------

// CGetTouchIconDataMsg

// optional uint32 appid = 1;
inline bool CGetTouchIconDataMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CGetTouchIconDataMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CGetTouchIconDataMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CGetTouchIconDataMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CGetTouchIconDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CGetTouchIconDataMsg.appid)
  return _internal_appid();
}
inline void CGetTouchIconDataMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  appid_ = value;
}
inline void CGetTouchIconDataMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CGetTouchIconDataMsg.appid)
}

// optional string icon = 2;
inline bool CGetTouchIconDataMsg::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CGetTouchIconDataMsg::has_icon() const {
  return _internal_has_icon();
}
inline void CGetTouchIconDataMsg::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CGetTouchIconDataMsg::icon() const {
  // @@protoc_insertion_point(field_get:CGetTouchIconDataMsg.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CGetTouchIconDataMsg::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CGetTouchIconDataMsg.icon)
}
inline std::string* CGetTouchIconDataMsg::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:CGetTouchIconDataMsg.icon)
  return _s;
}
inline const std::string& CGetTouchIconDataMsg::_internal_icon() const {
  return icon_.Get();
}
inline void CGetTouchIconDataMsg::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CGetTouchIconDataMsg::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000001u;
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CGetTouchIconDataMsg::release_icon() {
  // @@protoc_insertion_point(field_release:CGetTouchIconDataMsg.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CGetTouchIconDataMsg::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CGetTouchIconDataMsg.icon)
}

// -------------------------------------------------------------------

// CSetTouchIconDataMsg

// optional uint32 appid = 1;
inline bool CSetTouchIconDataMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CSetTouchIconDataMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CSetTouchIconDataMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CSetTouchIconDataMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CSetTouchIconDataMsg::appid() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.appid)
  return _internal_appid();
}
inline void CSetTouchIconDataMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void CSetTouchIconDataMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.appid)
}

// optional string icon = 2;
inline bool CSetTouchIconDataMsg::_internal_has_icon() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetTouchIconDataMsg::has_icon() const {
  return _internal_has_icon();
}
inline void CSetTouchIconDataMsg::clear_icon() {
  icon_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CSetTouchIconDataMsg::icon() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.icon)
  return _internal_icon();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetTouchIconDataMsg::set_icon(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.icon)
}
inline std::string* CSetTouchIconDataMsg::mutable_icon() {
  std::string* _s = _internal_mutable_icon();
  // @@protoc_insertion_point(field_mutable:CSetTouchIconDataMsg.icon)
  return _s;
}
inline const std::string& CSetTouchIconDataMsg::_internal_icon() const {
  return icon_.Get();
}
inline void CSetTouchIconDataMsg::_internal_set_icon(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  icon_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetTouchIconDataMsg::_internal_mutable_icon() {
  _has_bits_[0] |= 0x00000001u;
  return icon_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetTouchIconDataMsg::release_icon() {
  // @@protoc_insertion_point(field_release:CSetTouchIconDataMsg.icon)
  if (!_internal_has_icon()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = icon_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetTouchIconDataMsg::set_allocated_icon(std::string* icon) {
  if (icon != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  icon_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), icon,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (icon_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    icon_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetTouchIconDataMsg.icon)
}

// optional bytes data = 3;
inline bool CSetTouchIconDataMsg::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CSetTouchIconDataMsg::has_data() const {
  return _internal_has_data();
}
inline void CSetTouchIconDataMsg::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CSetTouchIconDataMsg::data() const {
  // @@protoc_insertion_point(field_get:CSetTouchIconDataMsg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CSetTouchIconDataMsg::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CSetTouchIconDataMsg.data)
}
inline std::string* CSetTouchIconDataMsg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:CSetTouchIconDataMsg.data)
  return _s;
}
inline const std::string& CSetTouchIconDataMsg::_internal_data() const {
  return data_.Get();
}
inline void CSetTouchIconDataMsg::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CSetTouchIconDataMsg::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000002u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CSetTouchIconDataMsg::release_data() {
  // @@protoc_insertion_point(field_release:CSetTouchIconDataMsg.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CSetTouchIconDataMsg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CSetTouchIconDataMsg.data)
}

// -------------------------------------------------------------------

// CRemotePlayTogetherGroupUpdateMsg_Player

// optional uint32 accountid = 1;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_accountid() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_accountid() const {
  return _internal_has_accountid();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_accountid() {
  accountid_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::_internal_accountid() const {
  return accountid_;
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::accountid() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.accountid)
  return _internal_accountid();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_accountid(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  accountid_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_accountid(uint32_t value) {
  _internal_set_accountid(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.accountid)
}

// optional uint32 guestid = 2;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_guestid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_guestid() const {
  return _internal_has_guestid();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_guestid() {
  guestid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::_internal_guestid() const {
  return guestid_;
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::guestid() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.guestid)
  return _internal_guestid();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_guestid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  guestid_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_guestid(uint32_t value) {
  _internal_set_guestid(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.guestid)
}

// optional bool keyboard_enabled = 3;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_keyboard_enabled() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_keyboard_enabled() const {
  return _internal_has_keyboard_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_keyboard_enabled() {
  keyboard_enabled_ = false;
  _has_bits_[0] &= ~0x00000008u;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_keyboard_enabled() const {
  return keyboard_enabled_;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::keyboard_enabled() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.keyboard_enabled)
  return _internal_keyboard_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_keyboard_enabled(bool value) {
  _has_bits_[0] |= 0x00000008u;
  keyboard_enabled_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_keyboard_enabled(bool value) {
  _internal_set_keyboard_enabled(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.keyboard_enabled)
}

// optional bool mouse_enabled = 4;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_mouse_enabled() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_mouse_enabled() const {
  return _internal_has_mouse_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_mouse_enabled() {
  mouse_enabled_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_mouse_enabled() const {
  return mouse_enabled_;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::mouse_enabled() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.mouse_enabled)
  return _internal_mouse_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_mouse_enabled(bool value) {
  _has_bits_[0] |= 0x00000010u;
  mouse_enabled_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_mouse_enabled(bool value) {
  _internal_set_mouse_enabled(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.mouse_enabled)
}

// optional bool controller_enabled = 5;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_controller_enabled() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_controller_enabled() const {
  return _internal_has_controller_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_controller_enabled() {
  controller_enabled_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_controller_enabled() const {
  return controller_enabled_;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::controller_enabled() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.controller_enabled)
  return _internal_controller_enabled();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_controller_enabled(bool value) {
  _has_bits_[0] |= 0x00000020u;
  controller_enabled_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_controller_enabled(bool value) {
  _internal_set_controller_enabled(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.controller_enabled)
}

// repeated uint32 controller_slots = 6;
inline int CRemotePlayTogetherGroupUpdateMsg_Player::_internal_controller_slots_size() const {
  return controller_slots_.size();
}
inline int CRemotePlayTogetherGroupUpdateMsg_Player::controller_slots_size() const {
  return _internal_controller_slots_size();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_controller_slots() {
  controller_slots_.Clear();
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::_internal_controller_slots(int index) const {
  return controller_slots_.Get(index);
}
inline uint32_t CRemotePlayTogetherGroupUpdateMsg_Player::controller_slots(int index) const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
  return _internal_controller_slots(index);
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_controller_slots(int index, uint32_t value) {
  controller_slots_.Set(index, value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_add_controller_slots(uint32_t value) {
  controller_slots_.Add(value);
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::add_controller_slots(uint32_t value) {
  _internal_add_controller_slots(value);
  // @@protoc_insertion_point(field_add:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CRemotePlayTogetherGroupUpdateMsg_Player::_internal_controller_slots() const {
  return controller_slots_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CRemotePlayTogetherGroupUpdateMsg_Player::controller_slots() const {
  // @@protoc_insertion_point(field_list:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
  return _internal_controller_slots();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CRemotePlayTogetherGroupUpdateMsg_Player::_internal_mutable_controller_slots() {
  return &controller_slots_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CRemotePlayTogetherGroupUpdateMsg_Player::mutable_controller_slots() {
  // @@protoc_insertion_point(field_mutable_list:CRemotePlayTogetherGroupUpdateMsg.Player.controller_slots)
  return _internal_mutable_controller_slots();
}

// optional bytes avatar_hash = 7;
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::_internal_has_avatar_hash() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg_Player::has_avatar_hash() const {
  return _internal_has_avatar_hash();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::clear_avatar_hash() {
  avatar_hash_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg_Player::avatar_hash() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
  return _internal_avatar_hash();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CRemotePlayTogetherGroupUpdateMsg_Player::set_avatar_hash(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 avatar_hash_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg_Player::mutable_avatar_hash() {
  std::string* _s = _internal_mutable_avatar_hash();
  // @@protoc_insertion_point(field_mutable:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
  return _s;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg_Player::_internal_avatar_hash() const {
  return avatar_hash_.Get();
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::_internal_set_avatar_hash(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  avatar_hash_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg_Player::_internal_mutable_avatar_hash() {
  _has_bits_[0] |= 0x00000001u;
  return avatar_hash_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg_Player::release_avatar_hash() {
  // @@protoc_insertion_point(field_release:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
  if (!_internal_has_avatar_hash()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = avatar_hash_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CRemotePlayTogetherGroupUpdateMsg_Player::set_allocated_avatar_hash(std::string* avatar_hash) {
  if (avatar_hash != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  avatar_hash_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_hash,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_hash_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_hash_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRemotePlayTogetherGroupUpdateMsg.Player.avatar_hash)
}

// -------------------------------------------------------------------

// CRemotePlayTogetherGroupUpdateMsg

// repeated .CRemotePlayTogetherGroupUpdateMsg.Player players = 1;
inline int CRemotePlayTogetherGroupUpdateMsg::_internal_players_size() const {
  return players_.size();
}
inline int CRemotePlayTogetherGroupUpdateMsg::players_size() const {
  return _internal_players_size();
}
inline void CRemotePlayTogetherGroupUpdateMsg::clear_players() {
  players_.Clear();
}
inline ::CRemotePlayTogetherGroupUpdateMsg_Player* CRemotePlayTogetherGroupUpdateMsg::mutable_players(int index) {
  // @@protoc_insertion_point(field_mutable:CRemotePlayTogetherGroupUpdateMsg.players)
  return players_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRemotePlayTogetherGroupUpdateMsg_Player >*
CRemotePlayTogetherGroupUpdateMsg::mutable_players() {
  // @@protoc_insertion_point(field_mutable_list:CRemotePlayTogetherGroupUpdateMsg.players)
  return &players_;
}
inline const ::CRemotePlayTogetherGroupUpdateMsg_Player& CRemotePlayTogetherGroupUpdateMsg::_internal_players(int index) const {
  return players_.Get(index);
}
inline const ::CRemotePlayTogetherGroupUpdateMsg_Player& CRemotePlayTogetherGroupUpdateMsg::players(int index) const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.players)
  return _internal_players(index);
}
inline ::CRemotePlayTogetherGroupUpdateMsg_Player* CRemotePlayTogetherGroupUpdateMsg::_internal_add_players() {
  return players_.Add();
}
inline ::CRemotePlayTogetherGroupUpdateMsg_Player* CRemotePlayTogetherGroupUpdateMsg::add_players() {
  ::CRemotePlayTogetherGroupUpdateMsg_Player* _add = _internal_add_players();
  // @@protoc_insertion_point(field_add:CRemotePlayTogetherGroupUpdateMsg.players)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CRemotePlayTogetherGroupUpdateMsg_Player >&
CRemotePlayTogetherGroupUpdateMsg::players() const {
  // @@protoc_insertion_point(field_list:CRemotePlayTogetherGroupUpdateMsg.players)
  return players_;
}

// optional int32 player_index = 2;
inline bool CRemotePlayTogetherGroupUpdateMsg::_internal_has_player_index() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg::has_player_index() const {
  return _internal_has_player_index();
}
inline void CRemotePlayTogetherGroupUpdateMsg::clear_player_index() {
  player_index_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline int32_t CRemotePlayTogetherGroupUpdateMsg::_internal_player_index() const {
  return player_index_;
}
inline int32_t CRemotePlayTogetherGroupUpdateMsg::player_index() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.player_index)
  return _internal_player_index();
}
inline void CRemotePlayTogetherGroupUpdateMsg::_internal_set_player_index(int32_t value) {
  _has_bits_[0] |= 0x00000008u;
  player_index_ = value;
}
inline void CRemotePlayTogetherGroupUpdateMsg::set_player_index(int32_t value) {
  _internal_set_player_index(value);
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.player_index)
}

// optional string miniprofile_location = 3;
inline bool CRemotePlayTogetherGroupUpdateMsg::_internal_has_miniprofile_location() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg::has_miniprofile_location() const {
  return _internal_has_miniprofile_location();
}
inline void CRemotePlayTogetherGroupUpdateMsg::clear_miniprofile_location() {
  miniprofile_location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::miniprofile_location() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
  return _internal_miniprofile_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CRemotePlayTogetherGroupUpdateMsg::set_miniprofile_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 miniprofile_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::mutable_miniprofile_location() {
  std::string* _s = _internal_mutable_miniprofile_location();
  // @@protoc_insertion_point(field_mutable:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
  return _s;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::_internal_miniprofile_location() const {
  return miniprofile_location_.Get();
}
inline void CRemotePlayTogetherGroupUpdateMsg::_internal_set_miniprofile_location(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  miniprofile_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::_internal_mutable_miniprofile_location() {
  _has_bits_[0] |= 0x00000001u;
  return miniprofile_location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::release_miniprofile_location() {
  // @@protoc_insertion_point(field_release:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
  if (!_internal_has_miniprofile_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = miniprofile_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (miniprofile_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    miniprofile_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CRemotePlayTogetherGroupUpdateMsg::set_allocated_miniprofile_location(std::string* miniprofile_location) {
  if (miniprofile_location != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  miniprofile_location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), miniprofile_location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (miniprofile_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    miniprofile_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRemotePlayTogetherGroupUpdateMsg.miniprofile_location)
}

// optional string game_name = 4;
inline bool CRemotePlayTogetherGroupUpdateMsg::_internal_has_game_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg::has_game_name() const {
  return _internal_has_game_name();
}
inline void CRemotePlayTogetherGroupUpdateMsg::clear_game_name() {
  game_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::game_name() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.game_name)
  return _internal_game_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CRemotePlayTogetherGroupUpdateMsg::set_game_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.game_name)
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::mutable_game_name() {
  std::string* _s = _internal_mutable_game_name();
  // @@protoc_insertion_point(field_mutable:CRemotePlayTogetherGroupUpdateMsg.game_name)
  return _s;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::_internal_game_name() const {
  return game_name_.Get();
}
inline void CRemotePlayTogetherGroupUpdateMsg::_internal_set_game_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  game_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::_internal_mutable_game_name() {
  _has_bits_[0] |= 0x00000002u;
  return game_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::release_game_name() {
  // @@protoc_insertion_point(field_release:CRemotePlayTogetherGroupUpdateMsg.game_name)
  if (!_internal_has_game_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = game_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CRemotePlayTogetherGroupUpdateMsg::set_allocated_game_name(std::string* game_name) {
  if (game_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  game_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), game_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (game_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    game_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRemotePlayTogetherGroupUpdateMsg.game_name)
}

// optional string avatar_location = 5;
inline bool CRemotePlayTogetherGroupUpdateMsg::_internal_has_avatar_location() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CRemotePlayTogetherGroupUpdateMsg::has_avatar_location() const {
  return _internal_has_avatar_location();
}
inline void CRemotePlayTogetherGroupUpdateMsg::clear_avatar_location() {
  avatar_location_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::avatar_location() const {
  // @@protoc_insertion_point(field_get:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
  return _internal_avatar_location();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CRemotePlayTogetherGroupUpdateMsg::set_avatar_location(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000004u;
 avatar_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::mutable_avatar_location() {
  std::string* _s = _internal_mutable_avatar_location();
  // @@protoc_insertion_point(field_mutable:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
  return _s;
}
inline const std::string& CRemotePlayTogetherGroupUpdateMsg::_internal_avatar_location() const {
  return avatar_location_.Get();
}
inline void CRemotePlayTogetherGroupUpdateMsg::_internal_set_avatar_location(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  avatar_location_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::_internal_mutable_avatar_location() {
  _has_bits_[0] |= 0x00000004u;
  return avatar_location_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CRemotePlayTogetherGroupUpdateMsg::release_avatar_location() {
  // @@protoc_insertion_point(field_release:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
  if (!_internal_has_avatar_location()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  auto* p = avatar_location_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CRemotePlayTogetherGroupUpdateMsg::set_allocated_avatar_location(std::string* avatar_location) {
  if (avatar_location != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  avatar_location_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_location,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (avatar_location_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    avatar_location_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CRemotePlayTogetherGroupUpdateMsg.avatar_location)
}

// -------------------------------------------------------------------

// CSetInputTemporarilyDisabledMsg

// optional bool disabled = 1;
inline bool CSetInputTemporarilyDisabledMsg::_internal_has_disabled() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetInputTemporarilyDisabledMsg::has_disabled() const {
  return _internal_has_disabled();
}
inline void CSetInputTemporarilyDisabledMsg::clear_disabled() {
  disabled_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool CSetInputTemporarilyDisabledMsg::_internal_disabled() const {
  return disabled_;
}
inline bool CSetInputTemporarilyDisabledMsg::disabled() const {
  // @@protoc_insertion_point(field_get:CSetInputTemporarilyDisabledMsg.disabled)
  return _internal_disabled();
}
inline void CSetInputTemporarilyDisabledMsg::_internal_set_disabled(bool value) {
  _has_bits_[0] |= 0x00000001u;
  disabled_ = value;
}
inline void CSetInputTemporarilyDisabledMsg::set_disabled(bool value) {
  _internal_set_disabled(value);
  // @@protoc_insertion_point(field_set:CSetInputTemporarilyDisabledMsg.disabled)
}

// -------------------------------------------------------------------

// CSetQualityOverrideMsg

// optional int32 value = 1;
inline bool CSetQualityOverrideMsg::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetQualityOverrideMsg::has_value() const {
  return _internal_has_value();
}
inline void CSetQualityOverrideMsg::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CSetQualityOverrideMsg::_internal_value() const {
  return value_;
}
inline int32_t CSetQualityOverrideMsg::value() const {
  // @@protoc_insertion_point(field_get:CSetQualityOverrideMsg.value)
  return _internal_value();
}
inline void CSetQualityOverrideMsg::_internal_set_value(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void CSetQualityOverrideMsg::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CSetQualityOverrideMsg.value)
}

// -------------------------------------------------------------------

// CSetBitrateOverrideMsg

// optional int32 value = 1;
inline bool CSetBitrateOverrideMsg::_internal_has_value() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CSetBitrateOverrideMsg::has_value() const {
  return _internal_has_value();
}
inline void CSetBitrateOverrideMsg::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline int32_t CSetBitrateOverrideMsg::_internal_value() const {
  return value_;
}
inline int32_t CSetBitrateOverrideMsg::value() const {
  // @@protoc_insertion_point(field_get:CSetBitrateOverrideMsg.value)
  return _internal_value();
}
inline void CSetBitrateOverrideMsg::_internal_set_value(int32_t value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
}
inline void CSetBitrateOverrideMsg::set_value(int32_t value) {
  _internal_set_value(value);
  // @@protoc_insertion_point(field_set:CSetBitrateOverrideMsg.value)
}

// -------------------------------------------------------------------

// CShowOnScreenKeyboardMsg

// -------------------------------------------------------------------

// CControllerPersonalizationUpdateMsg

// optional string controller_path = 1;
inline bool CControllerPersonalizationUpdateMsg::_internal_has_controller_path() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerPersonalizationUpdateMsg::has_controller_path() const {
  return _internal_has_controller_path();
}
inline void CControllerPersonalizationUpdateMsg::clear_controller_path() {
  controller_path_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerPersonalizationUpdateMsg::controller_path() const {
  // @@protoc_insertion_point(field_get:CControllerPersonalizationUpdateMsg.controller_path)
  return _internal_controller_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerPersonalizationUpdateMsg::set_controller_path(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 controller_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerPersonalizationUpdateMsg.controller_path)
}
inline std::string* CControllerPersonalizationUpdateMsg::mutable_controller_path() {
  std::string* _s = _internal_mutable_controller_path();
  // @@protoc_insertion_point(field_mutable:CControllerPersonalizationUpdateMsg.controller_path)
  return _s;
}
inline const std::string& CControllerPersonalizationUpdateMsg::_internal_controller_path() const {
  return controller_path_.Get();
}
inline void CControllerPersonalizationUpdateMsg::_internal_set_controller_path(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  controller_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerPersonalizationUpdateMsg::_internal_mutable_controller_path() {
  _has_bits_[0] |= 0x00000001u;
  return controller_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerPersonalizationUpdateMsg::release_controller_path() {
  // @@protoc_insertion_point(field_release:CControllerPersonalizationUpdateMsg.controller_path)
  if (!_internal_has_controller_path()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = controller_path_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerPersonalizationUpdateMsg::set_allocated_controller_path(std::string* controller_path) {
  if (controller_path != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  controller_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_path,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_path_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_path_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerPersonalizationUpdateMsg.controller_path)
}

// optional string controller_name = 2;
inline bool CControllerPersonalizationUpdateMsg::_internal_has_controller_name() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CControllerPersonalizationUpdateMsg::has_controller_name() const {
  return _internal_has_controller_name();
}
inline void CControllerPersonalizationUpdateMsg::clear_controller_name() {
  controller_name_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CControllerPersonalizationUpdateMsg::controller_name() const {
  // @@protoc_insertion_point(field_get:CControllerPersonalizationUpdateMsg.controller_name)
  return _internal_controller_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerPersonalizationUpdateMsg::set_controller_name(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 controller_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerPersonalizationUpdateMsg.controller_name)
}
inline std::string* CControllerPersonalizationUpdateMsg::mutable_controller_name() {
  std::string* _s = _internal_mutable_controller_name();
  // @@protoc_insertion_point(field_mutable:CControllerPersonalizationUpdateMsg.controller_name)
  return _s;
}
inline const std::string& CControllerPersonalizationUpdateMsg::_internal_controller_name() const {
  return controller_name_.Get();
}
inline void CControllerPersonalizationUpdateMsg::_internal_set_controller_name(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  controller_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerPersonalizationUpdateMsg::_internal_mutable_controller_name() {
  _has_bits_[0] |= 0x00000002u;
  return controller_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerPersonalizationUpdateMsg::release_controller_name() {
  // @@protoc_insertion_point(field_release:CControllerPersonalizationUpdateMsg.controller_name)
  if (!_internal_has_controller_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = controller_name_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerPersonalizationUpdateMsg::set_allocated_controller_name(std::string* controller_name) {
  if (controller_name != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  controller_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controller_name,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controller_name_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controller_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerPersonalizationUpdateMsg.controller_name)
}

// optional bool reverse_diamond_button_layout = 3;
inline bool CControllerPersonalizationUpdateMsg::_internal_has_reverse_diamond_button_layout() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CControllerPersonalizationUpdateMsg::has_reverse_diamond_button_layout() const {
  return _internal_has_reverse_diamond_button_layout();
}
inline void CControllerPersonalizationUpdateMsg::clear_reverse_diamond_button_layout() {
  reverse_diamond_button_layout_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool CControllerPersonalizationUpdateMsg::_internal_reverse_diamond_button_layout() const {
  return reverse_diamond_button_layout_;
}
inline bool CControllerPersonalizationUpdateMsg::reverse_diamond_button_layout() const {
  // @@protoc_insertion_point(field_get:CControllerPersonalizationUpdateMsg.reverse_diamond_button_layout)
  return _internal_reverse_diamond_button_layout();
}
inline void CControllerPersonalizationUpdateMsg::_internal_set_reverse_diamond_button_layout(bool value) {
  _has_bits_[0] |= 0x00000004u;
  reverse_diamond_button_layout_ = value;
}
inline void CControllerPersonalizationUpdateMsg::set_reverse_diamond_button_layout(bool value) {
  _internal_set_reverse_diamond_button_layout(value);
  // @@protoc_insertion_point(field_set:CControllerPersonalizationUpdateMsg.reverse_diamond_button_layout)
}

// -------------------------------------------------------------------

// CStreamDataLostMsg

// repeated uint32 packets = 1;
inline int CStreamDataLostMsg::_internal_packets_size() const {
  return packets_.size();
}
inline int CStreamDataLostMsg::packets_size() const {
  return _internal_packets_size();
}
inline void CStreamDataLostMsg::clear_packets() {
  packets_.Clear();
}
inline uint32_t CStreamDataLostMsg::_internal_packets(int index) const {
  return packets_.Get(index);
}
inline uint32_t CStreamDataLostMsg::packets(int index) const {
  // @@protoc_insertion_point(field_get:CStreamDataLostMsg.packets)
  return _internal_packets(index);
}
inline void CStreamDataLostMsg::set_packets(int index, uint32_t value) {
  packets_.Set(index, value);
  // @@protoc_insertion_point(field_set:CStreamDataLostMsg.packets)
}
inline void CStreamDataLostMsg::_internal_add_packets(uint32_t value) {
  packets_.Add(value);
}
inline void CStreamDataLostMsg::add_packets(uint32_t value) {
  _internal_add_packets(value);
  // @@protoc_insertion_point(field_add:CStreamDataLostMsg.packets)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStreamDataLostMsg::_internal_packets() const {
  return packets_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >&
CStreamDataLostMsg::packets() const {
  // @@protoc_insertion_point(field_list:CStreamDataLostMsg.packets)
  return _internal_packets();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStreamDataLostMsg::_internal_mutable_packets() {
  return &packets_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< uint32_t >*
CStreamDataLostMsg::mutable_packets() {
  // @@protoc_insertion_point(field_mutable_list:CStreamDataLostMsg.packets)
  return _internal_mutable_packets();
}

// -------------------------------------------------------------------

// CAudioFormat

// required .EAudioFormat format = 1 [default = k_EAudioFormatNone];
inline bool CAudioFormat::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CAudioFormat::has_format() const {
  return _internal_has_format();
}
inline void CAudioFormat::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EAudioFormat CAudioFormat::_internal_format() const {
  return static_cast< ::EAudioFormat >(format_);
}
inline ::EAudioFormat CAudioFormat::format() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.format)
  return _internal_format();
}
inline void CAudioFormat::_internal_set_format(::EAudioFormat value) {
  assert(::EAudioFormat_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  format_ = value;
}
inline void CAudioFormat::set_format(::EAudioFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:CAudioFormat.format)
}

// optional uint32 frequency = 2;
inline bool CAudioFormat::_internal_has_frequency() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CAudioFormat::has_frequency() const {
  return _internal_has_frequency();
}
inline void CAudioFormat::clear_frequency() {
  frequency_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CAudioFormat::_internal_frequency() const {
  return frequency_;
}
inline uint32_t CAudioFormat::frequency() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.frequency)
  return _internal_frequency();
}
inline void CAudioFormat::_internal_set_frequency(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  frequency_ = value;
}
inline void CAudioFormat::set_frequency(uint32_t value) {
  _internal_set_frequency(value);
  // @@protoc_insertion_point(field_set:CAudioFormat.frequency)
}

// optional uint32 channels = 3;
inline bool CAudioFormat::_internal_has_channels() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CAudioFormat::has_channels() const {
  return _internal_has_channels();
}
inline void CAudioFormat::clear_channels() {
  channels_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CAudioFormat::_internal_channels() const {
  return channels_;
}
inline uint32_t CAudioFormat::channels() const {
  // @@protoc_insertion_point(field_get:CAudioFormat.channels)
  return _internal_channels();
}
inline void CAudioFormat::_internal_set_channels(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  channels_ = value;
}
inline void CAudioFormat::set_channels(uint32_t value) {
  _internal_set_channels(value);
  // @@protoc_insertion_point(field_set:CAudioFormat.channels)
}

// -------------------------------------------------------------------

// CVideoFormat

// required .EVideoFormat format = 1 [default = k_EVideoFormatNone];
inline bool CVideoFormat::_internal_has_format() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CVideoFormat::has_format() const {
  return _internal_has_format();
}
inline void CVideoFormat::clear_format() {
  format_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EVideoFormat CVideoFormat::_internal_format() const {
  return static_cast< ::EVideoFormat >(format_);
}
inline ::EVideoFormat CVideoFormat::format() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.format)
  return _internal_format();
}
inline void CVideoFormat::_internal_set_format(::EVideoFormat value) {
  assert(::EVideoFormat_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  format_ = value;
}
inline void CVideoFormat::set_format(::EVideoFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:CVideoFormat.format)
}

// optional uint32 width = 2;
inline bool CVideoFormat::_internal_has_width() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CVideoFormat::has_width() const {
  return _internal_has_width();
}
inline void CVideoFormat::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CVideoFormat::_internal_width() const {
  return width_;
}
inline uint32_t CVideoFormat::width() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.width)
  return _internal_width();
}
inline void CVideoFormat::_internal_set_width(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  width_ = value;
}
inline void CVideoFormat::set_width(uint32_t value) {
  _internal_set_width(value);
  // @@protoc_insertion_point(field_set:CVideoFormat.width)
}

// optional uint32 height = 3;
inline bool CVideoFormat::_internal_has_height() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CVideoFormat::has_height() const {
  return _internal_has_height();
}
inline void CVideoFormat::clear_height() {
  height_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CVideoFormat::_internal_height() const {
  return height_;
}
inline uint32_t CVideoFormat::height() const {
  // @@protoc_insertion_point(field_get:CVideoFormat.height)
  return _internal_height();
}
inline void CVideoFormat::_internal_set_height(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  height_ = value;
}
inline void CVideoFormat::set_height(uint32_t value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:CVideoFormat.height)
}

// -------------------------------------------------------------------

// CFrameEvent

// required .EStreamFrameEvent event_id = 1 [default = k_EStreamInputEventStart];
inline bool CFrameEvent::_internal_has_event_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CFrameEvent::has_event_id() const {
  return _internal_has_event_id();
}
inline void CFrameEvent::clear_event_id() {
  event_id_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EStreamFrameEvent CFrameEvent::_internal_event_id() const {
  return static_cast< ::EStreamFrameEvent >(event_id_);
}
inline ::EStreamFrameEvent CFrameEvent::event_id() const {
  // @@protoc_insertion_point(field_get:CFrameEvent.event_id)
  return _internal_event_id();
}
inline void CFrameEvent::_internal_set_event_id(::EStreamFrameEvent value) {
  assert(::EStreamFrameEvent_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  event_id_ = value;
}
inline void CFrameEvent::set_event_id(::EStreamFrameEvent value) {
  _internal_set_event_id(value);
  // @@protoc_insertion_point(field_set:CFrameEvent.event_id)
}

// required uint32 timestamp = 2;
inline bool CFrameEvent::_internal_has_timestamp() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CFrameEvent::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void CFrameEvent::clear_timestamp() {
  timestamp_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CFrameEvent::_internal_timestamp() const {
  return timestamp_;
}
inline uint32_t CFrameEvent::timestamp() const {
  // @@protoc_insertion_point(field_get:CFrameEvent.timestamp)
  return _internal_timestamp();
}
inline void CFrameEvent::_internal_set_timestamp(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  timestamp_ = value;
}
inline void CFrameEvent::set_timestamp(uint32_t value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:CFrameEvent.timestamp)
}

// -------------------------------------------------------------------

// CFrameStats

// required uint32 frame_id = 1;
inline bool CFrameStats::_internal_has_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CFrameStats::has_frame_id() const {
  return _internal_has_frame_id();
}
inline void CFrameStats::clear_frame_id() {
  frame_id_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline uint32_t CFrameStats::_internal_frame_id() const {
  return frame_id_;
}
inline uint32_t CFrameStats::frame_id() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_id)
  return _internal_frame_id();
}
inline void CFrameStats::_internal_set_frame_id(uint32_t value) {
  _has_bits_[0] |= 0x00000001u;
  frame_id_ = value;
}
inline void CFrameStats::set_frame_id(uint32_t value) {
  _internal_set_frame_id(value);
  // @@protoc_insertion_point(field_set:CFrameStats.frame_id)
}

// optional uint32 input_mark = 2;
inline bool CFrameStats::_internal_has_input_mark() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CFrameStats::has_input_mark() const {
  return _internal_has_input_mark();
}
inline void CFrameStats::clear_input_mark() {
  input_mark_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline uint32_t CFrameStats::_internal_input_mark() const {
  return input_mark_;
}
inline uint32_t CFrameStats::input_mark() const {
  // @@protoc_insertion_point(field_get:CFrameStats.input_mark)
  return _internal_input_mark();
}
inline void CFrameStats::_internal_set_input_mark(uint32_t value) {
  _has_bits_[0] |= 0x00000002u;
  input_mark_ = value;
}
inline void CFrameStats::set_input_mark(uint32_t value) {
  _internal_set_input_mark(value);
  // @@protoc_insertion_point(field_set:CFrameStats.input_mark)
}

// repeated .CFrameEvent events = 3;
inline int CFrameStats::_internal_events_size() const {
  return events_.size();
}
inline int CFrameStats::events_size() const {
  return _internal_events_size();
}
inline void CFrameStats::clear_events() {
  events_.Clear();
}
inline ::CFrameEvent* CFrameStats::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStats.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameEvent >*
CFrameStats::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStats.events)
  return &events_;
}
inline const ::CFrameEvent& CFrameStats::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::CFrameEvent& CFrameStats::events(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStats.events)
  return _internal_events(index);
}
inline ::CFrameEvent* CFrameStats::_internal_add_events() {
  return events_.Add();
}
inline ::CFrameEvent* CFrameStats::add_events() {
  ::CFrameEvent* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:CFrameStats.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameEvent >&
CFrameStats::events() const {
  // @@protoc_insertion_point(field_list:CFrameStats.events)
  return events_;
}

// required .EStreamFrameResult result = 4 [default = k_EStreamFrameResultPending];
inline bool CFrameStats::_internal_has_result() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CFrameStats::has_result() const {
  return _internal_has_result();
}
inline void CFrameStats::clear_result() {
  result_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::EStreamFrameResult CFrameStats::_internal_result() const {
  return static_cast< ::EStreamFrameResult >(result_);
}
inline ::EStreamFrameResult CFrameStats::result() const {
  // @@protoc_insertion_point(field_get:CFrameStats.result)
  return _internal_result();
}
inline void CFrameStats::_internal_set_result(::EStreamFrameResult value) {
  assert(::EStreamFrameResult_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  result_ = value;
}
inline void CFrameStats::set_result(::EStreamFrameResult value) {
  _internal_set_result(value);
  // @@protoc_insertion_point(field_set:CFrameStats.result)
}

// optional float frame_start_delta = 5;
inline bool CFrameStats::_internal_has_frame_start_delta() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CFrameStats::has_frame_start_delta() const {
  return _internal_has_frame_start_delta();
}
inline void CFrameStats::clear_frame_start_delta() {
  frame_start_delta_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CFrameStats::_internal_frame_start_delta() const {
  return frame_start_delta_;
}
inline float CFrameStats::frame_start_delta() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_start_delta)
  return _internal_frame_start_delta();
}
inline void CFrameStats::_internal_set_frame_start_delta(float value) {
  _has_bits_[0] |= 0x00000008u;
  frame_start_delta_ = value;
}
inline void CFrameStats::set_frame_start_delta(float value) {
  _internal_set_frame_start_delta(value);
  // @@protoc_insertion_point(field_set:CFrameStats.frame_start_delta)
}

// optional float frame_display_delta = 6;
inline bool CFrameStats::_internal_has_frame_display_delta() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CFrameStats::has_frame_display_delta() const {
  return _internal_has_frame_display_delta();
}
inline void CFrameStats::clear_frame_display_delta() {
  frame_display_delta_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline float CFrameStats::_internal_frame_display_delta() const {
  return frame_display_delta_;
}
inline float CFrameStats::frame_display_delta() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_display_delta)
  return _internal_frame_display_delta();
}
inline void CFrameStats::_internal_set_frame_display_delta(float value) {
  _has_bits_[0] |= 0x00000010u;
  frame_display_delta_ = value;
}
inline void CFrameStats::set_frame_display_delta(float value) {
  _internal_set_frame_display_delta(value);
  // @@protoc_insertion_point(field_set:CFrameStats.frame_display_delta)
}

// optional float ping_time = 7;
inline bool CFrameStats::_internal_has_ping_time() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CFrameStats::has_ping_time() const {
  return _internal_has_ping_time();
}
inline void CFrameStats::clear_ping_time() {
  ping_time_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline float CFrameStats::_internal_ping_time() const {
  return ping_time_;
}
inline float CFrameStats::ping_time() const {
  // @@protoc_insertion_point(field_get:CFrameStats.ping_time)
  return _internal_ping_time();
}
inline void CFrameStats::_internal_set_ping_time(float value) {
  _has_bits_[0] |= 0x00000020u;
  ping_time_ = value;
}
inline void CFrameStats::set_ping_time(float value) {
  _internal_set_ping_time(value);
  // @@protoc_insertion_point(field_set:CFrameStats.ping_time)
}

// optional float server_bitrate = 8;
inline bool CFrameStats::_internal_has_server_bitrate() const {
  bool value = (_has_bits_[0] & 0x00000040u) != 0;
  return value;
}
inline bool CFrameStats::has_server_bitrate() const {
  return _internal_has_server_bitrate();
}
inline void CFrameStats::clear_server_bitrate() {
  server_bitrate_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline float CFrameStats::_internal_server_bitrate() const {
  return server_bitrate_;
}
inline float CFrameStats::server_bitrate() const {
  // @@protoc_insertion_point(field_get:CFrameStats.server_bitrate)
  return _internal_server_bitrate();
}
inline void CFrameStats::_internal_set_server_bitrate(float value) {
  _has_bits_[0] |= 0x00000040u;
  server_bitrate_ = value;
}
inline void CFrameStats::set_server_bitrate(float value) {
  _internal_set_server_bitrate(value);
  // @@protoc_insertion_point(field_set:CFrameStats.server_bitrate)
}

// optional float client_bitrate = 9;
inline bool CFrameStats::_internal_has_client_bitrate() const {
  bool value = (_has_bits_[0] & 0x00000080u) != 0;
  return value;
}
inline bool CFrameStats::has_client_bitrate() const {
  return _internal_has_client_bitrate();
}
inline void CFrameStats::clear_client_bitrate() {
  client_bitrate_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float CFrameStats::_internal_client_bitrate() const {
  return client_bitrate_;
}
inline float CFrameStats::client_bitrate() const {
  // @@protoc_insertion_point(field_get:CFrameStats.client_bitrate)
  return _internal_client_bitrate();
}
inline void CFrameStats::_internal_set_client_bitrate(float value) {
  _has_bits_[0] |= 0x00000080u;
  client_bitrate_ = value;
}
inline void CFrameStats::set_client_bitrate(float value) {
  _internal_set_client_bitrate(value);
  // @@protoc_insertion_point(field_set:CFrameStats.client_bitrate)
}

// optional float link_bandwidth = 10;
inline bool CFrameStats::_internal_has_link_bandwidth() const {
  bool value = (_has_bits_[0] & 0x00000100u) != 0;
  return value;
}
inline bool CFrameStats::has_link_bandwidth() const {
  return _internal_has_link_bandwidth();
}
inline void CFrameStats::clear_link_bandwidth() {
  link_bandwidth_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline float CFrameStats::_internal_link_bandwidth() const {
  return link_bandwidth_;
}
inline float CFrameStats::link_bandwidth() const {
  // @@protoc_insertion_point(field_get:CFrameStats.link_bandwidth)
  return _internal_link_bandwidth();
}
inline void CFrameStats::_internal_set_link_bandwidth(float value) {
  _has_bits_[0] |= 0x00000100u;
  link_bandwidth_ = value;
}
inline void CFrameStats::set_link_bandwidth(float value) {
  _internal_set_link_bandwidth(value);
  // @@protoc_insertion_point(field_set:CFrameStats.link_bandwidth)
}

// optional float packet_loss = 11;
inline bool CFrameStats::_internal_has_packet_loss() const {
  bool value = (_has_bits_[0] & 0x00000200u) != 0;
  return value;
}
inline bool CFrameStats::has_packet_loss() const {
  return _internal_has_packet_loss();
}
inline void CFrameStats::clear_packet_loss() {
  packet_loss_ = 0;
  _has_bits_[0] &= ~0x00000200u;
}
inline float CFrameStats::_internal_packet_loss() const {
  return packet_loss_;
}
inline float CFrameStats::packet_loss() const {
  // @@protoc_insertion_point(field_get:CFrameStats.packet_loss)
  return _internal_packet_loss();
}
inline void CFrameStats::_internal_set_packet_loss(float value) {
  _has_bits_[0] |= 0x00000200u;
  packet_loss_ = value;
}
inline void CFrameStats::set_packet_loss(float value) {
  _internal_set_packet_loss(value);
  // @@protoc_insertion_point(field_set:CFrameStats.packet_loss)
}

// optional uint32 frame_size = 12;
inline bool CFrameStats::_internal_has_frame_size() const {
  bool value = (_has_bits_[0] & 0x00000400u) != 0;
  return value;
}
inline bool CFrameStats::has_frame_size() const {
  return _internal_has_frame_size();
}
inline void CFrameStats::clear_frame_size() {
  frame_size_ = 0u;
  _has_bits_[0] &= ~0x00000400u;
}
inline uint32_t CFrameStats::_internal_frame_size() const {
  return frame_size_;
}
inline uint32_t CFrameStats::frame_size() const {
  // @@protoc_insertion_point(field_get:CFrameStats.frame_size)
  return _internal_frame_size();
}
inline void CFrameStats::_internal_set_frame_size(uint32_t value) {
  _has_bits_[0] |= 0x00000400u;
  frame_size_ = value;
}
inline void CFrameStats::set_frame_size(uint32_t value) {
  _internal_set_frame_size(value);
  // @@protoc_insertion_point(field_set:CFrameStats.frame_size)
}

// -------------------------------------------------------------------

// CFrameStatAccumulatedValue

// required .EFrameAccumulatedStat stat_type = 1 [default = k_EFrameStatFPS];
inline bool CFrameStatAccumulatedValue::_internal_has_stat_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CFrameStatAccumulatedValue::has_stat_type() const {
  return _internal_has_stat_type();
}
inline void CFrameStatAccumulatedValue::clear_stat_type() {
  stat_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EFrameAccumulatedStat CFrameStatAccumulatedValue::_internal_stat_type() const {
  return static_cast< ::EFrameAccumulatedStat >(stat_type_);
}
inline ::EFrameAccumulatedStat CFrameStatAccumulatedValue::stat_type() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.stat_type)
  return _internal_stat_type();
}
inline void CFrameStatAccumulatedValue::_internal_set_stat_type(::EFrameAccumulatedStat value) {
  assert(::EFrameAccumulatedStat_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  stat_type_ = value;
}
inline void CFrameStatAccumulatedValue::set_stat_type(::EFrameAccumulatedStat value) {
  _internal_set_stat_type(value);
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.stat_type)
}

// required int32 count = 2;
inline bool CFrameStatAccumulatedValue::_internal_has_count() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CFrameStatAccumulatedValue::has_count() const {
  return _internal_has_count();
}
inline void CFrameStatAccumulatedValue::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CFrameStatAccumulatedValue::_internal_count() const {
  return count_;
}
inline int32_t CFrameStatAccumulatedValue::count() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.count)
  return _internal_count();
}
inline void CFrameStatAccumulatedValue::_internal_set_count(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  count_ = value;
}
inline void CFrameStatAccumulatedValue::set_count(int32_t value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.count)
}

// required float average = 3;
inline bool CFrameStatAccumulatedValue::_internal_has_average() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CFrameStatAccumulatedValue::has_average() const {
  return _internal_has_average();
}
inline void CFrameStatAccumulatedValue::clear_average() {
  average_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CFrameStatAccumulatedValue::_internal_average() const {
  return average_;
}
inline float CFrameStatAccumulatedValue::average() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.average)
  return _internal_average();
}
inline void CFrameStatAccumulatedValue::_internal_set_average(float value) {
  _has_bits_[0] |= 0x00000004u;
  average_ = value;
}
inline void CFrameStatAccumulatedValue::set_average(float value) {
  _internal_set_average(value);
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.average)
}

// optional float stddev = 4;
inline bool CFrameStatAccumulatedValue::_internal_has_stddev() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CFrameStatAccumulatedValue::has_stddev() const {
  return _internal_has_stddev();
}
inline void CFrameStatAccumulatedValue::clear_stddev() {
  stddev_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float CFrameStatAccumulatedValue::_internal_stddev() const {
  return stddev_;
}
inline float CFrameStatAccumulatedValue::stddev() const {
  // @@protoc_insertion_point(field_get:CFrameStatAccumulatedValue.stddev)
  return _internal_stddev();
}
inline void CFrameStatAccumulatedValue::_internal_set_stddev(float value) {
  _has_bits_[0] |= 0x00000008u;
  stddev_ = value;
}
inline void CFrameStatAccumulatedValue::set_stddev(float value) {
  _internal_set_stddev(value);
  // @@protoc_insertion_point(field_set:CFrameStatAccumulatedValue.stddev)
}

// -------------------------------------------------------------------

// CFrameStatsListMsg

// required .EStreamingDataType data_type = 1 [default = k_EStreamingAudioData];
inline bool CFrameStatsListMsg::_internal_has_data_type() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CFrameStatsListMsg::has_data_type() const {
  return _internal_has_data_type();
}
inline void CFrameStatsListMsg::clear_data_type() {
  data_type_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::EStreamingDataType CFrameStatsListMsg::_internal_data_type() const {
  return static_cast< ::EStreamingDataType >(data_type_);
}
inline ::EStreamingDataType CFrameStatsListMsg::data_type() const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.data_type)
  return _internal_data_type();
}
inline void CFrameStatsListMsg::_internal_set_data_type(::EStreamingDataType value) {
  assert(::EStreamingDataType_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  data_type_ = value;
}
inline void CFrameStatsListMsg::set_data_type(::EStreamingDataType value) {
  _internal_set_data_type(value);
  // @@protoc_insertion_point(field_set:CFrameStatsListMsg.data_type)
}

// repeated .CFrameStats stats = 2;
inline int CFrameStatsListMsg::_internal_stats_size() const {
  return stats_.size();
}
inline int CFrameStatsListMsg::stats_size() const {
  return _internal_stats_size();
}
inline void CFrameStatsListMsg::clear_stats() {
  stats_.Clear();
}
inline ::CFrameStats* CFrameStatsListMsg::mutable_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStatsListMsg.stats)
  return stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStats >*
CFrameStatsListMsg::mutable_stats() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStatsListMsg.stats)
  return &stats_;
}
inline const ::CFrameStats& CFrameStatsListMsg::_internal_stats(int index) const {
  return stats_.Get(index);
}
inline const ::CFrameStats& CFrameStatsListMsg::stats(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.stats)
  return _internal_stats(index);
}
inline ::CFrameStats* CFrameStatsListMsg::_internal_add_stats() {
  return stats_.Add();
}
inline ::CFrameStats* CFrameStatsListMsg::add_stats() {
  ::CFrameStats* _add = _internal_add_stats();
  // @@protoc_insertion_point(field_add:CFrameStatsListMsg.stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStats >&
CFrameStatsListMsg::stats() const {
  // @@protoc_insertion_point(field_list:CFrameStatsListMsg.stats)
  return stats_;
}

// repeated .CFrameStatAccumulatedValue accumulated_stats = 3;
inline int CFrameStatsListMsg::_internal_accumulated_stats_size() const {
  return accumulated_stats_.size();
}
inline int CFrameStatsListMsg::accumulated_stats_size() const {
  return _internal_accumulated_stats_size();
}
inline void CFrameStatsListMsg::clear_accumulated_stats() {
  accumulated_stats_.Clear();
}
inline ::CFrameStatAccumulatedValue* CFrameStatsListMsg::mutable_accumulated_stats(int index) {
  // @@protoc_insertion_point(field_mutable:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStatAccumulatedValue >*
CFrameStatsListMsg::mutable_accumulated_stats() {
  // @@protoc_insertion_point(field_mutable_list:CFrameStatsListMsg.accumulated_stats)
  return &accumulated_stats_;
}
inline const ::CFrameStatAccumulatedValue& CFrameStatsListMsg::_internal_accumulated_stats(int index) const {
  return accumulated_stats_.Get(index);
}
inline const ::CFrameStatAccumulatedValue& CFrameStatsListMsg::accumulated_stats(int index) const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.accumulated_stats)
  return _internal_accumulated_stats(index);
}
inline ::CFrameStatAccumulatedValue* CFrameStatsListMsg::_internal_add_accumulated_stats() {
  return accumulated_stats_.Add();
}
inline ::CFrameStatAccumulatedValue* CFrameStatsListMsg::add_accumulated_stats() {
  ::CFrameStatAccumulatedValue* _add = _internal_add_accumulated_stats();
  // @@protoc_insertion_point(field_add:CFrameStatsListMsg.accumulated_stats)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CFrameStatAccumulatedValue >&
CFrameStatsListMsg::accumulated_stats() const {
  // @@protoc_insertion_point(field_list:CFrameStatsListMsg.accumulated_stats)
  return accumulated_stats_;
}

// required int32 latest_frame_id = 4;
inline bool CFrameStatsListMsg::_internal_has_latest_frame_id() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CFrameStatsListMsg::has_latest_frame_id() const {
  return _internal_has_latest_frame_id();
}
inline void CFrameStatsListMsg::clear_latest_frame_id() {
  latest_frame_id_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CFrameStatsListMsg::_internal_latest_frame_id() const {
  return latest_frame_id_;
}
inline int32_t CFrameStatsListMsg::latest_frame_id() const {
  // @@protoc_insertion_point(field_get:CFrameStatsListMsg.latest_frame_id)
  return _internal_latest_frame_id();
}
inline void CFrameStatsListMsg::_internal_set_latest_frame_id(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  latest_frame_id_ = value;
}
inline void CFrameStatsListMsg::set_latest_frame_id(int32_t value) {
  _internal_set_latest_frame_id(value);
  // @@protoc_insertion_point(field_set:CFrameStatsListMsg.latest_frame_id)
}

// -------------------------------------------------------------------

// CStreamingSessionStats

// optional float frame_loss_percentage = 1;
inline bool CStreamingSessionStats::_internal_has_frame_loss_percentage() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CStreamingSessionStats::has_frame_loss_percentage() const {
  return _internal_has_frame_loss_percentage();
}
inline void CStreamingSessionStats::clear_frame_loss_percentage() {
  frame_loss_percentage_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float CStreamingSessionStats::_internal_frame_loss_percentage() const {
  return frame_loss_percentage_;
}
inline float CStreamingSessionStats::frame_loss_percentage() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.frame_loss_percentage)
  return _internal_frame_loss_percentage();
}
inline void CStreamingSessionStats::_internal_set_frame_loss_percentage(float value) {
  _has_bits_[0] |= 0x00000001u;
  frame_loss_percentage_ = value;
}
inline void CStreamingSessionStats::set_frame_loss_percentage(float value) {
  _internal_set_frame_loss_percentage(value);
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.frame_loss_percentage)
}

// optional float average_network_time_ms = 2;
inline bool CStreamingSessionStats::_internal_has_average_network_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CStreamingSessionStats::has_average_network_time_ms() const {
  return _internal_has_average_network_time_ms();
}
inline void CStreamingSessionStats::clear_average_network_time_ms() {
  average_network_time_ms_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float CStreamingSessionStats::_internal_average_network_time_ms() const {
  return average_network_time_ms_;
}
inline float CStreamingSessionStats::average_network_time_ms() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.average_network_time_ms)
  return _internal_average_network_time_ms();
}
inline void CStreamingSessionStats::_internal_set_average_network_time_ms(float value) {
  _has_bits_[0] |= 0x00000002u;
  average_network_time_ms_ = value;
}
inline void CStreamingSessionStats::set_average_network_time_ms(float value) {
  _internal_set_average_network_time_ms(value);
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.average_network_time_ms)
}

// optional float stddev_network_time_ms = 3;
inline bool CStreamingSessionStats::_internal_has_stddev_network_time_ms() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CStreamingSessionStats::has_stddev_network_time_ms() const {
  return _internal_has_stddev_network_time_ms();
}
inline void CStreamingSessionStats::clear_stddev_network_time_ms() {
  stddev_network_time_ms_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float CStreamingSessionStats::_internal_stddev_network_time_ms() const {
  return stddev_network_time_ms_;
}
inline float CStreamingSessionStats::stddev_network_time_ms() const {
  // @@protoc_insertion_point(field_get:CStreamingSessionStats.stddev_network_time_ms)
  return _internal_stddev_network_time_ms();
}
inline void CStreamingSessionStats::_internal_set_stddev_network_time_ms(float value) {
  _has_bits_[0] |= 0x00000004u;
  stddev_network_time_ms_ = value;
}
inline void CStreamingSessionStats::set_stddev_network_time_ms(float value) {
  _internal_set_stddev_network_time_ms(value);
  // @@protoc_insertion_point(field_set:CStreamingSessionStats.stddev_network_time_ms)
}

// -------------------------------------------------------------------

// CDebugDumpMsg

// optional bytes screenshot = 1;
inline bool CDebugDumpMsg::_internal_has_screenshot() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CDebugDumpMsg::has_screenshot() const {
  return _internal_has_screenshot();
}
inline void CDebugDumpMsg::clear_screenshot() {
  screenshot_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CDebugDumpMsg::screenshot() const {
  // @@protoc_insertion_point(field_get:CDebugDumpMsg.screenshot)
  return _internal_screenshot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CDebugDumpMsg::set_screenshot(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 screenshot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CDebugDumpMsg.screenshot)
}
inline std::string* CDebugDumpMsg::mutable_screenshot() {
  std::string* _s = _internal_mutable_screenshot();
  // @@protoc_insertion_point(field_mutable:CDebugDumpMsg.screenshot)
  return _s;
}
inline const std::string& CDebugDumpMsg::_internal_screenshot() const {
  return screenshot_.Get();
}
inline void CDebugDumpMsg::_internal_set_screenshot(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  screenshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CDebugDumpMsg::_internal_mutable_screenshot() {
  _has_bits_[0] |= 0x00000001u;
  return screenshot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CDebugDumpMsg::release_screenshot() {
  // @@protoc_insertion_point(field_release:CDebugDumpMsg.screenshot)
  if (!_internal_has_screenshot()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = screenshot_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CDebugDumpMsg::set_allocated_screenshot(std::string* screenshot) {
  if (screenshot != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  screenshot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), screenshot,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (screenshot_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    screenshot_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CDebugDumpMsg.screenshot)
}

// -------------------------------------------------------------------

// CLogMsg

// optional int32 type = 1;
inline bool CLogMsg::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CLogMsg::has_type() const {
  return _internal_has_type();
}
inline void CLogMsg::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline int32_t CLogMsg::_internal_type() const {
  return type_;
}
inline int32_t CLogMsg::type() const {
  // @@protoc_insertion_point(field_get:CLogMsg.type)
  return _internal_type();
}
inline void CLogMsg::_internal_set_type(int32_t value) {
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void CLogMsg::set_type(int32_t value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CLogMsg.type)
}

// optional string message = 2;
inline bool CLogMsg::_internal_has_message() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CLogMsg::has_message() const {
  return _internal_has_message();
}
inline void CLogMsg::clear_message() {
  message_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CLogMsg::message() const {
  // @@protoc_insertion_point(field_get:CLogMsg.message)
  return _internal_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLogMsg::set_message(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLogMsg.message)
}
inline std::string* CLogMsg::mutable_message() {
  std::string* _s = _internal_mutable_message();
  // @@protoc_insertion_point(field_mutable:CLogMsg.message)
  return _s;
}
inline const std::string& CLogMsg::_internal_message() const {
  return message_.Get();
}
inline void CLogMsg::_internal_set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CLogMsg::_internal_mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  return message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CLogMsg::release_message() {
  // @@protoc_insertion_point(field_release:CLogMsg.message)
  if (!_internal_has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = message_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CLogMsg::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (message_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLogMsg.message)
}

// -------------------------------------------------------------------

// CLogUploadMsg

// optional .ELogFileType type = 1 [default = k_ELogFileSystemBoot];
inline bool CLogUploadMsg::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CLogUploadMsg::has_type() const {
  return _internal_has_type();
}
inline void CLogUploadMsg::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::ELogFileType CLogUploadMsg::_internal_type() const {
  return static_cast< ::ELogFileType >(type_);
}
inline ::ELogFileType CLogUploadMsg::type() const {
  // @@protoc_insertion_point(field_get:CLogUploadMsg.type)
  return _internal_type();
}
inline void CLogUploadMsg::_internal_set_type(::ELogFileType value) {
  assert(::ELogFileType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
}
inline void CLogUploadMsg::set_type(::ELogFileType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CLogUploadMsg.type)
}

// optional bytes data = 3;
inline bool CLogUploadMsg::_internal_has_data() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CLogUploadMsg::has_data() const {
  return _internal_has_data();
}
inline void CLogUploadMsg::clear_data() {
  data_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CLogUploadMsg::data() const {
  // @@protoc_insertion_point(field_get:CLogUploadMsg.data)
  return _internal_data();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CLogUploadMsg::set_data(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 data_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CLogUploadMsg.data)
}
inline std::string* CLogUploadMsg::mutable_data() {
  std::string* _s = _internal_mutable_data();
  // @@protoc_insertion_point(field_mutable:CLogUploadMsg.data)
  return _s;
}
inline const std::string& CLogUploadMsg::_internal_data() const {
  return data_.Get();
}
inline void CLogUploadMsg::_internal_set_data(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CLogUploadMsg::_internal_mutable_data() {
  _has_bits_[0] |= 0x00000001u;
  return data_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CLogUploadMsg::release_data() {
  // @@protoc_insertion_point(field_release:CLogUploadMsg.data)
  if (!_internal_has_data()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = data_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CLogUploadMsg::set_allocated_data(std::string* data) {
  if (data != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  data_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), data,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (data_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CLogUploadMsg.data)
}

// -------------------------------------------------------------------

// CTransportSignalMsg_WebRTCMessage_Candidate

// optional string sdp_mid = 1;
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::_internal_has_sdp_mid() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::has_sdp_mid() const {
  return _internal_has_sdp_mid();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::clear_sdp_mid() {
  sdp_mid_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage_Candidate::sdp_mid() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
  return _internal_sdp_mid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransportSignalMsg_WebRTCMessage_Candidate::set_sdp_mid(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 sdp_mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::mutable_sdp_mid() {
  std::string* _s = _internal_mutable_sdp_mid();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
  return _s;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage_Candidate::_internal_sdp_mid() const {
  return sdp_mid_.Get();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::_internal_set_sdp_mid(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  sdp_mid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::_internal_mutable_sdp_mid() {
  _has_bits_[0] |= 0x00000001u;
  return sdp_mid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::release_sdp_mid() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
  if (!_internal_has_sdp_mid()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = sdp_mid_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_mid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::set_allocated_sdp_mid(std::string* sdp_mid) {
  if (sdp_mid != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sdp_mid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sdp_mid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sdp_mid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sdp_mid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mid)
}

// optional int32 sdp_mline_index = 2;
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::_internal_has_sdp_mline_index() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::has_sdp_mline_index() const {
  return _internal_has_sdp_mline_index();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::clear_sdp_mline_index() {
  sdp_mline_index_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline int32_t CTransportSignalMsg_WebRTCMessage_Candidate::_internal_sdp_mline_index() const {
  return sdp_mline_index_;
}
inline int32_t CTransportSignalMsg_WebRTCMessage_Candidate::sdp_mline_index() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mline_index)
  return _internal_sdp_mline_index();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::_internal_set_sdp_mline_index(int32_t value) {
  _has_bits_[0] |= 0x00000004u;
  sdp_mline_index_ = value;
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::set_sdp_mline_index(int32_t value) {
  _internal_set_sdp_mline_index(value);
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.Candidate.sdp_mline_index)
}

// optional string candidate = 3;
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::_internal_has_candidate() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CTransportSignalMsg_WebRTCMessage_Candidate::has_candidate() const {
  return _internal_has_candidate();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::clear_candidate() {
  candidate_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage_Candidate::candidate() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
  return _internal_candidate();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CTransportSignalMsg_WebRTCMessage_Candidate::set_candidate(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::mutable_candidate() {
  std::string* _s = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
  return _s;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage_Candidate::_internal_candidate() const {
  return candidate_.Get();
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::_internal_set_candidate(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  candidate_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::_internal_mutable_candidate() {
  _has_bits_[0] |= 0x00000002u;
  return candidate_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage_Candidate::release_candidate() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
  if (!_internal_has_candidate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = candidate_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (candidate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    candidate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CTransportSignalMsg_WebRTCMessage_Candidate::set_allocated_candidate(std::string* candidate) {
  if (candidate != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  candidate_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), candidate,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (candidate_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    candidate_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.WebRTCMessage.Candidate.candidate)
}

// -------------------------------------------------------------------

// CTransportSignalMsg_WebRTCMessage

// bool greeting = 1;
inline bool CTransportSignalMsg_WebRTCMessage::_internal_has_greeting() const {
  return msg_case() == kGreeting;
}
inline bool CTransportSignalMsg_WebRTCMessage::has_greeting() const {
  return _internal_has_greeting();
}
inline void CTransportSignalMsg_WebRTCMessage::set_has_greeting() {
  _oneof_case_[0] = kGreeting;
}
inline void CTransportSignalMsg_WebRTCMessage::clear_greeting() {
  if (_internal_has_greeting()) {
    msg_.greeting_ = false;
    clear_has_msg();
  }
}
inline bool CTransportSignalMsg_WebRTCMessage::_internal_greeting() const {
  if (_internal_has_greeting()) {
    return msg_.greeting_;
  }
  return false;
}
inline void CTransportSignalMsg_WebRTCMessage::_internal_set_greeting(bool value) {
  if (!_internal_has_greeting()) {
    clear_msg();
    set_has_greeting();
  }
  msg_.greeting_ = value;
}
inline bool CTransportSignalMsg_WebRTCMessage::greeting() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.greeting)
  return _internal_greeting();
}
inline void CTransportSignalMsg_WebRTCMessage::set_greeting(bool value) {
  _internal_set_greeting(value);
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.greeting)
}

// string offer = 2;
inline bool CTransportSignalMsg_WebRTCMessage::_internal_has_offer() const {
  return msg_case() == kOffer;
}
inline bool CTransportSignalMsg_WebRTCMessage::has_offer() const {
  return _internal_has_offer();
}
inline void CTransportSignalMsg_WebRTCMessage::set_has_offer() {
  _oneof_case_[0] = kOffer;
}
inline void CTransportSignalMsg_WebRTCMessage::clear_offer() {
  if (_internal_has_offer()) {
    msg_.offer_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_msg();
  }
}
inline const std::string& CTransportSignalMsg_WebRTCMessage::offer() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.offer)
  return _internal_offer();
}
template <typename ArgT0, typename... ArgT>
inline void CTransportSignalMsg_WebRTCMessage::set_offer(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_offer()) {
    clear_msg();
    set_has_offer();
    msg_.offer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  msg_.offer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.offer)
}
inline std::string* CTransportSignalMsg_WebRTCMessage::mutable_offer() {
  std::string* _s = _internal_mutable_offer();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.WebRTCMessage.offer)
  return _s;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage::_internal_offer() const {
  if (_internal_has_offer()) {
    return msg_.offer_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CTransportSignalMsg_WebRTCMessage::_internal_set_offer(const std::string& value) {
  if (!_internal_has_offer()) {
    clear_msg();
    set_has_offer();
    msg_.offer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  msg_.offer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage::_internal_mutable_offer() {
  if (!_internal_has_offer()) {
    clear_msg();
    set_has_offer();
    msg_.offer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return msg_.offer_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage::release_offer() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.WebRTCMessage.offer)
  if (_internal_has_offer()) {
    clear_has_msg();
    return msg_.offer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CTransportSignalMsg_WebRTCMessage::set_allocated_offer(std::string* offer) {
  if (has_msg()) {
    clear_msg();
  }
  if (offer != nullptr) {
    set_has_offer();
    msg_.offer_.UnsafeSetDefault(offer);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(offer);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.WebRTCMessage.offer)
}

// string answer = 3;
inline bool CTransportSignalMsg_WebRTCMessage::_internal_has_answer() const {
  return msg_case() == kAnswer;
}
inline bool CTransportSignalMsg_WebRTCMessage::has_answer() const {
  return _internal_has_answer();
}
inline void CTransportSignalMsg_WebRTCMessage::set_has_answer() {
  _oneof_case_[0] = kAnswer;
}
inline void CTransportSignalMsg_WebRTCMessage::clear_answer() {
  if (_internal_has_answer()) {
    msg_.answer_.Destroy(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
    clear_has_msg();
  }
}
inline const std::string& CTransportSignalMsg_WebRTCMessage::answer() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.answer)
  return _internal_answer();
}
template <typename ArgT0, typename... ArgT>
inline void CTransportSignalMsg_WebRTCMessage::set_answer(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_answer()) {
    clear_msg();
    set_has_answer();
    msg_.answer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  msg_.answer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.WebRTCMessage.answer)
}
inline std::string* CTransportSignalMsg_WebRTCMessage::mutable_answer() {
  std::string* _s = _internal_mutable_answer();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.WebRTCMessage.answer)
  return _s;
}
inline const std::string& CTransportSignalMsg_WebRTCMessage::_internal_answer() const {
  if (_internal_has_answer()) {
    return msg_.answer_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void CTransportSignalMsg_WebRTCMessage::_internal_set_answer(const std::string& value) {
  if (!_internal_has_answer()) {
    clear_msg();
    set_has_answer();
    msg_.answer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  msg_.answer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage::_internal_mutable_answer() {
  if (!_internal_has_answer()) {
    clear_msg();
    set_has_answer();
    msg_.answer_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  return msg_.answer_.Mutable(
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CTransportSignalMsg_WebRTCMessage::release_answer() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.WebRTCMessage.answer)
  if (_internal_has_answer()) {
    clear_has_msg();
    return msg_.answer_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
  } else {
    return nullptr;
  }
}
inline void CTransportSignalMsg_WebRTCMessage::set_allocated_answer(std::string* answer) {
  if (has_msg()) {
    clear_msg();
  }
  if (answer != nullptr) {
    set_has_answer();
    msg_.answer_.UnsafeSetDefault(answer);
    ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArenaForAllocation();
    if (arena != nullptr) {
      arena->Own(answer);
    }
  }
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.WebRTCMessage.answer)
}

// .CTransportSignalMsg.WebRTCMessage.Candidate candidate = 4;
inline bool CTransportSignalMsg_WebRTCMessage::_internal_has_candidate() const {
  return msg_case() == kCandidate;
}
inline bool CTransportSignalMsg_WebRTCMessage::has_candidate() const {
  return _internal_has_candidate();
}
inline void CTransportSignalMsg_WebRTCMessage::set_has_candidate() {
  _oneof_case_[0] = kCandidate;
}
inline void CTransportSignalMsg_WebRTCMessage::clear_candidate() {
  if (_internal_has_candidate()) {
    if (GetArenaForAllocation() == nullptr) {
      delete msg_.candidate_;
    }
    clear_has_msg();
  }
}
inline ::CTransportSignalMsg_WebRTCMessage_Candidate* CTransportSignalMsg_WebRTCMessage::release_candidate() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.WebRTCMessage.candidate)
  if (_internal_has_candidate()) {
    clear_has_msg();
      ::CTransportSignalMsg_WebRTCMessage_Candidate* temp = msg_.candidate_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    msg_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::CTransportSignalMsg_WebRTCMessage_Candidate& CTransportSignalMsg_WebRTCMessage::_internal_candidate() const {
  return _internal_has_candidate()
      ? *msg_.candidate_
      : reinterpret_cast< ::CTransportSignalMsg_WebRTCMessage_Candidate&>(::_CTransportSignalMsg_WebRTCMessage_Candidate_default_instance_);
}
inline const ::CTransportSignalMsg_WebRTCMessage_Candidate& CTransportSignalMsg_WebRTCMessage::candidate() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.WebRTCMessage.candidate)
  return _internal_candidate();
}
inline ::CTransportSignalMsg_WebRTCMessage_Candidate* CTransportSignalMsg_WebRTCMessage::unsafe_arena_release_candidate() {
  // @@protoc_insertion_point(field_unsafe_arena_release:CTransportSignalMsg.WebRTCMessage.candidate)
  if (_internal_has_candidate()) {
    clear_has_msg();
    ::CTransportSignalMsg_WebRTCMessage_Candidate* temp = msg_.candidate_;
    msg_.candidate_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void CTransportSignalMsg_WebRTCMessage::unsafe_arena_set_allocated_candidate(::CTransportSignalMsg_WebRTCMessage_Candidate* candidate) {
  clear_msg();
  if (candidate) {
    set_has_candidate();
    msg_.candidate_ = candidate;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CTransportSignalMsg.WebRTCMessage.candidate)
}
inline ::CTransportSignalMsg_WebRTCMessage_Candidate* CTransportSignalMsg_WebRTCMessage::_internal_mutable_candidate() {
  if (!_internal_has_candidate()) {
    clear_msg();
    set_has_candidate();
    msg_.candidate_ = CreateMaybeMessage< ::CTransportSignalMsg_WebRTCMessage_Candidate >(GetArenaForAllocation());
  }
  return msg_.candidate_;
}
inline ::CTransportSignalMsg_WebRTCMessage_Candidate* CTransportSignalMsg_WebRTCMessage::mutable_candidate() {
  ::CTransportSignalMsg_WebRTCMessage_Candidate* _msg = _internal_mutable_candidate();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.WebRTCMessage.candidate)
  return _msg;
}

inline bool CTransportSignalMsg_WebRTCMessage::has_msg() const {
  return msg_case() != MSG_NOT_SET;
}
inline void CTransportSignalMsg_WebRTCMessage::clear_has_msg() {
  _oneof_case_[0] = MSG_NOT_SET;
}
inline CTransportSignalMsg_WebRTCMessage::MsgCase CTransportSignalMsg_WebRTCMessage::msg_case() const {
  return CTransportSignalMsg_WebRTCMessage::MsgCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// CTransportSignalMsg

// optional .CTransportSignalMsg.WebRTCMessage webrtc = 1;
inline bool CTransportSignalMsg::_internal_has_webrtc() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || webrtc_ != nullptr);
  return value;
}
inline bool CTransportSignalMsg::has_webrtc() const {
  return _internal_has_webrtc();
}
inline void CTransportSignalMsg::clear_webrtc() {
  if (webrtc_ != nullptr) webrtc_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::CTransportSignalMsg_WebRTCMessage& CTransportSignalMsg::_internal_webrtc() const {
  const ::CTransportSignalMsg_WebRTCMessage* p = webrtc_;
  return p != nullptr ? *p : reinterpret_cast<const ::CTransportSignalMsg_WebRTCMessage&>(
      ::_CTransportSignalMsg_WebRTCMessage_default_instance_);
}
inline const ::CTransportSignalMsg_WebRTCMessage& CTransportSignalMsg::webrtc() const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.webrtc)
  return _internal_webrtc();
}
inline void CTransportSignalMsg::unsafe_arena_set_allocated_webrtc(
    ::CTransportSignalMsg_WebRTCMessage* webrtc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(webrtc_);
  }
  webrtc_ = webrtc;
  if (webrtc) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CTransportSignalMsg.webrtc)
}
inline ::CTransportSignalMsg_WebRTCMessage* CTransportSignalMsg::release_webrtc() {
  _has_bits_[0] &= ~0x00000001u;
  ::CTransportSignalMsg_WebRTCMessage* temp = webrtc_;
  webrtc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CTransportSignalMsg_WebRTCMessage* CTransportSignalMsg::unsafe_arena_release_webrtc() {
  // @@protoc_insertion_point(field_release:CTransportSignalMsg.webrtc)
  _has_bits_[0] &= ~0x00000001u;
  ::CTransportSignalMsg_WebRTCMessage* temp = webrtc_;
  webrtc_ = nullptr;
  return temp;
}
inline ::CTransportSignalMsg_WebRTCMessage* CTransportSignalMsg::_internal_mutable_webrtc() {
  _has_bits_[0] |= 0x00000001u;
  if (webrtc_ == nullptr) {
    auto* p = CreateMaybeMessage<::CTransportSignalMsg_WebRTCMessage>(GetArenaForAllocation());
    webrtc_ = p;
  }
  return webrtc_;
}
inline ::CTransportSignalMsg_WebRTCMessage* CTransportSignalMsg::mutable_webrtc() {
  ::CTransportSignalMsg_WebRTCMessage* _msg = _internal_mutable_webrtc();
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.webrtc)
  return _msg;
}
inline void CTransportSignalMsg::set_allocated_webrtc(::CTransportSignalMsg_WebRTCMessage* webrtc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete webrtc_;
  }
  if (webrtc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CTransportSignalMsg_WebRTCMessage>::GetOwningArena(webrtc);
    if (message_arena != submessage_arena) {
      webrtc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, webrtc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  webrtc_ = webrtc;
  // @@protoc_insertion_point(field_set_allocated:CTransportSignalMsg.webrtc)
}

// repeated bytes sdr = 2;
inline int CTransportSignalMsg::_internal_sdr_size() const {
  return sdr_.size();
}
inline int CTransportSignalMsg::sdr_size() const {
  return _internal_sdr_size();
}
inline void CTransportSignalMsg::clear_sdr() {
  sdr_.Clear();
}
inline std::string* CTransportSignalMsg::add_sdr() {
  std::string* _s = _internal_add_sdr();
  // @@protoc_insertion_point(field_add_mutable:CTransportSignalMsg.sdr)
  return _s;
}
inline const std::string& CTransportSignalMsg::_internal_sdr(int index) const {
  return sdr_.Get(index);
}
inline const std::string& CTransportSignalMsg::sdr(int index) const {
  // @@protoc_insertion_point(field_get:CTransportSignalMsg.sdr)
  return _internal_sdr(index);
}
inline std::string* CTransportSignalMsg::mutable_sdr(int index) {
  // @@protoc_insertion_point(field_mutable:CTransportSignalMsg.sdr)
  return sdr_.Mutable(index);
}
inline void CTransportSignalMsg::set_sdr(int index, const std::string& value) {
  sdr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::set_sdr(int index, std::string&& value) {
  sdr_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::set_sdr(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sdr_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::set_sdr(int index, const void* value, size_t size) {
  sdr_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:CTransportSignalMsg.sdr)
}
inline std::string* CTransportSignalMsg::_internal_add_sdr() {
  return sdr_.Add();
}
inline void CTransportSignalMsg::add_sdr(const std::string& value) {
  sdr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::add_sdr(std::string&& value) {
  sdr_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::add_sdr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  sdr_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:CTransportSignalMsg.sdr)
}
inline void CTransportSignalMsg::add_sdr(const void* value, size_t size) {
  sdr_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:CTransportSignalMsg.sdr)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CTransportSignalMsg::sdr() const {
  // @@protoc_insertion_point(field_list:CTransportSignalMsg.sdr)
  return sdr_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CTransportSignalMsg::mutable_sdr() {
  // @@protoc_insertion_point(field_mutable_list:CTransportSignalMsg.sdr)
  return &sdr_;
}

// -------------------------------------------------------------------

// CControllerConfigMsg_ControllerConfigResponse

// optional uint32 appid = 1;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_appid() const {
  return _internal_has_appid();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::_internal_appid() const {
  return appid_;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::appid() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.appid)
  return _internal_appid();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.appid)
}

// optional string configURL = 2;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_configurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_configurl() const {
  return _internal_has_configurl();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_configurl() {
  configurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerConfigMsg_ControllerConfigResponse::configurl() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.configURL)
  return _internal_configurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerConfigResponse::set_configurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.configURL)
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::mutable_configurl() {
  std::string* _s = _internal_mutable_configurl();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerConfigResponse.configURL)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerConfigResponse::_internal_configurl() const {
  return configurl_.Get();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_configurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::_internal_mutable_configurl() {
  _has_bits_[0] |= 0x00000001u;
  return configurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::release_configurl() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerConfigResponse.configURL)
  if (!_internal_has_configurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = configurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_allocated_configurl(std::string* configurl) {
  if (configurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  configurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configurl,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerConfigResponse.configURL)
}

// optional uint32 controllerType = 3;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_controllertype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_controllertype() const {
  return _internal_has_controllertype();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_controllertype() {
  controllertype_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::_internal_controllertype() const {
  return controllertype_;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::controllertype() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.controllerType)
  return _internal_controllertype();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_controllertype(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  controllertype_ = value;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_controllertype(uint32_t value) {
  _internal_set_controllertype(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.controllerType)
}

// optional string controllerData = 4;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_controllerdata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_controllerdata() const {
  return _internal_has_controllerdata();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_controllerdata() {
  controllerdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CControllerConfigMsg_ControllerConfigResponse::controllerdata() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.controllerData)
  return _internal_controllerdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerConfigResponse::set_controllerdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.controllerData)
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::mutable_controllerdata() {
  std::string* _s = _internal_mutable_controllerdata();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerConfigResponse.controllerData)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerConfigResponse::_internal_controllerdata() const {
  return controllerdata_.Get();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_controllerdata(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::_internal_mutable_controllerdata() {
  _has_bits_[0] |= 0x00000002u;
  return controllerdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerConfigResponse::release_controllerdata() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerConfigResponse.controllerData)
  if (!_internal_has_controllerdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = controllerdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_allocated_controllerdata(std::string* controllerdata) {
  if (controllerdata != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  controllerdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controllerdata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerConfigResponse.controllerData)
}

// optional uint32 selectionOrder = 5;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_selectionorder() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_selectionorder() const {
  return _internal_has_selectionorder();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_selectionorder() {
  selectionorder_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::_internal_selectionorder() const {
  return selectionorder_;
}
inline uint32_t CControllerConfigMsg_ControllerConfigResponse::selectionorder() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.selectionOrder)
  return _internal_selectionorder();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_selectionorder(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  selectionorder_ = value;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_selectionorder(uint32_t value) {
  _internal_set_selectionorder(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.selectionOrder)
}

// optional bool actionBlock = 6;
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_has_actionblock() const {
  bool value = (_has_bits_[0] & 0x00000020u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::has_actionblock() const {
  return _internal_has_actionblock();
}
inline void CControllerConfigMsg_ControllerConfigResponse::clear_actionblock() {
  actionblock_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::_internal_actionblock() const {
  return actionblock_;
}
inline bool CControllerConfigMsg_ControllerConfigResponse::actionblock() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerConfigResponse.actionBlock)
  return _internal_actionblock();
}
inline void CControllerConfigMsg_ControllerConfigResponse::_internal_set_actionblock(bool value) {
  _has_bits_[0] |= 0x00000020u;
  actionblock_ = value;
}
inline void CControllerConfigMsg_ControllerConfigResponse::set_actionblock(bool value) {
  _internal_set_actionblock(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerConfigResponse.actionBlock)
}

// -------------------------------------------------------------------

// CControllerConfigMsg_ControllerPersonalizationResponse

// optional string personalizationData = 1;
inline bool CControllerConfigMsg_ControllerPersonalizationResponse::_internal_has_personalizationdata() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerPersonalizationResponse::has_personalizationdata() const {
  return _internal_has_personalizationdata();
}
inline void CControllerConfigMsg_ControllerPersonalizationResponse::clear_personalizationdata() {
  personalizationdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerConfigMsg_ControllerPersonalizationResponse::personalizationdata() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
  return _internal_personalizationdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerPersonalizationResponse::set_personalizationdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 personalizationdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
}
inline std::string* CControllerConfigMsg_ControllerPersonalizationResponse::mutable_personalizationdata() {
  std::string* _s = _internal_mutable_personalizationdata();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerPersonalizationResponse::_internal_personalizationdata() const {
  return personalizationdata_.Get();
}
inline void CControllerConfigMsg_ControllerPersonalizationResponse::_internal_set_personalizationdata(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  personalizationdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerPersonalizationResponse::_internal_mutable_personalizationdata() {
  _has_bits_[0] |= 0x00000001u;
  return personalizationdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerPersonalizationResponse::release_personalizationdata() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
  if (!_internal_has_personalizationdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = personalizationdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (personalizationdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    personalizationdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerPersonalizationResponse::set_allocated_personalizationdata(std::string* personalizationdata) {
  if (personalizationdata != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  personalizationdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), personalizationdata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (personalizationdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    personalizationdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerPersonalizationResponse.personalizationData)
}

// -------------------------------------------------------------------

// CControllerConfigMsg_ControllerActiveConfigChangeResponse

// optional string configURL = 2;
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_has_configurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::has_configurl() const {
  return _internal_has_configurl();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::clear_configurl() {
  configurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigChangeResponse::configurl() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
  return _internal_configurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_configurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::mutable_configurl() {
  std::string* _s = _internal_mutable_configurl();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_configurl() const {
  return configurl_.Get();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_set_configurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_mutable_configurl() {
  _has_bits_[0] |= 0x00000001u;
  return configurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::release_configurl() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
  if (!_internal_has_configurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = configurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_allocated_configurl(std::string* configurl) {
  if (configurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  configurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configurl,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerActiveConfigChangeResponse.configURL)
}

// optional uint32 controllerType = 3;
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_has_controllertype() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::has_controllertype() const {
  return _internal_has_controllertype();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::clear_controllertype() {
  controllertype_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_controllertype() const {
  return controllertype_;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigChangeResponse::controllertype() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerType)
  return _internal_controllertype();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_set_controllertype(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  controllertype_ = value;
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_controllertype(uint32_t value) {
  _internal_set_controllertype(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerType)
}

// optional string controllerData = 4;
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_has_controllerdata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::has_controllerdata() const {
  return _internal_has_controllerdata();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::clear_controllerdata() {
  controllerdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigChangeResponse::controllerdata() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
  return _internal_controllerdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_controllerdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::mutable_controllerdata() {
  std::string* _s = _internal_mutable_controllerdata();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_controllerdata() const {
  return controllerdata_.Get();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_set_controllerdata(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_mutable_controllerdata() {
  _has_bits_[0] |= 0x00000002u;
  return controllerdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigChangeResponse::release_controllerdata() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
  if (!_internal_has_controllerdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = controllerdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_allocated_controllerdata(std::string* controllerdata) {
  if (controllerdata != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  controllerdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controllerdata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerActiveConfigChangeResponse.controllerData)
}

// optional uint32 selectionOrder = 5;
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_has_selectionorder() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigChangeResponse::has_selectionorder() const {
  return _internal_has_selectionorder();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::clear_selectionorder() {
  selectionorder_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_selectionorder() const {
  return selectionorder_;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigChangeResponse::selectionorder() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigChangeResponse.selectionOrder)
  return _internal_selectionorder();
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::_internal_set_selectionorder(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  selectionorder_ = value;
}
inline void CControllerConfigMsg_ControllerActiveConfigChangeResponse::set_selectionorder(uint32_t value) {
  _internal_set_selectionorder(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigChangeResponse.selectionOrder)
}

// -------------------------------------------------------------------

// CControllerConfigMsg_ControllerActiveConfigMsg

// optional uint32 appid = 1;
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigMsg::appid() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigMsg.appid)
  return _internal_appid();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000004u;
  appid_ = value;
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigMsg.appid)
}

// optional string configURL = 2;
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::_internal_has_configurl() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::has_configurl() const {
  return _internal_has_configurl();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::clear_configurl() {
  configurl_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigMsg::configurl() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
  return _internal_configurl();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerActiveConfigMsg::set_configurl(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::mutable_configurl() {
  std::string* _s = _internal_mutable_configurl();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigMsg::_internal_configurl() const {
  return configurl_.Get();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::_internal_set_configurl(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  configurl_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::_internal_mutable_configurl() {
  _has_bits_[0] |= 0x00000001u;
  return configurl_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::release_configurl() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
  if (!_internal_has_configurl()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = configurl_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::set_allocated_configurl(std::string* configurl) {
  if (configurl != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  configurl_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), configurl,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (configurl_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    configurl_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerActiveConfigMsg.configURL)
}

// optional uint32 controllerType = 3;
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::_internal_has_controllertype() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::has_controllertype() const {
  return _internal_has_controllertype();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::clear_controllertype() {
  controllertype_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigMsg::_internal_controllertype() const {
  return controllertype_;
}
inline uint32_t CControllerConfigMsg_ControllerActiveConfigMsg::controllertype() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigMsg.controllerType)
  return _internal_controllertype();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::_internal_set_controllertype(uint32_t value) {
  _has_bits_[0] |= 0x00000008u;
  controllertype_ = value;
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::set_controllertype(uint32_t value) {
  _internal_set_controllertype(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigMsg.controllerType)
}

// optional string controllerData = 4;
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::_internal_has_controllerdata() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool CControllerConfigMsg_ControllerActiveConfigMsg::has_controllerdata() const {
  return _internal_has_controllerdata();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::clear_controllerdata() {
  controllerdata_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigMsg::controllerdata() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
  return _internal_controllerdata();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg_ControllerActiveConfigMsg::set_controllerdata(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000002u;
 controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::mutable_controllerdata() {
  std::string* _s = _internal_mutable_controllerdata();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
  return _s;
}
inline const std::string& CControllerConfigMsg_ControllerActiveConfigMsg::_internal_controllerdata() const {
  return controllerdata_.Get();
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::_internal_set_controllerdata(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  controllerdata_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::_internal_mutable_controllerdata() {
  _has_bits_[0] |= 0x00000002u;
  return controllerdata_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg_ControllerActiveConfigMsg::release_controllerdata() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
  if (!_internal_has_controllerdata()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  auto* p = controllerdata_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg_ControllerActiveConfigMsg::set_allocated_controllerdata(std::string* controllerdata) {
  if (controllerdata != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  controllerdata_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controllerdata,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerdata_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerdata_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.ControllerActiveConfigMsg.controllerData)
}

// -------------------------------------------------------------------

// CControllerConfigMsg

// required .EStreamControllerConfigMsg type = 1 [default = k_EStreamControllerConfigMsg_RequestConfigsForApp];
inline bool CControllerConfigMsg::_internal_has_type() const {
  bool value = (_has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool CControllerConfigMsg::has_type() const {
  return _internal_has_type();
}
inline void CControllerConfigMsg::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::EStreamControllerConfigMsg CControllerConfigMsg::_internal_type() const {
  return static_cast< ::EStreamControllerConfigMsg >(type_);
}
inline ::EStreamControllerConfigMsg CControllerConfigMsg::type() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.type)
  return _internal_type();
}
inline void CControllerConfigMsg::_internal_set_type(::EStreamControllerConfigMsg value) {
  assert(::EStreamControllerConfigMsg_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  type_ = value;
}
inline void CControllerConfigMsg::set_type(::EStreamControllerConfigMsg value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.type)
}

// optional string controllerPath = 2;
inline bool CControllerConfigMsg::_internal_has_controllerpath() const {
  bool value = (_has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool CControllerConfigMsg::has_controllerpath() const {
  return _internal_has_controllerpath();
}
inline void CControllerConfigMsg::clear_controllerpath() {
  controllerpath_.ClearToEmpty();
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& CControllerConfigMsg::controllerpath() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.controllerPath)
  return _internal_controllerpath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CControllerConfigMsg::set_controllerpath(ArgT0&& arg0, ArgT... args) {
 _has_bits_[0] |= 0x00000001u;
 controllerpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.controllerPath)
}
inline std::string* CControllerConfigMsg::mutable_controllerpath() {
  std::string* _s = _internal_mutable_controllerpath();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.controllerPath)
  return _s;
}
inline const std::string& CControllerConfigMsg::_internal_controllerpath() const {
  return controllerpath_.Get();
}
inline void CControllerConfigMsg::_internal_set_controllerpath(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  controllerpath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg::_internal_mutable_controllerpath() {
  _has_bits_[0] |= 0x00000001u;
  return controllerpath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CControllerConfigMsg::release_controllerpath() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.controllerPath)
  if (!_internal_has_controllerpath()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  auto* p = controllerpath_.ReleaseNonDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void CControllerConfigMsg::set_allocated_controllerpath(std::string* controllerpath) {
  if (controllerpath != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  controllerpath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), controllerpath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (controllerpath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    controllerpath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.controllerPath)
}

// optional uint32 appid = 3;
inline bool CControllerConfigMsg::_internal_has_appid() const {
  bool value = (_has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool CControllerConfigMsg::has_appid() const {
  return _internal_has_appid();
}
inline void CControllerConfigMsg::clear_appid() {
  appid_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline uint32_t CControllerConfigMsg::_internal_appid() const {
  return appid_;
}
inline uint32_t CControllerConfigMsg::appid() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.appid)
  return _internal_appid();
}
inline void CControllerConfigMsg::_internal_set_appid(uint32_t value) {
  _has_bits_[0] |= 0x00000010u;
  appid_ = value;
}
inline void CControllerConfigMsg::set_appid(uint32_t value) {
  _internal_set_appid(value);
  // @@protoc_insertion_point(field_set:CControllerConfigMsg.appid)
}

// optional .CControllerConfigMsg.ControllerPersonalizationResponse personalizationResponse = 4;
inline bool CControllerConfigMsg::_internal_has_personalizationresponse() const {
  bool value = (_has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || personalizationresponse_ != nullptr);
  return value;
}
inline bool CControllerConfigMsg::has_personalizationresponse() const {
  return _internal_has_personalizationresponse();
}
inline void CControllerConfigMsg::clear_personalizationresponse() {
  if (personalizationresponse_ != nullptr) personalizationresponse_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::CControllerConfigMsg_ControllerPersonalizationResponse& CControllerConfigMsg::_internal_personalizationresponse() const {
  const ::CControllerConfigMsg_ControllerPersonalizationResponse* p = personalizationresponse_;
  return p != nullptr ? *p : reinterpret_cast<const ::CControllerConfigMsg_ControllerPersonalizationResponse&>(
      ::_CControllerConfigMsg_ControllerPersonalizationResponse_default_instance_);
}
inline const ::CControllerConfigMsg_ControllerPersonalizationResponse& CControllerConfigMsg::personalizationresponse() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.personalizationResponse)
  return _internal_personalizationresponse();
}
inline void CControllerConfigMsg::unsafe_arena_set_allocated_personalizationresponse(
    ::CControllerConfigMsg_ControllerPersonalizationResponse* personalizationresponse) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(personalizationresponse_);
  }
  personalizationresponse_ = personalizationresponse;
  if (personalizationresponse) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CControllerConfigMsg.personalizationResponse)
}
inline ::CControllerConfigMsg_ControllerPersonalizationResponse* CControllerConfigMsg::release_personalizationresponse() {
  _has_bits_[0] &= ~0x00000002u;
  ::CControllerConfigMsg_ControllerPersonalizationResponse* temp = personalizationresponse_;
  personalizationresponse_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CControllerConfigMsg_ControllerPersonalizationResponse* CControllerConfigMsg::unsafe_arena_release_personalizationresponse() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.personalizationResponse)
  _has_bits_[0] &= ~0x00000002u;
  ::CControllerConfigMsg_ControllerPersonalizationResponse* temp = personalizationresponse_;
  personalizationresponse_ = nullptr;
  return temp;
}
inline ::CControllerConfigMsg_ControllerPersonalizationResponse* CControllerConfigMsg::_internal_mutable_personalizationresponse() {
  _has_bits_[0] |= 0x00000002u;
  if (personalizationresponse_ == nullptr) {
    auto* p = CreateMaybeMessage<::CControllerConfigMsg_ControllerPersonalizationResponse>(GetArenaForAllocation());
    personalizationresponse_ = p;
  }
  return personalizationresponse_;
}
inline ::CControllerConfigMsg_ControllerPersonalizationResponse* CControllerConfigMsg::mutable_personalizationresponse() {
  ::CControllerConfigMsg_ControllerPersonalizationResponse* _msg = _internal_mutable_personalizationresponse();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.personalizationResponse)
  return _msg;
}
inline void CControllerConfigMsg::set_allocated_personalizationresponse(::CControllerConfigMsg_ControllerPersonalizationResponse* personalizationresponse) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete personalizationresponse_;
  }
  if (personalizationresponse) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CControllerConfigMsg_ControllerPersonalizationResponse>::GetOwningArena(personalizationresponse);
    if (message_arena != submessage_arena) {
      personalizationresponse = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, personalizationresponse, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  personalizationresponse_ = personalizationresponse;
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.personalizationResponse)
}

// repeated .CControllerConfigMsg.ControllerConfigResponse configResponse = 6;
inline int CControllerConfigMsg::_internal_configresponse_size() const {
  return configresponse_.size();
}
inline int CControllerConfigMsg::configresponse_size() const {
  return _internal_configresponse_size();
}
inline void CControllerConfigMsg::clear_configresponse() {
  configresponse_.Clear();
}
inline ::CControllerConfigMsg_ControllerConfigResponse* CControllerConfigMsg::mutable_configresponse(int index) {
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.configResponse)
  return configresponse_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CControllerConfigMsg_ControllerConfigResponse >*
CControllerConfigMsg::mutable_configresponse() {
  // @@protoc_insertion_point(field_mutable_list:CControllerConfigMsg.configResponse)
  return &configresponse_;
}
inline const ::CControllerConfigMsg_ControllerConfigResponse& CControllerConfigMsg::_internal_configresponse(int index) const {
  return configresponse_.Get(index);
}
inline const ::CControllerConfigMsg_ControllerConfigResponse& CControllerConfigMsg::configresponse(int index) const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.configResponse)
  return _internal_configresponse(index);
}
inline ::CControllerConfigMsg_ControllerConfigResponse* CControllerConfigMsg::_internal_add_configresponse() {
  return configresponse_.Add();
}
inline ::CControllerConfigMsg_ControllerConfigResponse* CControllerConfigMsg::add_configresponse() {
  ::CControllerConfigMsg_ControllerConfigResponse* _add = _internal_add_configresponse();
  // @@protoc_insertion_point(field_add:CControllerConfigMsg.configResponse)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::CControllerConfigMsg_ControllerConfigResponse >&
CControllerConfigMsg::configresponse() const {
  // @@protoc_insertion_point(field_list:CControllerConfigMsg.configResponse)
  return configresponse_;
}

// optional .CControllerConfigMsg.ControllerActiveConfigMsg activeConfigChangeMsg = 7;
inline bool CControllerConfigMsg::_internal_has_activeconfigchangemsg() const {
  bool value = (_has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || activeconfigchangemsg_ != nullptr);
  return value;
}
inline bool CControllerConfigMsg::has_activeconfigchangemsg() const {
  return _internal_has_activeconfigchangemsg();
}
inline void CControllerConfigMsg::clear_activeconfigchangemsg() {
  if (activeconfigchangemsg_ != nullptr) activeconfigchangemsg_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::CControllerConfigMsg_ControllerActiveConfigMsg& CControllerConfigMsg::_internal_activeconfigchangemsg() const {
  const ::CControllerConfigMsg_ControllerActiveConfigMsg* p = activeconfigchangemsg_;
  return p != nullptr ? *p : reinterpret_cast<const ::CControllerConfigMsg_ControllerActiveConfigMsg&>(
      ::_CControllerConfigMsg_ControllerActiveConfigMsg_default_instance_);
}
inline const ::CControllerConfigMsg_ControllerActiveConfigMsg& CControllerConfigMsg::activeconfigchangemsg() const {
  // @@protoc_insertion_point(field_get:CControllerConfigMsg.activeConfigChangeMsg)
  return _internal_activeconfigchangemsg();
}
inline void CControllerConfigMsg::unsafe_arena_set_allocated_activeconfigchangemsg(
    ::CControllerConfigMsg_ControllerActiveConfigMsg* activeconfigchangemsg) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(activeconfigchangemsg_);
  }
  activeconfigchangemsg_ = activeconfigchangemsg;
  if (activeconfigchangemsg) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:CControllerConfigMsg.activeConfigChangeMsg)
}
inline ::CControllerConfigMsg_ControllerActiveConfigMsg* CControllerConfigMsg::release_activeconfigchangemsg() {
  _has_bits_[0] &= ~0x00000004u;
  ::CControllerConfigMsg_ControllerActiveConfigMsg* temp = activeconfigchangemsg_;
  activeconfigchangemsg_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::CControllerConfigMsg_ControllerActiveConfigMsg* CControllerConfigMsg::unsafe_arena_release_activeconfigchangemsg() {
  // @@protoc_insertion_point(field_release:CControllerConfigMsg.activeConfigChangeMsg)
  _has_bits_[0] &= ~0x00000004u;
  ::CControllerConfigMsg_ControllerActiveConfigMsg* temp = activeconfigchangemsg_;
  activeconfigchangemsg_ = nullptr;
  return temp;
}
inline ::CControllerConfigMsg_ControllerActiveConfigMsg* CControllerConfigMsg::_internal_mutable_activeconfigchangemsg() {
  _has_bits_[0] |= 0x00000004u;
  if (activeconfigchangemsg_ == nullptr) {
    auto* p = CreateMaybeMessage<::CControllerConfigMsg_ControllerActiveConfigMsg>(GetArenaForAllocation());
    activeconfigchangemsg_ = p;
  }
  return activeconfigchangemsg_;
}
inline ::CControllerConfigMsg_ControllerActiveConfigMsg* CControllerConfigMsg::mutable_activeconfigchangemsg() {
  ::CControllerConfigMsg_ControllerActiveConfigMsg* _msg = _internal_mutable_activeconfigchangemsg();
  // @@protoc_insertion_point(field_mutable:CControllerConfigMsg.activeConfigChangeMsg)
  return _msg;
}
inline void CControllerConfigMsg::set_allocated_activeconfigchangemsg(::CControllerConfigMsg_ControllerActiveConfigMsg* activeconfigchangemsg) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete activeconfigchangemsg_;
  }
  if (activeconfigchangemsg) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::CControllerConfigMsg_ControllerActiveConfigMsg>::GetOwningArena(activeconfigchangemsg);
    if (message_arena != submessage_arena) {
      activeconfigchangemsg = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, activeconfigchangemsg, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  activeconfigchangemsg_ = activeconfigchangemsg;
  // @@protoc_insertion_point(field_set_allocated:CControllerConfigMsg.activeConfigChangeMsg)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::CAuthenticationResponseMsg_AuthenticationResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::CAuthenticationResponseMsg_AuthenticationResult>() {
  return ::CAuthenticationResponseMsg_AuthenticationResult_descriptor();
}
template <> struct is_proto_enum< ::EStreamChannel> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamChannel>() {
  return ::EStreamChannel_descriptor();
}
template <> struct is_proto_enum< ::EStreamDiscoveryMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamDiscoveryMessage>() {
  return ::EStreamDiscoveryMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamControlMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamControlMessage>() {
  return ::EStreamControlMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamVersion> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamVersion>() {
  return ::EStreamVersion_descriptor();
}
template <> struct is_proto_enum< ::EStreamAudioCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamAudioCodec>() {
  return ::EStreamAudioCodec_descriptor();
}
template <> struct is_proto_enum< ::EStreamVideoCodec> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamVideoCodec>() {
  return ::EStreamVideoCodec_descriptor();
}
template <> struct is_proto_enum< ::EStreamQualityPreference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamQualityPreference>() {
  return ::EStreamQualityPreference_descriptor();
}
template <> struct is_proto_enum< ::EStreamBitrate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamBitrate>() {
  return ::EStreamBitrate_descriptor();
}
template <> struct is_proto_enum< ::EStreamColorspace> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamColorspace>() {
  return ::EStreamColorspace_descriptor();
}
template <> struct is_proto_enum< ::EStreamP2PScope> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamP2PScope>() {
  return ::EStreamP2PScope_descriptor();
}
template <> struct is_proto_enum< ::EStreamHostPlayAudioPreference> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamHostPlayAudioPreference>() {
  return ::EStreamHostPlayAudioPreference_descriptor();
}
template <> struct is_proto_enum< ::EStreamingDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamingDataType>() {
  return ::EStreamingDataType_descriptor();
}
template <> struct is_proto_enum< ::EStreamMouseButton> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamMouseButton>() {
  return ::EStreamMouseButton_descriptor();
}
template <> struct is_proto_enum< ::EStreamMouseWheelDirection> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamMouseWheelDirection>() {
  return ::EStreamMouseWheelDirection_descriptor();
}
template <> struct is_proto_enum< ::EStreamFramerateLimiter> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFramerateLimiter>() {
  return ::EStreamFramerateLimiter_descriptor();
}
template <> struct is_proto_enum< ::EStreamActivity> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamActivity>() {
  return ::EStreamActivity_descriptor();
}
template <> struct is_proto_enum< ::EStreamDataMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamDataMessage>() {
  return ::EStreamDataMessage_descriptor();
}
template <> struct is_proto_enum< ::EAudioFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EAudioFormat>() {
  return ::EAudioFormat_descriptor();
}
template <> struct is_proto_enum< ::EVideoFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EVideoFormat>() {
  return ::EVideoFormat_descriptor();
}
template <> struct is_proto_enum< ::EStreamStatsMessage> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamStatsMessage>() {
  return ::EStreamStatsMessage_descriptor();
}
template <> struct is_proto_enum< ::EStreamFrameEvent> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFrameEvent>() {
  return ::EStreamFrameEvent_descriptor();
}
template <> struct is_proto_enum< ::EStreamFrameResult> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamFrameResult>() {
  return ::EStreamFrameResult_descriptor();
}
template <> struct is_proto_enum< ::EFrameAccumulatedStat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EFrameAccumulatedStat>() {
  return ::EFrameAccumulatedStat_descriptor();
}
template <> struct is_proto_enum< ::ELogFileType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ELogFileType>() {
  return ::ELogFileType_descriptor();
}
template <> struct is_proto_enum< ::EStreamControllerConfigMsg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::EStreamControllerConfigMsg>() {
  return ::EStreamControllerConfigMsg_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_steammessages_5fremoteplay_2eproto
