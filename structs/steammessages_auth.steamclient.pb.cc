// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: steammessages_auth.steamclient.proto

#include "steammessages_auth.steamclient.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG
constexpr CAuthentication_GetPasswordRSAPublicKey_Request::CAuthentication_GetPasswordRSAPublicKey_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : account_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal {
  constexpr CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_GetPasswordRSAPublicKey_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetPasswordRSAPublicKey_RequestDefaultTypeInternal _CAuthentication_GetPasswordRSAPublicKey_Request_default_instance_;
constexpr CAuthentication_GetPasswordRSAPublicKey_Response::CAuthentication_GetPasswordRSAPublicKey_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : publickey_mod_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , publickey_exp_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , timestamp_(uint64_t{0u}){}
struct CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal {
  constexpr CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_GetPasswordRSAPublicKey_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetPasswordRSAPublicKey_ResponseDefaultTypeInternal _CAuthentication_GetPasswordRSAPublicKey_Response_default_instance_;
constexpr CAuthentication_DeviceDetails::CAuthentication_DeviceDetails(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_friendly_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , machine_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , platform_type_(0)

  , os_type_(0)
  , gaming_device_type_(0u)
  , client_count_(0u){}
struct CAuthentication_DeviceDetailsDefaultTypeInternal {
  constexpr CAuthentication_DeviceDetailsDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_DeviceDetailsDefaultTypeInternal() {}
  union {
    CAuthentication_DeviceDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_DeviceDetailsDefaultTypeInternal _CAuthentication_DeviceDetails_default_instance_;
constexpr CAuthentication_BeginAuthSessionViaQR_Request::CAuthentication_BeginAuthSessionViaQR_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_friendly_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , website_id_(nullptr)
  , device_details_(nullptr)
  , platform_type_(0)
{}
struct CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal {
  constexpr CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_BeginAuthSessionViaQR_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_BeginAuthSessionViaQR_RequestDefaultTypeInternal _CAuthentication_BeginAuthSessionViaQR_Request_default_instance_;
constexpr CAuthentication_AllowedConfirmation::CAuthentication_AllowedConfirmation(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : associated_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , confirmation_type_(0)
{}
struct CAuthentication_AllowedConfirmationDefaultTypeInternal {
  constexpr CAuthentication_AllowedConfirmationDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_AllowedConfirmationDefaultTypeInternal() {}
  union {
    CAuthentication_AllowedConfirmation _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_AllowedConfirmationDefaultTypeInternal _CAuthentication_AllowedConfirmation_default_instance_;
constexpr CAuthentication_BeginAuthSessionViaQR_Response::CAuthentication_BeginAuthSessionViaQR_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : allowed_confirmations_()
  , challenge_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , request_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , interval_(0)
  , version_(0){}
struct CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal {
  constexpr CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_BeginAuthSessionViaQR_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_BeginAuthSessionViaQR_ResponseDefaultTypeInternal _CAuthentication_BeginAuthSessionViaQR_Response_default_instance_;
constexpr CAuthentication_BeginAuthSessionViaCredentials_Request::CAuthentication_BeginAuthSessionViaCredentials_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : device_friendly_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , account_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , encrypted_password_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , website_id_(nullptr)
  , guard_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_details_(nullptr)
  , encryption_timestamp_(uint64_t{0u})
  , remember_login_(false)
  , platform_type_(0)

  , language_(0u)
  , persistence_(1)

  , qos_level_(2){}
struct CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal {
  constexpr CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_BeginAuthSessionViaCredentials_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_BeginAuthSessionViaCredentials_RequestDefaultTypeInternal _CAuthentication_BeginAuthSessionViaCredentials_Request_default_instance_;
constexpr CAuthentication_BeginAuthSessionViaCredentials_Response::CAuthentication_BeginAuthSessionViaCredentials_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : allowed_confirmations_()
  , request_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , weak_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , agreement_session_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , extended_error_message_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , interval_(0){}
struct CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal {
  constexpr CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_BeginAuthSessionViaCredentials_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_BeginAuthSessionViaCredentials_ResponseDefaultTypeInternal _CAuthentication_BeginAuthSessionViaCredentials_Response_default_instance_;
constexpr CAuthentication_PollAuthSessionStatus_Request::CAuthentication_PollAuthSessionStatus_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : request_id_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , token_to_revoke_(uint64_t{0u}){}
struct CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal {
  constexpr CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_PollAuthSessionStatus_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_PollAuthSessionStatus_RequestDefaultTypeInternal _CAuthentication_PollAuthSessionStatus_Request_default_instance_;
constexpr CAuthentication_PollAuthSessionStatus_Response::CAuthentication_PollAuthSessionStatus_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : new_challenge_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , refresh_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , access_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , account_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , new_guard_data_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , agreement_session_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , new_client_id_(uint64_t{0u})
  , had_remote_interaction_(false){}
struct CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal {
  constexpr CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_PollAuthSessionStatus_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_PollAuthSessionStatus_ResponseDefaultTypeInternal _CAuthentication_PollAuthSessionStatus_Response_default_instance_;
constexpr CAuthentication_GetAuthSessionInfo_Request::CAuthentication_GetAuthSessionInfo_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_id_(uint64_t{0u}){}
struct CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal {
  constexpr CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_GetAuthSessionInfo_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetAuthSessionInfo_RequestDefaultTypeInternal _CAuthentication_GetAuthSessionInfo_Request_default_instance_;
constexpr CAuthentication_GetAuthSessionInfo_Response::CAuthentication_GetAuthSessionInfo_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , geoloc_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , city_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , country_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , device_friendly_name_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , platform_type_(0)

  , version_(0)
  , login_history_(0)

  , requestor_location_mismatch_(false)
  , high_usage_login_(false)
  , requested_persistence_(-1)
{}
struct CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal {
  constexpr CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_GetAuthSessionInfo_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetAuthSessionInfo_ResponseDefaultTypeInternal _CAuthentication_GetAuthSessionInfo_Response_default_instance_;
constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , version_(0)
  , confirm_(false)
  , persistence_(1)
{}
struct CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal {
  constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_UpdateAuthSessionWithMobileConfirmation_RequestDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request_default_instance_;
constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal {
  constexpr CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_UpdateAuthSessionWithMobileConfirmation_ResponseDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response_default_instance_;
constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : code_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , client_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , code_type_(0)
{}
struct CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal {
  constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_UpdateAuthSessionWithSteamGuardCode_RequestDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request_default_instance_;
constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : agreement_session_url_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal {
  constexpr CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_UpdateAuthSessionWithSteamGuardCode_ResponseDefaultTypeInternal _CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response_default_instance_;
constexpr CAuthentication_AccessToken_GenerateForApp_Request::CAuthentication_AccessToken_GenerateForApp_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : refresh_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , steamid_(uint64_t{0u})
  , renewal_type_(0)
{}
struct CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal {
  constexpr CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_AccessToken_GenerateForApp_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_AccessToken_GenerateForApp_RequestDefaultTypeInternal _CAuthentication_AccessToken_GenerateForApp_Request_default_instance_;
constexpr CAuthentication_AccessToken_GenerateForApp_Response::CAuthentication_AccessToken_GenerateForApp_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : access_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , refresh_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal {
  constexpr CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_AccessToken_GenerateForApp_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_AccessToken_GenerateForApp_ResponseDefaultTypeInternal _CAuthentication_AccessToken_GenerateForApp_Response_default_instance_;
constexpr CAuthentication_RefreshToken_Enumerate_Request::CAuthentication_RefreshToken_Enumerate_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Enumerate_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Enumerate_RequestDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Request_default_instance_;
constexpr CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : locale_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , country_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , city_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_(nullptr)
  , time_(0u){}
struct CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEventDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_;
constexpr CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , first_seen_(nullptr)
  , last_seen_(nullptr)
  , token_id_(uint64_t{0u})
  , time_updated_(0u)
  , platform_type_(0)

  , logged_in_(false)
  , os_platform_(0u)
  , auth_type_(0u)
  , gaming_device_type_(0u)
  , os_type_(0){}
struct CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescriptionDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription_default_instance_;
constexpr CAuthentication_RefreshToken_Enumerate_Response::CAuthentication_RefreshToken_Enumerate_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : refresh_tokens_()
  , requesting_token_(uint64_t{0u}){}
struct CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Enumerate_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Enumerate_ResponseDefaultTypeInternal _CAuthentication_RefreshToken_Enumerate_Response_default_instance_;
constexpr CAuthentication_GetAuthSessionsForAccount_Request::CAuthentication_GetAuthSessionsForAccount_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal {
  constexpr CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_GetAuthSessionsForAccount_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetAuthSessionsForAccount_RequestDefaultTypeInternal _CAuthentication_GetAuthSessionsForAccount_Request_default_instance_;
constexpr CAuthentication_GetAuthSessionsForAccount_Response::CAuthentication_GetAuthSessionsForAccount_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : client_ids_(){}
struct CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal {
  constexpr CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_GetAuthSessionsForAccount_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_GetAuthSessionsForAccount_ResponseDefaultTypeInternal _CAuthentication_GetAuthSessionsForAccount_Response_default_instance_;
constexpr CAuthentication_MigrateMobileSession_Request::CAuthentication_MigrateMobileSession_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , steamid_(uint64_t{0u}){}
struct CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal {
  constexpr CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_MigrateMobileSession_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_MigrateMobileSession_RequestDefaultTypeInternal _CAuthentication_MigrateMobileSession_Request_default_instance_;
constexpr CAuthentication_MigrateMobileSession_Response::CAuthentication_MigrateMobileSession_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : refresh_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , access_token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal {
  constexpr CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_MigrateMobileSession_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_MigrateMobileSession_ResponseDefaultTypeInternal _CAuthentication_MigrateMobileSession_Response_default_instance_;
constexpr CAuthentication_Token_Revoke_Request::CAuthentication_Token_Revoke_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , revoke_action_(1)
{}
struct CAuthentication_Token_Revoke_RequestDefaultTypeInternal {
  constexpr CAuthentication_Token_Revoke_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_Token_Revoke_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_Token_Revoke_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_Token_Revoke_RequestDefaultTypeInternal _CAuthentication_Token_Revoke_Request_default_instance_;
constexpr CAuthentication_Token_Revoke_Response::CAuthentication_Token_Revoke_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthentication_Token_Revoke_ResponseDefaultTypeInternal {
  constexpr CAuthentication_Token_Revoke_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_Token_Revoke_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_Token_Revoke_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_Token_Revoke_ResponseDefaultTypeInternal _CAuthentication_Token_Revoke_Response_default_instance_;
constexpr CAuthentication_RefreshToken_Revoke_Request::CAuthentication_RefreshToken_Revoke_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : signature_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , token_id_(uint64_t{0u})
  , steamid_(uint64_t{0u})
  , revoke_action_(1)
{}
struct CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Revoke_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Revoke_RequestDefaultTypeInternal _CAuthentication_RefreshToken_Revoke_Request_default_instance_;
constexpr CAuthentication_RefreshToken_Revoke_Response::CAuthentication_RefreshToken_Revoke_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal {
  constexpr CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal() {}
  union {
    CAuthentication_RefreshToken_Revoke_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthentication_RefreshToken_Revoke_ResponseDefaultTypeInternal _CAuthentication_RefreshToken_Revoke_Response_default_instance_;
constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_Request::CAuthenticationSupport_QueryRefreshTokensByAccount_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : steamid_(uint64_t{0u})
  , include_revoked_tokens_(false){}
struct CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal {
  constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_QueryRefreshTokensByAccount_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_QueryRefreshTokensByAccount_RequestDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokensByAccount_Request_default_instance_;
constexpr CSupportRefreshTokenDescription_TokenUsageEvent::CSupportRefreshTokenDescription_TokenUsageEvent(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : country_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , state_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , city_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , ip_(nullptr)
  , time_(0u){}
struct CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal {
  constexpr CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal() {}
  union {
    CSupportRefreshTokenDescription_TokenUsageEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSupportRefreshTokenDescription_TokenUsageEventDefaultTypeInternal _CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_;
constexpr CSupportRefreshTokenDescription::CSupportRefreshTokenDescription(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_description_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , first_seen_(nullptr)
  , last_seen_(nullptr)
  , token_id_(uint64_t{0u})
  , time_updated_(0u)
  , platform_type_(0)

  , owner_steamid_(uint64_t{0u})
  , token_state_(0)

  , os_platform_(0u)
  , os_type_(0)
  , auth_type_(0u)
  , gaming_device_type_(0u){}
struct CSupportRefreshTokenDescriptionDefaultTypeInternal {
  constexpr CSupportRefreshTokenDescriptionDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSupportRefreshTokenDescriptionDefaultTypeInternal() {}
  union {
    CSupportRefreshTokenDescription _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSupportRefreshTokenDescriptionDefaultTypeInternal _CSupportRefreshTokenDescription_default_instance_;
constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_Response::CAuthenticationSupport_QueryRefreshTokensByAccount_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : refresh_tokens_()
  , last_token_reset_(0){}
struct CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal {
  constexpr CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_QueryRefreshTokensByAccount_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_QueryRefreshTokensByAccount_ResponseDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokensByAccount_Response_default_instance_;
constexpr CAuthenticationSupport_QueryRefreshTokenByID_Request::CAuthenticationSupport_QueryRefreshTokenByID_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_id_(uint64_t{0u}){}
struct CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal {
  constexpr CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_QueryRefreshTokenByID_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_QueryRefreshTokenByID_RequestDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokenByID_Request_default_instance_;
constexpr CAuthenticationSupport_QueryRefreshTokenByID_Response::CAuthenticationSupport_QueryRefreshTokenByID_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : refresh_tokens_(){}
struct CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal {
  constexpr CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_QueryRefreshTokenByID_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_QueryRefreshTokenByID_ResponseDefaultTypeInternal _CAuthenticationSupport_QueryRefreshTokenByID_Response_default_instance_;
constexpr CAuthenticationSupport_RevokeToken_Request::CAuthenticationSupport_RevokeToken_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_id_(uint64_t{0u})
  , steamid_(uint64_t{0u}){}
struct CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal {
  constexpr CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_RevokeToken_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_RevokeToken_RequestDefaultTypeInternal _CAuthenticationSupport_RevokeToken_Request_default_instance_;
constexpr CAuthenticationSupport_RevokeToken_Response::CAuthenticationSupport_RevokeToken_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized){}
struct CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal {
  constexpr CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_RevokeToken_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_RevokeToken_ResponseDefaultTypeInternal _CAuthenticationSupport_RevokeToken_Response_default_instance_;
constexpr CAuthenticationSupport_GetTokenHistory_Request::CAuthenticationSupport_GetTokenHistory_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : token_id_(uint64_t{0u}){}
struct CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal {
  constexpr CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_GetTokenHistory_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_GetTokenHistory_RequestDefaultTypeInternal _CAuthenticationSupport_GetTokenHistory_Request_default_instance_;
constexpr CSupportRefreshTokenAudit::CSupportRefreshTokenAudit(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : ip_(nullptr)
  , action_(0)
  , time_(0u)
  , actor_(uint64_t{0u}){}
struct CSupportRefreshTokenAuditDefaultTypeInternal {
  constexpr CSupportRefreshTokenAuditDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CSupportRefreshTokenAuditDefaultTypeInternal() {}
  union {
    CSupportRefreshTokenAudit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CSupportRefreshTokenAuditDefaultTypeInternal _CSupportRefreshTokenAudit_default_instance_;
constexpr CAuthenticationSupport_GetTokenHistory_Response::CAuthenticationSupport_GetTokenHistory_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : history_(){}
struct CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal {
  constexpr CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal() {}
  union {
    CAuthenticationSupport_GetTokenHistory_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CAuthenticationSupport_GetTokenHistory_ResponseDefaultTypeInternal _CAuthenticationSupport_GetTokenHistory_Response_default_instance_;
constexpr CCloudGaming_CreateNonce_Request::CCloudGaming_CreateNonce_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : platform_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , appid_(0u){}
struct CCloudGaming_CreateNonce_RequestDefaultTypeInternal {
  constexpr CCloudGaming_CreateNonce_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloudGaming_CreateNonce_RequestDefaultTypeInternal() {}
  union {
    CCloudGaming_CreateNonce_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloudGaming_CreateNonce_RequestDefaultTypeInternal _CCloudGaming_CreateNonce_Request_default_instance_;
constexpr CCloudGaming_CreateNonce_Response::CCloudGaming_CreateNonce_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : nonce_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string)
  , expiry_(0u){}
struct CCloudGaming_CreateNonce_ResponseDefaultTypeInternal {
  constexpr CCloudGaming_CreateNonce_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloudGaming_CreateNonce_ResponseDefaultTypeInternal() {}
  union {
    CCloudGaming_CreateNonce_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloudGaming_CreateNonce_ResponseDefaultTypeInternal _CCloudGaming_CreateNonce_Response_default_instance_;
constexpr CCloudGaming_GetTimeRemaining_Request::CCloudGaming_GetTimeRemaining_Request(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_list_()
  , platform_(&::PROTOBUF_NAMESPACE_ID::internal::fixed_address_empty_string){}
struct CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal {
  constexpr CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal() {}
  union {
    CCloudGaming_GetTimeRemaining_Request _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloudGaming_GetTimeRemaining_RequestDefaultTypeInternal _CCloudGaming_GetTimeRemaining_Request_default_instance_;
constexpr CCloudGaming_TimeRemaining::CCloudGaming_TimeRemaining(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : appid_(0u)
  , minutes_remaining_(0u){}
struct CCloudGaming_TimeRemainingDefaultTypeInternal {
  constexpr CCloudGaming_TimeRemainingDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloudGaming_TimeRemainingDefaultTypeInternal() {}
  union {
    CCloudGaming_TimeRemaining _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloudGaming_TimeRemainingDefaultTypeInternal _CCloudGaming_TimeRemaining_default_instance_;
constexpr CCloudGaming_GetTimeRemaining_Response::CCloudGaming_GetTimeRemaining_Response(
  ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized)
  : entries_(){}
struct CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal {
  constexpr CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal()
    : _instance(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized{}) {}
  ~CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal() {}
  union {
    CCloudGaming_GetTimeRemaining_Response _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT CCloudGaming_GetTimeRemaining_ResponseDefaultTypeInternal _CCloudGaming_GetTimeRemaining_Response_default_instance_;
static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[46];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[6];
static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[3];

const uint32_t TableStruct_steammessages_5fauth_2esteamclient_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Request, account_name_),
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Response, publickey_mod_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Response, publickey_exp_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetPasswordRSAPublicKey_Response, timestamp_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, device_friendly_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, os_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, gaming_device_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, client_count_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_DeviceDetails, machine_id_),
  0,
  2,
  3,
  4,
  5,
  1,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, device_friendly_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, device_details_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Request, website_id_),
  0,
  3,
  2,
  1,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AllowedConfirmation, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AllowedConfirmation, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AllowedConfirmation, confirmation_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AllowedConfirmation, associated_message_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, challenge_url_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, request_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, interval_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, allowed_confirmations_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaQR_Response, version_),
  2,
  0,
  1,
  3,
  ~0u,
  4,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, device_friendly_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, account_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, encrypted_password_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, encryption_timestamp_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, remember_login_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, persistence_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, website_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, device_details_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, guard_data_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, language_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Request, qos_level_),
  0,
  1,
  2,
  6,
  7,
  8,
  10,
  3,
  5,
  4,
  9,
  11,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, request_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, interval_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, allowed_confirmations_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, weak_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, agreement_session_url_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_BeginAuthSessionViaCredentials_Response, extended_error_message_),
  4,
  0,
  6,
  ~0u,
  5,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Request, client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Request, request_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Request, token_to_revoke_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, new_client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, new_challenge_url_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, refresh_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, access_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, had_remote_interaction_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, account_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, new_guard_data_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_PollAuthSessionStatus_Response, agreement_session_url_),
  6,
  0,
  1,
  2,
  7,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Request, client_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, ip_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, geoloc_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, city_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, state_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, country_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, device_friendly_name_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, version_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, login_history_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, requestor_location_mismatch_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, high_usage_login_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionInfo_Response, requested_persistence_),
  0,
  1,
  2,
  3,
  4,
  6,
  5,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, version_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, signature_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, confirm_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, persistence_),
  3,
  1,
  2,
  0,
  4,
  5,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, client_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, code_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, code_type_),
  1,
  2,
  0,
  3,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response, agreement_session_url_),
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Request, refresh_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Request, renewal_type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Response, access_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_AccessToken_GenerateForApp_Response, refresh_token_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, time_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, ip_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, locale_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, country_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, state_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, city_),
  5,
  4,
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, token_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, token_description_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, time_updated_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, logged_in_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, os_platform_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, auth_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, gaming_device_type_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, first_seen_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, last_seen_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, os_type_),
  3,
  0,
  4,
  5,
  6,
  7,
  8,
  9,
  1,
  2,
  10,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response, refresh_tokens_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Enumerate_Response, requesting_token_),
  ~0u,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionsForAccount_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionsForAccount_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_GetAuthSessionsForAccount_Response, client_ids_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Request, token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Request, signature_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Response, refresh_token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_MigrateMobileSession_Response, access_token_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CAuthentication_Token_Revoke_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_Token_Revoke_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_Token_Revoke_Request, token_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_Token_Revoke_Request, revoke_action_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_Token_Revoke_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, token_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, revoke_action_),
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Request, signature_),
  1,
  2,
  3,
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthentication_RefreshToken_Revoke_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Request, steamid_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Request, include_revoked_tokens_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, time_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, ip_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, country_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, state_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription_TokenUsageEvent, city_),
  4,
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, token_id_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, token_description_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, time_updated_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, platform_type_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, token_state_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, owner_steamid_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, os_platform_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, os_type_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, auth_type_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, gaming_device_type_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, first_seen_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenDescription, last_seen_),
  3,
  0,
  4,
  5,
  7,
  6,
  8,
  9,
  10,
  11,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Response, refresh_tokens_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokensByAccount_Response, last_token_reset_),
  ~0u,
  0,
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokenByID_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokenByID_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokenByID_Request, token_id_),
  0,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokenByID_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_QueryRefreshTokenByID_Response, refresh_tokens_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_RevokeToken_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_RevokeToken_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_RevokeToken_Request, token_id_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_RevokeToken_Request, steamid_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_RevokeToken_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_GetTokenHistory_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_GetTokenHistory_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_GetTokenHistory_Request, token_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, action_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, time_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, ip_),
  PROTOBUF_FIELD_OFFSET(::CSupportRefreshTokenAudit, actor_),
  1,
  2,
  0,
  3,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_GetTokenHistory_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CAuthenticationSupport_GetTokenHistory_Response, history_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Request, platform_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Request, appid_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Response, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Response, nonce_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_CreateNonce_Response, expiry_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Request, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Request, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Request, platform_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Request, appid_list_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_TimeRemaining, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_TimeRemaining, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_TimeRemaining, appid_),
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_TimeRemaining, minutes_remaining_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Response, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCloudGaming_GetTimeRemaining_Response, entries_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, -1, sizeof(::CAuthentication_GetPasswordRSAPublicKey_Request)},
  { 8, 17, -1, sizeof(::CAuthentication_GetPasswordRSAPublicKey_Response)},
  { 20, 32, -1, sizeof(::CAuthentication_DeviceDetails)},
  { 38, 48, -1, sizeof(::CAuthentication_BeginAuthSessionViaQR_Request)},
  { 52, 60, -1, sizeof(::CAuthentication_AllowedConfirmation)},
  { 62, 74, -1, sizeof(::CAuthentication_BeginAuthSessionViaQR_Response)},
  { 80, 98, -1, sizeof(::CAuthentication_BeginAuthSessionViaCredentials_Request)},
  { 110, 124, -1, sizeof(::CAuthentication_BeginAuthSessionViaCredentials_Response)},
  { 132, 141, -1, sizeof(::CAuthentication_PollAuthSessionStatus_Request)},
  { 144, 158, -1, sizeof(::CAuthentication_PollAuthSessionStatus_Response)},
  { 166, 173, -1, sizeof(::CAuthentication_GetAuthSessionInfo_Request)},
  { 174, 192, -1, sizeof(::CAuthentication_GetAuthSessionInfo_Response)},
  { 204, 216, -1, sizeof(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)},
  { 222, -1, -1, sizeof(::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response)},
  { 228, 238, -1, sizeof(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)},
  { 242, 249, -1, sizeof(::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)},
  { 250, 259, -1, sizeof(::CAuthentication_AccessToken_GenerateForApp_Request)},
  { 262, 270, -1, sizeof(::CAuthentication_AccessToken_GenerateForApp_Response)},
  { 272, -1, -1, sizeof(::CAuthentication_RefreshToken_Enumerate_Request)},
  { 278, 290, -1, sizeof(::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent)},
  { 296, 313, -1, sizeof(::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription)},
  { 324, 332, -1, sizeof(::CAuthentication_RefreshToken_Enumerate_Response)},
  { 334, -1, -1, sizeof(::CAuthentication_GetAuthSessionsForAccount_Request)},
  { 340, -1, -1, sizeof(::CAuthentication_GetAuthSessionsForAccount_Response)},
  { 347, 356, -1, sizeof(::CAuthentication_MigrateMobileSession_Request)},
  { 359, 367, -1, sizeof(::CAuthentication_MigrateMobileSession_Response)},
  { 369, 377, -1, sizeof(::CAuthentication_Token_Revoke_Request)},
  { 379, -1, -1, sizeof(::CAuthentication_Token_Revoke_Response)},
  { 385, 395, -1, sizeof(::CAuthentication_RefreshToken_Revoke_Request)},
  { 399, -1, -1, sizeof(::CAuthentication_RefreshToken_Revoke_Response)},
  { 405, 413, -1, sizeof(::CAuthenticationSupport_QueryRefreshTokensByAccount_Request)},
  { 415, 426, -1, sizeof(::CSupportRefreshTokenDescription_TokenUsageEvent)},
  { 431, 449, -1, sizeof(::CSupportRefreshTokenDescription)},
  { 461, 469, -1, sizeof(::CAuthenticationSupport_QueryRefreshTokensByAccount_Response)},
  { 471, 478, -1, sizeof(::CAuthenticationSupport_QueryRefreshTokenByID_Request)},
  { 479, -1, -1, sizeof(::CAuthenticationSupport_QueryRefreshTokenByID_Response)},
  { 486, 494, -1, sizeof(::CAuthenticationSupport_RevokeToken_Request)},
  { 496, -1, -1, sizeof(::CAuthenticationSupport_RevokeToken_Response)},
  { 502, 509, -1, sizeof(::CAuthenticationSupport_GetTokenHistory_Request)},
  { 510, 520, -1, sizeof(::CSupportRefreshTokenAudit)},
  { 524, -1, -1, sizeof(::CAuthenticationSupport_GetTokenHistory_Response)},
  { 531, 539, -1, sizeof(::CCloudGaming_CreateNonce_Request)},
  { 541, 549, -1, sizeof(::CCloudGaming_CreateNonce_Response)},
  { 551, 559, -1, sizeof(::CCloudGaming_GetTimeRemaining_Request)},
  { 561, 569, -1, sizeof(::CCloudGaming_TimeRemaining)},
  { 571, -1, -1, sizeof(::CCloudGaming_GetTimeRemaining_Response)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetPasswordRSAPublicKey_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetPasswordRSAPublicKey_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_DeviceDetails_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_BeginAuthSessionViaQR_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_AllowedConfirmation_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_BeginAuthSessionViaQR_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_BeginAuthSessionViaCredentials_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_BeginAuthSessionViaCredentials_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_PollAuthSessionStatus_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_PollAuthSessionStatus_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetAuthSessionInfo_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetAuthSessionInfo_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_AccessToken_GenerateForApp_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_AccessToken_GenerateForApp_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Enumerate_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Enumerate_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetAuthSessionsForAccount_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_GetAuthSessionsForAccount_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_MigrateMobileSession_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_MigrateMobileSession_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_Token_Revoke_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_Token_Revoke_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Revoke_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthentication_RefreshToken_Revoke_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_QueryRefreshTokensByAccount_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSupportRefreshTokenDescription_TokenUsageEvent_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSupportRefreshTokenDescription_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_QueryRefreshTokensByAccount_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_QueryRefreshTokenByID_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_QueryRefreshTokenByID_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_RevokeToken_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_RevokeToken_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_GetTokenHistory_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CSupportRefreshTokenAudit_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CAuthenticationSupport_GetTokenHistory_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloudGaming_CreateNonce_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloudGaming_CreateNonce_Response_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloudGaming_GetTimeRemaining_Request_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloudGaming_TimeRemaining_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_CCloudGaming_GetTimeRemaining_Response_default_instance_),
};

const char descriptor_table_protodef_steammessages_5fauth_2esteamclient_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n$steammessages_auth.steamclient.proto\032\030"
  "steammessages_base.proto\032,steammessages_"
  "unified_base.steamclient.proto\032\013enums.pr"
  "oto\"}\n/CAuthentication_GetPasswordRSAPub"
  "licKey_Request\022J\n\014account_name\030\001 \001(\tB4\202\265"
  "\0300user-provided account name to get an R"
  "SA key for\"\325\001\n0CAuthentication_GetPasswo"
  "rdRSAPublicKey_Response\0221\n\rpublickey_mod"
  "\030\001 \001(\tB\032\202\265\030\026the public key modulus\0222\n\rpu"
  "blickey_exp\030\002 \001(\tB\033\202\265\030\027the public key ex"
  "ponent\022:\n\ttimestamp\030\003 \001(\004B\'\202\265\030#the times"
  "tamp the key was generated\"\265\004\n\035CAuthenti"
  "cation_DeviceDetails\022\\\n\024device_friendly_"
  "name\030\001 \001(\tB>\202\265\030:User-supplied, or client"
  "-supplied, friendly name of device\022\200\001\n\rp"
  "latform_type\030\002 \001(\0162\027.EAuthTokenPlatformT"
  "ype: k_EAuthTokenPlatformType_UnknownB.\202"
  "\265\030*EAuthTokenPlatformType, claimed, of d"
  "evice\022;\n\007os_type\030\003 \001(\005B*\202\265\030&EOSType, cla"
  "imed, of authorized device\022n\n\022gaming_dev"
  "ice_type\030\004 \001(\rBR\202\265\030NEGamingDeviceType, c"
  "laimed, of authorized device for steam c"
  "lient-type devices\022S\n\014client_count\030\005 \001(\r"
  "B=\202\265\0309For desktop clients, quantized num"
  "ber of users in history\0221\n\nmachine_id\030\006 "
  "\001(\014B\035\202\265\030\031Additional device context\"\370\002\n-C"
  "Authentication_BeginAuthSessionViaQR_Req"
  "uest\022\034\n\024device_friendly_name\030\001 \001(\t\022P\n\rpl"
  "atform_type\030\002 \001(\0162\027.EAuthTokenPlatformTy"
  "pe: k_EAuthTokenPlatformType_Unknown\022x\n\016"
  "device_details\030\003 \001(\0132\036.CAuthentication_D"
  "eviceDetailsB@\202\265\030<User-supplied details "
  "about the device attempting to sign in\022]"
  "\n\nwebsite_id\030\004 \001(\t:\007UnknownB@\202\265\030<(EMachi"
  "neAuthWebDomain) identifier of client re"
  "questing auth\"\362\002\n#CAuthentication_Allowe"
  "dConfirmation\022\216\001\n\021confirmation_type\030\001 \001("
  "\0162\026.EAuthSessionGuardType:\037k_EAuthSessio"
  "nGuardType_UnknownB:\202\265\0306authentication c"
  "an proceed with this confirmation type\022\271"
  "\001\n\022associated_message\030\002 \001(\tB\234\001\202\265\030\227\001messa"
  "ge to be interpreted depending on the co"
  "nfirmation type. for email confirmation,"
  " this might be the redacted email addres"
  "s to which email was sent.\"\361\004\n.CAuthenti"
  "cation_BeginAuthSessionViaQR_Response\022`\n"
  "\tclient_id\030\001 \001(\004BM\202\265\030Iunique identifier "
  "of requestor, also used for routing, por"
  "tion of QR code\022T\n\rchallenge_url\030\002 \001(\tB="
  "\202\265\0309URL based on client ID, which will b"
  "e rendered as QR code\022p\n\nrequest_id\030\003 \001("
  "\014B\\\202\265\030Xunique request ID to be presented"
  " by requestor at poll time - must not be"
  " rendered in QR\022]\n\010interval\030\004 \001(\002BK\202\265\030Gr"
  "efresh interval with which requestor sho"
  "uld call PollAuthSessionStatus\022\210\001\n\025allow"
  "ed_confirmations\030\005 \003(\0132$.CAuthentication"
  "_AllowedConfirmationBC\202\265\030\?the confirmati"
  "on types that will be able to confirm th"
  "e request\022+\n\007version\030\006 \001(\005B\032\202\265\030\026version "
  "of the QR data\"\202\007\n6CAuthentication_Begin"
  "AuthSessionViaCredentials_Request\022\034\n\024dev"
  "ice_friendly_name\030\001 \001(\t\022\024\n\014account_name\030"
  "\002 \001(\t\022C\n\022encrypted_password\030\003 \001(\tB\'\202\265\030#p"
  "assword, RSA encrypted client side\022C\n\024en"
  "cryption_timestamp\030\004 \001(\004B%\202\265\030!timestamp "
  "to map to a key - STime\022&\n\016remember_logi"
  "n\030\005 \001(\010B\016\202\265\030\ndeprecated\022P\n\rplatform_type"
  "\030\006 \001(\0162\027.EAuthTokenPlatformType: k_EAuth"
  "TokenPlatformType_Unknown\022\217\001\n\013persistenc"
  "e\030\007 \001(\0162\024.ESessionPersistence: k_ESessio"
  "nPersistence_PersistentBB\202\265\030>whether we "
  "are requesting a persistent or an epheme"
  "ral session\022]\n\nwebsite_id\030\010 \001(\t:\007Unknown"
  "B@\202\265\030<(EMachineAuthWebDomain) identifier"
  " of client requesting auth\022x\n\016device_det"
  "ails\030\t \001(\0132\036.CAuthentication_DeviceDetai"
  "lsB@\202\265\030<User-supplied details about the "
  "device attempting to sign in\0229\n\nguard_da"
  "ta\030\n \001(\tB%\202\265\030!steam guard data for clien"
  "t login\022\020\n\010language\030\013 \001(\r\022X\n\tqos_level\030\014"
  " \001(\005:\0012BB\202\265\030>[ENetQOSLevel] client-speci"
  "fied priority for this auth attempt\"\372\006\n7"
  "CAuthentication_BeginAuthSessionViaCrede"
  "ntials_Response\022L\n\tclient_id\030\001 \001(\004B9\202\265\0305"
  "unique identifier of requestor, also use"
  "d for routing\022z\n\nrequest_id\030\002 \001(\014Bf\202\265\030bu"
  "nique request ID to be presented by requ"
  "estor at poll time - must not be transfe"
  "rred or displayed\022]\n\010interval\030\003 \001(\002BK\202\265\030"
  "Grefresh interval with which requestor s"
  "hould call PollAuthSessionStatus\022\210\001\n\025all"
  "owed_confirmations\030\004 \003(\0132$.CAuthenticati"
  "on_AllowedConfirmationBC\202\265\030\?the confirma"
  "tion types that will be able to confirm "
  "the request\022n\n\007steamid\030\005 \001(\004B]\202\265\030Ysteami"
  "d of the account logging in - will only "
  "be included if the credentials were corr"
  "ect\022z\n\nweak_token\030\006 \001(\tBf\202\265\030bpartial-aut"
  "hentication token - limited lifetime and"
  " scope, included only if credentials wer"
  "e valid\022G\n\025agreement_session_url\030\007 \001(\tB("
  "\202\265\030$agreement the user needs to agree to"
  "\022V\n\026extended_error_message\030\010 \001(\tB6\202\265\0302er"
  "ror string to display if supported by th"
  "e client\"\275\001\n-CAuthentication_PollAuthSes"
  "sionStatus_Request\022\021\n\tclient_id\030\001 \001(\004\022\022\n"
  "\nrequest_id\030\002 \001(\014\022e\n\017token_to_revoke\030\003 \001"
  "(\006BL\202\265\030HIf this is set to a token owned "
  "by this user, that token will be retired"
  "\"\323\006\n.CAuthentication_PollAuthSessionStat"
  "us_Response\022I\n\rnew_client_id\030\001 \001(\004B2\202\265\030."
  "if challenge is old, this is the new cli"
  "ent id\022u\n\021new_challenge_url\030\002 \001(\tBZ\202\265\030Vi"
  "f challenge is old, this is the new chal"
  "lenge ID to re-render for mobile confirm"
  "ation\022a\n\rrefresh_token\030\003 \001(\tBJ\202\265\030Fif log"
  "in has been confirmed, this is the reque"
  "stor\'s new refresh token\022g\n\014access_token"
  "\030\004 \001(\tBQ\202\265\030Mif login has been confirmed,"
  " this is a new token subordinate to refr"
  "esh_token\022\205\001\n\026had_remote_interaction\030\005 \001"
  "(\010Be\202\265\030awhether or not the auth session "
  "appears to have had remote interaction f"
  "rom a potential confirmer\022U\n\014account_nam"
  "e\030\006 \001(\tB\?\202\265\030;account name of authenticat"
  "ing account, for use by UI layer\022k\n\016new_"
  "guard_data\030\007 \001(\tBS\202\265\030Oif login has been "
  "confirmed, may contain remembered machin"
  "e ID for future login\022G\n\025agreement_sessi"
  "on_url\030\010 \001(\tB(\202\265\030$agreement the user nee"
  "ds to agree to\"u\n*CAuthentication_GetAut"
  "hSessionInfo_Request\022G\n\tclient_id\030\001 \001(\004B"
  "4\202\265\0300client ID from scanned QR Code, use"
  "d for routing\"\273\007\n+CAuthentication_GetAut"
  "hSessionInfo_Response\022\'\n\002ip\030\001 \001(\tB\033\202\265\030\027I"
  "P address of requestor\022,\n\006geoloc\030\002 \001(\tB\034"
  "\202\265\030\030geoloc info of requestor\022#\n\004city\030\003 \001"
  "(\tB\025\202\265\030\021city of requestor\022%\n\005state\030\004 \001(\t"
  "B\026\202\265\030\022state of requestor\022)\n\007country\030\005 \001("
  "\tB\030\202\265\030\024country of requestor\022p\n\rplatform_"
  "type\030\006 \001(\0162\027.EAuthTokenPlatformType: k_E"
  "AuthTokenPlatformType_UnknownB\036\202\265\030\032platf"
  "orm type of requestor\022:\n\024device_friendly"
  "_name\030\007 \001(\tB\034\202\265\030\030name of requestor devic"
  "e\022\"\n\007version\030\010 \001(\005B\021\202\265\030\rversion field\022\244\001"
  "\n\rlogin_history\030\t \001(\0162\034.EAuthSessionSecu"
  "rityHistory:%k_EAuthSessionSecurityHisto"
  "ry_InvalidBH\202\265\030Dwhether the ip has previ"
  "uously been used on the account successf"
  "ully\022f\n\033requestor_location_mismatch\030\n \001("
  "\010BA\202\265\030=whether the requestor location ma"
  "tches this requests location\022M\n\020high_usa"
  "ge_login\030\013 \001(\010B3\202\265\030/whether this login h"
  "as seen high usage recently\022\215\001\n\025requeste"
  "d_persistence\030\014 \001(\0162\024.ESessionPersistenc"
  "e:\035k_ESessionPersistence_InvalidB9\202\265\0305se"
  "ssion persistence requestor has indicate"
  "d they want\"\234\004\n\?CAuthentication_UpdateAu"
  "thSessionWithMobileConfirmation_Request\022"
  "\"\n\007version\030\001 \001(\005B\021\202\265\030\rversion field\022>\n\tc"
  "lient_id\030\002 \001(\004B+\202\265\030\'pending client ID, f"
  "rom scanned QR Code\022,\n\007steamid\030\003 \001(\006B\033\202\265"
  "\030\027user who wants to login\022Z\n\tsignature\030\004"
  " \001(\014BG\202\265\030CHMAC digest over {version,clie"
  "nt_id,steamid} via user\'s private key\022Y\n"
  "\007confirm\030\005 \001(\010:\005falseBA\202\265\030=Whether to co"
  "nfirm the login (true) or deny the login"
  " (false)\022\217\001\n\013persistence\030\006 \001(\0162\024.ESessio"
  "nPersistence: k_ESessionPersistence_Pers"
  "istentBB\202\265\030>whether we are requesting a "
  "persistent or an ephemeral session\"B\n@CA"
  "uthentication_UpdateAuthSessionWithMobil"
  "eConfirmation_Response\"\277\002\n;CAuthenticati"
  "on_UpdateAuthSessionWithSteamGuardCode_R"
  "equest\022B\n\tclient_id\030\001 \001(\004B/\202\265\030+pending c"
  "lient ID, from initialized session\022,\n\007st"
  "eamid\030\002 \001(\006B\033\202\265\030\027user who wants to login"
  "\022#\n\004code\030\003 \001(\tB\025\202\265\030\021confirmation code\022i\n"
  "\tcode_type\030\004 \001(\0162\026.EAuthSessionGuardType"
  ":\037k_EAuthSessionGuardType_UnknownB\035\202\265\030\031t"
  "ype of confirmation code\"\207\001\n<CAuthentica"
  "tion_UpdateAuthSessionWithSteamGuardCode"
  "_Response\022G\n\025agreement_session_url\030\007 \001(\t"
  "B(\202\265\030$agreement the user needs to agree "
  "to\"\240\001\n2CAuthentication_AccessToken_Gener"
  "ateForApp_Request\022\025\n\rrefresh_token\030\001 \001(\t"
  "\022\017\n\007steamid\030\002 \001(\006\022B\n\014renewal_type\030\003 \001(\0162"
  "\022.ETokenRenewalType:\030k_ETokenRenewalType"
  "_None\"b\n3CAuthentication_AccessToken_Gen"
  "erateForApp_Response\022\024\n\014access_token\030\001 \001"
  "(\t\022\025\n\rrefresh_token\030\002 \001(\t\"0\n.CAuthentica"
  "tion_RefreshToken_Enumerate_Request\"\253\r\n/"
  "CAuthentication_RefreshToken_Enumerate_R"
  "esponse\022`\n\016refresh_tokens\030\001 \003(\0132H.CAuthe"
  "ntication_RefreshToken_Enumerate_Respons"
  "e.RefreshTokenDescription\022\030\n\020requesting_"
  "token\030\002 \001(\006\032\223\003\n\017TokenUsageEvent\022[\n\004time\030"
  "\001 \001(\rBM\202\265\030IApproximate time of history e"
  "vent (may be deliberately fuzzed or omit"
  "ted)\022>\n\002ip\030\002 \001(\0132\016.CMsgIPAddressB\"\202\265\030\036IP"
  " at which event was observed\022\016\n\006locale\030\003"
  " \001(\t\022J\n\007country\030\004 \001(\tB9\202\265\0305Location (cou"
  "ntry code) of event, as inferred from IP"
  "\022F\n\005state\030\005 \001(\tB7\202\265\0303Location (state cod"
  "e) of event, as inferred from IP\022\?\n\004city"
  "\030\006 \001(\tB1\202\265\030-Location (city) of event, as"
  " inferred from IP\032\345\010\n\027RefreshTokenDescri"
  "ption\0228\n\010token_id\030\001 \001(\006B&\202\265\030\"Persistent "
  "token/device identifier\022K\n\021token_descrip"
  "tion\030\002 \001(\tB0\202\265\030,client-supplied friendly"
  " name for the device\022\024\n\014time_updated\030\003 \001"
  "(\r\022\201\001\n\rplatform_type\030\004 \001(\0162\027.EAuthTokenP"
  "latformType: k_EAuthTokenPlatformType_Un"
  "knownB/\202\265\030+gross platform type (mobile/c"
  "lient/browser)\022\224\001\n\tlogged_in\030\005 \001(\010B\200\001\202\265\030"
  "|If true, this token is currently valid."
  " False indicates it is a machine token -"
  " ok for steamguard if you know the crede"
  "ntial\022T\n\013os_platform\030\006 \001(\rB\?\202\265\030;EPlatfor"
  "mType - rough classification of device O"
  "S, if known\022U\n\tauth_type\030\007 \001(\rBB\202\265\030>EAut"
  "hTokenGuardType - device authorization m"
  "echanism, if known\022\202\001\n\022gaming_device_typ"
  "e\030\010 \001(\rBf\202\265\030bEGamingDeviceType - classif"
  "y console/PC/SteamDeck, if known; applie"
  "s only for Steam Client devices\022\210\001\n\nfirs"
  "t_seen\030\t \001(\0132@.CAuthentication_RefreshTo"
  "ken_Enumerate_Response.TokenUsageEventB2"
  "\202\265\030.Information about original authoriza"
  "tion event\022\227\001\n\tlast_seen\030\n \001(\0132@.CAuthen"
  "tication_RefreshToken_Enumerate_Response"
  ".TokenUsageEventBB\202\265\030>Information about "
  "most-recently seen, if known for this de"
  "vice\022;\n\007os_type\030\013 \001(\005B*\202\265\030&EOSType - spe"
  "cific device OS, if known\"3\n1CAuthentica"
  "tion_GetAuthSessionsForAccount_Request\"\203"
  "\001\n2CAuthentication_GetAuthSessionsForAcc"
  "ount_Response\022M\n\nclient_ids\030\001 \003(\004B9\202\265\0305u"
  "nique identifier of requestor, also used"
  " for routing\"\333\001\n,CAuthentication_Migrate"
  "MobileSession_Request\0224\n\007steamid\030\001 \001(\006B#"
  "\202\265\030\037Steam ID of the user to migrate\022&\n\005t"
  "oken\030\002 \001(\tB\027\202\265\030\023WG Token to migrate\022M\n\ts"
  "ignature\030\003 \001(\tB:\202\265\0306Signature over the w"
  "g token using the user\'s 2FA token\"\\\n-CA"
  "uthentication_MigrateMobileSession_Respo"
  "nse\022\025\n\rrefresh_token\030\001 \001(\t\022\024\n\014access_tok"
  "en\030\002 \001(\t\"\274\001\n$CAuthentication_Token_Revok"
  "e_Request\022\r\n\005token\030\001 \001(\t\022\204\001\n\rrevoke_acti"
  "on\030\002 \001(\0162\027.EAuthTokenRevokeAction:\033k_EAu"
  "thTokenRevokePermanentB7\202\265\0303Select betwe"
  "en logout and logout-and-forget-machine\""
  "\'\n%CAuthentication_Token_Revoke_Response"
  "\"\317\002\n+CAuthentication_RefreshToken_Revoke"
  "_Request\022\020\n\010token_id\030\001 \001(\006\022N\n\007steamid\030\002 "
  "\001(\006B=\202\265\0309Token holder if an admin action"
  " on behalf of another user\022\204\001\n\rrevoke_ac"
  "tion\030\003 \001(\0162\027.EAuthTokenRevokeAction:\033k_E"
  "AuthTokenRevokePermanentB7\202\265\0303Select bet"
  "ween logout and logout-and-forget-machin"
  "e\0227\n\tsignature\030\004 \001(\014B$\202\265\030 required signa"
  "ture over token_id\".\n,CAuthentication_Re"
  "freshToken_Revoke_Response\"\333\001\n:CAuthenti"
  "cationSupport_QueryRefreshTokensByAccoun"
  "t_Request\022\?\n\007steamid\030\001 \001(\006B.\202\265\030*SteamID "
  "of the account to query (required)\022\\\n\026in"
  "clude_revoked_tokens\030\002 \001(\010B<\202\265\0308Includes"
  " tokens that are revoked or expired in t"
  "he query\"\210\n\n\037CSupportRefreshTokenDescrip"
  "tion\022\020\n\010token_id\030\001 \001(\006\022\031\n\021token_descript"
  "ion\030\002 \001(\t\022\024\n\014time_updated\030\003 \001(\r\022P\n\rplatf"
  "orm_type\030\004 \001(\0162\027.EAuthTokenPlatformType:"
  " k_EAuthTokenPlatformType_Unknown\022@\n\013tok"
  "en_state\030\005 \001(\0162\020.EAuthTokenState:\031k_EAut"
  "hTokenState_Invalid\022\025\n\rowner_steamid\030\006 \001"
  "(\006\022T\n\013os_platform\030\007 \001(\rB\?\202\265\030;EPlatformTy"
  "pe - rough classification of device OS, "
  "if known\022;\n\007os_type\030\010 \001(\005B*\202\265\030&EOSType -"
  " specific device OS, if known\022U\n\tauth_ty"
  "pe\030\t \001(\rBB\202\265\030>EAuthTokenGuardType - devi"
  "ce authorization mechanism, if known\022\202\001\n"
  "\022gaming_device_type\030\n \001(\rBf\202\265\030bEGamingDe"
  "viceType - classify console/PC/SteamDeck"
  ", if known; applies only for Steam Clien"
  "t devices\022x\n\nfirst_seen\030\013 \001(\01320.CSupport"
  "RefreshTokenDescription.TokenUsageEventB"
  "2\202\265\030.Information about original authoriz"
  "ation event\022\207\001\n\tlast_seen\030\014 \001(\01320.CSuppo"
  "rtRefreshTokenDescription.TokenUsageEven"
  "tBB\202\265\030>Information about most-recently s"
  "een, if known for this device\032\203\003\n\017TokenU"
  "sageEvent\022[\n\004time\030\001 \001(\rBM\202\265\030IApproximate"
  " time of history event (may be deliberat"
  "ely fuzzed or omitted)\022>\n\002ip\030\002 \001(\0132\016.CMs"
  "gIPAddressB\"\202\265\030\036IP at which event was ob"
  "served\022J\n\007country\030\003 \001(\tB9\202\265\0305Location (c"
  "ountry code) of event, as inferred from "
  "IP\022F\n\005state\030\004 \001(\tB7\202\265\0303Location (state c"
  "ode) of event, as inferred from IP\022\?\n\004ci"
  "ty\030\005 \001(\tB1\202\265\030-Location (city) of event, "
  "as inferred from IP\"\221\001\n;CAuthenticationS"
  "upport_QueryRefreshTokensByAccount_Respo"
  "nse\0228\n\016refresh_tokens\030\001 \003(\0132 .CSupportRe"
  "freshTokenDescription\022\030\n\020last_token_rese"
  "t\030\002 \001(\005\"y\n4CAuthenticationSupport_QueryR"
  "efreshTokenByID_Request\022A\n\010token_id\030\001 \001("
  "\006B/\202\265\030+Token ID of the token to look up "
  "(required)\"q\n5CAuthenticationSupport_Que"
  "ryRefreshTokenByID_Response\0228\n\016refresh_t"
  "okens\030\001 \003(\0132 .CSupportRefreshTokenDescri"
  "ption\"\263\001\n*CAuthenticationSupport_RevokeT"
  "oken_Request\022@\n\010token_id\030\001 \001(\006B.\202\265\030*Toke"
  "n ID of the token to revoke (required)\022C"
  "\n\007steamid\030\002 \001(\006B2\202\265\030.Steam ID of the own"
  "er of that token (required)\"-\n+CAuthenti"
  "cationSupport_RevokeToken_Response\"{\n.CA"
  "uthenticationSupport_GetTokenHistory_Req"
  "uest\022I\n\010token_id\030\001 \001(\006B7\202\265\0303Token ID of "
  "the token to get history for (required)\""
  "d\n\031CSupportRefreshTokenAudit\022\016\n\006action\030\001"
  " \001(\005\022\014\n\004time\030\002 \001(\r\022\032\n\002ip\030\003 \001(\0132\016.CMsgIPA"
  "ddress\022\r\n\005actor\030\004 \001(\006\"^\n/CAuthentication"
  "Support_GetTokenHistory_Response\022+\n\007hist"
  "ory\030\001 \003(\0132\032.CSupportRefreshTokenAudit\"C\n"
  " CCloudGaming_CreateNonce_Request\022\020\n\010pla"
  "tform\030\001 \001(\t\022\r\n\005appid\030\002 \001(\r\"B\n!CCloudGami"
  "ng_CreateNonce_Response\022\r\n\005nonce\030\001 \001(\t\022\016"
  "\n\006expiry\030\002 \001(\r\"M\n%CCloudGaming_GetTimeRe"
  "maining_Request\022\020\n\010platform\030\001 \001(\t\022\022\n\napp"
  "id_list\030\002 \003(\r\"F\n\032CCloudGaming_TimeRemain"
  "ing\022\r\n\005appid\030\001 \001(\r\022\031\n\021minutes_remaining\030"
  "\002 \001(\r\"V\n&CCloudGaming_GetTimeRemaining_R"
  "esponse\022,\n\007entries\030\002 \003(\0132\033.CCloudGaming_"
  "TimeRemaining*\271\001\n\026EAuthTokenPlatformType"
  "\022$\n k_EAuthTokenPlatformType_Unknown\020\000\022("
  "\n$k_EAuthTokenPlatformType_SteamClient\020\001"
  "\022\'\n#k_EAuthTokenPlatformType_WebBrowser\020"
  "\002\022&\n\"k_EAuthTokenPlatformType_MobileApp\020"
  "\003*\345\002\n\025EAuthSessionGuardType\022#\n\037k_EAuthSe"
  "ssionGuardType_Unknown\020\000\022 \n\034k_EAuthSessi"
  "onGuardType_None\020\001\022%\n!k_EAuthSessionGuar"
  "dType_EmailCode\020\002\022&\n\"k_EAuthSessionGuard"
  "Type_DeviceCode\020\003\022.\n*k_EAuthSessionGuard"
  "Type_DeviceConfirmation\020\004\022-\n)k_EAuthSess"
  "ionGuardType_EmailConfirmation\020\005\022(\n$k_EA"
  "uthSessionGuardType_MachineToken\020\006\022-\n)k_"
  "EAuthSessionGuardType_LegacyMachineAuth\020"
  "\007*\254\001\n\033EAuthSessionSecurityHistory\022)\n%k_E"
  "AuthSessionSecurityHistory_Invalid\020\000\0220\n,"
  "k_EAuthSessionSecurityHistory_UsedPrevio"
  "usly\020\001\0220\n,k_EAuthSessionSecurityHistory_"
  "NoPriorHistory\020\002*P\n\021ETokenRenewalType\022\034\n"
  "\030k_ETokenRenewalType_None\020\000\022\035\n\031k_ETokenR"
  "enewalType_Allow\020\001*\257\002\n\026EAuthTokenRevokeA"
  "ction\022\034\n\030k_EAuthTokenRevokeLogout\020\000\022\037\n\033k"
  "_EAuthTokenRevokePermanent\020\001\022\036\n\032k_EAuthT"
  "okenRevokeReplaced\020\002\022\035\n\031k_EAuthTokenRevo"
  "keSupport\020\003\022\035\n\031k_EAuthTokenRevokeConsume"
  "\020\004\022)\n%k_EAuthTokenRevokeNonRememberedLog"
  "out\020\005\022,\n(k_EAuthTokenRevokeNonRemembered"
  "Permanent\020\006\022\037\n\033k_EAuthTokenRevokeAutomat"
  "ic\020\007*\210\002\n\017EAuthTokenState\022\035\n\031k_EAuthToken"
  "State_Invalid\020\000\022\031\n\025k_EAuthTokenState_New"
  "\020\001\022\037\n\033k_EAuthTokenState_Confirmed\020\002\022\034\n\030k"
  "_EAuthTokenState_Issued\020\003\022\034\n\030k_EAuthToke"
  "nState_Denied\020\004\022\037\n\033k_EAuthTokenState_Log"
  "gedOut\020\005\022\036\n\032k_EAuthTokenState_Consumed\020\006"
  "\022\035\n\031k_EAuthTokenState_Revoked\020c2\352\024\n\016Auth"
  "entication\022\317\001\n\027GetPasswordRSAPublicKey\0220"
  ".CAuthentication_GetPasswordRSAPublicKey"
  "_Request\0321.CAuthentication_GetPasswordRS"
  "APublicKey_Response\"O\202\265\030KFetches RSA pub"
  "lic key to use to encrypt passwords for "
  "a given account name\022\232\001\n\025BeginAuthSessio"
  "nViaQR\022..CAuthentication_BeginAuthSessio"
  "nViaQR_Request\032/.CAuthentication_BeginAu"
  "thSessionViaQR_Response\" \202\265\030\034start authe"
  "ntication process\022\265\001\n\036BeginAuthSessionVi"
  "aCredentials\0227.CAuthentication_BeginAuth"
  "SessionViaCredentials_Request\0328.CAuthent"
  "ication_BeginAuthSessionViaCredentials_R"
  "esponse\" \202\265\030\034start authentication proces"
  "s\022\240\001\n\025PollAuthSessionStatus\022..CAuthentic"
  "ation_PollAuthSessionStatus_Request\032/.CA"
  "uthentication_PollAuthSessionStatus_Resp"
  "onse\"&\202\265\030\"poll during authentication pro"
  "cess\022\316\001\n\022GetAuthSessionInfo\022+.CAuthentic"
  "ation_GetAuthSessionInfo_Request\032,.CAuth"
  "entication_GetAuthSessionInfo_Response\"]"
  "\202\265\030Yget metadata of specific auth sessio"
  "n, this will also implicitly bind the ca"
  "lling account\022\344\001\n\'UpdateAuthSessionWithM"
  "obileConfirmation\022@.CAuthentication_Upda"
  "teAuthSessionWithMobileConfirmation_Requ"
  "est\032A.CAuthentication_UpdateAuthSessionW"
  "ithMobileConfirmation_Response\"4\202\265\0300appr"
  "ove an authentication session via mobile"
  " 2fa\022\336\001\n#UpdateAuthSessionWithSteamGuard"
  "Code\022<.CAuthentication_UpdateAuthSession"
  "WithSteamGuardCode_Request\032=.CAuthentica"
  "tion_UpdateAuthSessionWithSteamGuardCode"
  "_Response\":\202\265\0306approve an authentication"
  " session via steam guard code\022\373\001\n\031Genera"
  "teAccessTokenForApp\0223.CAuthentication_Ac"
  "cessToken_GenerateForApp_Request\0324.CAuth"
  "entication_AccessToken_GenerateForApp_Re"
  "sponse\"s\202\265\030oGiven a refresh token for a "
  "client app audience (e.g. desktop client"
  " / mobile client), generate an access to"
  "ken\022\272\001\n\017EnumerateTokens\022/.CAuthenticatio"
  "n_RefreshToken_Enumerate_Request\0320.CAuth"
  "entication_RefreshToken_Enumerate_Respon"
  "se\"D\202\265\030@Enumerate durable (refresh) toke"
  "ns for the given subject account\022\326\001\n\031Get"
  "AuthSessionsForAccount\0222.CAuthentication"
  "_GetAuthSessionsForAccount_Request\0323.CAu"
  "thentication_GetAuthSessionsForAccount_R"
  "esponse\"P\202\265\030LGets all active auth sessio"
  "ns for an account for reference by the m"
  "obile app\022\344\001\n\024MigrateMobileSession\022-.CAu"
  "thentication_MigrateMobileSession_Reques"
  "t\032..CAuthentication_MigrateMobileSession"
  "_Response\"m\202\265\030iMigrates a WG token to an"
  " access and refresh token using a signat"
  "ure generated with the user\'s 2FA secret"
  "\022\274\001\n\013RevokeToken\022%.CAuthentication_Token"
  "_Revoke_Request\032&.CAuthentication_Token_"
  "Revoke_Response\"^\202\265\030ZRevoke a single tok"
  "en immediately, making it unable to rene"
  "w or generate new access tokens\022\236\001\n\022Revo"
  "keRefreshToken\022,.CAuthentication_Refresh"
  "Token_Revoke_Request\032-.CAuthentication_R"
  "efreshToken_Revoke_Response\"+\202\265\030\'Mark th"
  "e given refresh token as revoked\032\032\202\265\030\026Au"
  "thentication Service2\260\006\n\025AuthenticationS"
  "upport\022\345\001\n\033QueryRefreshTokensByAccount\022;"
  ".CAuthenticationSupport_QueryRefreshToke"
  "nsByAccount_Request\032<.CAuthenticationSup"
  "port_QueryRefreshTokensByAccount_Respons"
  "e\"K\202\265\030GAsks the server for a list of ref"
  "resh tokens associated with an account\022\323"
  "\001\n\025QueryRefreshTokenByID\0225.CAuthenticati"
  "onSupport_QueryRefreshTokenByID_Request\032"
  "6.CAuthenticationSupport_QueryRefreshTok"
  "enByID_Response\"K\202\265\030GAsks the server for"
  " a list of refresh tokens associated wit"
  "h an account\022\211\001\n\013RevokeToken\022+.CAuthenti"
  "cationSupport_RevokeToken_Request\032,.CAut"
  "henticationSupport_RevokeToken_Response\""
  "\037\202\265\030\033Revokes a user\'s auth token\022\250\001\n\017Get"
  "TokenHistory\022/.CAuthenticationSupport_Ge"
  "tTokenHistory_Request\0320.CAuthenticationS"
  "upport_GetTokenHistory_Response\"2\202\265\030.Get"
  "s the audit history for a user\'s auth to"
  "ken\032\"\202\265\030\036Authentication Support Service2"
  "\362\002\n\013CloudGaming\022\213\001\n\013CreateNonce\022!.CCloud"
  "Gaming_CreateNonce_Request\032\".CCloudGamin"
  "g_CreateNonce_Response\"5\202\265\0301Create a non"
  "ce for a cloud gaming service session\022\245\001"
  "\n\020GetTimeRemaining\022&.CCloudGaming_GetTim"
  "eRemaining_Request\032\'.CCloudGaming_GetTim"
  "eRemaining_Response\"@\202\265\030<Get the amount "
  "of streaming time remaining for a set of"
  " apps\032-\202\265\030)Methods for Steam cloud gamin"
  "g operationsB\003\200\001\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_steammessages_5fauth_2esteamclient_2eproto_deps[3] = {
  &::descriptor_table_enums_2eproto,
  &::descriptor_table_steammessages_5fbase_2eproto,
  &::descriptor_table_steammessages_5funified_5fbase_2esteamclient_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_steammessages_5fauth_2esteamclient_2eproto = {
  false, false, 18617, descriptor_table_protodef_steammessages_5fauth_2esteamclient_2eproto, "steammessages_auth.steamclient.proto", 
  &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once, descriptor_table_steammessages_5fauth_2esteamclient_2eproto_deps, 3, 46,
  schemas, file_default_instances, TableStruct_steammessages_5fauth_2esteamclient_2eproto::offsets,
  file_level_metadata_steammessages_5fauth_2esteamclient_2eproto, file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto, file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable* descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter() {
  return &descriptor_table_steammessages_5fauth_2esteamclient_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY static ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptorsRunner dynamic_init_dummy_steammessages_5fauth_2esteamclient_2eproto(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenPlatformType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[0];
}
bool EAuthTokenPlatformType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthSessionGuardType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[1];
}
bool EAuthSessionGuardType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthSessionSecurityHistory_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[2];
}
bool EAuthSessionSecurityHistory_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETokenRenewalType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[3];
}
bool ETokenRenewalType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenRevokeAction_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[4];
}
bool EAuthTokenRevokeAction_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EAuthTokenState_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_enum_descriptors_steammessages_5fauth_2esteamclient_2eproto[5];
}
bool EAuthTokenState_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 99:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CAuthentication_GetPasswordRSAPublicKey_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_GetPasswordRSAPublicKey_Request>()._has_bits_);
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_GetPasswordRSAPublicKey_Request::CAuthentication_GetPasswordRSAPublicKey_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetPasswordRSAPublicKey_Request)
}
CAuthentication_GetPasswordRSAPublicKey_Request::CAuthentication_GetPasswordRSAPublicKey_Request(const CAuthentication_GetPasswordRSAPublicKey_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_account_name(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetPasswordRSAPublicKey_Request)
}

inline void CAuthentication_GetPasswordRSAPublicKey_Request::SharedCtor() {
account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CAuthentication_GetPasswordRSAPublicKey_Request::~CAuthentication_GetPasswordRSAPublicKey_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_GetPasswordRSAPublicKey_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_GetPasswordRSAPublicKey_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  account_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_GetPasswordRSAPublicKey_Request::ArenaDtor(void* object) {
  CAuthentication_GetPasswordRSAPublicKey_Request* _this = reinterpret_cast< CAuthentication_GetPasswordRSAPublicKey_Request* >(object);
  (void)_this;
}
void CAuthentication_GetPasswordRSAPublicKey_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_GetPasswordRSAPublicKey_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_GetPasswordRSAPublicKey_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_GetPasswordRSAPublicKey_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    account_name_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_GetPasswordRSAPublicKey_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string account_name = 1 [(.description) = "user-provided account name to get an RSA key for"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_account_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetPasswordRSAPublicKey_Request.account_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_GetPasswordRSAPublicKey_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_GetPasswordRSAPublicKey_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string account_name = 1 [(.description) = "user-provided account name to get an RSA key for"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetPasswordRSAPublicKey_Request.account_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_account_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_GetPasswordRSAPublicKey_Request)
  return target;
}

size_t CAuthentication_GetPasswordRSAPublicKey_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_GetPasswordRSAPublicKey_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string account_name = 1 [(.description) = "user-provided account name to get an RSA key for"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_account_name());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetPasswordRSAPublicKey_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_GetPasswordRSAPublicKey_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetPasswordRSAPublicKey_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_GetPasswordRSAPublicKey_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_GetPasswordRSAPublicKey_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_GetPasswordRSAPublicKey_Request &>(from));
}


void CAuthentication_GetPasswordRSAPublicKey_Request::MergeFrom(const CAuthentication_GetPasswordRSAPublicKey_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_GetPasswordRSAPublicKey_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_account_name()) {
    _internal_set_account_name(from._internal_account_name());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_GetPasswordRSAPublicKey_Request::CopyFrom(const CAuthentication_GetPasswordRSAPublicKey_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_GetPasswordRSAPublicKey_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_GetPasswordRSAPublicKey_Request::IsInitialized() const {
  return true;
}

void CAuthentication_GetPasswordRSAPublicKey_Request::InternalSwap(CAuthentication_GetPasswordRSAPublicKey_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &account_name_, lhs_arena,
      &other->account_name_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetPasswordRSAPublicKey_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[0]);
}

// ===================================================================

class CAuthentication_GetPasswordRSAPublicKey_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_GetPasswordRSAPublicKey_Response>()._has_bits_);
  static void set_has_publickey_mod(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_publickey_exp(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CAuthentication_GetPasswordRSAPublicKey_Response::CAuthentication_GetPasswordRSAPublicKey_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetPasswordRSAPublicKey_Response)
}
CAuthentication_GetPasswordRSAPublicKey_Response::CAuthentication_GetPasswordRSAPublicKey_Response(const CAuthentication_GetPasswordRSAPublicKey_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  publickey_mod_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    publickey_mod_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey_mod()) {
    publickey_mod_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_publickey_mod(), 
      GetArenaForAllocation());
  }
  publickey_exp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    publickey_exp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_publickey_exp()) {
    publickey_exp_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_publickey_exp(), 
      GetArenaForAllocation());
  }
  timestamp_ = from.timestamp_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetPasswordRSAPublicKey_Response)
}

inline void CAuthentication_GetPasswordRSAPublicKey_Response::SharedCtor() {
publickey_mod_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  publickey_mod_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
publickey_exp_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  publickey_exp_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
timestamp_ = uint64_t{0u};
}

CAuthentication_GetPasswordRSAPublicKey_Response::~CAuthentication_GetPasswordRSAPublicKey_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_GetPasswordRSAPublicKey_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_GetPasswordRSAPublicKey_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  publickey_mod_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  publickey_exp_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_GetPasswordRSAPublicKey_Response::ArenaDtor(void* object) {
  CAuthentication_GetPasswordRSAPublicKey_Response* _this = reinterpret_cast< CAuthentication_GetPasswordRSAPublicKey_Response* >(object);
  (void)_this;
}
void CAuthentication_GetPasswordRSAPublicKey_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_GetPasswordRSAPublicKey_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_GetPasswordRSAPublicKey_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_GetPasswordRSAPublicKey_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      publickey_mod_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      publickey_exp_.ClearNonDefaultToEmpty();
    }
  }
  timestamp_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_GetPasswordRSAPublicKey_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string publickey_mod = 1 [(.description) = "the public key modulus"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_publickey_mod();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string publickey_exp = 2 [(.description) = "the public key exponent"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_publickey_exp();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 timestamp = 3 [(.description) = "the timestamp the key was generated"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_timestamp(&has_bits);
          timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_GetPasswordRSAPublicKey_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_GetPasswordRSAPublicKey_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string publickey_mod = 1 [(.description) = "the public key modulus"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_publickey_mod().data(), static_cast<int>(this->_internal_publickey_mod().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetPasswordRSAPublicKey_Response.publickey_mod");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_publickey_mod(), target);
  }

  // optional string publickey_exp = 2 [(.description) = "the public key exponent"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_publickey_exp().data(), static_cast<int>(this->_internal_publickey_exp().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetPasswordRSAPublicKey_Response.publickey_exp");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_publickey_exp(), target);
  }

  // optional uint64 timestamp = 3 [(.description) = "the timestamp the key was generated"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(3, this->_internal_timestamp(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_GetPasswordRSAPublicKey_Response)
  return target;
}

size_t CAuthentication_GetPasswordRSAPublicKey_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_GetPasswordRSAPublicKey_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string publickey_mod = 1 [(.description) = "the public key modulus"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_publickey_mod());
    }

    // optional string publickey_exp = 2 [(.description) = "the public key exponent"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_publickey_exp());
    }

    // optional uint64 timestamp = 3 [(.description) = "the timestamp the key was generated"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_timestamp());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetPasswordRSAPublicKey_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_GetPasswordRSAPublicKey_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetPasswordRSAPublicKey_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_GetPasswordRSAPublicKey_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_GetPasswordRSAPublicKey_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_GetPasswordRSAPublicKey_Response &>(from));
}


void CAuthentication_GetPasswordRSAPublicKey_Response::MergeFrom(const CAuthentication_GetPasswordRSAPublicKey_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_GetPasswordRSAPublicKey_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_publickey_mod(from._internal_publickey_mod());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_publickey_exp(from._internal_publickey_exp());
    }
    if (cached_has_bits & 0x00000004u) {
      timestamp_ = from.timestamp_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_GetPasswordRSAPublicKey_Response::CopyFrom(const CAuthentication_GetPasswordRSAPublicKey_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_GetPasswordRSAPublicKey_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_GetPasswordRSAPublicKey_Response::IsInitialized() const {
  return true;
}

void CAuthentication_GetPasswordRSAPublicKey_Response::InternalSwap(CAuthentication_GetPasswordRSAPublicKey_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &publickey_mod_, lhs_arena,
      &other->publickey_mod_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &publickey_exp_, lhs_arena,
      &other->publickey_exp_, rhs_arena
  );
  swap(timestamp_, other->timestamp_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetPasswordRSAPublicKey_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[1]);
}

// ===================================================================

class CAuthentication_DeviceDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_DeviceDetails>()._has_bits_);
  static void set_has_device_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_gaming_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_client_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_machine_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthentication_DeviceDetails::CAuthentication_DeviceDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_DeviceDetails)
}
CAuthentication_DeviceDetails::CAuthentication_DeviceDetails(const CAuthentication_DeviceDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_friendly_name()) {
    device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_friendly_name(), 
      GetArenaForAllocation());
  }
  machine_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    machine_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_machine_id()) {
    machine_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_machine_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&platform_type_, &from.platform_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&client_count_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(client_count_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_DeviceDetails)
}

inline void CAuthentication_DeviceDetails::SharedCtor() {
device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
machine_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  machine_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&platform_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&client_count_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(client_count_));
}

CAuthentication_DeviceDetails::~CAuthentication_DeviceDetails() {
  // @@protoc_insertion_point(destructor:CAuthentication_DeviceDetails)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_DeviceDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  machine_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_DeviceDetails::ArenaDtor(void* object) {
  CAuthentication_DeviceDetails* _this = reinterpret_cast< CAuthentication_DeviceDetails* >(object);
  (void)_this;
}
void CAuthentication_DeviceDetails::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_DeviceDetails::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_DeviceDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_DeviceDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      device_friendly_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      machine_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&platform_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&client_count_) -
        reinterpret_cast<char*>(&platform_type_)) + sizeof(client_count_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_DeviceDetails::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_friendly_name = 1 [(.description) = "User-supplied, or client-supplied, friendly name of device"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_DeviceDetails.device_friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "EAuthTokenPlatformType, claimed, of device"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 os_type = 3 [(.description) = "EOSType, claimed, of authorized device"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_os_type(&has_bits);
          os_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gaming_device_type = 4 [(.description) = "EGamingDeviceType, claimed, of authorized device for steam client-type devices"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_gaming_device_type(&has_bits);
          gaming_device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 client_count = 5 [(.description) = "For desktop clients, quantized number of users in history"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_client_count(&has_bits);
          client_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes machine_id = 6 [(.description) = "Additional device context"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_machine_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_DeviceDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_DeviceDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_friendly_name = 1 [(.description) = "User-supplied, or client-supplied, friendly name of device"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_friendly_name().data(), static_cast<int>(this->_internal_device_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_DeviceDetails.device_friendly_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_friendly_name(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "EAuthTokenPlatformType, claimed, of device"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional int32 os_type = 3 [(.description) = "EOSType, claimed, of authorized device"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_os_type(), target);
  }

  // optional uint32 gaming_device_type = 4 [(.description) = "EGamingDeviceType, claimed, of authorized device for steam client-type devices"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_gaming_device_type(), target);
  }

  // optional uint32 client_count = 5 [(.description) = "For desktop clients, quantized number of users in history"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_client_count(), target);
  }

  // optional bytes machine_id = 6 [(.description) = "Additional device context"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        6, this->_internal_machine_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_DeviceDetails)
  return target;
}

size_t CAuthentication_DeviceDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_DeviceDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string device_friendly_name = 1 [(.description) = "User-supplied, or client-supplied, friendly name of device"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_friendly_name());
    }

    // optional bytes machine_id = 6 [(.description) = "Additional device context"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_machine_id());
    }

    // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "EAuthTokenPlatformType, claimed, of device"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional int32 os_type = 3 [(.description) = "EOSType, claimed, of authorized device"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_os_type());
    }

    // optional uint32 gaming_device_type = 4 [(.description) = "EGamingDeviceType, claimed, of authorized device for steam client-type devices"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gaming_device_type());
    }

    // optional uint32 client_count = 5 [(.description) = "For desktop clients, quantized number of users in history"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_client_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_DeviceDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_DeviceDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_DeviceDetails::GetClassData() const { return &_class_data_; }

void CAuthentication_DeviceDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_DeviceDetails *>(to)->MergeFrom(
      static_cast<const CAuthentication_DeviceDetails &>(from));
}


void CAuthentication_DeviceDetails::MergeFrom(const CAuthentication_DeviceDetails& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_DeviceDetails)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_friendly_name(from._internal_device_friendly_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_machine_id(from._internal_machine_id());
    }
    if (cached_has_bits & 0x00000004u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000008u) {
      os_type_ = from.os_type_;
    }
    if (cached_has_bits & 0x00000010u) {
      gaming_device_type_ = from.gaming_device_type_;
    }
    if (cached_has_bits & 0x00000020u) {
      client_count_ = from.client_count_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_DeviceDetails::CopyFrom(const CAuthentication_DeviceDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_DeviceDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_DeviceDetails::IsInitialized() const {
  return true;
}

void CAuthentication_DeviceDetails::InternalSwap(CAuthentication_DeviceDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_friendly_name_, lhs_arena,
      &other->device_friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &machine_id_, lhs_arena,
      &other->machine_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_DeviceDetails, client_count_)
      + sizeof(CAuthentication_DeviceDetails::client_count_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_DeviceDetails, platform_type_)>(
          reinterpret_cast<char*>(&platform_type_),
          reinterpret_cast<char*>(&other->platform_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_DeviceDetails::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[2]);
}

// ===================================================================

class CAuthentication_BeginAuthSessionViaQR_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_BeginAuthSessionViaQR_Request>()._has_bits_);
  static void set_has_device_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CAuthentication_DeviceDetails& device_details(const CAuthentication_BeginAuthSessionViaQR_Request* msg);
  static void set_has_device_details(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_website_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CAuthentication_DeviceDetails&
CAuthentication_BeginAuthSessionViaQR_Request::_Internal::device_details(const CAuthentication_BeginAuthSessionViaQR_Request* msg) {
  return *msg->device_details_;
}
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString CAuthentication_BeginAuthSessionViaQR_Request::_i_give_permission_to_break_this_code_default_website_id_{{{"Unknown", 7}}, {nullptr}};
CAuthentication_BeginAuthSessionViaQR_Request::CAuthentication_BeginAuthSessionViaQR_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_BeginAuthSessionViaQR_Request)
}
CAuthentication_BeginAuthSessionViaQR_Request::CAuthentication_BeginAuthSessionViaQR_Request(const CAuthentication_BeginAuthSessionViaQR_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_friendly_name()) {
    device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_friendly_name(), 
      GetArenaForAllocation());
  }
  website_id_.UnsafeSetDefault(nullptr);
  if (from._internal_has_website_id()) {
    website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_website_id(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_device_details()) {
    device_details_ = new ::CAuthentication_DeviceDetails(*from.device_details_);
  } else {
    device_details_ = nullptr;
  }
  platform_type_ = from.platform_type_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_BeginAuthSessionViaQR_Request)
}

inline void CAuthentication_BeginAuthSessionViaQR_Request::SharedCtor() {
device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
website_id_.UnsafeSetDefault(nullptr);
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_details_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&platform_type_) -
    reinterpret_cast<char*>(&device_details_)) + sizeof(platform_type_));
}

CAuthentication_BeginAuthSessionViaQR_Request::~CAuthentication_BeginAuthSessionViaQR_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_BeginAuthSessionViaQR_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_BeginAuthSessionViaQR_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  website_id_.DestroyNoArena(nullptr);
  if (this != internal_default_instance()) delete device_details_;
}

void CAuthentication_BeginAuthSessionViaQR_Request::ArenaDtor(void* object) {
  CAuthentication_BeginAuthSessionViaQR_Request* _this = reinterpret_cast< CAuthentication_BeginAuthSessionViaQR_Request* >(object);
  (void)_this;
}
void CAuthentication_BeginAuthSessionViaQR_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_BeginAuthSessionViaQR_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_BeginAuthSessionViaQR_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_BeginAuthSessionViaQR_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      device_friendly_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      website_id_.ClearToDefault(::CAuthentication_BeginAuthSessionViaQR_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(device_details_ != nullptr);
      device_details_->Clear();
    }
  }
  platform_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_BeginAuthSessionViaQR_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_friendly_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .CAuthentication_DeviceDetails device_details = 3 [(.description) = "User-supplied details about the device attempting to sign in"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string website_id = 4 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_website_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaQR_Request.website_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_BeginAuthSessionViaQR_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_BeginAuthSessionViaQR_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_friendly_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_friendly_name().data(), static_cast<int>(this->_internal_device_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaQR_Request.device_friendly_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_friendly_name(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_platform_type(), target);
  }

  // optional .CAuthentication_DeviceDetails device_details = 3 [(.description) = "User-supplied details about the device attempting to sign in"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::device_details(this), target, stream);
  }

  // optional string website_id = 4 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_website_id().data(), static_cast<int>(this->_internal_website_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaQR_Request.website_id");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_website_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_BeginAuthSessionViaQR_Request)
  return target;
}

size_t CAuthentication_BeginAuthSessionViaQR_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_BeginAuthSessionViaQR_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string device_friendly_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_friendly_name());
    }

    // optional string website_id = 4 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_website_id());
    }

    // optional .CAuthentication_DeviceDetails device_details = 3 [(.description) = "User-supplied details about the device attempting to sign in"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_details_);
    }

    // optional .EAuthTokenPlatformType platform_type = 2 [default = k_EAuthTokenPlatformType_Unknown];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_BeginAuthSessionViaQR_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_BeginAuthSessionViaQR_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_BeginAuthSessionViaQR_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_BeginAuthSessionViaQR_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_BeginAuthSessionViaQR_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_BeginAuthSessionViaQR_Request &>(from));
}


void CAuthentication_BeginAuthSessionViaQR_Request::MergeFrom(const CAuthentication_BeginAuthSessionViaQR_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_BeginAuthSessionViaQR_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_friendly_name(from._internal_device_friendly_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_website_id(from._internal_website_id());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_device_details()->::CAuthentication_DeviceDetails::MergeFrom(from._internal_device_details());
    }
    if (cached_has_bits & 0x00000008u) {
      platform_type_ = from.platform_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_BeginAuthSessionViaQR_Request::CopyFrom(const CAuthentication_BeginAuthSessionViaQR_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_BeginAuthSessionViaQR_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_BeginAuthSessionViaQR_Request::IsInitialized() const {
  return true;
}

void CAuthentication_BeginAuthSessionViaQR_Request::InternalSwap(CAuthentication_BeginAuthSessionViaQR_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_friendly_name_, lhs_arena,
      &other->device_friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &website_id_, lhs_arena,
      &other->website_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaQR_Request, platform_type_)
      + sizeof(CAuthentication_BeginAuthSessionViaQR_Request::platform_type_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaQR_Request, device_details_)>(
          reinterpret_cast<char*>(&device_details_),
          reinterpret_cast<char*>(&other->device_details_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_BeginAuthSessionViaQR_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[3]);
}

// ===================================================================

class CAuthentication_AllowedConfirmation::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_AllowedConfirmation>()._has_bits_);
  static void set_has_confirmation_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_associated_message(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_AllowedConfirmation::CAuthentication_AllowedConfirmation(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_AllowedConfirmation)
}
CAuthentication_AllowedConfirmation::CAuthentication_AllowedConfirmation(const CAuthentication_AllowedConfirmation& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  associated_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    associated_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_associated_message()) {
    associated_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_associated_message(), 
      GetArenaForAllocation());
  }
  confirmation_type_ = from.confirmation_type_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_AllowedConfirmation)
}

inline void CAuthentication_AllowedConfirmation::SharedCtor() {
associated_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  associated_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
confirmation_type_ = 0;
}

CAuthentication_AllowedConfirmation::~CAuthentication_AllowedConfirmation() {
  // @@protoc_insertion_point(destructor:CAuthentication_AllowedConfirmation)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_AllowedConfirmation::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  associated_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_AllowedConfirmation::ArenaDtor(void* object) {
  CAuthentication_AllowedConfirmation* _this = reinterpret_cast< CAuthentication_AllowedConfirmation* >(object);
  (void)_this;
}
void CAuthentication_AllowedConfirmation::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_AllowedConfirmation::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_AllowedConfirmation::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_AllowedConfirmation)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    associated_message_.ClearNonDefaultToEmpty();
  }
  confirmation_type_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_AllowedConfirmation::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .EAuthSessionGuardType confirmation_type = 1 [default = k_EAuthSessionGuardType_Unknown, (.description) = "authentication can proceed with this confirmation type"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthSessionGuardType_IsValid(val))) {
            _internal_set_confirmation_type(static_cast<::EAuthSessionGuardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string associated_message = 2 [(.description) = "message to be interpreted depending on the confirmation type. for email confirmation, this might be the redacted email address to which email was sent."];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_associated_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_AllowedConfirmation.associated_message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_AllowedConfirmation::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_AllowedConfirmation)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional .EAuthSessionGuardType confirmation_type = 1 [default = k_EAuthSessionGuardType_Unknown, (.description) = "authentication can proceed with this confirmation type"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->_internal_confirmation_type(), target);
  }

  // optional string associated_message = 2 [(.description) = "message to be interpreted depending on the confirmation type. for email confirmation, this might be the redacted email address to which email was sent."];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_associated_message().data(), static_cast<int>(this->_internal_associated_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_AllowedConfirmation.associated_message");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_associated_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_AllowedConfirmation)
  return target;
}

size_t CAuthentication_AllowedConfirmation::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_AllowedConfirmation)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string associated_message = 2 [(.description) = "message to be interpreted depending on the confirmation type. for email confirmation, this might be the redacted email address to which email was sent."];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_associated_message());
    }

    // optional .EAuthSessionGuardType confirmation_type = 1 [default = k_EAuthSessionGuardType_Unknown, (.description) = "authentication can proceed with this confirmation type"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_confirmation_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_AllowedConfirmation::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_AllowedConfirmation::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_AllowedConfirmation::GetClassData() const { return &_class_data_; }

void CAuthentication_AllowedConfirmation::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_AllowedConfirmation *>(to)->MergeFrom(
      static_cast<const CAuthentication_AllowedConfirmation &>(from));
}


void CAuthentication_AllowedConfirmation::MergeFrom(const CAuthentication_AllowedConfirmation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_AllowedConfirmation)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_associated_message(from._internal_associated_message());
    }
    if (cached_has_bits & 0x00000002u) {
      confirmation_type_ = from.confirmation_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_AllowedConfirmation::CopyFrom(const CAuthentication_AllowedConfirmation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_AllowedConfirmation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_AllowedConfirmation::IsInitialized() const {
  return true;
}

void CAuthentication_AllowedConfirmation::InternalSwap(CAuthentication_AllowedConfirmation* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &associated_message_, lhs_arena,
      &other->associated_message_, rhs_arena
  );
  swap(confirmation_type_, other->confirmation_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_AllowedConfirmation::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[4]);
}

// ===================================================================

class CAuthentication_BeginAuthSessionViaQR_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_BeginAuthSessionViaQR_Response>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_challenge_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CAuthentication_BeginAuthSessionViaQR_Response::CAuthentication_BeginAuthSessionViaQR_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  allowed_confirmations_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_BeginAuthSessionViaQR_Response)
}
CAuthentication_BeginAuthSessionViaQR_Response::CAuthentication_BeginAuthSessionViaQR_Response(const CAuthentication_BeginAuthSessionViaQR_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      allowed_confirmations_(from.allowed_confirmations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  challenge_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_challenge_url()) {
    challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_challenge_url(), 
      GetArenaForAllocation());
  }
  request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_id()) {
    request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_request_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(version_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_BeginAuthSessionViaQR_Response)
}

inline void CAuthentication_BeginAuthSessionViaQR_Response::SharedCtor() {
challenge_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&version_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(version_));
}

CAuthentication_BeginAuthSessionViaQR_Response::~CAuthentication_BeginAuthSessionViaQR_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_BeginAuthSessionViaQR_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_BeginAuthSessionViaQR_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  challenge_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  request_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_BeginAuthSessionViaQR_Response::ArenaDtor(void* object) {
  CAuthentication_BeginAuthSessionViaQR_Response* _this = reinterpret_cast< CAuthentication_BeginAuthSessionViaQR_Response* >(object);
  (void)_this;
}
void CAuthentication_BeginAuthSessionViaQR_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_BeginAuthSessionViaQR_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_BeginAuthSessionViaQR_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_BeginAuthSessionViaQR_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowed_confirmations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      challenge_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      request_id_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(version_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_BeginAuthSessionViaQR_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing, portion of QR code"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string challenge_url = 2 [(.description) = "URL based on client ID, which will be rendered as QR code"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_challenge_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaQR_Response.challenge_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes request_id = 3 [(.description) = "unique request ID to be presented by requestor at poll time - must not be rendered in QR"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_request_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float interval = 4 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_interval(&has_bits);
          interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 5 [(.description) = "the confirmation types that will be able to confirm the request"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allowed_confirmations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<42>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 6 [(.description) = "version of the QR data"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_BeginAuthSessionViaQR_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_BeginAuthSessionViaQR_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing, portion of QR code"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional string challenge_url = 2 [(.description) = "URL based on client ID, which will be rendered as QR code"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_challenge_url().data(), static_cast<int>(this->_internal_challenge_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaQR_Response.challenge_url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_challenge_url(), target);
  }

  // optional bytes request_id = 3 [(.description) = "unique request ID to be presented by requestor at poll time - must not be rendered in QR"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_request_id(), target);
  }

  // optional float interval = 4 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(4, this->_internal_interval(), target);
  }

  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 5 [(.description) = "the confirmation types that will be able to confirm the request"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_allowed_confirmations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, this->_internal_allowed_confirmations(i), target, stream);
  }

  // optional int32 version = 6 [(.description) = "version of the QR data"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(6, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_BeginAuthSessionViaQR_Response)
  return target;
}

size_t CAuthentication_BeginAuthSessionViaQR_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_BeginAuthSessionViaQR_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 5 [(.description) = "the confirmation types that will be able to confirm the request"];
  total_size += 1UL * this->_internal_allowed_confirmations_size();
  for (const auto& msg : this->allowed_confirmations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string challenge_url = 2 [(.description) = "URL based on client ID, which will be rendered as QR code"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_challenge_url());
    }

    // optional bytes request_id = 3 [(.description) = "unique request ID to be presented by requestor at poll time - must not be rendered in QR"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_request_id());
    }

    // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing, portion of QR code"];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional float interval = 4 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 version = 6 [(.description) = "version of the QR data"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_BeginAuthSessionViaQR_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_BeginAuthSessionViaQR_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_BeginAuthSessionViaQR_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_BeginAuthSessionViaQR_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_BeginAuthSessionViaQR_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_BeginAuthSessionViaQR_Response &>(from));
}


void CAuthentication_BeginAuthSessionViaQR_Response::MergeFrom(const CAuthentication_BeginAuthSessionViaQR_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_BeginAuthSessionViaQR_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowed_confirmations_.MergeFrom(from.allowed_confirmations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_challenge_url(from._internal_challenge_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_request_id(from._internal_request_id());
    }
    if (cached_has_bits & 0x00000004u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      interval_ = from.interval_;
    }
    if (cached_has_bits & 0x00000010u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_BeginAuthSessionViaQR_Response::CopyFrom(const CAuthentication_BeginAuthSessionViaQR_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_BeginAuthSessionViaQR_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_BeginAuthSessionViaQR_Response::IsInitialized() const {
  return true;
}

void CAuthentication_BeginAuthSessionViaQR_Response::InternalSwap(CAuthentication_BeginAuthSessionViaQR_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowed_confirmations_.InternalSwap(&other->allowed_confirmations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &challenge_url_, lhs_arena,
      &other->challenge_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &request_id_, lhs_arena,
      &other->request_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaQR_Response, version_)
      + sizeof(CAuthentication_BeginAuthSessionViaQR_Response::version_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaQR_Response, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_BeginAuthSessionViaQR_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[5]);
}

// ===================================================================

class CAuthentication_BeginAuthSessionViaCredentials_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_BeginAuthSessionViaCredentials_Request>()._has_bits_);
  static void set_has_device_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_encrypted_password(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_encryption_timestamp(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_remember_login(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_persistence(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_website_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CAuthentication_DeviceDetails& device_details(const CAuthentication_BeginAuthSessionViaCredentials_Request* msg);
  static void set_has_device_details(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_guard_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_language(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_qos_level(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

const ::CAuthentication_DeviceDetails&
CAuthentication_BeginAuthSessionViaCredentials_Request::_Internal::device_details(const CAuthentication_BeginAuthSessionViaCredentials_Request* msg) {
  return *msg->device_details_;
}
const ::PROTOBUF_NAMESPACE_ID::internal::LazyString CAuthentication_BeginAuthSessionViaCredentials_Request::_i_give_permission_to_break_this_code_default_website_id_{{{"Unknown", 7}}, {nullptr}};
CAuthentication_BeginAuthSessionViaCredentials_Request::CAuthentication_BeginAuthSessionViaCredentials_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_BeginAuthSessionViaCredentials_Request)
}
CAuthentication_BeginAuthSessionViaCredentials_Request::CAuthentication_BeginAuthSessionViaCredentials_Request(const CAuthentication_BeginAuthSessionViaCredentials_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_friendly_name()) {
    device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_friendly_name(), 
      GetArenaForAllocation());
  }
  account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_account_name(), 
      GetArenaForAllocation());
  }
  encrypted_password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    encrypted_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_encrypted_password()) {
    encrypted_password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_encrypted_password(), 
      GetArenaForAllocation());
  }
  website_id_.UnsafeSetDefault(nullptr);
  if (from._internal_has_website_id()) {
    website_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::NonEmptyDefault{}, from._internal_website_id(), 
      GetArenaForAllocation());
  }
  guard_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_guard_data()) {
    guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_guard_data(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_device_details()) {
    device_details_ = new ::CAuthentication_DeviceDetails(*from.device_details_);
  } else {
    device_details_ = nullptr;
  }
  ::memcpy(&encryption_timestamp_, &from.encryption_timestamp_,
    static_cast<size_t>(reinterpret_cast<char*>(&qos_level_) -
    reinterpret_cast<char*>(&encryption_timestamp_)) + sizeof(qos_level_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_BeginAuthSessionViaCredentials_Request)
}

inline void CAuthentication_BeginAuthSessionViaCredentials_Request::SharedCtor() {
device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
encrypted_password_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  encrypted_password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
website_id_.UnsafeSetDefault(nullptr);
guard_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&device_details_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&language_) -
    reinterpret_cast<char*>(&device_details_)) + sizeof(language_));
persistence_ = 1;
qos_level_ = 2;
}

CAuthentication_BeginAuthSessionViaCredentials_Request::~CAuthentication_BeginAuthSessionViaCredentials_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_BeginAuthSessionViaCredentials_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_BeginAuthSessionViaCredentials_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  account_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  encrypted_password_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  website_id_.DestroyNoArena(nullptr);
  guard_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete device_details_;
}

void CAuthentication_BeginAuthSessionViaCredentials_Request::ArenaDtor(void* object) {
  CAuthentication_BeginAuthSessionViaCredentials_Request* _this = reinterpret_cast< CAuthentication_BeginAuthSessionViaCredentials_Request* >(object);
  (void)_this;
}
void CAuthentication_BeginAuthSessionViaCredentials_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_BeginAuthSessionViaCredentials_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_BeginAuthSessionViaCredentials_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_BeginAuthSessionViaCredentials_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      device_friendly_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      encrypted_password_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      website_id_.ClearToDefault(::CAuthentication_BeginAuthSessionViaCredentials_Request::_i_give_permission_to_break_this_code_default_website_id_, GetArenaForAllocation());
       }
    if (cached_has_bits & 0x00000010u) {
      guard_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(device_details_ != nullptr);
      device_details_->Clear();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&encryption_timestamp_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&remember_login_) -
        reinterpret_cast<char*>(&encryption_timestamp_)) + sizeof(remember_login_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&platform_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&language_) -
        reinterpret_cast<char*>(&platform_type_)) + sizeof(language_));
    persistence_ = 1;
    qos_level_ = 2;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_BeginAuthSessionViaCredentials_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string device_friendly_name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string account_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_account_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Request.account_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string encrypted_password = 3 [(.description) = "password, RSA encrypted client side"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_encrypted_password();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 encryption_timestamp = 4 [(.description) = "timestamp to map to a key - STime"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_encryption_timestamp(&has_bits);
          encryption_timestamp_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool remember_login = 5 [(.description) = "deprecated"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_remember_login(&has_bits);
          remember_login_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .ESessionPersistence persistence = 7 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESessionPersistence_IsValid(val))) {
            _internal_set_persistence(static_cast<::ESessionPersistence>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string website_id = 8 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_website_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Request.website_id");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CAuthentication_DeviceDetails device_details = 9 [(.description) = "User-supplied details about the device attempting to sign in"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_device_details(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string guard_data = 10 [(.description) = "steam guard data for client login"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_guard_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 language = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_language(&has_bits);
          language_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 qos_level = 12 [default = 2, (.description) = "[ENetQOSLevel] client-specified priority for this auth attempt"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_qos_level(&has_bits);
          qos_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_BeginAuthSessionViaCredentials_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_BeginAuthSessionViaCredentials_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string device_friendly_name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_friendly_name().data(), static_cast<int>(this->_internal_device_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Request.device_friendly_name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_friendly_name(), target);
  }

  // optional string account_name = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Request.account_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_account_name(), target);
  }

  // optional string encrypted_password = 3 [(.description) = "password, RSA encrypted client side"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_encrypted_password().data(), static_cast<int>(this->_internal_encrypted_password().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Request.encrypted_password");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_encrypted_password(), target);
  }

  // optional uint64 encryption_timestamp = 4 [(.description) = "timestamp to map to a key - STime"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(4, this->_internal_encryption_timestamp(), target);
  }

  // optional bool remember_login = 5 [(.description) = "deprecated"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_remember_login(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_platform_type(), target);
  }

  // optional .ESessionPersistence persistence = 7 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      7, this->_internal_persistence(), target);
  }

  // optional string website_id = 8 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_website_id().data(), static_cast<int>(this->_internal_website_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Request.website_id");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_website_id(), target);
  }

  // optional .CAuthentication_DeviceDetails device_details = 9 [(.description) = "User-supplied details about the device attempting to sign in"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::device_details(this), target, stream);
  }

  // optional string guard_data = 10 [(.description) = "steam guard data for client login"];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_guard_data().data(), static_cast<int>(this->_internal_guard_data().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Request.guard_data");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_guard_data(), target);
  }

  // optional uint32 language = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->_internal_language(), target);
  }

  // optional int32 qos_level = 12 [default = 2, (.description) = "[ENetQOSLevel] client-specified priority for this auth attempt"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(12, this->_internal_qos_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_BeginAuthSessionViaCredentials_Request)
  return target;
}

size_t CAuthentication_BeginAuthSessionViaCredentials_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_BeginAuthSessionViaCredentials_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string device_friendly_name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_friendly_name());
    }

    // optional string account_name = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_account_name());
    }

    // optional string encrypted_password = 3 [(.description) = "password, RSA encrypted client side"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_encrypted_password());
    }

    // optional string website_id = 8 [default = "Unknown", (.description) = "(EMachineAuthWebDomain) identifier of client requesting auth"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_website_id());
    }

    // optional string guard_data = 10 [(.description) = "steam guard data for client login"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_guard_data());
    }

    // optional .CAuthentication_DeviceDetails device_details = 9 [(.description) = "User-supplied details about the device attempting to sign in"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *device_details_);
    }

    // optional uint64 encryption_timestamp = 4 [(.description) = "timestamp to map to a key - STime"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_encryption_timestamp());
    }

    // optional bool remember_login = 5 [(.description) = "deprecated"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional uint32 language = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_language());
    }

    // optional .ESessionPersistence persistence = 7 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_persistence());
    }

    // optional int32 qos_level = 12 [default = 2, (.description) = "[ENetQOSLevel] client-specified priority for this auth attempt"];
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_qos_level());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_BeginAuthSessionViaCredentials_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_BeginAuthSessionViaCredentials_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_BeginAuthSessionViaCredentials_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_BeginAuthSessionViaCredentials_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_BeginAuthSessionViaCredentials_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_BeginAuthSessionViaCredentials_Request &>(from));
}


void CAuthentication_BeginAuthSessionViaCredentials_Request::MergeFrom(const CAuthentication_BeginAuthSessionViaCredentials_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_BeginAuthSessionViaCredentials_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_device_friendly_name(from._internal_device_friendly_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_encrypted_password(from._internal_encrypted_password());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_website_id(from._internal_website_id());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_guard_data(from._internal_guard_data());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_mutable_device_details()->::CAuthentication_DeviceDetails::MergeFrom(from._internal_device_details());
    }
    if (cached_has_bits & 0x00000040u) {
      encryption_timestamp_ = from.encryption_timestamp_;
    }
    if (cached_has_bits & 0x00000080u) {
      remember_login_ = from.remember_login_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      language_ = from.language_;
    }
    if (cached_has_bits & 0x00000400u) {
      persistence_ = from.persistence_;
    }
    if (cached_has_bits & 0x00000800u) {
      qos_level_ = from.qos_level_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_BeginAuthSessionViaCredentials_Request::CopyFrom(const CAuthentication_BeginAuthSessionViaCredentials_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_BeginAuthSessionViaCredentials_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_BeginAuthSessionViaCredentials_Request::IsInitialized() const {
  return true;
}

void CAuthentication_BeginAuthSessionViaCredentials_Request::InternalSwap(CAuthentication_BeginAuthSessionViaCredentials_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_friendly_name_, lhs_arena,
      &other->device_friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &account_name_, lhs_arena,
      &other->account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &encrypted_password_, lhs_arena,
      &other->encrypted_password_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      nullptr,
      &website_id_, lhs_arena,
      &other->website_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &guard_data_, lhs_arena,
      &other->guard_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaCredentials_Request, language_)
      + sizeof(CAuthentication_BeginAuthSessionViaCredentials_Request::language_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaCredentials_Request, device_details_)>(
          reinterpret_cast<char*>(&device_details_),
          reinterpret_cast<char*>(&other->device_details_));
  swap(persistence_, other->persistence_);
  swap(qos_level_, other->qos_level_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_BeginAuthSessionViaCredentials_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[6]);
}

// ===================================================================

class CAuthentication_BeginAuthSessionViaCredentials_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_BeginAuthSessionViaCredentials_Response>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_weak_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_agreement_session_url(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_extended_error_message(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CAuthentication_BeginAuthSessionViaCredentials_Response::CAuthentication_BeginAuthSessionViaCredentials_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  allowed_confirmations_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_BeginAuthSessionViaCredentials_Response)
}
CAuthentication_BeginAuthSessionViaCredentials_Response::CAuthentication_BeginAuthSessionViaCredentials_Response(const CAuthentication_BeginAuthSessionViaCredentials_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      allowed_confirmations_(from.allowed_confirmations_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_id()) {
    request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_request_id(), 
      GetArenaForAllocation());
  }
  weak_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    weak_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_weak_token()) {
    weak_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_weak_token(), 
      GetArenaForAllocation());
  }
  agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_agreement_session_url()) {
    agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_agreement_session_url(), 
      GetArenaForAllocation());
  }
  extended_error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    extended_error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_extended_error_message()) {
    extended_error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_extended_error_message(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&interval_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(interval_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_BeginAuthSessionViaCredentials_Response)
}

inline void CAuthentication_BeginAuthSessionViaCredentials_Response::SharedCtor() {
request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
weak_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  weak_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
extended_error_message_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  extended_error_message_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&interval_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(interval_));
}

CAuthentication_BeginAuthSessionViaCredentials_Response::~CAuthentication_BeginAuthSessionViaCredentials_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_BeginAuthSessionViaCredentials_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_BeginAuthSessionViaCredentials_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  request_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  weak_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  agreement_session_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  extended_error_message_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_BeginAuthSessionViaCredentials_Response::ArenaDtor(void* object) {
  CAuthentication_BeginAuthSessionViaCredentials_Response* _this = reinterpret_cast< CAuthentication_BeginAuthSessionViaCredentials_Response* >(object);
  (void)_this;
}
void CAuthentication_BeginAuthSessionViaCredentials_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_BeginAuthSessionViaCredentials_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_BeginAuthSessionViaCredentials_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_BeginAuthSessionViaCredentials_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  allowed_confirmations_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      request_id_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      weak_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      agreement_session_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      extended_error_message_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x00000070u) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&interval_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(interval_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_BeginAuthSessionViaCredentials_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes request_id = 2 [(.description) = "unique request ID to be presented by requestor at poll time - must not be transferred or displayed"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_request_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float interval = 3 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_interval(&has_bits);
          interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 4 [(.description) = "the confirmation types that will be able to confirm the request"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_allowed_confirmations(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint64 steamid = 5 [(.description) = "steamid of the account logging in - will only be included if the credentials were correct"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string weak_token = 6 [(.description) = "partial-authentication token - limited lifetime and scope, included only if credentials were valid"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_weak_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_agreement_session_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string extended_error_message = 8 [(.description) = "error string to display if supported by the client"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_extended_error_message();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_BeginAuthSessionViaCredentials_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_BeginAuthSessionViaCredentials_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional bytes request_id = 2 [(.description) = "unique request ID to be presented by requestor at poll time - must not be transferred or displayed"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_request_id(), target);
  }

  // optional float interval = 3 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFloatToArray(3, this->_internal_interval(), target);
  }

  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 4 [(.description) = "the confirmation types that will be able to confirm the request"];
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_allowed_confirmations_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, this->_internal_allowed_confirmations(i), target, stream);
  }

  // optional uint64 steamid = 5 [(.description) = "steamid of the account logging in - will only be included if the credentials were correct"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(5, this->_internal_steamid(), target);
  }

  // optional string weak_token = 6 [(.description) = "partial-authentication token - limited lifetime and scope, included only if credentials were valid"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_weak_token().data(), static_cast<int>(this->_internal_weak_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Response.weak_token");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_weak_token(), target);
  }

  // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_agreement_session_url().data(), static_cast<int>(this->_internal_agreement_session_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Response.agreement_session_url");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_agreement_session_url(), target);
  }

  // optional string extended_error_message = 8 [(.description) = "error string to display if supported by the client"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_extended_error_message().data(), static_cast<int>(this->_internal_extended_error_message().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_BeginAuthSessionViaCredentials_Response.extended_error_message");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_extended_error_message(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_BeginAuthSessionViaCredentials_Response)
  return target;
}

size_t CAuthentication_BeginAuthSessionViaCredentials_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_BeginAuthSessionViaCredentials_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CAuthentication_AllowedConfirmation allowed_confirmations = 4 [(.description) = "the confirmation types that will be able to confirm the request"];
  total_size += 1UL * this->_internal_allowed_confirmations_size();
  for (const auto& msg : this->allowed_confirmations_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional bytes request_id = 2 [(.description) = "unique request ID to be presented by requestor at poll time - must not be transferred or displayed"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_request_id());
    }

    // optional string weak_token = 6 [(.description) = "partial-authentication token - limited lifetime and scope, included only if credentials were valid"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_weak_token());
    }

    // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_agreement_session_url());
    }

    // optional string extended_error_message = 8 [(.description) = "error string to display if supported by the client"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_extended_error_message());
    }

    // optional uint64 client_id = 1 [(.description) = "unique identifier of requestor, also used for routing"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional uint64 steamid = 5 [(.description) = "steamid of the account logging in - will only be included if the credentials were correct"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional float interval = 3 [(.description) = "refresh interval with which requestor should call PollAuthSessionStatus"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_BeginAuthSessionViaCredentials_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_BeginAuthSessionViaCredentials_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_BeginAuthSessionViaCredentials_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_BeginAuthSessionViaCredentials_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_BeginAuthSessionViaCredentials_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_BeginAuthSessionViaCredentials_Response &>(from));
}


void CAuthentication_BeginAuthSessionViaCredentials_Response::MergeFrom(const CAuthentication_BeginAuthSessionViaCredentials_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_BeginAuthSessionViaCredentials_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  allowed_confirmations_.MergeFrom(from.allowed_confirmations_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_request_id(from._internal_request_id());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_weak_token(from._internal_weak_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_agreement_session_url(from._internal_agreement_session_url());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_extended_error_message(from._internal_extended_error_message());
    }
    if (cached_has_bits & 0x00000010u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000040u) {
      interval_ = from.interval_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_BeginAuthSessionViaCredentials_Response::CopyFrom(const CAuthentication_BeginAuthSessionViaCredentials_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_BeginAuthSessionViaCredentials_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_BeginAuthSessionViaCredentials_Response::IsInitialized() const {
  return true;
}

void CAuthentication_BeginAuthSessionViaCredentials_Response::InternalSwap(CAuthentication_BeginAuthSessionViaCredentials_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  allowed_confirmations_.InternalSwap(&other->allowed_confirmations_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &request_id_, lhs_arena,
      &other->request_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &weak_token_, lhs_arena,
      &other->weak_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &agreement_session_url_, lhs_arena,
      &other->agreement_session_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &extended_error_message_, lhs_arena,
      &other->extended_error_message_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaCredentials_Response, interval_)
      + sizeof(CAuthentication_BeginAuthSessionViaCredentials_Response::interval_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_BeginAuthSessionViaCredentials_Response, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_BeginAuthSessionViaCredentials_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[7]);
}

// ===================================================================

class CAuthentication_PollAuthSessionStatus_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_PollAuthSessionStatus_Request>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_request_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_token_to_revoke(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CAuthentication_PollAuthSessionStatus_Request::CAuthentication_PollAuthSessionStatus_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_PollAuthSessionStatus_Request)
}
CAuthentication_PollAuthSessionStatus_Request::CAuthentication_PollAuthSessionStatus_Request(const CAuthentication_PollAuthSessionStatus_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_request_id()) {
    request_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_request_id(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&token_to_revoke_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(token_to_revoke_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_PollAuthSessionStatus_Request)
}

inline void CAuthentication_PollAuthSessionStatus_Request::SharedCtor() {
request_id_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  request_id_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&token_to_revoke_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(token_to_revoke_));
}

CAuthentication_PollAuthSessionStatus_Request::~CAuthentication_PollAuthSessionStatus_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_PollAuthSessionStatus_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_PollAuthSessionStatus_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  request_id_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_PollAuthSessionStatus_Request::ArenaDtor(void* object) {
  CAuthentication_PollAuthSessionStatus_Request* _this = reinterpret_cast< CAuthentication_PollAuthSessionStatus_Request* >(object);
  (void)_this;
}
void CAuthentication_PollAuthSessionStatus_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_PollAuthSessionStatus_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_PollAuthSessionStatus_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_PollAuthSessionStatus_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    request_id_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&token_to_revoke_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(token_to_revoke_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_PollAuthSessionStatus_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes request_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_request_id();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 token_to_revoke = 3 [(.description) = "If this is set to a token owned by this user, that token will be retired"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_token_to_revoke(&has_bits);
          token_to_revoke_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_PollAuthSessionStatus_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_PollAuthSessionStatus_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional bytes request_id = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_request_id(), target);
  }

  // optional fixed64 token_to_revoke = 3 [(.description) = "If this is set to a token owned by this user, that token will be retired"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_token_to_revoke(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_PollAuthSessionStatus_Request)
  return target;
}

size_t CAuthentication_PollAuthSessionStatus_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_PollAuthSessionStatus_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes request_id = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_request_id());
    }

    // optional uint64 client_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional fixed64 token_to_revoke = 3 [(.description) = "If this is set to a token owned by this user, that token will be retired"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_PollAuthSessionStatus_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_PollAuthSessionStatus_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_PollAuthSessionStatus_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_PollAuthSessionStatus_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_PollAuthSessionStatus_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_PollAuthSessionStatus_Request &>(from));
}


void CAuthentication_PollAuthSessionStatus_Request::MergeFrom(const CAuthentication_PollAuthSessionStatus_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_PollAuthSessionStatus_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_request_id(from._internal_request_id());
    }
    if (cached_has_bits & 0x00000002u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      token_to_revoke_ = from.token_to_revoke_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_PollAuthSessionStatus_Request::CopyFrom(const CAuthentication_PollAuthSessionStatus_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_PollAuthSessionStatus_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_PollAuthSessionStatus_Request::IsInitialized() const {
  return true;
}

void CAuthentication_PollAuthSessionStatus_Request::InternalSwap(CAuthentication_PollAuthSessionStatus_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &request_id_, lhs_arena,
      &other->request_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_PollAuthSessionStatus_Request, token_to_revoke_)
      + sizeof(CAuthentication_PollAuthSessionStatus_Request::token_to_revoke_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_PollAuthSessionStatus_Request, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_PollAuthSessionStatus_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[8]);
}

// ===================================================================

class CAuthentication_PollAuthSessionStatus_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_PollAuthSessionStatus_Response>()._has_bits_);
  static void set_has_new_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_new_challenge_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_refresh_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_access_token(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_had_remote_interaction(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_account_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_new_guard_data(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_agreement_session_url(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CAuthentication_PollAuthSessionStatus_Response::CAuthentication_PollAuthSessionStatus_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_PollAuthSessionStatus_Response)
}
CAuthentication_PollAuthSessionStatus_Response::CAuthentication_PollAuthSessionStatus_Response(const CAuthentication_PollAuthSessionStatus_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  new_challenge_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    new_challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_challenge_url()) {
    new_challenge_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_new_challenge_url(), 
      GetArenaForAllocation());
  }
  refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_refresh_token()) {
    refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_refresh_token(), 
      GetArenaForAllocation());
  }
  access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_access_token()) {
    access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_access_token(), 
      GetArenaForAllocation());
  }
  account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_account_name()) {
    account_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_account_name(), 
      GetArenaForAllocation());
  }
  new_guard_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    new_guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_new_guard_data()) {
    new_guard_data_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_new_guard_data(), 
      GetArenaForAllocation());
  }
  agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_agreement_session_url()) {
    agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_agreement_session_url(), 
      GetArenaForAllocation());
  }
  ::memcpy(&new_client_id_, &from.new_client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&had_remote_interaction_) -
    reinterpret_cast<char*>(&new_client_id_)) + sizeof(had_remote_interaction_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_PollAuthSessionStatus_Response)
}

inline void CAuthentication_PollAuthSessionStatus_Response::SharedCtor() {
new_challenge_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  new_challenge_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
account_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  account_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
new_guard_data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  new_guard_data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&new_client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&had_remote_interaction_) -
    reinterpret_cast<char*>(&new_client_id_)) + sizeof(had_remote_interaction_));
}

CAuthentication_PollAuthSessionStatus_Response::~CAuthentication_PollAuthSessionStatus_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_PollAuthSessionStatus_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_PollAuthSessionStatus_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  new_challenge_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  refresh_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  access_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  account_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  new_guard_data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  agreement_session_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_PollAuthSessionStatus_Response::ArenaDtor(void* object) {
  CAuthentication_PollAuthSessionStatus_Response* _this = reinterpret_cast< CAuthentication_PollAuthSessionStatus_Response* >(object);
  (void)_this;
}
void CAuthentication_PollAuthSessionStatus_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_PollAuthSessionStatus_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_PollAuthSessionStatus_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_PollAuthSessionStatus_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      new_challenge_url_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      refresh_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      access_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      account_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      new_guard_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      agreement_session_url_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&new_client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&had_remote_interaction_) -
        reinterpret_cast<char*>(&new_client_id_)) + sizeof(had_remote_interaction_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_PollAuthSessionStatus_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 new_client_id = 1 [(.description) = "if challenge is old, this is the new client id"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_new_client_id(&has_bits);
          new_client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string new_challenge_url = 2 [(.description) = "if challenge is old, this is the new challenge ID to re-render for mobile confirmation"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_new_challenge_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.new_challenge_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string refresh_token = 3 [(.description) = "if login has been confirmed, this is the requestor\'s new refresh token"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_refresh_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.refresh_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string access_token = 4 [(.description) = "if login has been confirmed, this is a new token subordinate to refresh_token"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_access_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.access_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool had_remote_interaction = 5 [(.description) = "whether or not the auth session appears to have had remote interaction from a potential confirmer"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_had_remote_interaction(&has_bits);
          had_remote_interaction_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string account_name = 6 [(.description) = "account name of authenticating account, for use by UI layer"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_account_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.account_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string new_guard_data = 7 [(.description) = "if login has been confirmed, may contain remembered machine ID for future login"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_new_guard_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.new_guard_data");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string agreement_session_url = 8 [(.description) = "agreement the user needs to agree to"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          auto str = _internal_mutable_agreement_session_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_PollAuthSessionStatus_Response.agreement_session_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_PollAuthSessionStatus_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_PollAuthSessionStatus_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 new_client_id = 1 [(.description) = "if challenge is old, this is the new client id"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_new_client_id(), target);
  }

  // optional string new_challenge_url = 2 [(.description) = "if challenge is old, this is the new challenge ID to re-render for mobile confirmation"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_new_challenge_url().data(), static_cast<int>(this->_internal_new_challenge_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.new_challenge_url");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_new_challenge_url(), target);
  }

  // optional string refresh_token = 3 [(.description) = "if login has been confirmed, this is the requestor\'s new refresh token"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_refresh_token().data(), static_cast<int>(this->_internal_refresh_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.refresh_token");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_refresh_token(), target);
  }

  // optional string access_token = 4 [(.description) = "if login has been confirmed, this is a new token subordinate to refresh_token"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_access_token().data(), static_cast<int>(this->_internal_access_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.access_token");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_access_token(), target);
  }

  // optional bool had_remote_interaction = 5 [(.description) = "whether or not the auth session appears to have had remote interaction from a potential confirmer"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_had_remote_interaction(), target);
  }

  // optional string account_name = 6 [(.description) = "account name of authenticating account, for use by UI layer"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_account_name().data(), static_cast<int>(this->_internal_account_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.account_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_account_name(), target);
  }

  // optional string new_guard_data = 7 [(.description) = "if login has been confirmed, may contain remembered machine ID for future login"];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_new_guard_data().data(), static_cast<int>(this->_internal_new_guard_data().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.new_guard_data");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_new_guard_data(), target);
  }

  // optional string agreement_session_url = 8 [(.description) = "agreement the user needs to agree to"];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_agreement_session_url().data(), static_cast<int>(this->_internal_agreement_session_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_PollAuthSessionStatus_Response.agreement_session_url");
    target = stream->WriteStringMaybeAliased(
        8, this->_internal_agreement_session_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_PollAuthSessionStatus_Response)
  return target;
}

size_t CAuthentication_PollAuthSessionStatus_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_PollAuthSessionStatus_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string new_challenge_url = 2 [(.description) = "if challenge is old, this is the new challenge ID to re-render for mobile confirmation"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_challenge_url());
    }

    // optional string refresh_token = 3 [(.description) = "if login has been confirmed, this is the requestor\'s new refresh token"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_refresh_token());
    }

    // optional string access_token = 4 [(.description) = "if login has been confirmed, this is a new token subordinate to refresh_token"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_access_token());
    }

    // optional string account_name = 6 [(.description) = "account name of authenticating account, for use by UI layer"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_account_name());
    }

    // optional string new_guard_data = 7 [(.description) = "if login has been confirmed, may contain remembered machine ID for future login"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_new_guard_data());
    }

    // optional string agreement_session_url = 8 [(.description) = "agreement the user needs to agree to"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_agreement_session_url());
    }

    // optional uint64 new_client_id = 1 [(.description) = "if challenge is old, this is the new client id"];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_new_client_id());
    }

    // optional bool had_remote_interaction = 5 [(.description) = "whether or not the auth session appears to have had remote interaction from a potential confirmer"];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_PollAuthSessionStatus_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_PollAuthSessionStatus_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_PollAuthSessionStatus_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_PollAuthSessionStatus_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_PollAuthSessionStatus_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_PollAuthSessionStatus_Response &>(from));
}


void CAuthentication_PollAuthSessionStatus_Response::MergeFrom(const CAuthentication_PollAuthSessionStatus_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_PollAuthSessionStatus_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_new_challenge_url(from._internal_new_challenge_url());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_refresh_token(from._internal_refresh_token());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_access_token(from._internal_access_token());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_account_name(from._internal_account_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_new_guard_data(from._internal_new_guard_data());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_agreement_session_url(from._internal_agreement_session_url());
    }
    if (cached_has_bits & 0x00000040u) {
      new_client_id_ = from.new_client_id_;
    }
    if (cached_has_bits & 0x00000080u) {
      had_remote_interaction_ = from.had_remote_interaction_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_PollAuthSessionStatus_Response::CopyFrom(const CAuthentication_PollAuthSessionStatus_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_PollAuthSessionStatus_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_PollAuthSessionStatus_Response::IsInitialized() const {
  return true;
}

void CAuthentication_PollAuthSessionStatus_Response::InternalSwap(CAuthentication_PollAuthSessionStatus_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &new_challenge_url_, lhs_arena,
      &other->new_challenge_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &refresh_token_, lhs_arena,
      &other->refresh_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &access_token_, lhs_arena,
      &other->access_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &account_name_, lhs_arena,
      &other->account_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &new_guard_data_, lhs_arena,
      &other->new_guard_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &agreement_session_url_, lhs_arena,
      &other->agreement_session_url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_PollAuthSessionStatus_Response, had_remote_interaction_)
      + sizeof(CAuthentication_PollAuthSessionStatus_Response::had_remote_interaction_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_PollAuthSessionStatus_Response, new_client_id_)>(
          reinterpret_cast<char*>(&new_client_id_),
          reinterpret_cast<char*>(&other->new_client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_PollAuthSessionStatus_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[9]);
}

// ===================================================================

class CAuthentication_GetAuthSessionInfo_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_GetAuthSessionInfo_Request>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_GetAuthSessionInfo_Request::CAuthentication_GetAuthSessionInfo_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetAuthSessionInfo_Request)
}
CAuthentication_GetAuthSessionInfo_Request::CAuthentication_GetAuthSessionInfo_Request(const CAuthentication_GetAuthSessionInfo_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  client_id_ = from.client_id_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetAuthSessionInfo_Request)
}

inline void CAuthentication_GetAuthSessionInfo_Request::SharedCtor() {
client_id_ = uint64_t{0u};
}

CAuthentication_GetAuthSessionInfo_Request::~CAuthentication_GetAuthSessionInfo_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_GetAuthSessionInfo_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_GetAuthSessionInfo_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthentication_GetAuthSessionInfo_Request::ArenaDtor(void* object) {
  CAuthentication_GetAuthSessionInfo_Request* _this = reinterpret_cast< CAuthentication_GetAuthSessionInfo_Request* >(object);
  (void)_this;
}
void CAuthentication_GetAuthSessionInfo_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_GetAuthSessionInfo_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_GetAuthSessionInfo_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_GetAuthSessionInfo_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_GetAuthSessionInfo_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1 [(.description) = "client ID from scanned QR Code, used for routing"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_GetAuthSessionInfo_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_GetAuthSessionInfo_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1 [(.description) = "client ID from scanned QR Code, used for routing"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_GetAuthSessionInfo_Request)
  return target;
}

size_t CAuthentication_GetAuthSessionInfo_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_GetAuthSessionInfo_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 client_id = 1 [(.description) = "client ID from scanned QR Code, used for routing"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetAuthSessionInfo_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_GetAuthSessionInfo_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetAuthSessionInfo_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_GetAuthSessionInfo_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_GetAuthSessionInfo_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_GetAuthSessionInfo_Request &>(from));
}


void CAuthentication_GetAuthSessionInfo_Request::MergeFrom(const CAuthentication_GetAuthSessionInfo_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_GetAuthSessionInfo_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_client_id()) {
    _internal_set_client_id(from._internal_client_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_GetAuthSessionInfo_Request::CopyFrom(const CAuthentication_GetAuthSessionInfo_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_GetAuthSessionInfo_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_GetAuthSessionInfo_Request::IsInitialized() const {
  return true;
}

void CAuthentication_GetAuthSessionInfo_Request::InternalSwap(CAuthentication_GetAuthSessionInfo_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(client_id_, other->client_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetAuthSessionInfo_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[10]);
}

// ===================================================================

class CAuthentication_GetAuthSessionInfo_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_GetAuthSessionInfo_Response>()._has_bits_);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_geoloc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_city(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_device_friendly_name(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_login_history(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_requestor_location_mismatch(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_high_usage_login(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_requested_persistence(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CAuthentication_GetAuthSessionInfo_Response::CAuthentication_GetAuthSessionInfo_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetAuthSessionInfo_Response)
}
CAuthentication_GetAuthSessionInfo_Response::CAuthentication_GetAuthSessionInfo_Response(const CAuthentication_GetAuthSessionInfo_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_ip()) {
    ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_ip(), 
      GetArenaForAllocation());
  }
  geoloc_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    geoloc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_geoloc()) {
    geoloc_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_geoloc(), 
      GetArenaForAllocation());
  }
  city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_city()) {
    city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_city(), 
      GetArenaForAllocation());
  }
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state(), 
      GetArenaForAllocation());
  }
  country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country(), 
      GetArenaForAllocation());
  }
  device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_device_friendly_name()) {
    device_friendly_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_device_friendly_name(), 
      GetArenaForAllocation());
  }
  ::memcpy(&platform_type_, &from.platform_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&requested_persistence_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(requested_persistence_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetAuthSessionInfo_Response)
}

inline void CAuthentication_GetAuthSessionInfo_Response::SharedCtor() {
ip_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  ip_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
geoloc_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  geoloc_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
device_friendly_name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_friendly_name_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&platform_type_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&high_usage_login_) -
    reinterpret_cast<char*>(&platform_type_)) + sizeof(high_usage_login_));
requested_persistence_ = -1;
}

CAuthentication_GetAuthSessionInfo_Response::~CAuthentication_GetAuthSessionInfo_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_GetAuthSessionInfo_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_GetAuthSessionInfo_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  ip_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  geoloc_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  city_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  country_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  device_friendly_name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_GetAuthSessionInfo_Response::ArenaDtor(void* object) {
  CAuthentication_GetAuthSessionInfo_Response* _this = reinterpret_cast< CAuthentication_GetAuthSessionInfo_Response* >(object);
  (void)_this;
}
void CAuthentication_GetAuthSessionInfo_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_GetAuthSessionInfo_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_GetAuthSessionInfo_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_GetAuthSessionInfo_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      ip_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      geoloc_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      city_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      device_friendly_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000c0u) {
    ::memset(&platform_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&version_) -
        reinterpret_cast<char*>(&platform_type_)) + sizeof(version_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&login_history_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&high_usage_login_) -
        reinterpret_cast<char*>(&login_history_)) + sizeof(high_usage_login_));
    requested_persistence_ = -1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_GetAuthSessionInfo_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string ip = 1 [(.description) = "IP address of requestor"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_ip();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.ip");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string geoloc = 2 [(.description) = "geoloc info of requestor"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_geoloc();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.geoloc");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string city = 3 [(.description) = "city of requestor"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_city();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.city");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string state = 4 [(.description) = "state of requestor"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.state");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 5 [(.description) = "country of requestor"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_country();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.country");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "platform type of requestor"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string device_friendly_name = 7 [(.description) = "name of requestor device"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_device_friendly_name();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_GetAuthSessionInfo_Response.device_friendly_name");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 8 [(.description) = "version field"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthSessionSecurityHistory login_history = 9 [default = k_EAuthSessionSecurityHistory_Invalid, (.description) = "whether the ip has previuously been used on the account successfully"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthSessionSecurityHistory_IsValid(val))) {
            _internal_set_login_history(static_cast<::EAuthSessionSecurityHistory>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool requestor_location_mismatch = 10 [(.description) = "whether the requestor location matches this requests location"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_requestor_location_mismatch(&has_bits);
          requestor_location_mismatch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool high_usage_login = 11 [(.description) = "whether this login has seen high usage recently"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_high_usage_login(&has_bits);
          high_usage_login_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESessionPersistence requested_persistence = 12 [default = k_ESessionPersistence_Invalid, (.description) = "session persistence requestor has indicated they want"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESessionPersistence_IsValid(val))) {
            _internal_set_requested_persistence(static_cast<::ESessionPersistence>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(12, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_GetAuthSessionInfo_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_GetAuthSessionInfo_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string ip = 1 [(.description) = "IP address of requestor"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_ip().data(), static_cast<int>(this->_internal_ip().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.ip");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_ip(), target);
  }

  // optional string geoloc = 2 [(.description) = "geoloc info of requestor"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_geoloc().data(), static_cast<int>(this->_internal_geoloc().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.geoloc");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_geoloc(), target);
  }

  // optional string city = 3 [(.description) = "city of requestor"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_city().data(), static_cast<int>(this->_internal_city().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.city");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_city(), target);
  }

  // optional string state = 4 [(.description) = "state of requestor"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_state().data(), static_cast<int>(this->_internal_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.state");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state(), target);
  }

  // optional string country = 5 [(.description) = "country of requestor"];
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.country");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_country(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "platform type of requestor"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_platform_type(), target);
  }

  // optional string device_friendly_name = 7 [(.description) = "name of requestor device"];
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_device_friendly_name().data(), static_cast<int>(this->_internal_device_friendly_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_GetAuthSessionInfo_Response.device_friendly_name");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_device_friendly_name(), target);
  }

  // optional int32 version = 8 [(.description) = "version field"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_version(), target);
  }

  // optional .EAuthSessionSecurityHistory login_history = 9 [default = k_EAuthSessionSecurityHistory_Invalid, (.description) = "whether the ip has previuously been used on the account successfully"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->_internal_login_history(), target);
  }

  // optional bool requestor_location_mismatch = 10 [(.description) = "whether the requestor location matches this requests location"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(10, this->_internal_requestor_location_mismatch(), target);
  }

  // optional bool high_usage_login = 11 [(.description) = "whether this login has seen high usage recently"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(11, this->_internal_high_usage_login(), target);
  }

  // optional .ESessionPersistence requested_persistence = 12 [default = k_ESessionPersistence_Invalid, (.description) = "session persistence requestor has indicated they want"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      12, this->_internal_requested_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_GetAuthSessionInfo_Response)
  return target;
}

size_t CAuthentication_GetAuthSessionInfo_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_GetAuthSessionInfo_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string ip = 1 [(.description) = "IP address of requestor"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_ip());
    }

    // optional string geoloc = 2 [(.description) = "geoloc info of requestor"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_geoloc());
    }

    // optional string city = 3 [(.description) = "city of requestor"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_city());
    }

    // optional string state = 4 [(.description) = "state of requestor"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state());
    }

    // optional string country = 5 [(.description) = "country of requestor"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string device_friendly_name = 7 [(.description) = "name of requestor device"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_device_friendly_name());
    }

    // optional .EAuthTokenPlatformType platform_type = 6 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "platform type of requestor"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional int32 version = 8 [(.description) = "version field"];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional .EAuthSessionSecurityHistory login_history = 9 [default = k_EAuthSessionSecurityHistory_Invalid, (.description) = "whether the ip has previuously been used on the account successfully"];
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_login_history());
    }

    // optional bool requestor_location_mismatch = 10 [(.description) = "whether the requestor location matches this requests location"];
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool high_usage_login = 11 [(.description) = "whether this login has seen high usage recently"];
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional .ESessionPersistence requested_persistence = 12 [default = k_ESessionPersistence_Invalid, (.description) = "session persistence requestor has indicated they want"];
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_requested_persistence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetAuthSessionInfo_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_GetAuthSessionInfo_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetAuthSessionInfo_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_GetAuthSessionInfo_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_GetAuthSessionInfo_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_GetAuthSessionInfo_Response &>(from));
}


void CAuthentication_GetAuthSessionInfo_Response::MergeFrom(const CAuthentication_GetAuthSessionInfo_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_GetAuthSessionInfo_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_ip(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_geoloc(from._internal_geoloc());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_city(from._internal_city());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000020u) {
      _internal_set_device_friendly_name(from._internal_device_friendly_name());
    }
    if (cached_has_bits & 0x00000040u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000080u) {
      version_ = from.version_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      login_history_ = from.login_history_;
    }
    if (cached_has_bits & 0x00000200u) {
      requestor_location_mismatch_ = from.requestor_location_mismatch_;
    }
    if (cached_has_bits & 0x00000400u) {
      high_usage_login_ = from.high_usage_login_;
    }
    if (cached_has_bits & 0x00000800u) {
      requested_persistence_ = from.requested_persistence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_GetAuthSessionInfo_Response::CopyFrom(const CAuthentication_GetAuthSessionInfo_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_GetAuthSessionInfo_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_GetAuthSessionInfo_Response::IsInitialized() const {
  return true;
}

void CAuthentication_GetAuthSessionInfo_Response::InternalSwap(CAuthentication_GetAuthSessionInfo_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &ip_, lhs_arena,
      &other->ip_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &geoloc_, lhs_arena,
      &other->geoloc_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &city_, lhs_arena,
      &other->city_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_, lhs_arena,
      &other->state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &device_friendly_name_, lhs_arena,
      &other->device_friendly_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_GetAuthSessionInfo_Response, high_usage_login_)
      + sizeof(CAuthentication_GetAuthSessionInfo_Response::high_usage_login_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_GetAuthSessionInfo_Response, platform_type_)>(
          reinterpret_cast<char*>(&platform_type_),
          reinterpret_cast<char*>(&other->platform_type_));
  swap(requested_persistence_, other->requested_persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetAuthSessionInfo_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[11]);
}

// ===================================================================

class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request>()._has_bits_);
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_confirm(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_persistence(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
}
CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&persistence_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(persistence_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
}

inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::SharedCtor() {
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&confirm_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(confirm_));
persistence_ = 1;
}

CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::~CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::ArenaDtor(void* object) {
  CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* _this = reinterpret_cast< CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* >(object);
  (void)_this;
}
void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    signature_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&confirm_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(confirm_));
    persistence_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 version = 1 [(.description) = "version field"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_version(&has_bits);
          version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 client_id = 2 [(.description) = "pending client ID, from scanned QR Code"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 3 [(.description) = "user who wants to login"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 4 [(.description) = "HMAC digest over {version,client_id,steamid} via user\'s private key"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool confirm = 5 [default = false, (.description) = "Whether to confirm the login (true) or deny the login (false)"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_confirm(&has_bits);
          confirm_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .ESessionPersistence persistence = 6 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESessionPersistence_IsValid(val))) {
            _internal_set_persistence(static_cast<::ESessionPersistence>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 version = 1 [(.description) = "version field"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_version(), target);
  }

  // optional uint64 client_id = 2 [(.description) = "pending client ID, from scanned QR Code"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->_internal_client_id(), target);
  }

  // optional fixed64 steamid = 3 [(.description) = "user who wants to login"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(3, this->_internal_steamid(), target);
  }

  // optional bytes signature = 4 [(.description) = "HMAC digest over {version,client_id,steamid} via user\'s private key"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  // optional bool confirm = 5 [default = false, (.description) = "Whether to confirm the login (true) or deny the login (false)"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_confirm(), target);
  }

  // optional .ESessionPersistence persistence = 6 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->_internal_persistence(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  return target;
}

size_t CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional bytes signature = 4 [(.description) = "HMAC digest over {version,client_id,steamid} via user\'s private key"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional uint64 client_id = 2 [(.description) = "pending client ID, from scanned QR Code"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional fixed64 steamid = 3 [(.description) = "user who wants to login"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional int32 version = 1 [(.description) = "version field"];
    if (cached_has_bits & 0x00000008u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

    // optional bool confirm = 5 [default = false, (.description) = "Whether to confirm the login (true) or deny the login (false)"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional .ESessionPersistence persistence = 6 [default = k_ESessionPersistence_Persistent, (.description) = "whether we are requesting a persistent or an ephemeral session"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_persistence());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request &>(from));
}


void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::MergeFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000002u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      version_ = from.version_;
    }
    if (cached_has_bits & 0x00000010u) {
      confirm_ = from.confirm_;
    }
    if (cached_has_bits & 0x00000020u) {
      persistence_ = from.persistence_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::CopyFrom(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::IsInitialized() const {
  return true;
}

void CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::InternalSwap(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, confirm_)
      + sizeof(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::confirm_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
  swap(persistence_, other->persistence_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[12]);
}

// ===================================================================

class CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::_Internal {
 public:
};

CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response)
}
CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response(const CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[13]);
}

// ===================================================================

class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request>()._has_bits_);
  static void set_has_client_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_code(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_code_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
}
CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_code()) {
    code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_code(), 
      GetArenaForAllocation());
  }
  ::memcpy(&client_id_, &from.client_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&code_type_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(code_type_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
}

inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::SharedCtor() {
code_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  code_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&client_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&code_type_) -
    reinterpret_cast<char*>(&client_id_)) + sizeof(code_type_));
}

CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::~CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  code_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::ArenaDtor(void* object) {
  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* _this = reinterpret_cast< CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* >(object);
  (void)_this;
}
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    code_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&client_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&code_type_) -
        reinterpret_cast<char*>(&client_id_)) + sizeof(code_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 client_id = 1 [(.description) = "pending client ID, from initialized session"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_client_id(&has_bits);
          client_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2 [(.description) = "user who wants to login"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string code = 3 [(.description) = "confirmation code"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_code();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthSessionGuardType code_type = 4 [default = k_EAuthSessionGuardType_Unknown, (.description) = "type of confirmation code"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthSessionGuardType_IsValid(val))) {
            _internal_set_code_type(static_cast<::EAuthSessionGuardType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint64 client_id = 1 [(.description) = "pending client ID, from initialized session"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_id(), target);
  }

  // optional fixed64 steamid = 2 [(.description) = "user who wants to login"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional string code = 3 [(.description) = "confirmation code"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_code().data(), static_cast<int>(this->_internal_code().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request.code");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_code(), target);
  }

  // optional .EAuthSessionGuardType code_type = 4 [default = k_EAuthSessionGuardType_Unknown, (.description) = "type of confirmation code"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_code_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  return target;
}

size_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string code = 3 [(.description) = "confirmation code"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_code());
    }

    // optional uint64 client_id = 1 [(.description) = "pending client ID, from initialized session"];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64SizePlusOne(this->_internal_client_id());
    }

    // optional fixed64 steamid = 2 [(.description) = "user who wants to login"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .EAuthSessionGuardType code_type = 4 [default = k_EAuthSessionGuardType_Unknown, (.description) = "type of confirmation code"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_code_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request &>(from));
}


void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::MergeFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_code(from._internal_code());
    }
    if (cached_has_bits & 0x00000002u) {
      client_id_ = from.client_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      code_type_ = from.code_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::CopyFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::IsInitialized() const {
  return true;
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::InternalSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &code_, lhs_arena,
      &other->code_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, code_type_)
      + sizeof(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::code_type_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request, client_id_)>(
          reinterpret_cast<char*>(&client_id_),
          reinterpret_cast<char*>(&other->client_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[14]);
}

// ===================================================================

class CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response>()._has_bits_);
  static void set_has_agreement_session_url(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
}
CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_agreement_session_url()) {
    agreement_session_url_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_agreement_session_url(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
}

inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::SharedCtor() {
agreement_session_url_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  agreement_session_url_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::~CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  agreement_session_url_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::ArenaDtor(void* object) {
  CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* _this = reinterpret_cast< CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* >(object);
  (void)_this;
}
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    agreement_session_url_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_agreement_session_url();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_agreement_session_url().data(), static_cast<int>(this->_internal_agreement_session_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response.agreement_session_url");
    target = stream->WriteStringMaybeAliased(
        7, this->_internal_agreement_session_url(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  return target;
}

size_t CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string agreement_session_url = 7 [(.description) = "agreement the user needs to agree to"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_agreement_session_url());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response &>(from));
}


void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::MergeFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_agreement_session_url()) {
    _internal_set_agreement_session_url(from._internal_agreement_session_url());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::CopyFrom(const CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::IsInitialized() const {
  return true;
}

void CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::InternalSwap(CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &agreement_session_url_, lhs_arena,
      &other->agreement_session_url_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[15]);
}

// ===================================================================

class CAuthentication_AccessToken_GenerateForApp_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_AccessToken_GenerateForApp_Request>()._has_bits_);
  static void set_has_refresh_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_renewal_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CAuthentication_AccessToken_GenerateForApp_Request::CAuthentication_AccessToken_GenerateForApp_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_AccessToken_GenerateForApp_Request)
}
CAuthentication_AccessToken_GenerateForApp_Request::CAuthentication_AccessToken_GenerateForApp_Request(const CAuthentication_AccessToken_GenerateForApp_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_refresh_token()) {
    refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_refresh_token(), 
      GetArenaForAllocation());
  }
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&renewal_type_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(renewal_type_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_AccessToken_GenerateForApp_Request)
}

inline void CAuthentication_AccessToken_GenerateForApp_Request::SharedCtor() {
refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&renewal_type_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(renewal_type_));
}

CAuthentication_AccessToken_GenerateForApp_Request::~CAuthentication_AccessToken_GenerateForApp_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_AccessToken_GenerateForApp_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_AccessToken_GenerateForApp_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  refresh_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_AccessToken_GenerateForApp_Request::ArenaDtor(void* object) {
  CAuthentication_AccessToken_GenerateForApp_Request* _this = reinterpret_cast< CAuthentication_AccessToken_GenerateForApp_Request* >(object);
  (void)_this;
}
void CAuthentication_AccessToken_GenerateForApp_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_AccessToken_GenerateForApp_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_AccessToken_GenerateForApp_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_AccessToken_GenerateForApp_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    refresh_token_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&renewal_type_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(renewal_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_AccessToken_GenerateForApp_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string refresh_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_refresh_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_AccessToken_GenerateForApp_Request.refresh_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .ETokenRenewalType renewal_type = 3 [default = k_ETokenRenewalType_None];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ETokenRenewalType_IsValid(val))) {
            _internal_set_renewal_type(static_cast<::ETokenRenewalType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_AccessToken_GenerateForApp_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_AccessToken_GenerateForApp_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string refresh_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_refresh_token().data(), static_cast<int>(this->_internal_refresh_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_AccessToken_GenerateForApp_Request.refresh_token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_refresh_token(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional .ETokenRenewalType renewal_type = 3 [default = k_ETokenRenewalType_None];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_renewal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_AccessToken_GenerateForApp_Request)
  return target;
}

size_t CAuthentication_AccessToken_GenerateForApp_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_AccessToken_GenerateForApp_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string refresh_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_refresh_token());
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional .ETokenRenewalType renewal_type = 3 [default = k_ETokenRenewalType_None];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_renewal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_AccessToken_GenerateForApp_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_AccessToken_GenerateForApp_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_AccessToken_GenerateForApp_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_AccessToken_GenerateForApp_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_AccessToken_GenerateForApp_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_AccessToken_GenerateForApp_Request &>(from));
}


void CAuthentication_AccessToken_GenerateForApp_Request::MergeFrom(const CAuthentication_AccessToken_GenerateForApp_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_AccessToken_GenerateForApp_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_refresh_token(from._internal_refresh_token());
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      renewal_type_ = from.renewal_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_AccessToken_GenerateForApp_Request::CopyFrom(const CAuthentication_AccessToken_GenerateForApp_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_AccessToken_GenerateForApp_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_AccessToken_GenerateForApp_Request::IsInitialized() const {
  return true;
}

void CAuthentication_AccessToken_GenerateForApp_Request::InternalSwap(CAuthentication_AccessToken_GenerateForApp_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &refresh_token_, lhs_arena,
      &other->refresh_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_AccessToken_GenerateForApp_Request, renewal_type_)
      + sizeof(CAuthentication_AccessToken_GenerateForApp_Request::renewal_type_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_AccessToken_GenerateForApp_Request, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_AccessToken_GenerateForApp_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[16]);
}

// ===================================================================

class CAuthentication_AccessToken_GenerateForApp_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_AccessToken_GenerateForApp_Response>()._has_bits_);
  static void set_has_access_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_refresh_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthentication_AccessToken_GenerateForApp_Response::CAuthentication_AccessToken_GenerateForApp_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_AccessToken_GenerateForApp_Response)
}
CAuthentication_AccessToken_GenerateForApp_Response::CAuthentication_AccessToken_GenerateForApp_Response(const CAuthentication_AccessToken_GenerateForApp_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_access_token()) {
    access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_access_token(), 
      GetArenaForAllocation());
  }
  refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_refresh_token()) {
    refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_refresh_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CAuthentication_AccessToken_GenerateForApp_Response)
}

inline void CAuthentication_AccessToken_GenerateForApp_Response::SharedCtor() {
access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CAuthentication_AccessToken_GenerateForApp_Response::~CAuthentication_AccessToken_GenerateForApp_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_AccessToken_GenerateForApp_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_AccessToken_GenerateForApp_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  access_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  refresh_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_AccessToken_GenerateForApp_Response::ArenaDtor(void* object) {
  CAuthentication_AccessToken_GenerateForApp_Response* _this = reinterpret_cast< CAuthentication_AccessToken_GenerateForApp_Response* >(object);
  (void)_this;
}
void CAuthentication_AccessToken_GenerateForApp_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_AccessToken_GenerateForApp_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_AccessToken_GenerateForApp_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_AccessToken_GenerateForApp_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      access_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      refresh_token_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_AccessToken_GenerateForApp_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string access_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_access_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_AccessToken_GenerateForApp_Response.access_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string refresh_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_refresh_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_AccessToken_GenerateForApp_Response.refresh_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_AccessToken_GenerateForApp_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_AccessToken_GenerateForApp_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string access_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_access_token().data(), static_cast<int>(this->_internal_access_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_AccessToken_GenerateForApp_Response.access_token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_access_token(), target);
  }

  // optional string refresh_token = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_refresh_token().data(), static_cast<int>(this->_internal_refresh_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_AccessToken_GenerateForApp_Response.refresh_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_refresh_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_AccessToken_GenerateForApp_Response)
  return target;
}

size_t CAuthentication_AccessToken_GenerateForApp_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_AccessToken_GenerateForApp_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string access_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_access_token());
    }

    // optional string refresh_token = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_refresh_token());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_AccessToken_GenerateForApp_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_AccessToken_GenerateForApp_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_AccessToken_GenerateForApp_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_AccessToken_GenerateForApp_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_AccessToken_GenerateForApp_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_AccessToken_GenerateForApp_Response &>(from));
}


void CAuthentication_AccessToken_GenerateForApp_Response::MergeFrom(const CAuthentication_AccessToken_GenerateForApp_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_AccessToken_GenerateForApp_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_access_token(from._internal_access_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_refresh_token(from._internal_refresh_token());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_AccessToken_GenerateForApp_Response::CopyFrom(const CAuthentication_AccessToken_GenerateForApp_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_AccessToken_GenerateForApp_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_AccessToken_GenerateForApp_Response::IsInitialized() const {
  return true;
}

void CAuthentication_AccessToken_GenerateForApp_Response::InternalSwap(CAuthentication_AccessToken_GenerateForApp_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &access_token_, lhs_arena,
      &other->access_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &refresh_token_, lhs_arena,
      &other->refresh_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_AccessToken_GenerateForApp_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[17]);
}

// ===================================================================

class CAuthentication_RefreshToken_Enumerate_Request::_Internal {
 public:
};

CAuthentication_RefreshToken_Enumerate_Request::CAuthentication_RefreshToken_Enumerate_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Enumerate_Request)
}
CAuthentication_RefreshToken_Enumerate_Request::CAuthentication_RefreshToken_Enumerate_Request(const CAuthentication_RefreshToken_Enumerate_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Enumerate_Request)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Enumerate_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Enumerate_Request::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Enumerate_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[18]);
}

// ===================================================================

class CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::CMsgIPAddress& ip(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* msg);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_locale(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_city(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgIPAddress&
CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_Internal::ip(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* msg) {
  return *msg->ip_;
}
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::clear_ip() {
  if (ip_ != nullptr) ip_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
}
CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  locale_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_locale()) {
    locale_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_locale(), 
      GetArenaForAllocation());
  }
  country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country(), 
      GetArenaForAllocation());
  }
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state(), 
      GetArenaForAllocation());
  }
  city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_city()) {
    city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_city(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_ip()) {
    ip_ = new ::CMsgIPAddress(*from.ip_);
  } else {
    ip_ = nullptr;
  }
  time_ = from.time_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
}

inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::SharedCtor() {
locale_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  locale_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_) -
    reinterpret_cast<char*>(&ip_)) + sizeof(time_));
}

CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::~CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent() {
  // @@protoc_insertion_point(destructor:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  locale_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  country_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  city_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete ip_;
}

void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::ArenaDtor(void* object) {
  CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* _this = reinterpret_cast< CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* >(object);
  (void)_this;
}
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      locale_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      city_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(ip_ != nullptr);
      ip_->Clear();
    }
  }
  time_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string locale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_locale();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 4 [(.description) = "Location (country code) of event, as inferred from IP"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_country();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string state = 5 [(.description) = "Location (state code) of event, as inferred from IP"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string city = 6 [(.description) = "Location (city) of event, as inferred from IP"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_city();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time(), target);
  }

  // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ip(this), target, stream);
  }

  // optional string locale = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_locale().data(), static_cast<int>(this->_internal_locale().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.locale");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_locale(), target);
  }

  // optional string country = 4 [(.description) = "Location (country code) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.country");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_country(), target);
  }

  // optional string state = 5 [(.description) = "Location (state code) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_state().data(), static_cast<int>(this->_internal_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.state");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_state(), target);
  }

  // optional string city = 6 [(.description) = "Location (city) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_city().data(), static_cast<int>(this->_internal_city().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent.city");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_city(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  return target;
}

size_t CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional string locale = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_locale());
    }

    // optional string country = 4 [(.description) = "Location (country code) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string state = 5 [(.description) = "Location (state code) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state());
    }

    // optional string city = 6 [(.description) = "Location (city) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_city());
    }

    // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_);
    }

    // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::GetClassData() const { return &_class_data_; }

void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent *>(to)->MergeFrom(
      static_cast<const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent &>(from));
}


void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_locale(from._internal_locale());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_set_city(from._internal_city());
    }
    if (cached_has_bits & 0x00000010u) {
      _internal_mutable_ip()->::CMsgIPAddress::MergeFrom(from._internal_ip());
    }
    if (cached_has_bits & 0x00000020u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::IsInitialized() const {
  return true;
}

void CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::InternalSwap(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &locale_, lhs_arena,
      &other->locale_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_, lhs_arena,
      &other->state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &city_, lhs_arena,
      &other->city_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, time_)
      + sizeof(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::time_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent, ip_)>(
          reinterpret_cast<char*>(&ip_),
          reinterpret_cast<char*>(&other->ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[19]);
}

// ===================================================================

class CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_token_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_logged_in(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_os_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_auth_type(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_gaming_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& first_seen(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* msg);
  static void set_has_first_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent& last_seen(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* msg);
  static void set_has_last_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&
CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_Internal::first_seen(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* msg) {
  return *msg->first_seen_;
}
const ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent&
CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_Internal::last_seen(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* msg) {
  return *msg->last_seen_;
}
CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
}
CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token_description()) {
    token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_first_seen()) {
    first_seen_ = new ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(*from.first_seen_);
  } else {
    first_seen_ = nullptr;
  }
  if (from._internal_has_last_seen()) {
    last_seen_ = new ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent(*from.last_seen_);
  } else {
    last_seen_ = nullptr;
  }
  ::memcpy(&token_id_, &from.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&os_type_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(os_type_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
}

inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::SharedCtor() {
token_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_seen_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&os_type_) -
    reinterpret_cast<char*>(&first_seen_)) + sizeof(os_type_));
}

CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::~CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription() {
  // @@protoc_insertion_point(destructor:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete first_seen_;
  if (this != internal_default_instance()) delete last_seen_;
}

void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::ArenaDtor(void* object) {
  CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* _this = reinterpret_cast< CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* >(object);
  (void)_this;
}
void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      token_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(first_seen_ != nullptr);
      first_seen_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(last_seen_ != nullptr);
      last_seen_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&os_platform_) -
        reinterpret_cast<char*>(&token_id_)) + sizeof(os_platform_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&auth_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&os_type_) -
        reinterpret_cast<char*>(&auth_type_)) + sizeof(os_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1 [(.description) = "Persistent token/device identifier"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string token_description = 2 [(.description) = "client-supplied friendly name for the device"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_updated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time_updated(&has_bits);
          time_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "gross platform type (mobile/client/browser)"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bool logged_in = 5 [(.description) = "If true, this token is currently valid. False indicates it is a machine token - ok for steamguard if you know the credential"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_logged_in(&has_bits);
          logged_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 os_platform = 6 [(.description) = "EPlatformType - rough classification of device OS, if known"];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_os_platform(&has_bits);
          os_platform_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_type = 7 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_auth_type(&has_bits);
          auth_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gaming_device_type = 8 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_gaming_device_type(&has_bits);
          gaming_device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent first_seen = 9 [(.description) = "Information about original authorization event"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_seen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent last_seen = 10 [(.description) = "Information about most-recently seen, if known for this device"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_seen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 os_type = 11 [(.description) = "EOSType - specific device OS, if known"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_os_type(&has_bits);
          os_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1 [(.description) = "Persistent token/device identifier"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  // optional string token_description = 2 [(.description) = "client-supplied friendly name for the device"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token_description().data(), static_cast<int>(this->_internal_token_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription.token_description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token_description(), target);
  }

  // optional uint32 time_updated = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_time_updated(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "gross platform type (mobile/client/browser)"];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_platform_type(), target);
  }

  // optional bool logged_in = 5 [(.description) = "If true, this token is currently valid. False indicates it is a machine token - ok for steamguard if you know the credential"];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_logged_in(), target);
  }

  // optional uint32 os_platform = 6 [(.description) = "EPlatformType - rough classification of device OS, if known"];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_os_platform(), target);
  }

  // optional uint32 auth_type = 7 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_auth_type(), target);
  }

  // optional uint32 gaming_device_type = 8 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(8, this->_internal_gaming_device_type(), target);
  }

  // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent first_seen = 9 [(.description) = "Information about original authorization event"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        9, _Internal::first_seen(this), target, stream);
  }

  // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent last_seen = 10 [(.description) = "Information about most-recently seen, if known for this device"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        10, _Internal::last_seen(this), target, stream);
  }

  // optional int32 os_type = 11 [(.description) = "EOSType - specific device OS, if known"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(11, this->_internal_os_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  return target;
}

size_t CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string token_description = 2 [(.description) = "client-supplied friendly name for the device"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token_description());
    }

    // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent first_seen = 9 [(.description) = "Information about original authorization event"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *first_seen_);
    }

    // optional .CAuthentication_RefreshToken_Enumerate_Response.TokenUsageEvent last_seen = 10 [(.description) = "Information about most-recently seen, if known for this device"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *last_seen_);
    }

    // optional fixed64 token_id = 1 [(.description) = "Persistent token/device identifier"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional uint32 time_updated = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time_updated());
    }

    // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown, (.description) = "gross platform type (mobile/client/browser)"];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional bool logged_in = 5 [(.description) = "If true, this token is currently valid. False indicates it is a machine token - ok for steamguard if you know the credential"];
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional uint32 os_platform = 6 [(.description) = "EPlatformType - rough classification of device OS, if known"];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_os_platform());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional uint32 auth_type = 7 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_auth_type());
    }

    // optional uint32 gaming_device_type = 8 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gaming_device_type());
    }

    // optional int32 os_type = 11 [(.description) = "EOSType - specific device OS, if known"];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_os_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::GetClassData() const { return &_class_data_; }

void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription *>(to)->MergeFrom(
      static_cast<const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription &>(from));
}


void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token_description(from._internal_token_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_first_seen()->::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::MergeFrom(from._internal_first_seen());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_last_seen()->::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent::MergeFrom(from._internal_last_seen());
    }
    if (cached_has_bits & 0x00000008u) {
      token_id_ = from.token_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_updated_ = from.time_updated_;
    }
    if (cached_has_bits & 0x00000020u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      logged_in_ = from.logged_in_;
    }
    if (cached_has_bits & 0x00000080u) {
      os_platform_ = from.os_platform_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      auth_type_ = from.auth_type_;
    }
    if (cached_has_bits & 0x00000200u) {
      gaming_device_type_ = from.gaming_device_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      os_type_ = from.os_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::IsInitialized() const {
  return true;
}

void CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::InternalSwap(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_description_, lhs_arena,
      &other->token_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, os_type_)
      + sizeof(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::os_type_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription, first_seen_)>(
          reinterpret_cast<char*>(&first_seen_),
          reinterpret_cast<char*>(&other->first_seen_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[20]);
}

// ===================================================================

class CAuthentication_RefreshToken_Enumerate_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_RefreshToken_Enumerate_Response>()._has_bits_);
  static void set_has_requesting_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_RefreshToken_Enumerate_Response::CAuthentication_RefreshToken_Enumerate_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  refresh_tokens_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Enumerate_Response)
}
CAuthentication_RefreshToken_Enumerate_Response::CAuthentication_RefreshToken_Enumerate_Response(const CAuthentication_RefreshToken_Enumerate_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      refresh_tokens_(from.refresh_tokens_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  requesting_token_ = from.requesting_token_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Enumerate_Response)
}

inline void CAuthentication_RefreshToken_Enumerate_Response::SharedCtor() {
requesting_token_ = uint64_t{0u};
}

CAuthentication_RefreshToken_Enumerate_Response::~CAuthentication_RefreshToken_Enumerate_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_RefreshToken_Enumerate_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_RefreshToken_Enumerate_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthentication_RefreshToken_Enumerate_Response::ArenaDtor(void* object) {
  CAuthentication_RefreshToken_Enumerate_Response* _this = reinterpret_cast< CAuthentication_RefreshToken_Enumerate_Response* >(object);
  (void)_this;
}
void CAuthentication_RefreshToken_Enumerate_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_RefreshToken_Enumerate_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_RefreshToken_Enumerate_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_RefreshToken_Enumerate_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  refresh_tokens_.Clear();
  requesting_token_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_RefreshToken_Enumerate_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription refresh_tokens = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_refresh_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 requesting_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_requesting_token(&has_bits);
          requesting_token_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_RefreshToken_Enumerate_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_RefreshToken_Enumerate_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription refresh_tokens = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_refresh_tokens_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_refresh_tokens(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional fixed64 requesting_token = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_requesting_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_RefreshToken_Enumerate_Response)
  return target;
}

size_t CAuthentication_RefreshToken_Enumerate_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_RefreshToken_Enumerate_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CAuthentication_RefreshToken_Enumerate_Response.RefreshTokenDescription refresh_tokens = 1;
  total_size += 1UL * this->_internal_refresh_tokens_size();
  for (const auto& msg : this->refresh_tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional fixed64 requesting_token = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Enumerate_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_RefreshToken_Enumerate_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Enumerate_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_RefreshToken_Enumerate_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_RefreshToken_Enumerate_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_RefreshToken_Enumerate_Response &>(from));
}


void CAuthentication_RefreshToken_Enumerate_Response::MergeFrom(const CAuthentication_RefreshToken_Enumerate_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_RefreshToken_Enumerate_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  refresh_tokens_.MergeFrom(from.refresh_tokens_);
  if (from._internal_has_requesting_token()) {
    _internal_set_requesting_token(from._internal_requesting_token());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_RefreshToken_Enumerate_Response::CopyFrom(const CAuthentication_RefreshToken_Enumerate_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_RefreshToken_Enumerate_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_RefreshToken_Enumerate_Response::IsInitialized() const {
  return true;
}

void CAuthentication_RefreshToken_Enumerate_Response::InternalSwap(CAuthentication_RefreshToken_Enumerate_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  refresh_tokens_.InternalSwap(&other->refresh_tokens_);
  swap(requesting_token_, other->requesting_token_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Enumerate_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[21]);
}

// ===================================================================

class CAuthentication_GetAuthSessionsForAccount_Request::_Internal {
 public:
};

CAuthentication_GetAuthSessionsForAccount_Request::CAuthentication_GetAuthSessionsForAccount_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetAuthSessionsForAccount_Request)
}
CAuthentication_GetAuthSessionsForAccount_Request::CAuthentication_GetAuthSessionsForAccount_Request(const CAuthentication_GetAuthSessionsForAccount_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetAuthSessionsForAccount_Request)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetAuthSessionsForAccount_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetAuthSessionsForAccount_Request::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetAuthSessionsForAccount_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[22]);
}

// ===================================================================

class CAuthentication_GetAuthSessionsForAccount_Response::_Internal {
 public:
};

CAuthentication_GetAuthSessionsForAccount_Response::CAuthentication_GetAuthSessionsForAccount_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  client_ids_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_GetAuthSessionsForAccount_Response)
}
CAuthentication_GetAuthSessionsForAccount_Response::CAuthentication_GetAuthSessionsForAccount_Response(const CAuthentication_GetAuthSessionsForAccount_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      client_ids_(from.client_ids_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_GetAuthSessionsForAccount_Response)
}

inline void CAuthentication_GetAuthSessionsForAccount_Response::SharedCtor() {
}

CAuthentication_GetAuthSessionsForAccount_Response::~CAuthentication_GetAuthSessionsForAccount_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_GetAuthSessionsForAccount_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_GetAuthSessionsForAccount_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthentication_GetAuthSessionsForAccount_Response::ArenaDtor(void* object) {
  CAuthentication_GetAuthSessionsForAccount_Response* _this = reinterpret_cast< CAuthentication_GetAuthSessionsForAccount_Response* >(object);
  (void)_this;
}
void CAuthentication_GetAuthSessionsForAccount_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_GetAuthSessionsForAccount_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_GetAuthSessionsForAccount_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_GetAuthSessionsForAccount_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  client_ids_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_GetAuthSessionsForAccount_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated uint64 client_ids = 1 [(.description) = "unique identifier of requestor, also used for routing"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_client_ids(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<8>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt64Parser(_internal_mutable_client_ids(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_GetAuthSessionsForAccount_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_GetAuthSessionsForAccount_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated uint64 client_ids = 1 [(.description) = "unique identifier of requestor, also used for routing"];
  for (int i = 0, n = this->_internal_client_ids_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->_internal_client_ids(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_GetAuthSessionsForAccount_Response)
  return target;
}

size_t CAuthentication_GetAuthSessionsForAccount_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_GetAuthSessionsForAccount_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint64 client_ids = 1 [(.description) = "unique identifier of requestor, also used for routing"];
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt64Size(this->client_ids_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_client_ids_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_GetAuthSessionsForAccount_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_GetAuthSessionsForAccount_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_GetAuthSessionsForAccount_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_GetAuthSessionsForAccount_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_GetAuthSessionsForAccount_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_GetAuthSessionsForAccount_Response &>(from));
}


void CAuthentication_GetAuthSessionsForAccount_Response::MergeFrom(const CAuthentication_GetAuthSessionsForAccount_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_GetAuthSessionsForAccount_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  client_ids_.MergeFrom(from.client_ids_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_GetAuthSessionsForAccount_Response::CopyFrom(const CAuthentication_GetAuthSessionsForAccount_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_GetAuthSessionsForAccount_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_GetAuthSessionsForAccount_Response::IsInitialized() const {
  return true;
}

void CAuthentication_GetAuthSessionsForAccount_Response::InternalSwap(CAuthentication_GetAuthSessionsForAccount_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  client_ids_.InternalSwap(&other->client_ids_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_GetAuthSessionsForAccount_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[23]);
}

// ===================================================================

class CAuthentication_MigrateMobileSession_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_MigrateMobileSession_Request>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthentication_MigrateMobileSession_Request::CAuthentication_MigrateMobileSession_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_MigrateMobileSession_Request)
}
CAuthentication_MigrateMobileSession_Request::CAuthentication_MigrateMobileSession_Request(const CAuthentication_MigrateMobileSession_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  steamid_ = from.steamid_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_MigrateMobileSession_Request)
}

inline void CAuthentication_MigrateMobileSession_Request::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
steamid_ = uint64_t{0u};
}

CAuthentication_MigrateMobileSession_Request::~CAuthentication_MigrateMobileSession_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_MigrateMobileSession_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_MigrateMobileSession_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_MigrateMobileSession_Request::ArenaDtor(void* object) {
  CAuthentication_MigrateMobileSession_Request* _this = reinterpret_cast< CAuthentication_MigrateMobileSession_Request* >(object);
  (void)_this;
}
void CAuthentication_MigrateMobileSession_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_MigrateMobileSession_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_MigrateMobileSession_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_MigrateMobileSession_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      signature_.ClearNonDefaultToEmpty();
    }
  }
  steamid_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_MigrateMobileSession_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.description) = "Steam ID of the user to migrate"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string token = 2 [(.description) = "WG Token to migrate"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_MigrateMobileSession_Request.token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string signature = 3 [(.description) = "Signature over the wg token using the user\'s 2FA token"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_MigrateMobileSession_Request.signature");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_MigrateMobileSession_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_MigrateMobileSession_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.description) = "Steam ID of the user to migrate"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string token = 2 [(.description) = "WG Token to migrate"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_MigrateMobileSession_Request.token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token(), target);
  }

  // optional string signature = 3 [(.description) = "Signature over the wg token using the user\'s 2FA token"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_signature().data(), static_cast<int>(this->_internal_signature().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_MigrateMobileSession_Request.signature");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_MigrateMobileSession_Request)
  return target;
}

size_t CAuthentication_MigrateMobileSession_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_MigrateMobileSession_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string token = 2 [(.description) = "WG Token to migrate"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional string signature = 3 [(.description) = "Signature over the wg token using the user\'s 2FA token"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_signature());
    }

    // optional fixed64 steamid = 1 [(.description) = "Steam ID of the user to migrate"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_MigrateMobileSession_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_MigrateMobileSession_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_MigrateMobileSession_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_MigrateMobileSession_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_MigrateMobileSession_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_MigrateMobileSession_Request &>(from));
}


void CAuthentication_MigrateMobileSession_Request::MergeFrom(const CAuthentication_MigrateMobileSession_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_MigrateMobileSession_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_MigrateMobileSession_Request::CopyFrom(const CAuthentication_MigrateMobileSession_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_MigrateMobileSession_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_MigrateMobileSession_Request::IsInitialized() const {
  return true;
}

void CAuthentication_MigrateMobileSession_Request::InternalSwap(CAuthentication_MigrateMobileSession_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  swap(steamid_, other->steamid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_MigrateMobileSession_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[24]);
}

// ===================================================================

class CAuthentication_MigrateMobileSession_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_MigrateMobileSession_Response>()._has_bits_);
  static void set_has_refresh_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_access_token(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthentication_MigrateMobileSession_Response::CAuthentication_MigrateMobileSession_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_MigrateMobileSession_Response)
}
CAuthentication_MigrateMobileSession_Response::CAuthentication_MigrateMobileSession_Response(const CAuthentication_MigrateMobileSession_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_refresh_token()) {
    refresh_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_refresh_token(), 
      GetArenaForAllocation());
  }
  access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_access_token()) {
    access_token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_access_token(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CAuthentication_MigrateMobileSession_Response)
}

inline void CAuthentication_MigrateMobileSession_Response::SharedCtor() {
refresh_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  refresh_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
access_token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  access_token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CAuthentication_MigrateMobileSession_Response::~CAuthentication_MigrateMobileSession_Response() {
  // @@protoc_insertion_point(destructor:CAuthentication_MigrateMobileSession_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_MigrateMobileSession_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  refresh_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  access_token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_MigrateMobileSession_Response::ArenaDtor(void* object) {
  CAuthentication_MigrateMobileSession_Response* _this = reinterpret_cast< CAuthentication_MigrateMobileSession_Response* >(object);
  (void)_this;
}
void CAuthentication_MigrateMobileSession_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_MigrateMobileSession_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_MigrateMobileSession_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_MigrateMobileSession_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      refresh_token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      access_token_.ClearNonDefaultToEmpty();
    }
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_MigrateMobileSession_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string refresh_token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_refresh_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_MigrateMobileSession_Response.refresh_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string access_token = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_access_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_MigrateMobileSession_Response.access_token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_MigrateMobileSession_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_MigrateMobileSession_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string refresh_token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_refresh_token().data(), static_cast<int>(this->_internal_refresh_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_MigrateMobileSession_Response.refresh_token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_refresh_token(), target);
  }

  // optional string access_token = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_access_token().data(), static_cast<int>(this->_internal_access_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_MigrateMobileSession_Response.access_token");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_access_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_MigrateMobileSession_Response)
  return target;
}

size_t CAuthentication_MigrateMobileSession_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_MigrateMobileSession_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string refresh_token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_refresh_token());
    }

    // optional string access_token = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_access_token());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_MigrateMobileSession_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_MigrateMobileSession_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_MigrateMobileSession_Response::GetClassData() const { return &_class_data_; }

void CAuthentication_MigrateMobileSession_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_MigrateMobileSession_Response *>(to)->MergeFrom(
      static_cast<const CAuthentication_MigrateMobileSession_Response &>(from));
}


void CAuthentication_MigrateMobileSession_Response::MergeFrom(const CAuthentication_MigrateMobileSession_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_MigrateMobileSession_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_refresh_token(from._internal_refresh_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_access_token(from._internal_access_token());
    }
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_MigrateMobileSession_Response::CopyFrom(const CAuthentication_MigrateMobileSession_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_MigrateMobileSession_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_MigrateMobileSession_Response::IsInitialized() const {
  return true;
}

void CAuthentication_MigrateMobileSession_Response::InternalSwap(CAuthentication_MigrateMobileSession_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &refresh_token_, lhs_arena,
      &other->refresh_token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &access_token_, lhs_arena,
      &other->access_token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_MigrateMobileSession_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[25]);
}

// ===================================================================

class CAuthentication_Token_Revoke_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_Token_Revoke_Request>()._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_revoke_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthentication_Token_Revoke_Request::CAuthentication_Token_Revoke_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_Token_Revoke_Request)
}
CAuthentication_Token_Revoke_Request::CAuthentication_Token_Revoke_Request(const CAuthentication_Token_Revoke_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    token_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token(), 
      GetArenaForAllocation());
  }
  revoke_action_ = from.revoke_action_;
  // @@protoc_insertion_point(copy_constructor:CAuthentication_Token_Revoke_Request)
}

inline void CAuthentication_Token_Revoke_Request::SharedCtor() {
token_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
revoke_action_ = 1;
}

CAuthentication_Token_Revoke_Request::~CAuthentication_Token_Revoke_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_Token_Revoke_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_Token_Revoke_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_Token_Revoke_Request::ArenaDtor(void* object) {
  CAuthentication_Token_Revoke_Request* _this = reinterpret_cast< CAuthentication_Token_Revoke_Request* >(object);
  (void)_this;
}
void CAuthentication_Token_Revoke_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_Token_Revoke_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_Token_Revoke_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_Token_Revoke_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_.ClearNonDefaultToEmpty();
    }
    revoke_action_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_Token_Revoke_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CAuthentication_Token_Revoke_Request.token");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenRevokeAction revoke_action = 2 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenRevokeAction_IsValid(val))) {
            _internal_set_revoke_action(static_cast<::EAuthTokenRevokeAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_Token_Revoke_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_Token_Revoke_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string token = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token().data(), static_cast<int>(this->_internal_token().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CAuthentication_Token_Revoke_Request.token");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional .EAuthTokenRevokeAction revoke_action = 2 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->_internal_revoke_action(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_Token_Revoke_Request)
  return target;
}

size_t CAuthentication_Token_Revoke_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_Token_Revoke_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token());
    }

    // optional .EAuthTokenRevokeAction revoke_action = 2 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_revoke_action());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_Token_Revoke_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_Token_Revoke_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_Token_Revoke_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_Token_Revoke_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_Token_Revoke_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_Token_Revoke_Request &>(from));
}


void CAuthentication_Token_Revoke_Request::MergeFrom(const CAuthentication_Token_Revoke_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_Token_Revoke_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      revoke_action_ = from.revoke_action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_Token_Revoke_Request::CopyFrom(const CAuthentication_Token_Revoke_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_Token_Revoke_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_Token_Revoke_Request::IsInitialized() const {
  return true;
}

void CAuthentication_Token_Revoke_Request::InternalSwap(CAuthentication_Token_Revoke_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_, lhs_arena,
      &other->token_, rhs_arena
  );
  swap(revoke_action_, other->revoke_action_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_Token_Revoke_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[26]);
}

// ===================================================================

class CAuthentication_Token_Revoke_Response::_Internal {
 public:
};

CAuthentication_Token_Revoke_Response::CAuthentication_Token_Revoke_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthentication_Token_Revoke_Response)
}
CAuthentication_Token_Revoke_Response::CAuthentication_Token_Revoke_Response(const CAuthentication_Token_Revoke_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_Token_Revoke_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_Token_Revoke_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_Token_Revoke_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_Token_Revoke_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[27]);
}

// ===================================================================

class CAuthentication_RefreshToken_Revoke_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthentication_RefreshToken_Revoke_Request>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_revoke_action(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_signature(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthentication_RefreshToken_Revoke_Request::CAuthentication_RefreshToken_Revoke_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Revoke_Request)
}
CAuthentication_RefreshToken_Revoke_Request::CAuthentication_RefreshToken_Revoke_Request(const CAuthentication_RefreshToken_Revoke_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_signature()) {
    signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_signature(), 
      GetArenaForAllocation());
  }
  ::memcpy(&token_id_, &from.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&revoke_action_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(revoke_action_));
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Revoke_Request)
}

inline void CAuthentication_RefreshToken_Revoke_Request::SharedCtor() {
signature_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  signature_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&token_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steamid_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(steamid_));
revoke_action_ = 1;
}

CAuthentication_RefreshToken_Revoke_Request::~CAuthentication_RefreshToken_Revoke_Request() {
  // @@protoc_insertion_point(destructor:CAuthentication_RefreshToken_Revoke_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthentication_RefreshToken_Revoke_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  signature_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CAuthentication_RefreshToken_Revoke_Request::ArenaDtor(void* object) {
  CAuthentication_RefreshToken_Revoke_Request* _this = reinterpret_cast< CAuthentication_RefreshToken_Revoke_Request* >(object);
  (void)_this;
}
void CAuthentication_RefreshToken_Revoke_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthentication_RefreshToken_Revoke_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthentication_RefreshToken_Revoke_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthentication_RefreshToken_Revoke_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    signature_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steamid_) -
        reinterpret_cast<char*>(&token_id_)) + sizeof(steamid_));
    revoke_action_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthentication_RefreshToken_Revoke_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2 [(.description) = "Token holder if an admin action on behalf of another user"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenRevokeAction revoke_action = 3 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenRevokeAction_IsValid(val))) {
            _internal_set_revoke_action(static_cast<::EAuthTokenRevokeAction>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes signature = 4 [(.description) = "required signature over token_id"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_signature();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthentication_RefreshToken_Revoke_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthentication_RefreshToken_Revoke_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  // optional fixed64 steamid = 2 [(.description) = "Token holder if an admin action on behalf of another user"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional .EAuthTokenRevokeAction revoke_action = 3 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_revoke_action(), target);
  }

  // optional bytes signature = 4 [(.description) = "required signature over token_id"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_signature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthentication_RefreshToken_Revoke_Request)
  return target;
}

size_t CAuthentication_RefreshToken_Revoke_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthentication_RefreshToken_Revoke_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes signature = 4 [(.description) = "required signature over token_id"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_signature());
    }

    // optional fixed64 token_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional fixed64 steamid = 2 [(.description) = "Token holder if an admin action on behalf of another user"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 8;
    }

    // optional .EAuthTokenRevokeAction revoke_action = 3 [default = k_EAuthTokenRevokePermanent, (.description) = "Select between logout and logout-and-forget-machine"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_revoke_action());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Revoke_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthentication_RefreshToken_Revoke_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Revoke_Request::GetClassData() const { return &_class_data_; }

void CAuthentication_RefreshToken_Revoke_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthentication_RefreshToken_Revoke_Request *>(to)->MergeFrom(
      static_cast<const CAuthentication_RefreshToken_Revoke_Request &>(from));
}


void CAuthentication_RefreshToken_Revoke_Request::MergeFrom(const CAuthentication_RefreshToken_Revoke_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthentication_RefreshToken_Revoke_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_signature(from._internal_signature());
    }
    if (cached_has_bits & 0x00000002u) {
      token_id_ = from.token_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000008u) {
      revoke_action_ = from.revoke_action_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthentication_RefreshToken_Revoke_Request::CopyFrom(const CAuthentication_RefreshToken_Revoke_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthentication_RefreshToken_Revoke_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthentication_RefreshToken_Revoke_Request::IsInitialized() const {
  return true;
}

void CAuthentication_RefreshToken_Revoke_Request::InternalSwap(CAuthentication_RefreshToken_Revoke_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &signature_, lhs_arena,
      &other->signature_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Revoke_Request, steamid_)
      + sizeof(CAuthentication_RefreshToken_Revoke_Request::steamid_)
      - PROTOBUF_FIELD_OFFSET(CAuthentication_RefreshToken_Revoke_Request, token_id_)>(
          reinterpret_cast<char*>(&token_id_),
          reinterpret_cast<char*>(&other->token_id_));
  swap(revoke_action_, other->revoke_action_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Revoke_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[28]);
}

// ===================================================================

class CAuthentication_RefreshToken_Revoke_Response::_Internal {
 public:
};

CAuthentication_RefreshToken_Revoke_Response::CAuthentication_RefreshToken_Revoke_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthentication_RefreshToken_Revoke_Response)
}
CAuthentication_RefreshToken_Revoke_Response::CAuthentication_RefreshToken_Revoke_Response(const CAuthentication_RefreshToken_Revoke_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthentication_RefreshToken_Revoke_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthentication_RefreshToken_Revoke_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthentication_RefreshToken_Revoke_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthentication_RefreshToken_Revoke_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[29]);
}

// ===================================================================

class CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationSupport_QueryRefreshTokensByAccount_Request>()._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_include_revoked_tokens(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthenticationSupport_QueryRefreshTokensByAccount_Request::CAuthenticationSupport_QueryRefreshTokensByAccount_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
}
CAuthenticationSupport_QueryRefreshTokensByAccount_Request::CAuthenticationSupport_QueryRefreshTokensByAccount_Request(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&steamid_, &from.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&include_revoked_tokens_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(include_revoked_tokens_));
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
}

inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&steamid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&include_revoked_tokens_) -
    reinterpret_cast<char*>(&steamid_)) + sizeof(include_revoked_tokens_));
}

CAuthenticationSupport_QueryRefreshTokensByAccount_Request::~CAuthenticationSupport_QueryRefreshTokensByAccount_Request() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::ArenaDtor(void* object) {
  CAuthenticationSupport_QueryRefreshTokensByAccount_Request* _this = reinterpret_cast< CAuthenticationSupport_QueryRefreshTokensByAccount_Request* >(object);
  (void)_this;
}
void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&include_revoked_tokens_) -
        reinterpret_cast<char*>(&steamid_)) + sizeof(include_revoked_tokens_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 steamid = 1 [(.description) = "SteamID of the account to query (required)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional bool include_revoked_tokens = 2 [(.description) = "Includes tokens that are revoked or expired in the query"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_include_revoked_tokens(&has_bits);
          include_revoked_tokens_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 steamid = 1 [(.description) = "SteamID of the account to query (required)"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_steamid(), target);
  }

  // optional bool include_revoked_tokens = 2 [(.description) = "Includes tokens that are revoked or expired in the query"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_include_revoked_tokens(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  return target;
}

size_t CAuthenticationSupport_QueryRefreshTokensByAccount_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 steamid = 1 [(.description) = "SteamID of the account to query (required)"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional bool include_revoked_tokens = 2 [(.description) = "Includes tokens that are revoked or expired in the query"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_QueryRefreshTokensByAccount_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_QueryRefreshTokensByAccount_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_QueryRefreshTokensByAccount_Request::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_QueryRefreshTokensByAccount_Request *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_QueryRefreshTokensByAccount_Request &>(from));
}


void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::MergeFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      steamid_ = from.steamid_;
    }
    if (cached_has_bits & 0x00000002u) {
      include_revoked_tokens_ = from.include_revoked_tokens_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::CopyFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_QueryRefreshTokensByAccount_Request::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Request::InternalSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthenticationSupport_QueryRefreshTokensByAccount_Request, include_revoked_tokens_)
      + sizeof(CAuthenticationSupport_QueryRefreshTokensByAccount_Request::include_revoked_tokens_)
      - PROTOBUF_FIELD_OFFSET(CAuthenticationSupport_QueryRefreshTokensByAccount_Request, steamid_)>(
          reinterpret_cast<char*>(&steamid_),
          reinterpret_cast<char*>(&other->steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_QueryRefreshTokensByAccount_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[30]);
}

// ===================================================================

class CSupportRefreshTokenDescription_TokenUsageEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CSupportRefreshTokenDescription_TokenUsageEvent>()._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgIPAddress& ip(const CSupportRefreshTokenDescription_TokenUsageEvent* msg);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_country(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_city(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgIPAddress&
CSupportRefreshTokenDescription_TokenUsageEvent::_Internal::ip(const CSupportRefreshTokenDescription_TokenUsageEvent* msg) {
  return *msg->ip_;
}
void CSupportRefreshTokenDescription_TokenUsageEvent::clear_ip() {
  if (ip_ != nullptr) ip_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
CSupportRefreshTokenDescription_TokenUsageEvent::CSupportRefreshTokenDescription_TokenUsageEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSupportRefreshTokenDescription.TokenUsageEvent)
}
CSupportRefreshTokenDescription_TokenUsageEvent::CSupportRefreshTokenDescription_TokenUsageEvent(const CSupportRefreshTokenDescription_TokenUsageEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_country()) {
    country_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_country(), 
      GetArenaForAllocation());
  }
  state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_state()) {
    state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_state(), 
      GetArenaForAllocation());
  }
  city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_city()) {
    city_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_city(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_ip()) {
    ip_ = new ::CMsgIPAddress(*from.ip_);
  } else {
    ip_ = nullptr;
  }
  time_ = from.time_;
  // @@protoc_insertion_point(copy_constructor:CSupportRefreshTokenDescription.TokenUsageEvent)
}

inline void CSupportRefreshTokenDescription_TokenUsageEvent::SharedCtor() {
country_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  country_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
state_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
city_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  city_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&time_) -
    reinterpret_cast<char*>(&ip_)) + sizeof(time_));
}

CSupportRefreshTokenDescription_TokenUsageEvent::~CSupportRefreshTokenDescription_TokenUsageEvent() {
  // @@protoc_insertion_point(destructor:CSupportRefreshTokenDescription.TokenUsageEvent)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSupportRefreshTokenDescription_TokenUsageEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  country_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  state_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  city_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete ip_;
}

void CSupportRefreshTokenDescription_TokenUsageEvent::ArenaDtor(void* object) {
  CSupportRefreshTokenDescription_TokenUsageEvent* _this = reinterpret_cast< CSupportRefreshTokenDescription_TokenUsageEvent* >(object);
  (void)_this;
}
void CSupportRefreshTokenDescription_TokenUsageEvent::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSupportRefreshTokenDescription_TokenUsageEvent::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSupportRefreshTokenDescription_TokenUsageEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CSupportRefreshTokenDescription.TokenUsageEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      country_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      state_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      city_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(ip_ != nullptr);
      ip_->Clear();
    }
  }
  time_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSupportRefreshTokenDescription_TokenUsageEvent::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string country = 3 [(.description) = "Location (country code) of event, as inferred from IP"];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_country();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSupportRefreshTokenDescription.TokenUsageEvent.country");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string state = 4 [(.description) = "Location (state code) of event, as inferred from IP"];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_state();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSupportRefreshTokenDescription.TokenUsageEvent.state");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string city = 5 [(.description) = "Location (city) of event, as inferred from IP"];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_city();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSupportRefreshTokenDescription.TokenUsageEvent.city");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSupportRefreshTokenDescription_TokenUsageEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSupportRefreshTokenDescription.TokenUsageEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_time(), target);
  }

  // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::ip(this), target, stream);
  }

  // optional string country = 3 [(.description) = "Location (country code) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_country().data(), static_cast<int>(this->_internal_country().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSupportRefreshTokenDescription.TokenUsageEvent.country");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_country(), target);
  }

  // optional string state = 4 [(.description) = "Location (state code) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_state().data(), static_cast<int>(this->_internal_state().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSupportRefreshTokenDescription.TokenUsageEvent.state");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_state(), target);
  }

  // optional string city = 5 [(.description) = "Location (city) of event, as inferred from IP"];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_city().data(), static_cast<int>(this->_internal_city().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSupportRefreshTokenDescription.TokenUsageEvent.city");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_city(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSupportRefreshTokenDescription.TokenUsageEvent)
  return target;
}

size_t CSupportRefreshTokenDescription_TokenUsageEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSupportRefreshTokenDescription.TokenUsageEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string country = 3 [(.description) = "Location (country code) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_country());
    }

    // optional string state = 4 [(.description) = "Location (state code) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_state());
    }

    // optional string city = 5 [(.description) = "Location (city) of event, as inferred from IP"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_city());
    }

    // optional .CMsgIPAddress ip = 2 [(.description) = "IP at which event was observed"];
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_);
    }

    // optional uint32 time = 1 [(.description) = "Approximate time of history event (may be deliberately fuzzed or omitted)"];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSupportRefreshTokenDescription_TokenUsageEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSupportRefreshTokenDescription_TokenUsageEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSupportRefreshTokenDescription_TokenUsageEvent::GetClassData() const { return &_class_data_; }

void CSupportRefreshTokenDescription_TokenUsageEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSupportRefreshTokenDescription_TokenUsageEvent *>(to)->MergeFrom(
      static_cast<const CSupportRefreshTokenDescription_TokenUsageEvent &>(from));
}


void CSupportRefreshTokenDescription_TokenUsageEvent::MergeFrom(const CSupportRefreshTokenDescription_TokenUsageEvent& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSupportRefreshTokenDescription.TokenUsageEvent)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_country(from._internal_country());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_set_state(from._internal_state());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_set_city(from._internal_city());
    }
    if (cached_has_bits & 0x00000008u) {
      _internal_mutable_ip()->::CMsgIPAddress::MergeFrom(from._internal_ip());
    }
    if (cached_has_bits & 0x00000010u) {
      time_ = from.time_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSupportRefreshTokenDescription_TokenUsageEvent::CopyFrom(const CSupportRefreshTokenDescription_TokenUsageEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSupportRefreshTokenDescription.TokenUsageEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSupportRefreshTokenDescription_TokenUsageEvent::IsInitialized() const {
  return true;
}

void CSupportRefreshTokenDescription_TokenUsageEvent::InternalSwap(CSupportRefreshTokenDescription_TokenUsageEvent* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &country_, lhs_arena,
      &other->country_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &state_, lhs_arena,
      &other->state_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &city_, lhs_arena,
      &other->city_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenDescription_TokenUsageEvent, time_)
      + sizeof(CSupportRefreshTokenDescription_TokenUsageEvent::time_)
      - PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenDescription_TokenUsageEvent, ip_)>(
          reinterpret_cast<char*>(&ip_),
          reinterpret_cast<char*>(&other->ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSupportRefreshTokenDescription_TokenUsageEvent::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[31]);
}

// ===================================================================

class CSupportRefreshTokenDescription::_Internal {
 public:
  using HasBits = decltype(std::declval<CSupportRefreshTokenDescription>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_token_description(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_time_updated(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_platform_type(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_token_state(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_owner_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_os_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_os_type(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_auth_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_gaming_device_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::CSupportRefreshTokenDescription_TokenUsageEvent& first_seen(const CSupportRefreshTokenDescription* msg);
  static void set_has_first_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CSupportRefreshTokenDescription_TokenUsageEvent& last_seen(const CSupportRefreshTokenDescription* msg);
  static void set_has_last_seen(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CSupportRefreshTokenDescription_TokenUsageEvent&
CSupportRefreshTokenDescription::_Internal::first_seen(const CSupportRefreshTokenDescription* msg) {
  return *msg->first_seen_;
}
const ::CSupportRefreshTokenDescription_TokenUsageEvent&
CSupportRefreshTokenDescription::_Internal::last_seen(const CSupportRefreshTokenDescription* msg) {
  return *msg->last_seen_;
}
CSupportRefreshTokenDescription::CSupportRefreshTokenDescription(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSupportRefreshTokenDescription)
}
CSupportRefreshTokenDescription::CSupportRefreshTokenDescription(const CSupportRefreshTokenDescription& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token_description()) {
    token_description_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_token_description(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_first_seen()) {
    first_seen_ = new ::CSupportRefreshTokenDescription_TokenUsageEvent(*from.first_seen_);
  } else {
    first_seen_ = nullptr;
  }
  if (from._internal_has_last_seen()) {
    last_seen_ = new ::CSupportRefreshTokenDescription_TokenUsageEvent(*from.last_seen_);
  } else {
    last_seen_ = nullptr;
  }
  ::memcpy(&token_id_, &from.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&gaming_device_type_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(gaming_device_type_));
  // @@protoc_insertion_point(copy_constructor:CSupportRefreshTokenDescription)
}

inline void CSupportRefreshTokenDescription::SharedCtor() {
token_description_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  token_description_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_seen_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&gaming_device_type_) -
    reinterpret_cast<char*>(&first_seen_)) + sizeof(gaming_device_type_));
}

CSupportRefreshTokenDescription::~CSupportRefreshTokenDescription() {
  // @@protoc_insertion_point(destructor:CSupportRefreshTokenDescription)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSupportRefreshTokenDescription::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  token_description_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete first_seen_;
  if (this != internal_default_instance()) delete last_seen_;
}

void CSupportRefreshTokenDescription::ArenaDtor(void* object) {
  CSupportRefreshTokenDescription* _this = reinterpret_cast< CSupportRefreshTokenDescription* >(object);
  (void)_this;
}
void CSupportRefreshTokenDescription::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSupportRefreshTokenDescription::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSupportRefreshTokenDescription::Clear() {
// @@protoc_insertion_point(message_clear_start:CSupportRefreshTokenDescription)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      token_description_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(first_seen_ != nullptr);
      first_seen_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(last_seen_ != nullptr);
      last_seen_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&token_state_) -
        reinterpret_cast<char*>(&token_id_)) + sizeof(token_state_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&os_platform_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&gaming_device_type_) -
        reinterpret_cast<char*>(&os_platform_)) + sizeof(gaming_device_type_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSupportRefreshTokenDescription::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional string token_description = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_token_description();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CSupportRefreshTokenDescription.token_description");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time_updated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_time_updated(&has_bits);
          time_updated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenPlatformType_IsValid(val))) {
            _internal_set_platform_type(static_cast<::EAuthTokenPlatformType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional .EAuthTokenState token_state = 5 [default = k_EAuthTokenState_Invalid];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::EAuthTokenState_IsValid(val))) {
            _internal_set_token_state(static_cast<::EAuthTokenState>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 owner_steamid = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 49)) {
          _Internal::set_has_owner_steamid(&has_bits);
          owner_steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 os_platform = 7 [(.description) = "EPlatformType - rough classification of device OS, if known"];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_os_platform(&has_bits);
          os_platform_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 os_type = 8 [(.description) = "EOSType - specific device OS, if known"];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_os_type(&has_bits);
          os_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 auth_type = 9 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_auth_type(&has_bits);
          auth_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 gaming_device_type = 10 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_gaming_device_type(&has_bits);
          gaming_device_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSupportRefreshTokenDescription.TokenUsageEvent first_seen = 11 [(.description) = "Information about original authorization event"];
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_seen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSupportRefreshTokenDescription.TokenUsageEvent last_seen = 12 [(.description) = "Information about most-recently seen, if known for this device"];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_seen(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSupportRefreshTokenDescription::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSupportRefreshTokenDescription)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  // optional string token_description = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_token_description().data(), static_cast<int>(this->_internal_token_description().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSupportRefreshTokenDescription.token_description");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_token_description(), target);
  }

  // optional uint32 time_updated = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->_internal_time_updated(), target);
  }

  // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->_internal_platform_type(), target);
  }

  // optional .EAuthTokenState token_state = 5 [default = k_EAuthTokenState_Invalid];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      5, this->_internal_token_state(), target);
  }

  // optional fixed64 owner_steamid = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(6, this->_internal_owner_steamid(), target);
  }

  // optional uint32 os_platform = 7 [(.description) = "EPlatformType - rough classification of device OS, if known"];
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(7, this->_internal_os_platform(), target);
  }

  // optional int32 os_type = 8 [(.description) = "EOSType - specific device OS, if known"];
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(8, this->_internal_os_type(), target);
  }

  // optional uint32 auth_type = 9 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(9, this->_internal_auth_type(), target);
  }

  // optional uint32 gaming_device_type = 10 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(10, this->_internal_gaming_device_type(), target);
  }

  // optional .CSupportRefreshTokenDescription.TokenUsageEvent first_seen = 11 [(.description) = "Information about original authorization event"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        11, _Internal::first_seen(this), target, stream);
  }

  // optional .CSupportRefreshTokenDescription.TokenUsageEvent last_seen = 12 [(.description) = "Information about most-recently seen, if known for this device"];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        12, _Internal::last_seen(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSupportRefreshTokenDescription)
  return target;
}

size_t CSupportRefreshTokenDescription::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSupportRefreshTokenDescription)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string token_description = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_token_description());
    }

    // optional .CSupportRefreshTokenDescription.TokenUsageEvent first_seen = 11 [(.description) = "Information about original authorization event"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *first_seen_);
    }

    // optional .CSupportRefreshTokenDescription.TokenUsageEvent last_seen = 12 [(.description) = "Information about most-recently seen, if known for this device"];
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *last_seen_);
    }

    // optional fixed64 token_id = 1;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

    // optional uint32 time_updated = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time_updated());
    }

    // optional .EAuthTokenPlatformType platform_type = 4 [default = k_EAuthTokenPlatformType_Unknown];
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_platform_type());
    }

    // optional fixed64 owner_steamid = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 8;
    }

    // optional .EAuthTokenState token_state = 5 [default = k_EAuthTokenState_Invalid];
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_token_state());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional uint32 os_platform = 7 [(.description) = "EPlatformType - rough classification of device OS, if known"];
    if (cached_has_bits & 0x00000100u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_os_platform());
    }

    // optional int32 os_type = 8 [(.description) = "EOSType - specific device OS, if known"];
    if (cached_has_bits & 0x00000200u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_os_type());
    }

    // optional uint32 auth_type = 9 [(.description) = "EAuthTokenGuardType - device authorization mechanism, if known"];
    if (cached_has_bits & 0x00000400u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_auth_type());
    }

    // optional uint32 gaming_device_type = 10 [(.description) = "EGamingDeviceType - classify console/PC/SteamDeck, if known; applies only for Steam Client devices"];
    if (cached_has_bits & 0x00000800u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_gaming_device_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSupportRefreshTokenDescription::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSupportRefreshTokenDescription::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSupportRefreshTokenDescription::GetClassData() const { return &_class_data_; }

void CSupportRefreshTokenDescription::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSupportRefreshTokenDescription *>(to)->MergeFrom(
      static_cast<const CSupportRefreshTokenDescription &>(from));
}


void CSupportRefreshTokenDescription::MergeFrom(const CSupportRefreshTokenDescription& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSupportRefreshTokenDescription)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_token_description(from._internal_token_description());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_first_seen()->::CSupportRefreshTokenDescription_TokenUsageEvent::MergeFrom(from._internal_first_seen());
    }
    if (cached_has_bits & 0x00000004u) {
      _internal_mutable_last_seen()->::CSupportRefreshTokenDescription_TokenUsageEvent::MergeFrom(from._internal_last_seen());
    }
    if (cached_has_bits & 0x00000008u) {
      token_id_ = from.token_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      time_updated_ = from.time_updated_;
    }
    if (cached_has_bits & 0x00000020u) {
      platform_type_ = from.platform_type_;
    }
    if (cached_has_bits & 0x00000040u) {
      owner_steamid_ = from.owner_steamid_;
    }
    if (cached_has_bits & 0x00000080u) {
      token_state_ = from.token_state_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      os_platform_ = from.os_platform_;
    }
    if (cached_has_bits & 0x00000200u) {
      os_type_ = from.os_type_;
    }
    if (cached_has_bits & 0x00000400u) {
      auth_type_ = from.auth_type_;
    }
    if (cached_has_bits & 0x00000800u) {
      gaming_device_type_ = from.gaming_device_type_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSupportRefreshTokenDescription::CopyFrom(const CSupportRefreshTokenDescription& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSupportRefreshTokenDescription)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSupportRefreshTokenDescription::IsInitialized() const {
  return true;
}

void CSupportRefreshTokenDescription::InternalSwap(CSupportRefreshTokenDescription* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &token_description_, lhs_arena,
      &other->token_description_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenDescription, gaming_device_type_)
      + sizeof(CSupportRefreshTokenDescription::gaming_device_type_)
      - PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenDescription, first_seen_)>(
          reinterpret_cast<char*>(&first_seen_),
          reinterpret_cast<char*>(&other->first_seen_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSupportRefreshTokenDescription::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[32]);
}

// ===================================================================

class CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationSupport_QueryRefreshTokensByAccount_Response>()._has_bits_);
  static void set_has_last_token_reset(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthenticationSupport_QueryRefreshTokensByAccount_Response::CAuthenticationSupport_QueryRefreshTokensByAccount_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  refresh_tokens_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
}
CAuthenticationSupport_QueryRefreshTokensByAccount_Response::CAuthenticationSupport_QueryRefreshTokensByAccount_Response(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      refresh_tokens_(from.refresh_tokens_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  last_token_reset_ = from.last_token_reset_;
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
}

inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::SharedCtor() {
last_token_reset_ = 0;
}

CAuthenticationSupport_QueryRefreshTokensByAccount_Response::~CAuthenticationSupport_QueryRefreshTokensByAccount_Response() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::ArenaDtor(void* object) {
  CAuthenticationSupport_QueryRefreshTokensByAccount_Response* _this = reinterpret_cast< CAuthenticationSupport_QueryRefreshTokensByAccount_Response* >(object);
  (void)_this;
}
void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  refresh_tokens_.Clear();
  last_token_reset_ = 0;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_refresh_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 last_token_reset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_last_token_reset(&has_bits);
          last_token_reset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_refresh_tokens_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_refresh_tokens(i), target, stream);
  }

  cached_has_bits = _has_bits_[0];
  // optional int32 last_token_reset = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_last_token_reset(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  return target;
}

size_t CAuthenticationSupport_QueryRefreshTokensByAccount_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  total_size += 1UL * this->_internal_refresh_tokens_size();
  for (const auto& msg : this->refresh_tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional int32 last_token_reset = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_last_token_reset());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_QueryRefreshTokensByAccount_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_QueryRefreshTokensByAccount_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_QueryRefreshTokensByAccount_Response::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_QueryRefreshTokensByAccount_Response *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_QueryRefreshTokensByAccount_Response &>(from));
}


void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::MergeFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  refresh_tokens_.MergeFrom(from.refresh_tokens_);
  if (from._internal_has_last_token_reset()) {
    _internal_set_last_token_reset(from._internal_last_token_reset());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::CopyFrom(const CAuthenticationSupport_QueryRefreshTokensByAccount_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_QueryRefreshTokensByAccount_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_QueryRefreshTokensByAccount_Response::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_QueryRefreshTokensByAccount_Response::InternalSwap(CAuthenticationSupport_QueryRefreshTokensByAccount_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  refresh_tokens_.InternalSwap(&other->refresh_tokens_);
  swap(last_token_reset_, other->last_token_reset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_QueryRefreshTokensByAccount_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[33]);
}

// ===================================================================

class CAuthenticationSupport_QueryRefreshTokenByID_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationSupport_QueryRefreshTokenByID_Request>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthenticationSupport_QueryRefreshTokenByID_Request::CAuthenticationSupport_QueryRefreshTokenByID_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_QueryRefreshTokenByID_Request)
}
CAuthenticationSupport_QueryRefreshTokenByID_Request::CAuthenticationSupport_QueryRefreshTokenByID_Request(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_id_ = from.token_id_;
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_QueryRefreshTokenByID_Request)
}

inline void CAuthenticationSupport_QueryRefreshTokenByID_Request::SharedCtor() {
token_id_ = uint64_t{0u};
}

CAuthenticationSupport_QueryRefreshTokenByID_Request::~CAuthenticationSupport_QueryRefreshTokenByID_Request() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_QueryRefreshTokenByID_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Request::ArenaDtor(void* object) {
  CAuthenticationSupport_QueryRefreshTokenByID_Request* _this = reinterpret_cast< CAuthenticationSupport_QueryRefreshTokenByID_Request* >(object);
  (void)_this;
}
void CAuthenticationSupport_QueryRefreshTokenByID_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_QueryRefreshTokenByID_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  token_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_QueryRefreshTokenByID_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to look up (required)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_QueryRefreshTokenByID_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to look up (required)"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  return target;
}

size_t CAuthenticationSupport_QueryRefreshTokenByID_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to look up (required)"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_QueryRefreshTokenByID_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_QueryRefreshTokenByID_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_QueryRefreshTokenByID_Request::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_QueryRefreshTokenByID_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_QueryRefreshTokenByID_Request *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_QueryRefreshTokenByID_Request &>(from));
}


void CAuthenticationSupport_QueryRefreshTokenByID_Request::MergeFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token_id()) {
    _internal_set_token_id(from._internal_token_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Request::CopyFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_QueryRefreshTokenByID_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_QueryRefreshTokenByID_Request::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_QueryRefreshTokenByID_Request::InternalSwap(CAuthenticationSupport_QueryRefreshTokenByID_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(token_id_, other->token_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_QueryRefreshTokenByID_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[34]);
}

// ===================================================================

class CAuthenticationSupport_QueryRefreshTokenByID_Response::_Internal {
 public:
};

CAuthenticationSupport_QueryRefreshTokenByID_Response::CAuthenticationSupport_QueryRefreshTokenByID_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  refresh_tokens_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_QueryRefreshTokenByID_Response)
}
CAuthenticationSupport_QueryRefreshTokenByID_Response::CAuthenticationSupport_QueryRefreshTokenByID_Response(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      refresh_tokens_(from.refresh_tokens_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_QueryRefreshTokenByID_Response)
}

inline void CAuthenticationSupport_QueryRefreshTokenByID_Response::SharedCtor() {
}

CAuthenticationSupport_QueryRefreshTokenByID_Response::~CAuthenticationSupport_QueryRefreshTokenByID_Response() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_QueryRefreshTokenByID_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Response::ArenaDtor(void* object) {
  CAuthenticationSupport_QueryRefreshTokenByID_Response* _this = reinterpret_cast< CAuthenticationSupport_QueryRefreshTokenByID_Response* >(object);
  (void)_this;
}
void CAuthenticationSupport_QueryRefreshTokenByID_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_QueryRefreshTokenByID_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  refresh_tokens_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_QueryRefreshTokenByID_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_refresh_tokens(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_QueryRefreshTokenByID_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_refresh_tokens_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_refresh_tokens(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  return target;
}

size_t CAuthenticationSupport_QueryRefreshTokenByID_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenDescription refresh_tokens = 1;
  total_size += 1UL * this->_internal_refresh_tokens_size();
  for (const auto& msg : this->refresh_tokens_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_QueryRefreshTokenByID_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_QueryRefreshTokenByID_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_QueryRefreshTokenByID_Response::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_QueryRefreshTokenByID_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_QueryRefreshTokenByID_Response *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_QueryRefreshTokenByID_Response &>(from));
}


void CAuthenticationSupport_QueryRefreshTokenByID_Response::MergeFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  refresh_tokens_.MergeFrom(from.refresh_tokens_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_QueryRefreshTokenByID_Response::CopyFrom(const CAuthenticationSupport_QueryRefreshTokenByID_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_QueryRefreshTokenByID_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_QueryRefreshTokenByID_Response::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_QueryRefreshTokenByID_Response::InternalSwap(CAuthenticationSupport_QueryRefreshTokenByID_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  refresh_tokens_.InternalSwap(&other->refresh_tokens_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_QueryRefreshTokenByID_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[35]);
}

// ===================================================================

class CAuthenticationSupport_RevokeToken_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationSupport_RevokeToken_Request>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CAuthenticationSupport_RevokeToken_Request::CAuthenticationSupport_RevokeToken_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_RevokeToken_Request)
}
CAuthenticationSupport_RevokeToken_Request::CAuthenticationSupport_RevokeToken_Request(const CAuthenticationSupport_RevokeToken_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&token_id_, &from.token_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&steamid_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(steamid_));
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_RevokeToken_Request)
}

inline void CAuthenticationSupport_RevokeToken_Request::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&token_id_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&steamid_) -
    reinterpret_cast<char*>(&token_id_)) + sizeof(steamid_));
}

CAuthenticationSupport_RevokeToken_Request::~CAuthenticationSupport_RevokeToken_Request() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_RevokeToken_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_RevokeToken_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_RevokeToken_Request::ArenaDtor(void* object) {
  CAuthenticationSupport_RevokeToken_Request* _this = reinterpret_cast< CAuthenticationSupport_RevokeToken_Request* >(object);
  (void)_this;
}
void CAuthenticationSupport_RevokeToken_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_RevokeToken_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_RevokeToken_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_RevokeToken_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&token_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&steamid_) -
        reinterpret_cast<char*>(&token_id_)) + sizeof(steamid_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_RevokeToken_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to revoke (required)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2 [(.description) = "Steam ID of the owner of that token (required)"];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_RevokeToken_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_RevokeToken_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to revoke (required)"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  // optional fixed64 steamid = 2 [(.description) = "Steam ID of the owner of that token (required)"];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_RevokeToken_Request)
  return target;
}

size_t CAuthenticationSupport_RevokeToken_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_RevokeToken_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to revoke (required)"];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 steamid = 2 [(.description) = "Steam ID of the owner of that token (required)"];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_RevokeToken_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_RevokeToken_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_RevokeToken_Request::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_RevokeToken_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_RevokeToken_Request *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_RevokeToken_Request &>(from));
}


void CAuthenticationSupport_RevokeToken_Request::MergeFrom(const CAuthenticationSupport_RevokeToken_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_RevokeToken_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      token_id_ = from.token_id_;
    }
    if (cached_has_bits & 0x00000002u) {
      steamid_ = from.steamid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_RevokeToken_Request::CopyFrom(const CAuthenticationSupport_RevokeToken_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_RevokeToken_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_RevokeToken_Request::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_RevokeToken_Request::InternalSwap(CAuthenticationSupport_RevokeToken_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CAuthenticationSupport_RevokeToken_Request, steamid_)
      + sizeof(CAuthenticationSupport_RevokeToken_Request::steamid_)
      - PROTOBUF_FIELD_OFFSET(CAuthenticationSupport_RevokeToken_Request, token_id_)>(
          reinterpret_cast<char*>(&token_id_),
          reinterpret_cast<char*>(&other->token_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_RevokeToken_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[36]);
}

// ===================================================================

class CAuthenticationSupport_RevokeToken_Response::_Internal {
 public:
};

CAuthenticationSupport_RevokeToken_Response::CAuthenticationSupport_RevokeToken_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase(arena, is_message_owned) {
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_RevokeToken_Response)
}
CAuthenticationSupport_RevokeToken_Response::CAuthenticationSupport_RevokeToken_Response(const CAuthenticationSupport_RevokeToken_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase() {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_RevokeToken_Response)
}





const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_RevokeToken_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl,
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl,
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_RevokeToken_Response::GetClassData() const { return &_class_data_; }







::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_RevokeToken_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[37]);
}

// ===================================================================

class CAuthenticationSupport_GetTokenHistory_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CAuthenticationSupport_GetTokenHistory_Request>()._has_bits_);
  static void set_has_token_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CAuthenticationSupport_GetTokenHistory_Request::CAuthenticationSupport_GetTokenHistory_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_GetTokenHistory_Request)
}
CAuthenticationSupport_GetTokenHistory_Request::CAuthenticationSupport_GetTokenHistory_Request(const CAuthenticationSupport_GetTokenHistory_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  token_id_ = from.token_id_;
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_GetTokenHistory_Request)
}

inline void CAuthenticationSupport_GetTokenHistory_Request::SharedCtor() {
token_id_ = uint64_t{0u};
}

CAuthenticationSupport_GetTokenHistory_Request::~CAuthenticationSupport_GetTokenHistory_Request() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_GetTokenHistory_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_GetTokenHistory_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_GetTokenHistory_Request::ArenaDtor(void* object) {
  CAuthenticationSupport_GetTokenHistory_Request* _this = reinterpret_cast< CAuthenticationSupport_GetTokenHistory_Request* >(object);
  (void)_this;
}
void CAuthenticationSupport_GetTokenHistory_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_GetTokenHistory_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_GetTokenHistory_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_GetTokenHistory_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  token_id_ = uint64_t{0u};
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_GetTokenHistory_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to get history for (required)"];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_token_id(&has_bits);
          token_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_GetTokenHistory_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_GetTokenHistory_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to get history for (required)"];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(1, this->_internal_token_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_GetTokenHistory_Request)
  return target;
}

size_t CAuthenticationSupport_GetTokenHistory_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_GetTokenHistory_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed64 token_id = 1 [(.description) = "Token ID of the token to get history for (required)"];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 8;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_GetTokenHistory_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_GetTokenHistory_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_GetTokenHistory_Request::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_GetTokenHistory_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_GetTokenHistory_Request *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_GetTokenHistory_Request &>(from));
}


void CAuthenticationSupport_GetTokenHistory_Request::MergeFrom(const CAuthenticationSupport_GetTokenHistory_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_GetTokenHistory_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token_id()) {
    _internal_set_token_id(from._internal_token_id());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_GetTokenHistory_Request::CopyFrom(const CAuthenticationSupport_GetTokenHistory_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_GetTokenHistory_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_GetTokenHistory_Request::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_GetTokenHistory_Request::InternalSwap(CAuthenticationSupport_GetTokenHistory_Request* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(token_id_, other->token_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_GetTokenHistory_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[38]);
}

// ===================================================================

class CSupportRefreshTokenAudit::_Internal {
 public:
  using HasBits = decltype(std::declval<CSupportRefreshTokenAudit>()._has_bits_);
  static void set_has_action(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgIPAddress& ip(const CSupportRefreshTokenAudit* msg);
  static void set_has_ip(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_actor(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgIPAddress&
CSupportRefreshTokenAudit::_Internal::ip(const CSupportRefreshTokenAudit* msg) {
  return *msg->ip_;
}
void CSupportRefreshTokenAudit::clear_ip() {
  if (ip_ != nullptr) ip_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
CSupportRefreshTokenAudit::CSupportRefreshTokenAudit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CSupportRefreshTokenAudit)
}
CSupportRefreshTokenAudit::CSupportRefreshTokenAudit(const CSupportRefreshTokenAudit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ip()) {
    ip_ = new ::CMsgIPAddress(*from.ip_);
  } else {
    ip_ = nullptr;
  }
  ::memcpy(&action_, &from.action_,
    static_cast<size_t>(reinterpret_cast<char*>(&actor_) -
    reinterpret_cast<char*>(&action_)) + sizeof(actor_));
  // @@protoc_insertion_point(copy_constructor:CSupportRefreshTokenAudit)
}

inline void CSupportRefreshTokenAudit::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&ip_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&actor_) -
    reinterpret_cast<char*>(&ip_)) + sizeof(actor_));
}

CSupportRefreshTokenAudit::~CSupportRefreshTokenAudit() {
  // @@protoc_insertion_point(destructor:CSupportRefreshTokenAudit)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CSupportRefreshTokenAudit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete ip_;
}

void CSupportRefreshTokenAudit::ArenaDtor(void* object) {
  CSupportRefreshTokenAudit* _this = reinterpret_cast< CSupportRefreshTokenAudit* >(object);
  (void)_this;
}
void CSupportRefreshTokenAudit::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CSupportRefreshTokenAudit::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSupportRefreshTokenAudit::Clear() {
// @@protoc_insertion_point(message_clear_start:CSupportRefreshTokenAudit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(ip_ != nullptr);
    ip_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&action_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&actor_) -
        reinterpret_cast<char*>(&action_)) + sizeof(actor_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSupportRefreshTokenAudit::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 action = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_action(&has_bits);
          action_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_time(&has_bits);
          time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgIPAddress ip = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ip(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 actor = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_actor(&has_bits);
          actor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSupportRefreshTokenAudit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSupportRefreshTokenAudit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional int32 action = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_action(), target);
  }

  // optional uint32 time = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_time(), target);
  }

  // optional .CMsgIPAddress ip = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::ip(this), target, stream);
  }

  // optional fixed64 actor = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteFixed64ToArray(4, this->_internal_actor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSupportRefreshTokenAudit)
  return target;
}

size_t CSupportRefreshTokenAudit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSupportRefreshTokenAudit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgIPAddress ip = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *ip_);
    }

    // optional int32 action = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32SizePlusOne(this->_internal_action());
    }

    // optional uint32 time = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_time());
    }

    // optional fixed64 actor = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 8;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSupportRefreshTokenAudit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CSupportRefreshTokenAudit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSupportRefreshTokenAudit::GetClassData() const { return &_class_data_; }

void CSupportRefreshTokenAudit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CSupportRefreshTokenAudit *>(to)->MergeFrom(
      static_cast<const CSupportRefreshTokenAudit &>(from));
}


void CSupportRefreshTokenAudit::MergeFrom(const CSupportRefreshTokenAudit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CSupportRefreshTokenAudit)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_ip()->::CMsgIPAddress::MergeFrom(from._internal_ip());
    }
    if (cached_has_bits & 0x00000002u) {
      action_ = from.action_;
    }
    if (cached_has_bits & 0x00000004u) {
      time_ = from.time_;
    }
    if (cached_has_bits & 0x00000008u) {
      actor_ = from.actor_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSupportRefreshTokenAudit::CopyFrom(const CSupportRefreshTokenAudit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSupportRefreshTokenAudit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSupportRefreshTokenAudit::IsInitialized() const {
  return true;
}

void CSupportRefreshTokenAudit::InternalSwap(CSupportRefreshTokenAudit* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenAudit, actor_)
      + sizeof(CSupportRefreshTokenAudit::actor_)
      - PROTOBUF_FIELD_OFFSET(CSupportRefreshTokenAudit, ip_)>(
          reinterpret_cast<char*>(&ip_),
          reinterpret_cast<char*>(&other->ip_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSupportRefreshTokenAudit::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[39]);
}

// ===================================================================

class CAuthenticationSupport_GetTokenHistory_Response::_Internal {
 public:
};

CAuthenticationSupport_GetTokenHistory_Response::CAuthenticationSupport_GetTokenHistory_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  history_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CAuthenticationSupport_GetTokenHistory_Response)
}
CAuthenticationSupport_GetTokenHistory_Response::CAuthenticationSupport_GetTokenHistory_Response(const CAuthenticationSupport_GetTokenHistory_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      history_(from.history_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CAuthenticationSupport_GetTokenHistory_Response)
}

inline void CAuthenticationSupport_GetTokenHistory_Response::SharedCtor() {
}

CAuthenticationSupport_GetTokenHistory_Response::~CAuthenticationSupport_GetTokenHistory_Response() {
  // @@protoc_insertion_point(destructor:CAuthenticationSupport_GetTokenHistory_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CAuthenticationSupport_GetTokenHistory_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CAuthenticationSupport_GetTokenHistory_Response::ArenaDtor(void* object) {
  CAuthenticationSupport_GetTokenHistory_Response* _this = reinterpret_cast< CAuthenticationSupport_GetTokenHistory_Response* >(object);
  (void)_this;
}
void CAuthenticationSupport_GetTokenHistory_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CAuthenticationSupport_GetTokenHistory_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CAuthenticationSupport_GetTokenHistory_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CAuthenticationSupport_GetTokenHistory_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  history_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CAuthenticationSupport_GetTokenHistory_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CSupportRefreshTokenAudit history = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_history(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CAuthenticationSupport_GetTokenHistory_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CAuthenticationSupport_GetTokenHistory_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenAudit history = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_history_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, this->_internal_history(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CAuthenticationSupport_GetTokenHistory_Response)
  return target;
}

size_t CAuthenticationSupport_GetTokenHistory_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CAuthenticationSupport_GetTokenHistory_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSupportRefreshTokenAudit history = 1;
  total_size += 1UL * this->_internal_history_size();
  for (const auto& msg : this->history_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CAuthenticationSupport_GetTokenHistory_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CAuthenticationSupport_GetTokenHistory_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CAuthenticationSupport_GetTokenHistory_Response::GetClassData() const { return &_class_data_; }

void CAuthenticationSupport_GetTokenHistory_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CAuthenticationSupport_GetTokenHistory_Response *>(to)->MergeFrom(
      static_cast<const CAuthenticationSupport_GetTokenHistory_Response &>(from));
}


void CAuthenticationSupport_GetTokenHistory_Response::MergeFrom(const CAuthenticationSupport_GetTokenHistory_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CAuthenticationSupport_GetTokenHistory_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  history_.MergeFrom(from.history_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CAuthenticationSupport_GetTokenHistory_Response::CopyFrom(const CAuthenticationSupport_GetTokenHistory_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CAuthenticationSupport_GetTokenHistory_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CAuthenticationSupport_GetTokenHistory_Response::IsInitialized() const {
  return true;
}

void CAuthenticationSupport_GetTokenHistory_Response::InternalSwap(CAuthenticationSupport_GetTokenHistory_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  history_.InternalSwap(&other->history_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CAuthenticationSupport_GetTokenHistory_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[40]);
}

// ===================================================================

class CCloudGaming_CreateNonce_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CCloudGaming_CreateNonce_Request>()._has_bits_);
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCloudGaming_CreateNonce_Request::CCloudGaming_CreateNonce_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloudGaming_CreateNonce_Request)
}
CCloudGaming_CreateNonce_Request::CCloudGaming_CreateNonce_Request(const CCloudGaming_CreateNonce_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_platform(), 
      GetArenaForAllocation());
  }
  appid_ = from.appid_;
  // @@protoc_insertion_point(copy_constructor:CCloudGaming_CreateNonce_Request)
}

inline void CCloudGaming_CreateNonce_Request::SharedCtor() {
platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
appid_ = 0u;
}

CCloudGaming_CreateNonce_Request::~CCloudGaming_CreateNonce_Request() {
  // @@protoc_insertion_point(destructor:CCloudGaming_CreateNonce_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloudGaming_CreateNonce_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  platform_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CCloudGaming_CreateNonce_Request::ArenaDtor(void* object) {
  CCloudGaming_CreateNonce_Request* _this = reinterpret_cast< CCloudGaming_CreateNonce_Request* >(object);
  (void)_this;
}
void CCloudGaming_CreateNonce_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloudGaming_CreateNonce_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloudGaming_CreateNonce_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloudGaming_CreateNonce_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    platform_.ClearNonDefaultToEmpty();
  }
  appid_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloudGaming_CreateNonce_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string platform = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_platform();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CCloudGaming_CreateNonce_Request.platform");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 appid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloudGaming_CreateNonce_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloudGaming_CreateNonce_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string platform = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCloudGaming_CreateNonce_Request.platform");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_platform(), target);
  }

  // optional uint32 appid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloudGaming_CreateNonce_Request)
  return target;
}

size_t CCloudGaming_CreateNonce_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloudGaming_CreateNonce_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string platform = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_platform());
    }

    // optional uint32 appid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloudGaming_CreateNonce_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloudGaming_CreateNonce_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloudGaming_CreateNonce_Request::GetClassData() const { return &_class_data_; }

void CCloudGaming_CreateNonce_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloudGaming_CreateNonce_Request *>(to)->MergeFrom(
      static_cast<const CCloudGaming_CreateNonce_Request &>(from));
}


void CCloudGaming_CreateNonce_Request::MergeFrom(const CCloudGaming_CreateNonce_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloudGaming_CreateNonce_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_platform(from._internal_platform());
    }
    if (cached_has_bits & 0x00000002u) {
      appid_ = from.appid_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloudGaming_CreateNonce_Request::CopyFrom(const CCloudGaming_CreateNonce_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloudGaming_CreateNonce_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloudGaming_CreateNonce_Request::IsInitialized() const {
  return true;
}

void CCloudGaming_CreateNonce_Request::InternalSwap(CCloudGaming_CreateNonce_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
  swap(appid_, other->appid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloudGaming_CreateNonce_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[41]);
}

// ===================================================================

class CCloudGaming_CreateNonce_Response::_Internal {
 public:
  using HasBits = decltype(std::declval<CCloudGaming_CreateNonce_Response>()._has_bits_);
  static void set_has_nonce(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_expiry(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCloudGaming_CreateNonce_Response::CCloudGaming_CreateNonce_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloudGaming_CreateNonce_Response)
}
CCloudGaming_CreateNonce_Response::CCloudGaming_CreateNonce_Response(const CCloudGaming_CreateNonce_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  nonce_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_nonce()) {
    nonce_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_nonce(), 
      GetArenaForAllocation());
  }
  expiry_ = from.expiry_;
  // @@protoc_insertion_point(copy_constructor:CCloudGaming_CreateNonce_Response)
}

inline void CCloudGaming_CreateNonce_Response::SharedCtor() {
nonce_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  nonce_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
expiry_ = 0u;
}

CCloudGaming_CreateNonce_Response::~CCloudGaming_CreateNonce_Response() {
  // @@protoc_insertion_point(destructor:CCloudGaming_CreateNonce_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloudGaming_CreateNonce_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  nonce_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CCloudGaming_CreateNonce_Response::ArenaDtor(void* object) {
  CCloudGaming_CreateNonce_Response* _this = reinterpret_cast< CCloudGaming_CreateNonce_Response* >(object);
  (void)_this;
}
void CCloudGaming_CreateNonce_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloudGaming_CreateNonce_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloudGaming_CreateNonce_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloudGaming_CreateNonce_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    nonce_.ClearNonDefaultToEmpty();
  }
  expiry_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloudGaming_CreateNonce_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string nonce = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_nonce();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CCloudGaming_CreateNonce_Response.nonce");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 expiry = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_expiry(&has_bits);
          expiry_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloudGaming_CreateNonce_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloudGaming_CreateNonce_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string nonce = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_nonce().data(), static_cast<int>(this->_internal_nonce().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCloudGaming_CreateNonce_Response.nonce");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_nonce(), target);
  }

  // optional uint32 expiry = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_expiry(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloudGaming_CreateNonce_Response)
  return target;
}

size_t CCloudGaming_CreateNonce_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloudGaming_CreateNonce_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string nonce = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_nonce());
    }

    // optional uint32 expiry = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_expiry());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloudGaming_CreateNonce_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloudGaming_CreateNonce_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloudGaming_CreateNonce_Response::GetClassData() const { return &_class_data_; }

void CCloudGaming_CreateNonce_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloudGaming_CreateNonce_Response *>(to)->MergeFrom(
      static_cast<const CCloudGaming_CreateNonce_Response &>(from));
}


void CCloudGaming_CreateNonce_Response::MergeFrom(const CCloudGaming_CreateNonce_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloudGaming_CreateNonce_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_nonce(from._internal_nonce());
    }
    if (cached_has_bits & 0x00000002u) {
      expiry_ = from.expiry_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloudGaming_CreateNonce_Response::CopyFrom(const CCloudGaming_CreateNonce_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloudGaming_CreateNonce_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloudGaming_CreateNonce_Response::IsInitialized() const {
  return true;
}

void CCloudGaming_CreateNonce_Response::InternalSwap(CCloudGaming_CreateNonce_Response* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &nonce_, lhs_arena,
      &other->nonce_, rhs_arena
  );
  swap(expiry_, other->expiry_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloudGaming_CreateNonce_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[42]);
}

// ===================================================================

class CCloudGaming_GetTimeRemaining_Request::_Internal {
 public:
  using HasBits = decltype(std::declval<CCloudGaming_GetTimeRemaining_Request>()._has_bits_);
  static void set_has_platform(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCloudGaming_GetTimeRemaining_Request::CCloudGaming_GetTimeRemaining_Request(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  appid_list_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloudGaming_GetTimeRemaining_Request)
}
CCloudGaming_GetTimeRemaining_Request::CCloudGaming_GetTimeRemaining_Request(const CCloudGaming_GetTimeRemaining_Request& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      appid_list_(from.appid_list_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_platform()) {
    platform_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, from._internal_platform(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCloudGaming_GetTimeRemaining_Request)
}

inline void CCloudGaming_GetTimeRemaining_Request::SharedCtor() {
platform_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  platform_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCloudGaming_GetTimeRemaining_Request::~CCloudGaming_GetTimeRemaining_Request() {
  // @@protoc_insertion_point(destructor:CCloudGaming_GetTimeRemaining_Request)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloudGaming_GetTimeRemaining_Request::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  platform_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void CCloudGaming_GetTimeRemaining_Request::ArenaDtor(void* object) {
  CCloudGaming_GetTimeRemaining_Request* _this = reinterpret_cast< CCloudGaming_GetTimeRemaining_Request* >(object);
  (void)_this;
}
void CCloudGaming_GetTimeRemaining_Request::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloudGaming_GetTimeRemaining_Request::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloudGaming_GetTimeRemaining_Request::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloudGaming_GetTimeRemaining_Request)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  appid_list_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    platform_.ClearNonDefaultToEmpty();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloudGaming_GetTimeRemaining_Request::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string platform = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_platform();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          #ifndef NDEBUG
          ::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "CCloudGaming_GetTimeRemaining_Request.platform");
          #endif  // !NDEBUG
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 appid_list = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_appid_list(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_appid_list(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloudGaming_GetTimeRemaining_Request::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloudGaming_GetTimeRemaining_Request)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional string platform = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_platform().data(), static_cast<int>(this->_internal_platform().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCloudGaming_GetTimeRemaining_Request.platform");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_platform(), target);
  }

  // repeated uint32 appid_list = 2;
  for (int i = 0, n = this->_internal_appid_list_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_appid_list(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloudGaming_GetTimeRemaining_Request)
  return target;
}

size_t CCloudGaming_GetTimeRemaining_Request::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloudGaming_GetTimeRemaining_Request)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 appid_list = 2;
  {
    size_t data_size = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      UInt32Size(this->appid_list_);
    total_size += 1 *
                  ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(this->_internal_appid_list_size());
    total_size += data_size;
  }

  // optional string platform = 1;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_platform());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloudGaming_GetTimeRemaining_Request::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloudGaming_GetTimeRemaining_Request::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloudGaming_GetTimeRemaining_Request::GetClassData() const { return &_class_data_; }

void CCloudGaming_GetTimeRemaining_Request::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloudGaming_GetTimeRemaining_Request *>(to)->MergeFrom(
      static_cast<const CCloudGaming_GetTimeRemaining_Request &>(from));
}


void CCloudGaming_GetTimeRemaining_Request::MergeFrom(const CCloudGaming_GetTimeRemaining_Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloudGaming_GetTimeRemaining_Request)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  appid_list_.MergeFrom(from.appid_list_);
  if (from._internal_has_platform()) {
    _internal_set_platform(from._internal_platform());
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloudGaming_GetTimeRemaining_Request::CopyFrom(const CCloudGaming_GetTimeRemaining_Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloudGaming_GetTimeRemaining_Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloudGaming_GetTimeRemaining_Request::IsInitialized() const {
  return true;
}

void CCloudGaming_GetTimeRemaining_Request::InternalSwap(CCloudGaming_GetTimeRemaining_Request* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  appid_list_.InternalSwap(&other->appid_list_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      &platform_, lhs_arena,
      &other->platform_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloudGaming_GetTimeRemaining_Request::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[43]);
}

// ===================================================================

class CCloudGaming_TimeRemaining::_Internal {
 public:
  using HasBits = decltype(std::declval<CCloudGaming_TimeRemaining>()._has_bits_);
  static void set_has_appid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_minutes_remaining(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCloudGaming_TimeRemaining::CCloudGaming_TimeRemaining(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloudGaming_TimeRemaining)
}
CCloudGaming_TimeRemaining::CCloudGaming_TimeRemaining(const CCloudGaming_TimeRemaining& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&appid_, &from.appid_,
    static_cast<size_t>(reinterpret_cast<char*>(&minutes_remaining_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(minutes_remaining_));
  // @@protoc_insertion_point(copy_constructor:CCloudGaming_TimeRemaining)
}

inline void CCloudGaming_TimeRemaining::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&appid_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&minutes_remaining_) -
    reinterpret_cast<char*>(&appid_)) + sizeof(minutes_remaining_));
}

CCloudGaming_TimeRemaining::~CCloudGaming_TimeRemaining() {
  // @@protoc_insertion_point(destructor:CCloudGaming_TimeRemaining)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloudGaming_TimeRemaining::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCloudGaming_TimeRemaining::ArenaDtor(void* object) {
  CCloudGaming_TimeRemaining* _this = reinterpret_cast< CCloudGaming_TimeRemaining* >(object);
  (void)_this;
}
void CCloudGaming_TimeRemaining::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloudGaming_TimeRemaining::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloudGaming_TimeRemaining::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloudGaming_TimeRemaining)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&appid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&minutes_remaining_) -
        reinterpret_cast<char*>(&appid_)) + sizeof(minutes_remaining_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloudGaming_TimeRemaining::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 appid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_appid(&has_bits);
          appid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 minutes_remaining = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_minutes_remaining(&has_bits);
          minutes_remaining_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloudGaming_TimeRemaining::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloudGaming_TimeRemaining)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // optional uint32 appid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_appid(), target);
  }

  // optional uint32 minutes_remaining = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_minutes_remaining(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloudGaming_TimeRemaining)
  return target;
}

size_t CCloudGaming_TimeRemaining::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloudGaming_TimeRemaining)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional uint32 appid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_appid());
    }

    // optional uint32 minutes_remaining = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32SizePlusOne(this->_internal_minutes_remaining());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloudGaming_TimeRemaining::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloudGaming_TimeRemaining::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloudGaming_TimeRemaining::GetClassData() const { return &_class_data_; }

void CCloudGaming_TimeRemaining::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloudGaming_TimeRemaining *>(to)->MergeFrom(
      static_cast<const CCloudGaming_TimeRemaining &>(from));
}


void CCloudGaming_TimeRemaining::MergeFrom(const CCloudGaming_TimeRemaining& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloudGaming_TimeRemaining)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      appid_ = from.appid_;
    }
    if (cached_has_bits & 0x00000002u) {
      minutes_remaining_ = from.minutes_remaining_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloudGaming_TimeRemaining::CopyFrom(const CCloudGaming_TimeRemaining& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloudGaming_TimeRemaining)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloudGaming_TimeRemaining::IsInitialized() const {
  return true;
}

void CCloudGaming_TimeRemaining::InternalSwap(CCloudGaming_TimeRemaining* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCloudGaming_TimeRemaining, minutes_remaining_)
      + sizeof(CCloudGaming_TimeRemaining::minutes_remaining_)
      - PROTOBUF_FIELD_OFFSET(CCloudGaming_TimeRemaining, appid_)>(
          reinterpret_cast<char*>(&appid_),
          reinterpret_cast<char*>(&other->appid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloudGaming_TimeRemaining::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[44]);
}

// ===================================================================

class CCloudGaming_GetTimeRemaining_Response::_Internal {
 public:
};

CCloudGaming_GetTimeRemaining_Response::CCloudGaming_GetTimeRemaining_Response(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned),
  entries_(arena) {
  SharedCtor();
  if (!is_message_owned) {
    RegisterArenaDtor(arena);
  }
  // @@protoc_insertion_point(arena_constructor:CCloudGaming_GetTimeRemaining_Response)
}
CCloudGaming_GetTimeRemaining_Response::CCloudGaming_GetTimeRemaining_Response(const CCloudGaming_GetTimeRemaining_Response& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      entries_(from.entries_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CCloudGaming_GetTimeRemaining_Response)
}

inline void CCloudGaming_GetTimeRemaining_Response::SharedCtor() {
}

CCloudGaming_GetTimeRemaining_Response::~CCloudGaming_GetTimeRemaining_Response() {
  // @@protoc_insertion_point(destructor:CCloudGaming_GetTimeRemaining_Response)
  if (GetArenaForAllocation() != nullptr) return;
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

inline void CCloudGaming_GetTimeRemaining_Response::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCloudGaming_GetTimeRemaining_Response::ArenaDtor(void* object) {
  CCloudGaming_GetTimeRemaining_Response* _this = reinterpret_cast< CCloudGaming_GetTimeRemaining_Response* >(object);
  (void)_this;
}
void CCloudGaming_GetTimeRemaining_Response::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void CCloudGaming_GetTimeRemaining_Response::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CCloudGaming_GetTimeRemaining_Response::Clear() {
// @@protoc_insertion_point(message_clear_start:CCloudGaming_GetTimeRemaining_Response)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  entries_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCloudGaming_GetTimeRemaining_Response::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CCloudGaming_TimeRemaining entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_entries(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCloudGaming_GetTimeRemaining_Response::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCloudGaming_GetTimeRemaining_Response)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CCloudGaming_TimeRemaining entries = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_entries_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, this->_internal_entries(i), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCloudGaming_GetTimeRemaining_Response)
  return target;
}

size_t CCloudGaming_GetTimeRemaining_Response::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCloudGaming_GetTimeRemaining_Response)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CCloudGaming_TimeRemaining entries = 2;
  total_size += 1UL * this->_internal_entries_size();
  for (const auto& msg : this->entries_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCloudGaming_GetTimeRemaining_Response::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSizeCheck,
    CCloudGaming_GetTimeRemaining_Response::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCloudGaming_GetTimeRemaining_Response::GetClassData() const { return &_class_data_; }

void CCloudGaming_GetTimeRemaining_Response::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to,
                      const ::PROTOBUF_NAMESPACE_ID::Message& from) {
  static_cast<CCloudGaming_GetTimeRemaining_Response *>(to)->MergeFrom(
      static_cast<const CCloudGaming_GetTimeRemaining_Response &>(from));
}


void CCloudGaming_GetTimeRemaining_Response::MergeFrom(const CCloudGaming_GetTimeRemaining_Response& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:CCloudGaming_GetTimeRemaining_Response)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  entries_.MergeFrom(from.entries_);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCloudGaming_GetTimeRemaining_Response::CopyFrom(const CCloudGaming_GetTimeRemaining_Response& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCloudGaming_GetTimeRemaining_Response)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCloudGaming_GetTimeRemaining_Response::IsInitialized() const {
  return true;
}

void CCloudGaming_GetTimeRemaining_Response::InternalSwap(CCloudGaming_GetTimeRemaining_Response* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  entries_.InternalSwap(&other->entries_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCloudGaming_GetTimeRemaining_Response::GetMetadata() const {
  return ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(
      &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_getter, &descriptor_table_steammessages_5fauth_2esteamclient_2eproto_once,
      file_level_metadata_steammessages_5fauth_2esteamclient_2eproto[45]);
}

// ===================================================================

Authentication::~Authentication() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* Authentication::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[0];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* Authentication::GetDescriptor() {
  return descriptor();
}

void Authentication::GetPasswordRSAPublicKey(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_GetPasswordRSAPublicKey_Request*,
                         ::CAuthentication_GetPasswordRSAPublicKey_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetPasswordRSAPublicKey() not implemented.");
  done->Run();
}

void Authentication::BeginAuthSessionViaQR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_BeginAuthSessionViaQR_Request*,
                         ::CAuthentication_BeginAuthSessionViaQR_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method BeginAuthSessionViaQR() not implemented.");
  done->Run();
}

void Authentication::BeginAuthSessionViaCredentials(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_BeginAuthSessionViaCredentials_Request*,
                         ::CAuthentication_BeginAuthSessionViaCredentials_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method BeginAuthSessionViaCredentials() not implemented.");
  done->Run();
}

void Authentication::PollAuthSessionStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_PollAuthSessionStatus_Request*,
                         ::CAuthentication_PollAuthSessionStatus_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method PollAuthSessionStatus() not implemented.");
  done->Run();
}

void Authentication::GetAuthSessionInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_GetAuthSessionInfo_Request*,
                         ::CAuthentication_GetAuthSessionInfo_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetAuthSessionInfo() not implemented.");
  done->Run();
}

void Authentication::UpdateAuthSessionWithMobileConfirmation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request*,
                         ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UpdateAuthSessionWithMobileConfirmation() not implemented.");
  done->Run();
}

void Authentication::UpdateAuthSessionWithSteamGuardCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request*,
                         ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method UpdateAuthSessionWithSteamGuardCode() not implemented.");
  done->Run();
}

void Authentication::GenerateAccessTokenForApp(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_AccessToken_GenerateForApp_Request*,
                         ::CAuthentication_AccessToken_GenerateForApp_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GenerateAccessTokenForApp() not implemented.");
  done->Run();
}

void Authentication::EnumerateTokens(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_RefreshToken_Enumerate_Request*,
                         ::CAuthentication_RefreshToken_Enumerate_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method EnumerateTokens() not implemented.");
  done->Run();
}

void Authentication::GetAuthSessionsForAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_GetAuthSessionsForAccount_Request*,
                         ::CAuthentication_GetAuthSessionsForAccount_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetAuthSessionsForAccount() not implemented.");
  done->Run();
}

void Authentication::MigrateMobileSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_MigrateMobileSession_Request*,
                         ::CAuthentication_MigrateMobileSession_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method MigrateMobileSession() not implemented.");
  done->Run();
}

void Authentication::RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_Token_Revoke_Request*,
                         ::CAuthentication_Token_Revoke_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method RevokeToken() not implemented.");
  done->Run();
}

void Authentication::RevokeRefreshToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthentication_RefreshToken_Revoke_Request*,
                         ::CAuthentication_RefreshToken_Revoke_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method RevokeRefreshToken() not implemented.");
  done->Run();
}

void Authentication::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[0]);
  switch(method->index()) {
    case 0:
      GetPasswordRSAPublicKey(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_GetPasswordRSAPublicKey_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_GetPasswordRSAPublicKey_Response*>(
                 response),
             done);
      break;
    case 1:
      BeginAuthSessionViaQR(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_BeginAuthSessionViaQR_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_BeginAuthSessionViaQR_Response*>(
                 response),
             done);
      break;
    case 2:
      BeginAuthSessionViaCredentials(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_BeginAuthSessionViaCredentials_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_BeginAuthSessionViaCredentials_Response*>(
                 response),
             done);
      break;
    case 3:
      PollAuthSessionStatus(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_PollAuthSessionStatus_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_PollAuthSessionStatus_Response*>(
                 response),
             done);
      break;
    case 4:
      GetAuthSessionInfo(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_GetAuthSessionInfo_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_GetAuthSessionInfo_Response*>(
                 response),
             done);
      break;
    case 5:
      UpdateAuthSessionWithMobileConfirmation(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response*>(
                 response),
             done);
      break;
    case 6:
      UpdateAuthSessionWithSteamGuardCode(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response*>(
                 response),
             done);
      break;
    case 7:
      GenerateAccessTokenForApp(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_AccessToken_GenerateForApp_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_AccessToken_GenerateForApp_Response*>(
                 response),
             done);
      break;
    case 8:
      EnumerateTokens(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_RefreshToken_Enumerate_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_RefreshToken_Enumerate_Response*>(
                 response),
             done);
      break;
    case 9:
      GetAuthSessionsForAccount(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_GetAuthSessionsForAccount_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_GetAuthSessionsForAccount_Response*>(
                 response),
             done);
      break;
    case 10:
      MigrateMobileSession(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_MigrateMobileSession_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_MigrateMobileSession_Response*>(
                 response),
             done);
      break;
    case 11:
      RevokeToken(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_Token_Revoke_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_Token_Revoke_Response*>(
                 response),
             done);
      break;
    case 12:
      RevokeRefreshToken(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthentication_RefreshToken_Revoke_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthentication_RefreshToken_Revoke_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& Authentication::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CAuthentication_GetPasswordRSAPublicKey_Request::default_instance();
    case 1:
      return ::CAuthentication_BeginAuthSessionViaQR_Request::default_instance();
    case 2:
      return ::CAuthentication_BeginAuthSessionViaCredentials_Request::default_instance();
    case 3:
      return ::CAuthentication_PollAuthSessionStatus_Request::default_instance();
    case 4:
      return ::CAuthentication_GetAuthSessionInfo_Request::default_instance();
    case 5:
      return ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request::default_instance();
    case 6:
      return ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request::default_instance();
    case 7:
      return ::CAuthentication_AccessToken_GenerateForApp_Request::default_instance();
    case 8:
      return ::CAuthentication_RefreshToken_Enumerate_Request::default_instance();
    case 9:
      return ::CAuthentication_GetAuthSessionsForAccount_Request::default_instance();
    case 10:
      return ::CAuthentication_MigrateMobileSession_Request::default_instance();
    case 11:
      return ::CAuthentication_Token_Revoke_Request::default_instance();
    case 12:
      return ::CAuthentication_RefreshToken_Revoke_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& Authentication::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CAuthentication_GetPasswordRSAPublicKey_Response::default_instance();
    case 1:
      return ::CAuthentication_BeginAuthSessionViaQR_Response::default_instance();
    case 2:
      return ::CAuthentication_BeginAuthSessionViaCredentials_Response::default_instance();
    case 3:
      return ::CAuthentication_PollAuthSessionStatus_Response::default_instance();
    case 4:
      return ::CAuthentication_GetAuthSessionInfo_Response::default_instance();
    case 5:
      return ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response::default_instance();
    case 6:
      return ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response::default_instance();
    case 7:
      return ::CAuthentication_AccessToken_GenerateForApp_Response::default_instance();
    case 8:
      return ::CAuthentication_RefreshToken_Enumerate_Response::default_instance();
    case 9:
      return ::CAuthentication_GetAuthSessionsForAccount_Response::default_instance();
    case 10:
      return ::CAuthentication_MigrateMobileSession_Response::default_instance();
    case 11:
      return ::CAuthentication_Token_Revoke_Response::default_instance();
    case 12:
      return ::CAuthentication_RefreshToken_Revoke_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

Authentication_Stub::Authentication_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
Authentication_Stub::Authentication_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
Authentication_Stub::~Authentication_Stub() {
  if (owns_channel_) delete channel_;
}

void Authentication_Stub::GetPasswordRSAPublicKey(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_GetPasswordRSAPublicKey_Request* request,
                              ::CAuthentication_GetPasswordRSAPublicKey_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void Authentication_Stub::BeginAuthSessionViaQR(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_BeginAuthSessionViaQR_Request* request,
                              ::CAuthentication_BeginAuthSessionViaQR_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void Authentication_Stub::BeginAuthSessionViaCredentials(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_BeginAuthSessionViaCredentials_Request* request,
                              ::CAuthentication_BeginAuthSessionViaCredentials_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void Authentication_Stub::PollAuthSessionStatus(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_PollAuthSessionStatus_Request* request,
                              ::CAuthentication_PollAuthSessionStatus_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void Authentication_Stub::GetAuthSessionInfo(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_GetAuthSessionInfo_Request* request,
                              ::CAuthentication_GetAuthSessionInfo_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void Authentication_Stub::UpdateAuthSessionWithMobileConfirmation(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* request,
                              ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void Authentication_Stub::UpdateAuthSessionWithSteamGuardCode(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* request,
                              ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}
void Authentication_Stub::GenerateAccessTokenForApp(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_AccessToken_GenerateForApp_Request* request,
                              ::CAuthentication_AccessToken_GenerateForApp_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(7),
                       controller, request, response, done);
}
void Authentication_Stub::EnumerateTokens(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_RefreshToken_Enumerate_Request* request,
                              ::CAuthentication_RefreshToken_Enumerate_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(8),
                       controller, request, response, done);
}
void Authentication_Stub::GetAuthSessionsForAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_GetAuthSessionsForAccount_Request* request,
                              ::CAuthentication_GetAuthSessionsForAccount_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(9),
                       controller, request, response, done);
}
void Authentication_Stub::MigrateMobileSession(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_MigrateMobileSession_Request* request,
                              ::CAuthentication_MigrateMobileSession_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(10),
                       controller, request, response, done);
}
void Authentication_Stub::RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_Token_Revoke_Request* request,
                              ::CAuthentication_Token_Revoke_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(11),
                       controller, request, response, done);
}
void Authentication_Stub::RevokeRefreshToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthentication_RefreshToken_Revoke_Request* request,
                              ::CAuthentication_RefreshToken_Revoke_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(12),
                       controller, request, response, done);
}
// ===================================================================

AuthenticationSupport::~AuthenticationSupport() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* AuthenticationSupport::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[1];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* AuthenticationSupport::GetDescriptor() {
  return descriptor();
}

void AuthenticationSupport::QueryRefreshTokensByAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request*,
                         ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method QueryRefreshTokensByAccount() not implemented.");
  done->Run();
}

void AuthenticationSupport::QueryRefreshTokenByID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthenticationSupport_QueryRefreshTokenByID_Request*,
                         ::CAuthenticationSupport_QueryRefreshTokenByID_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method QueryRefreshTokenByID() not implemented.");
  done->Run();
}

void AuthenticationSupport::RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthenticationSupport_RevokeToken_Request*,
                         ::CAuthenticationSupport_RevokeToken_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method RevokeToken() not implemented.");
  done->Run();
}

void AuthenticationSupport::GetTokenHistory(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CAuthenticationSupport_GetTokenHistory_Request*,
                         ::CAuthenticationSupport_GetTokenHistory_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetTokenHistory() not implemented.");
  done->Run();
}

void AuthenticationSupport::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[1]);
  switch(method->index()) {
    case 0:
      QueryRefreshTokensByAccount(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthenticationSupport_QueryRefreshTokensByAccount_Response*>(
                 response),
             done);
      break;
    case 1:
      QueryRefreshTokenByID(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthenticationSupport_QueryRefreshTokenByID_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthenticationSupport_QueryRefreshTokenByID_Response*>(
                 response),
             done);
      break;
    case 2:
      RevokeToken(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthenticationSupport_RevokeToken_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthenticationSupport_RevokeToken_Response*>(
                 response),
             done);
      break;
    case 3:
      GetTokenHistory(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CAuthenticationSupport_GetTokenHistory_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CAuthenticationSupport_GetTokenHistory_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& AuthenticationSupport::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request::default_instance();
    case 1:
      return ::CAuthenticationSupport_QueryRefreshTokenByID_Request::default_instance();
    case 2:
      return ::CAuthenticationSupport_RevokeToken_Request::default_instance();
    case 3:
      return ::CAuthenticationSupport_GetTokenHistory_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& AuthenticationSupport::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response::default_instance();
    case 1:
      return ::CAuthenticationSupport_QueryRefreshTokenByID_Response::default_instance();
    case 2:
      return ::CAuthenticationSupport_RevokeToken_Response::default_instance();
    case 3:
      return ::CAuthenticationSupport_GetTokenHistory_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

AuthenticationSupport_Stub::AuthenticationSupport_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
AuthenticationSupport_Stub::AuthenticationSupport_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
AuthenticationSupport_Stub::~AuthenticationSupport_Stub() {
  if (owns_channel_) delete channel_;
}

void AuthenticationSupport_Stub::QueryRefreshTokensByAccount(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request* request,
                              ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void AuthenticationSupport_Stub::QueryRefreshTokenByID(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthenticationSupport_QueryRefreshTokenByID_Request* request,
                              ::CAuthenticationSupport_QueryRefreshTokenByID_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void AuthenticationSupport_Stub::RevokeToken(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthenticationSupport_RevokeToken_Request* request,
                              ::CAuthenticationSupport_RevokeToken_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void AuthenticationSupport_Stub::GetTokenHistory(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CAuthenticationSupport_GetTokenHistory_Request* request,
                              ::CAuthenticationSupport_GetTokenHistory_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
// ===================================================================

CloudGaming::~CloudGaming() {}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* CloudGaming::descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_steammessages_5fauth_2esteamclient_2eproto);
  return file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[2];
}

const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* CloudGaming::GetDescriptor() {
  return descriptor();
}

void CloudGaming::CreateNonce(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CCloudGaming_CreateNonce_Request*,
                         ::CCloudGaming_CreateNonce_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method CreateNonce() not implemented.");
  done->Run();
}

void CloudGaming::GetTimeRemaining(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                         const ::CCloudGaming_GetTimeRemaining_Request*,
                         ::CCloudGaming_GetTimeRemaining_Response*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method GetTimeRemaining() not implemented.");
  done->Run();
}

void CloudGaming::CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                             ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                             const ::PROTOBUF_NAMESPACE_ID::Message* request,
                             ::PROTOBUF_NAMESPACE_ID::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), file_level_service_descriptors_steammessages_5fauth_2esteamclient_2eproto[2]);
  switch(method->index()) {
    case 0:
      CreateNonce(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CCloudGaming_CreateNonce_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CCloudGaming_CreateNonce_Response*>(
                 response),
             done);
      break;
    case 1:
      GetTimeRemaining(controller,
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<const ::CCloudGaming_GetTimeRemaining_Request*>(
                 request),
             ::PROTOBUF_NAMESPACE_ID::internal::DownCast<::CCloudGaming_GetTimeRemaining_Response*>(
                 response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& CloudGaming::GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CCloudGaming_CreateNonce_Request::default_instance();
    case 1:
      return ::CCloudGaming_GetTimeRemaining_Request::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::PROTOBUF_NAMESPACE_ID::Message& CloudGaming::GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::CCloudGaming_CreateNonce_Response::default_instance();
    case 1:
      return ::CCloudGaming_GetTimeRemaining_Response::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::PROTOBUF_NAMESPACE_ID::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

CloudGaming_Stub::CloudGaming_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
CloudGaming_Stub::CloudGaming_Stub(
    ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
    ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::PROTOBUF_NAMESPACE_ID::Service::STUB_OWNS_CHANNEL) {}
CloudGaming_Stub::~CloudGaming_Stub() {
  if (owns_channel_) delete channel_;
}

void CloudGaming_Stub::CreateNonce(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CCloudGaming_CreateNonce_Request* request,
                              ::CCloudGaming_CreateNonce_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void CloudGaming_Stub::GetTimeRemaining(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                              const ::CCloudGaming_GetTimeRemaining_Request* request,
                              ::CCloudGaming_GetTimeRemaining_Response* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CAuthentication_GetPasswordRSAPublicKey_Request* Arena::CreateMaybeMessage< ::CAuthentication_GetPasswordRSAPublicKey_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetPasswordRSAPublicKey_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_GetPasswordRSAPublicKey_Response* Arena::CreateMaybeMessage< ::CAuthentication_GetPasswordRSAPublicKey_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetPasswordRSAPublicKey_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_DeviceDetails* Arena::CreateMaybeMessage< ::CAuthentication_DeviceDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_DeviceDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_BeginAuthSessionViaQR_Request* Arena::CreateMaybeMessage< ::CAuthentication_BeginAuthSessionViaQR_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_BeginAuthSessionViaQR_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_AllowedConfirmation* Arena::CreateMaybeMessage< ::CAuthentication_AllowedConfirmation >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_AllowedConfirmation >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_BeginAuthSessionViaQR_Response* Arena::CreateMaybeMessage< ::CAuthentication_BeginAuthSessionViaQR_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_BeginAuthSessionViaQR_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_BeginAuthSessionViaCredentials_Request* Arena::CreateMaybeMessage< ::CAuthentication_BeginAuthSessionViaCredentials_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_BeginAuthSessionViaCredentials_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_BeginAuthSessionViaCredentials_Response* Arena::CreateMaybeMessage< ::CAuthentication_BeginAuthSessionViaCredentials_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_BeginAuthSessionViaCredentials_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_PollAuthSessionStatus_Request* Arena::CreateMaybeMessage< ::CAuthentication_PollAuthSessionStatus_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_PollAuthSessionStatus_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_PollAuthSessionStatus_Response* Arena::CreateMaybeMessage< ::CAuthentication_PollAuthSessionStatus_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_PollAuthSessionStatus_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_GetAuthSessionInfo_Request* Arena::CreateMaybeMessage< ::CAuthentication_GetAuthSessionInfo_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetAuthSessionInfo_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_GetAuthSessionInfo_Response* Arena::CreateMaybeMessage< ::CAuthentication_GetAuthSessionInfo_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetAuthSessionInfo_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request* Arena::CreateMaybeMessage< ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response* Arena::CreateMaybeMessage< ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_UpdateAuthSessionWithMobileConfirmation_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request* Arena::CreateMaybeMessage< ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response* Arena::CreateMaybeMessage< ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_UpdateAuthSessionWithSteamGuardCode_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_AccessToken_GenerateForApp_Request* Arena::CreateMaybeMessage< ::CAuthentication_AccessToken_GenerateForApp_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_AccessToken_GenerateForApp_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_AccessToken_GenerateForApp_Response* Arena::CreateMaybeMessage< ::CAuthentication_AccessToken_GenerateForApp_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_AccessToken_GenerateForApp_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Enumerate_Request* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Enumerate_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Enumerate_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Enumerate_Response_TokenUsageEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Enumerate_Response_RefreshTokenDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Enumerate_Response* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Enumerate_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Enumerate_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_GetAuthSessionsForAccount_Request* Arena::CreateMaybeMessage< ::CAuthentication_GetAuthSessionsForAccount_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetAuthSessionsForAccount_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_GetAuthSessionsForAccount_Response* Arena::CreateMaybeMessage< ::CAuthentication_GetAuthSessionsForAccount_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_GetAuthSessionsForAccount_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_MigrateMobileSession_Request* Arena::CreateMaybeMessage< ::CAuthentication_MigrateMobileSession_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_MigrateMobileSession_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_MigrateMobileSession_Response* Arena::CreateMaybeMessage< ::CAuthentication_MigrateMobileSession_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_MigrateMobileSession_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_Token_Revoke_Request* Arena::CreateMaybeMessage< ::CAuthentication_Token_Revoke_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_Token_Revoke_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_Token_Revoke_Response* Arena::CreateMaybeMessage< ::CAuthentication_Token_Revoke_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_Token_Revoke_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Revoke_Request* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Revoke_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Revoke_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthentication_RefreshToken_Revoke_Response* Arena::CreateMaybeMessage< ::CAuthentication_RefreshToken_Revoke_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthentication_RefreshToken_Revoke_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request* Arena::CreateMaybeMessage< ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_QueryRefreshTokensByAccount_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CSupportRefreshTokenDescription_TokenUsageEvent* Arena::CreateMaybeMessage< ::CSupportRefreshTokenDescription_TokenUsageEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSupportRefreshTokenDescription_TokenUsageEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CSupportRefreshTokenDescription* Arena::CreateMaybeMessage< ::CSupportRefreshTokenDescription >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSupportRefreshTokenDescription >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response* Arena::CreateMaybeMessage< ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_QueryRefreshTokensByAccount_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_QueryRefreshTokenByID_Request* Arena::CreateMaybeMessage< ::CAuthenticationSupport_QueryRefreshTokenByID_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_QueryRefreshTokenByID_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_QueryRefreshTokenByID_Response* Arena::CreateMaybeMessage< ::CAuthenticationSupport_QueryRefreshTokenByID_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_QueryRefreshTokenByID_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_RevokeToken_Request* Arena::CreateMaybeMessage< ::CAuthenticationSupport_RevokeToken_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_RevokeToken_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_RevokeToken_Response* Arena::CreateMaybeMessage< ::CAuthenticationSupport_RevokeToken_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_RevokeToken_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_GetTokenHistory_Request* Arena::CreateMaybeMessage< ::CAuthenticationSupport_GetTokenHistory_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_GetTokenHistory_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CSupportRefreshTokenAudit* Arena::CreateMaybeMessage< ::CSupportRefreshTokenAudit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSupportRefreshTokenAudit >(arena);
}
template<> PROTOBUF_NOINLINE ::CAuthenticationSupport_GetTokenHistory_Response* Arena::CreateMaybeMessage< ::CAuthenticationSupport_GetTokenHistory_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CAuthenticationSupport_GetTokenHistory_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloudGaming_CreateNonce_Request* Arena::CreateMaybeMessage< ::CCloudGaming_CreateNonce_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloudGaming_CreateNonce_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloudGaming_CreateNonce_Response* Arena::CreateMaybeMessage< ::CCloudGaming_CreateNonce_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloudGaming_CreateNonce_Response >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloudGaming_GetTimeRemaining_Request* Arena::CreateMaybeMessage< ::CCloudGaming_GetTimeRemaining_Request >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloudGaming_GetTimeRemaining_Request >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloudGaming_TimeRemaining* Arena::CreateMaybeMessage< ::CCloudGaming_TimeRemaining >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloudGaming_TimeRemaining >(arena);
}
template<> PROTOBUF_NOINLINE ::CCloudGaming_GetTimeRemaining_Response* Arena::CreateMaybeMessage< ::CCloudGaming_GetTimeRemaining_Response >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCloudGaming_GetTimeRemaining_Response >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
